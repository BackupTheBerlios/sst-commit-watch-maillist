From stsp at mail.berlios.de  Thu Nov  4 23:23:18 2010
From: stsp at mail.berlios.de (stsp at mail.berlios.de)
Date: Thu,  4 Nov 2010 23:23:18 +0100
Subject: [Sst-commit-watch] r803 - trunk/src
Message-ID: <20101104222318.A5235480F6E@sheep.berlios.de>

Author: stsp
Date: 2010-11-04 23:23:18 +0100 (Thu, 04 Nov 2010)
New Revision: 803

Modified:
   trunk/src/sst.py
Log:
this enabled UTF8 for some recent versions of python2. python3 has no problems at all

Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-09-14 21:54:31 UTC (rev 802)
+++ trunk/src/sst.py	2010-11-04 22:23:18 UTC (rev 803)
@@ -3063,6 +3063,12 @@
 
 def iostart():
     global stdscr, rows
+    "for some recent versions of python2, the following enables UTF8"
+    "for the older ones we probably need to set C locale, and the python3"
+    "has no problems at all"
+    if sys.version_info.major < 3:
+	import locale
+	locale.setlocale(locale.LC_ALL, "")
     gettext.bindtextdomain("sst", "/usr/local/share/locale")
     gettext.textdomain("sst")
     if not (game.options & OPTION_CURSES):



From stsp at mail.berlios.de  Thu Nov  4 23:57:06 2010
From: stsp at mail.berlios.de (stsp at mail.berlios.de)
Date: Thu,  4 Nov 2010 23:57:06 +0100
Subject: [Sst-commit-watch] r804 - trunk/src
Message-ID: <20101104225707.09058480F6E@sheep.berlios.de>

Author: stsp
Date: 2010-11-04 23:57:06 +0100 (Thu, 04 Nov 2010)
New Revision: 804

Modified:
   trunk/src/sst.py
Log:
fixed visual bugs

Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-04 22:23:18 UTC (rev 803)
+++ trunk/src/sst.py	2010-11-04 22:57:06 UTC (rev 804)
@@ -3154,7 +3154,7 @@
 	if game.options & OPTION_CURSES:
             (y, x) = curwnd.getyx()
             (my, mx) = curwnd.getmaxyx()
-	    if curwnd == message_window and y >= my - 3:
+	    if curwnd == message_window and y >= my - 2:
 		pause_game()
 		clrscr()
 	    else:
@@ -4879,7 +4879,8 @@
 		    proutn(" ***")
 		elif not silent:
 		    proutn(" %3d" % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
-	prout(" ")
+	if not silent:
+	    prout(" ")
 
 def damagereport():
     "Damage report."



From stsp at mail.berlios.de  Thu Nov  4 23:58:33 2010
From: stsp at mail.berlios.de (stsp at mail.berlios.de)
Date: Thu,  4 Nov 2010 23:58:33 +0100
Subject: [Sst-commit-watch] r805 - trunk/src
Message-ID: <20101104225833.4D4A7480F6E@sheep.berlios.de>

Author: stsp
Date: 2010-11-04 23:58:33 +0100 (Thu, 04 Nov 2010)
New Revision: 805

Modified:
   trunk/src/sst.py
Log:
fix report

Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-04 22:57:06 UTC (rev 804)
+++ trunk/src/sst.py	2010-11-04 22:58:33 UTC (rev 805)
@@ -4785,7 +4785,7 @@
     scanner.chew()
     s1 = "" and game.thawed and _("thawed ")
     s2 = {1:"short", 2:"medium", 4:"long"}[game.length]
-    s3 = (None, _("novice"). _("fair"),
+    s3 = (None, _("novice"), _("fair"),
           _("good"), _("expert"), _("emeritus"))[game.skill]
     prout(_("You %s a %s%s %s game.") % ((_("were playing"), _("are playing"))[game.alldone], s1, s2, s3))
     if game.skill>SKILL_GOOD and game.thawed and not game.alldone:



From stsp at mail.berlios.de  Fri Nov  5 00:00:20 2010
From: stsp at mail.berlios.de (stsp at mail.berlios.de)
Date: Fri,  5 Nov 2010 00:00:20 +0100
Subject: [Sst-commit-watch] r806 - trunk/src
Message-ID: <20101104230020.E3811480F6E@sheep.berlios.de>

Author: stsp
Date: 2010-11-05 00:00:20 +0100 (Fri, 05 Nov 2010)
New Revision: 806

Modified:
   trunk/src/sst.py
Log:
shorten password to 3, its just a game

Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-04 22:58:33 UTC (rev 805)
+++ trunk/src/sst.py	2010-11-04 23:00:20 UTC (rev 806)
@@ -5748,7 +5748,7 @@
 		break
     else:
         game.passwd = ""
-        for i in range(8):
+        for i in range(3):
 	    game.passwd += chr(ord('a')+randrange(26))
 
 # Code from sst.c begins here



From stsp at mail.berlios.de  Fri Nov  5 00:58:22 2010
From: stsp at mail.berlios.de (stsp at mail.berlios.de)
Date: Fri,  5 Nov 2010 00:58:22 +0100
Subject: [Sst-commit-watch] r807 - trunk/src
Message-ID: <20101104235822.BF7A948100C@sheep.berlios.de>

Author: stsp
Date: 2010-11-05 00:58:22 +0100 (Fri, 05 Nov 2010)
New Revision: 807

Modified:
   trunk/src/sst.py
Log:
fix warp

Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-04 23:00:20 UTC (rev 806)
+++ trunk/src/sst.py	2010-11-04 23:58:22 UTC (rev 807)
@@ -3919,7 +3919,6 @@
             break
 	scanner.chew()
 	proutn(_("Warp factor- "))
-    scanner.chew()
     if key != "IHREAL":
 	huh()
 	return



From esr at mail.berlios.de  Tue Nov 30 08:23:53 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 08:23:53 +0100
Subject: [Sst-commit-watch] r808 - trunk/src
Message-ID: <20101130072354.10331480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 08:23:53 +0100 (Tue, 30 Nov 2010)
New Revision: 808

Modified:
   trunk/src/sst.py
Log:
TYpo fix.


Modified: trunk/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-04 23:58:22 UTC (rev 807)
+++ trunk/src/sst.py	2010-11-30 07:23:53 UTC (rev 808)
@@ -9,7 +9,7 @@
 Stas Sergeev, and Eric S. Raymond.
 
 See the doc/HACKING file in the distribution for designers notes and advice
-ion how to modify (and how not to modify!) this code.
+on how to modify (and how not to modify!) this code.
 """
 import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
 



From esr at mail.berlios.de  Tue Nov 30 08:54:08 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 08:54:08 +0100
Subject: [Sst-commit-watch] r809 - branches
Message-ID: <20101130075408.E426A480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 08:54:08 +0100 (Tue, 30 Nov 2010)
New Revision: 809

Removed:
   branches/c-version/
Log:
The C versioon we had saved was somewhat out of date.

We'll preserve those sources a different way.




From esr at mail.berlios.de  Tue Nov 30 09:15:36 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 09:15:36 +0100
Subject: [Sst-commit-watch] r810 - in trunk: . c-version c-version/src
Message-ID: <20101130081536.A6EF9480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 09:15:36 +0100 (Tue, 30 Nov 2010)
New Revision: 810

Added:
   trunk/c-version/
   trunk/c-version/ABOUT-NLS
   trunk/c-version/Makefile.am
   trunk/c-version/autogen.sh
   trunk/c-version/compile
   trunk/c-version/config.guess
   trunk/c-version/config.rpath
   trunk/c-version/config.sub
   trunk/c-version/configure.ac
   trunk/c-version/depcomp
   trunk/c-version/install-sh
   trunk/c-version/m4/
   trunk/c-version/missing
   trunk/c-version/mkinstalldirs
   trunk/c-version/src/
   trunk/c-version/sst.spec
   trunk/sst.py
Removed:
   trunk/ABOUT-NLS
   trunk/Makefile.am
   trunk/autogen.sh
   trunk/c-version/src/sst.py
   trunk/compile
   trunk/config.guess
   trunk/config.rpath
   trunk/config.sub
   trunk/configure.ac
   trunk/depcomp
   trunk/install-sh
   trunk/m4/
   trunk/missing
   trunk/mkinstalldirs
   trunk/src/
   trunk/sst.spec
Log:
C files and associated autotools stuff moved to the c-version subdirectory.


Deleted: trunk/ABOUT-NLS
===================================================================
--- trunk/ABOUT-NLS	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/ABOUT-NLS	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,996 +0,0 @@
-1 Notes on the Free Translation Project
-***************************************
-
-Free software is going international!  The Free Translation Project is
-a way to get maintainers of free software, translators, and users all
-together, so that free software will gradually become able to speak many
-languages.  A few packages already provide translations for their
-messages.
-
-   If you found this `ABOUT-NLS' file inside a distribution, you may
-assume that the distributed package does use GNU `gettext' internally,
-itself available at your nearest GNU archive site.  But you do _not_
-need to install GNU `gettext' prior to configuring, installing or using
-this package with messages translated.
-
-   Installers will find here some useful hints.  These notes also
-explain how users should proceed for getting the programs to use the
-available translations.  They tell how people wanting to contribute and
-work on translations can contact the appropriate team.
-
-   When reporting bugs in the `intl/' directory or bugs which may be
-related to internationalization, you should tell about the version of
-`gettext' which is used.  The information can be found in the
-`intl/VERSION' file, in internationalized packages.
-
-1.1 Quick configuration advice
-==============================
-
-If you want to exploit the full power of internationalization, you
-should configure it using
-
-     ./configure --with-included-gettext
-
-to force usage of internationalizing routines provided within this
-package, despite the existence of internationalizing capabilities in the
-operating system where this package is being installed.  So far, only
-the `gettext' implementation in the GNU C library version 2 provides as
-many features (such as locale alias, message inheritance, automatic
-charset conversion or plural form handling) as the implementation here.
-It is also not possible to offer this additional functionality on top
-of a `catgets' implementation.  Future versions of GNU `gettext' will
-very likely convey even more functionality.  So it might be a good idea
-to change to GNU `gettext' as soon as possible.
-
-   So you need _not_ provide this option if you are using GNU libc 2 or
-you have installed a recent copy of the GNU gettext package with the
-included `libintl'.
-
-1.2 INSTALL Matters
-===================
-
-Some packages are "localizable" when properly installed; the programs
-they contain can be made to speak your own native language.  Most such
-packages use GNU `gettext'.  Other packages have their own ways to
-internationalization, predating GNU `gettext'.
-
-   By default, this package will be installed to allow translation of
-messages.  It will automatically detect whether the system already
-provides the GNU `gettext' functions.  If not, the included GNU
-`gettext' library will be used.  This library is wholly contained
-within this package, usually in the `intl/' subdirectory, so prior
-installation of the GNU `gettext' package is _not_ required.
-Installers may use special options at configuration time for changing
-the default behaviour.  The commands:
-
-     ./configure --with-included-gettext
-     ./configure --disable-nls
-
-will, respectively, bypass any pre-existing `gettext' to use the
-internationalizing routines provided within this package, or else,
-_totally_ disable translation of messages.
-
-   When you already have GNU `gettext' installed on your system and run
-configure without an option for your new package, `configure' will
-probably detect the previously built and installed `libintl.a' file and
-will decide to use this.  This might not be desirable.  You should use
-the more recent version of the GNU `gettext' library.  I.e. if the file
-`intl/VERSION' shows that the library which comes with this package is
-more recent, you should use
-
-     ./configure --with-included-gettext
-
-to prevent auto-detection.
-
-   The configuration process will not test for the `catgets' function
-and therefore it will not be used.  The reason is that even an
-emulation of `gettext' on top of `catgets' could not provide all the
-extensions of the GNU `gettext' library.
-
-   Internationalized packages usually have many `po/LL.po' files, where
-LL gives an ISO 639 two-letter code identifying the language.  Unless
-translations have been forbidden at `configure' time by using the
-`--disable-nls' switch, all available translations are installed
-together with the package.  However, the environment variable `LINGUAS'
-may be set, prior to configuration, to limit the installed set.
-`LINGUAS' should then contain a space separated list of two-letter
-codes, stating which languages are allowed.
-
-1.3 Using This Package
-======================
-
-As a user, if your language has been installed for this package, you
-only have to set the `LANG' environment variable to the appropriate
-`LL_CC' combination.  Here `LL' is an ISO 639 two-letter language code,
-and `CC' is an ISO 3166 two-letter country code.  For example, let's
-suppose that you speak German and live in Germany.  At the shell
-prompt, merely execute `setenv LANG de_DE' (in `csh'),
-`export LANG; LANG=de_DE' (in `sh') or `export LANG=de_DE' (in `bash').
-This can be done from your `.login' or `.profile' file, once and for
-all.
-
-   You might think that the country code specification is redundant.
-But in fact, some languages have dialects in different countries.  For
-example, `de_AT' is used for Austria, and `pt_BR' for Brazil.  The
-country code serves to distinguish the dialects.
-
-   The locale naming convention of `LL_CC', with `LL' denoting the
-language and `CC' denoting the country, is the one use on systems based
-on GNU libc.  On other systems, some variations of this scheme are
-used, such as `LL' or `LL_CC.ENCODING'.  You can get the list of
-locales supported by your system for your country by running the command
-`locale -a | grep '^LL''.
-
-   Not all programs have translations for all languages.  By default, an
-English message is shown in place of a nonexistent translation.  If you
-understand other languages, you can set up a priority list of languages.
-This is done through a different environment variable, called
-`LANGUAGE'.  GNU `gettext' gives preference to `LANGUAGE' over `LANG'
-for the purpose of message handling, but you still need to have `LANG'
-set to the primary language; this is required by other parts of the
-system libraries.  For example, some Swedish users who would rather
-read translations in German than English for when Swedish is not
-available, set `LANGUAGE' to `sv:de' while leaving `LANG' to `sv_SE'.
-
-   Special advice for Norwegian users: The language code for Norwegian
-bokma*l changed from `no' to `nb' recently (in 2003).  During the
-transition period, while some message catalogs for this language are
-installed under `nb' and some older ones under `no', it's recommended
-for Norwegian users to set `LANGUAGE' to `nb:no' so that both newer and
-older translations are used.
-
-   In the `LANGUAGE' environment variable, but not in the `LANG'
-environment variable, `LL_CC' combinations can be abbreviated as `LL'
-to denote the language's main dialect.  For example, `de' is equivalent
-to `de_DE' (German as spoken in Germany), and `pt' to `pt_PT'
-(Portuguese as spoken in Portugal) in this context.
-
-1.4 Translating Teams
-=====================
-
-For the Free Translation Project to be a success, we need interested
-people who like their own language and write it well, and who are also
-able to synergize with other translators speaking the same language.
-Each translation team has its own mailing list.  The up-to-date list of
-teams can be found at the Free Translation Project's homepage,
-`http://www.iro.umontreal.ca/contrib/po/HTML/', in the "National teams"
-area.
-
-   If you'd like to volunteer to _work_ at translating messages, you
-should become a member of the translating team for your own language.
-The subscribing address is _not_ the same as the list itself, it has
-`-request' appended.  For example, speakers of Swedish can send a
-message to `sv-request at li.org', having this message body:
-
-     subscribe
-
-   Keep in mind that team members are expected to participate
-_actively_ in translations, or at solving translational difficulties,
-rather than merely lurking around.  If your team does not exist yet and
-you want to start one, or if you are unsure about what to do or how to
-get started, please write to `translation at iro.umontreal.ca' to reach the
-coordinator for all translator teams.
-
-   The English team is special.  It works at improving and uniformizing
-the terminology in use.  Proven linguistic skill are praised more than
-programming skill, here.
-
-1.5 Available Packages
-======================
-
-Languages are not equally supported in all packages.  The following
-matrix shows the current state of internationalization, as of May 2005.
-The matrix shows, in regard of each package, for which languages PO
-files have been submitted to translation coordination, with a
-translation percentage of at least 50%.
-
-     Ready PO files       af am ar az be bg bs ca cs cy da de el en en_GB
-                        +-------------------------------------------------+
-     GNUnet             |                                                 |
-     a2ps               |             []                [] [] []     []   |
-     aegis              |                                  ()             |
-     ant-phone          |                                  ()             |
-     anubis             |                                  []             |
-     ap-utils           |                                                 |
-     aspell             |                         []    [] []        []   |
-     bash               |                      []          []             |
-     batchelor          |                                  []             |
-     bfd                |                                                 |
-     bibshelf           |                                  []             |
-     binutils           |                               []                |
-     bison              |                               [] []             |
-     bluez-pin          | []                      []       [] []          |
-     clisp              |                                  []    []       |
-     console-tools      |                         []       []             |
-     coreutils          |                []    []       [] []             |
-     cpio               |                                                 |
-     cpplib             |                      []       [] []             |
-     darkstat           |                []             () []             |
-     dialog             |                      [] [] [] [] [] []          |
-     diffutils          |                      [] []    [] [] []          |
-     doodle             |                                  []             |
-     e2fsprogs          |                         []       []             |
-     enscript           |                      []       [] []        []   |
-     error              |                      []       [] []        []   |
-     fetchmail          |                      []       [] () []          |
-     fileutils          |                               [] []             |
-     findutils          |                      []       []    []          |
-     flex               |                      []       [] []             |
-     fslint             |                                  []             |
-     gas                |                                                 |
-     gawk               |                      []       [] []             |
-     gbiff              |                                  []             |
-     gcal               |                      []                         |
-     gcc                |                                  []             |
-     gettext-examples   | []                   []          [] []          |
-     gettext-runtime    |             []       []       [] []             |
-     gettext-tools      |                      []          []             |
-     gimp-print         |                         []    [] []        []   |
-     gip                |                                                 |
-     gliv               |                                  []             |
-     glunarclock        |                                                 |
-     gmult              | []                               []             |
-     gnubiff            |                                  ()             |
-     gnucash            |                         []       () ()     []   |
-     gnucash-glossary   |                               [] ()             |
-     gpe-aerial         |                         []       []             |
-     gpe-beam           |                         []       []             |
-     gpe-calendar       |                         []       []             |
-     gpe-clock          |                         []       []             |
-     gpe-conf           |                         []       []             |
-     gpe-contacts       |                                                 |
-     gpe-edit           |                         []                      |
-     gpe-go             |                         []                      |
-     gpe-login          |                         []       []             |
-     gpe-ownerinfo      |                         []       []             |
-     gpe-sketchbook     |                         []       []             |
-     gpe-su             |                         []       []             |
-     gpe-taskmanager    |                         []       []             |
-     gpe-timesheet      |                         []                      |
-     gpe-today          |                         []       []             |
-     gpe-todo           |                         []       []             |
-     gphoto2            |                         []    [] []        []   |
-     gprof              |                               [] []             |
-     gpsdrive           |                                  ()    ()       |
-     gramadoir          | []                               []             |
-     grep               | []          [] []    []          [] []          |
-     gretl              |                                                 |
-     gsasl              |                                  []             |
-     gss                |                                                 |
-     gst-plugins        | []       []          [] []       []        []   |
-     gstreamer          | []                   [] []       []        []   |
-     gtick              | []                               ()             |
-     gtkspell           |             []                   [] []          |
-     hello              |                      []       [] [] []          |
-     id-utils           |                               [] []             |
-     impost             |                                                 |
-     indent             |                      []          []             |
-     iso_3166           |                                                 |
-     iso_3166_1         |                      [] []    [] [] []          |
-     iso_3166_2         |                                                 |
-     iso_3166_3         |                                  []             |
-     iso_4217           |                                                 |
-     iso_639            |                                                 |
-     jpilot             |                         []                      |
-     jtag               |                                                 |
-     jwhois             |                                                 |
-     kbd                |                         []    [] [] []          |
-     latrine            |                                  ()             |
-     ld                 |                               []                |
-     libc               |                      [] []    [] [] []          |
-     libextractor       |                                                 |
-     libgpewidget       |                         []    [] []             |
-     libgphoto2         |                                  []             |
-     libgphoto2_port    |                                  []             |
-     libgsasl           |                                                 |
-     libiconv           | []                   []       [] [] []          |
-     libidn             |                                                 |
-     lifelines          |                               [] ()             |
-     lilypond           |                                  []             |
-     lingoteach         |                                                 |
-     lynx               |                      [] []    [] []             |
-     m4                 |                         []    [] [] []          |
-     mailutils          |                      []                         |
-     make               |                               [] []             |
-     man-db             |                      [] ()    [] []             |
-     minicom            |                         []       []             |
-     mysecretdiary      |                               [] []             |
-     nano               |                      [] ()       []             |
-     nano_1_0           |                      [] ()    [] []             |
-     opcodes            |                                  []             |
-     parted             |                      [] []    [] []             |
-     psmisc             |                                                 |
-     ptx                |                      []       [] []             |
-     pwdutils           |                                                 |
-     python             |                                                 |
-     radius             |                      []                         |
-     recode             |             []       []       [] [] []          |
-     rpm                |                         []    []                |
-     screem             |                                                 |
-     scrollkeeper       |          [] []       [] [] [] [] []        []   |
-     sed                |                      []          []             |
-     sh-utils           |                               [] []             |
-     shared-mime-info   |                []       []                      |
-     sharutils          |                      [] []    [] [] []          |
-     silky              |                                                 |
-     skencil            |                               [] ()             |
-     sketch             |                               [] ()             |
-     solfege            |                                  []             |
-     soundtracker       |                               [] []             |
-     sp                 |                                  []             |
-     stardict           |                         []                      |
-     tar                |                                                 |
-     texinfo            |                               [] []             |
-     textutils          |                      []       [] []             |
-     tin                |                                  ()        ()   |
-     tp-robot           |                                  []             |
-     tuxpaint           | []                   [] []    [] [] []     []   |
-     unicode-han-tra... |                                                 |
-     unicode-transla... |                                                 |
-     util-linux         |                      [] []    [] []             |
-     vorbis-tools       |             []          []    []           []   |
-     wastesedge         |                                  ()             |
-     wdiff              |                      []       [] []        []   |
-     wget               |                                                 |
-     xchat              |                []    []          [] []     []   |
-     xkeyboard-config   |                                                 |
-     xpad               |                                                 |
-                        +-------------------------------------------------+
-                          af am ar az be bg bs ca cs cy da de el en en_GB
-                          10  0  0  2  7  5  0 40 43  2 51 91 19  1  14
-
-                          eo es et eu fa fi fr  ga gl he hi hr hu id is
-                        +-----------------------------------------------+
-     GNUnet             |                                               |
-     a2ps               |       []       [] []                          |
-     aegis              |                                               |
-     ant-phone          |                   []                          |
-     anubis             |                   []                          |
-     ap-utils           |                   []                          |
-     aspell             |                   []  []                      |
-     bash               | [] []             []                 []       |
-     batchelor          |                   []  []                      |
-     bfd                |    []                                         |
-     bibshelf           |    []                 []                      |
-     binutils           |    []             []                          |
-     bison              |    [] []          []  []                []    |
-     bluez-pin          | []             [] []  []             [] []    |
-     clisp              |    []             []                          |
-     console-tools      |                                               |
-     coreutils          |    [] []       [] []  []                      |
-     cpio               |    []             []                          |
-     cpplib             |    []             []                          |
-     darkstat           |    []             ()  []             [] []    |
-     dialog             |    [] [] []    [] []  []             []       |
-     diffutils          | [] []          [] []  [] [] []       [] []    |
-     doodle             |                       []                      |
-     e2fsprogs          |    []             []                          |
-     enscript           |                   []              []          |
-     error              |    []          [] []  []             []       |
-     fetchmail          |    []                                         |
-     fileutils          |    [] []          []  []             []       |
-     findutils          |    [] []          []  []                      |
-     flex               |    []             []  []                      |
-     fslint             |                   []                          |
-     gas                |    []             []                          |
-     gawk               |    []             []  []    []                |
-     gbiff              |                   []                          |
-     gcal               |    []             []                          |
-     gcc                |    []                                         |
-     gettext-examples   |    []             []  []                      |
-     gettext-runtime    |    []          [] []  []                []    |
-     gettext-tools      |    []             []                          |
-     gimp-print         |    []             []                          |
-     gip                |    []    []       []                          |
-     gliv               |                   ()                          |
-     glunarclock        |                []     []             []       |
-     gmult              |          []       []                          |
-     gnubiff            |                   ()                          |
-     gnucash            |    []                                ()       |
-     gnucash-glossary   |    []                                         |
-     gpe-aerial         |    []             []                          |
-     gpe-beam           |    []             []                          |
-     gpe-calendar       |    []             []                 [] []    |
-     gpe-clock          |    []          [] []                          |
-     gpe-conf           |                   []                          |
-     gpe-contacts       |                   []                          |
-     gpe-edit           |                   []                    []    |
-     gpe-go             |    []             []                          |
-     gpe-login          |    []             []                 []       |
-     gpe-ownerinfo      |    []          [] []                 [] []    |
-     gpe-sketchbook     |    []             []                          |
-     gpe-su             |    []          [] []                          |
-     gpe-taskmanager    |    []          [] []                          |
-     gpe-timesheet      |    []             []  []                []    |
-     gpe-today          |    []          [] []  []                      |
-     gpe-todo           |    []             []                    []    |
-     gphoto2            |    []          [] []                 []       |
-     gprof              |    []             []                    []    |
-     gpsdrive           |    ()             ()                 []       |
-     gramadoir          |                   []  []                      |
-     grep               |    [] [] []    [] []  [] [] []    [] [] []    |
-     gretl              |    []             []                          |
-     gsasl              |          []       []  []                      |
-     gss                |                   []                          |
-     gst-plugins        |                   []                 []       |
-     gstreamer          |                                               |
-     gtick              |          []    [] []  []                      |
-     gtkspell           | [] []    []       []  []                      |
-     hello              | [] [] [] [] [] [] []  [] [] []    [] [] []    |
-     id-utils           |                   []                 [] []    |
-     impost             |                   []  []                      |
-     indent             | [] [] [] []    [] []  [] []          [] []    |
-     iso_3166           | []             [] []                          |
-     iso_3166_1         |    []    []    [] []  []             [] []    |
-     iso_3166_2         |                   []                          |
-     iso_3166_3         |                   []                          |
-     iso_4217           |       []       []        []                   |
-     iso_639            | []          [] [] []                          |
-     jpilot             |    []             []                          |
-     jtag               |                   []                          |
-     jwhois             |    []             []                 [] []    |
-     kbd                |    []             []                          |
-     latrine            |                   []  []                      |
-     ld                 |    []             []                          |
-     libc               |    []          [] []     []          []       |
-     libextractor       |                                               |
-     libgpewidget       |    []             []  []             [] []    |
-     libgphoto2         |    []             []                 []       |
-     libgphoto2_port    |                   []                          |
-     libgsasl           |                   []  []                      |
-     libiconv           | [] [] []       [] []  [] []       [] [] []    |
-     libidn             | []                []                          |
-     lifelines          |                   ()                          |
-     lilypond           |                                               |
-     lingoteach         |                   []                    []    |
-     lynx               |       []                             []       |
-     m4                 |                   []  [] []             []    |
-     mailutils          |    []             []                          |
-     make               |    []          [] []  [] [] []    []          |
-     man-db             |    ()                                         |
-     minicom            |    []          [] []                 []       |
-     mysecretdiary      |    []             []                    []    |
-     nano               |    []    []    () []                          |
-     nano_1_0           |    []             []     []             []    |
-     opcodes            |    []          [] []                          |
-     parted             |    []             []     []                   |
-     psmisc             |          []                                   |
-     ptx                | [] [] []       [] []  [] []          [] []    |
-     pwdutils           |                                               |
-     python             |                                               |
-     radius             |    []             []                          |
-     recode             | [] []             []     [] []       [] []    |
-     rpm                |                   []                          |
-     screem             |                                               |
-     scrollkeeper       |    []          []                    []       |
-     sed                | [] [] []          []  []             []       |
-     sh-utils           |    [] []       [] []  []             []       |
-     shared-mime-info   | [] []    []    [] []                 []       |
-     sharutils          |    [] []       [] []     []          []       |
-     silky              |                   []                          |
-     skencil            |    []             []                          |
-     sketch             |    []             []                          |
-     solfege            |                                               |
-     soundtracker       |    []             []                          |
-     sp                 |                   []                          |
-     stardict           |                                      []       |
-     tar                |    [] []          []  []                      |
-     texinfo            | []                []        []                |
-     textutils          |    []             []  [] []          []       |
-     tin                |       []          ()                          |
-     tp-robot           |                   []                 []       |
-     tuxpaint           |    []          [] []  []    []       [] [] [] |
-     unicode-han-tra... |                                               |
-     unicode-transla... |                   []  []                      |
-     util-linux         |    [] []       [] []                 []       |
-     vorbis-tools       |    []             []                          |
-     wastesedge         |                   ()                          |
-     wdiff              |    [] []          []  [] []          [] []    |
-     wget               |       [] []           []          []          |
-     xchat              |    []    []    [] []           []             |
-     xkeyboard-config   |                                               |
-     xpad               |    []                 []             []       |
-                        +-----------------------------------------------+
-                          eo es et eu fa fi fr  ga gl he hi hr hu id is
-                          15 85 21 15  2 35 115 45 16  8  1  6 40 27  1
-
-                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
-                        +--------------------------------------------------+
-     GNUnet             |                                                  |
-     a2ps               | ()    ()                   []       []    ()     |
-     aegis              |                                     ()           |
-     ant-phone          |                                     []           |
-     anubis             |                            []    [] []           |
-     ap-utils           |                                                  |
-     aspell             |                         []          []           |
-     bash               |                                     []           |
-     batchelor          |                                     []           |
-     bfd                |                                                  |
-     bibshelf           | []                                               |
-     binutils           |                                                  |
-     bison              | []                         []    [] []           |
-     bluez-pin          |          []                         []           |
-     clisp              |                                     []           |
-     console-tools      |                                                  |
-     coreutils          |    []                               []           |
-     cpio               |                                                  |
-     cpplib             |                                     []           |
-     darkstat           |                            []       []           |
-     dialog             | []                                  []           |
-     diffutils          | [] []                      []       []           |
-     doodle             | []                                               |
-     e2fsprogs          | []                                               |
-     enscript           |                                     []           |
-     error              |                                     []           |
-     fetchmail          |    []                               []           |
-     fileutils          | [] []       []                                   |
-     findutils          | []                                  []           |
-     flex               |       []                            []           |
-     fslint             |                                     []           |
-     gas                |                                                  |
-     gawk               |    []                               []           |
-     gbiff              |                                     []           |
-     gcal               |                                                  |
-     gcc                |                                                  |
-     gettext-examples   | [] []                               []           |
-     gettext-runtime    | [] [] []                            []           |
-     gettext-tools      | [] [] []                                         |
-     gimp-print         |    []                               []           |
-     gip                |                                     []           |
-     gliv               |                                     []           |
-     glunarclock        |                            []       []           |
-     gmult              | [] []                                            |
-     gnubiff            | ()                                               |
-     gnucash            | [] ()                            () []           |
-     gnucash-glossary   | []                                  []           |
-     gpe-aerial         |                                     []           |
-     gpe-beam           |                                     []           |
-     gpe-calendar       |                                     []           |
-     gpe-clock          |                                     []           |
-     gpe-conf           |                                     []           |
-     gpe-contacts       |                                                  |
-     gpe-edit           |                                     []           |
-     gpe-go             |                                     []           |
-     gpe-login          |                                     []           |
-     gpe-ownerinfo      |                                     []           |
-     gpe-sketchbook     |                                     []           |
-     gpe-su             |                                     []           |
-     gpe-taskmanager    |          []                         []           |
-     gpe-timesheet      |                                     []           |
-     gpe-today          |                                     []           |
-     gpe-todo           |                                     []           |
-     gphoto2            | [] []                               []           |
-     gprof              |                                                  |
-     gpsdrive           | () ()                               ()    ()     |
-     gramadoir          |                                     ()           |
-     grep               | [] []                            [] []           |
-     gretl              | []                                               |
-     gsasl              |                                     []           |
-     gss                |                                                  |
-     gst-plugins        | []                                  []           |
-     gstreamer          | []                                  []           |
-     gtick              | []                                  []           |
-     gtkspell           | []                      []          []           |
-     hello              | [] [] []          []       []    [] [] [] []     |
-     id-utils           | []                                  []           |
-     impost             |                                                  |
-     indent             | [] []                               []           |
-     iso_3166           |                                     []           |
-     iso_3166_1         |                                     []    []     |
-     iso_3166_2         |                                     []           |
-     iso_3166_3         |                                     []           |
-     iso_4217           |    []                   []          []           |
-     iso_639            |    []                               [] []        |
-     jpilot             |    ()                               ()    ()     |
-     jtag               |                                                  |
-     jwhois             | []                                  []           |
-     kbd                |                                     []           |
-     latrine            | []                                  []           |
-     ld                 |                                                  |
-     libc               |    [] []                         [] []    []     |
-     libextractor       |                                                  |
-     libgpewidget       |                                     []           |
-     libgphoto2         | [] []                                            |
-     libgphoto2_port    | [] []                                            |
-     libgsasl           |                                     []           |
-     libiconv           | []                                  []           |
-     libidn             | []                                               |
-     lifelines          |                                     []           |
-     lilypond           |                                                  |
-     lingoteach         | []                                  []           |
-     lynx               | [] []                               []           |
-     m4                 |    []                               []           |
-     mailutils          |                                                  |
-     make               |    [] []                            []           |
-     man-db             |    ()                                            |
-     minicom            |    []                                            |
-     mysecretdiary      |                                     []           |
-     nano               | []                         []    []              |
-     nano_1_0           | []                         []    []    []        |
-     opcodes            |                                     []           |
-     parted             | [] []                               [] []        |
-     psmisc             | []                               [] []           |
-     ptx                |                                  [] []    []     |
-     pwdutils           |                                                  |
-     python             |                                                  |
-     radius             |                                                  |
-     recode             | []                                  []           |
-     rpm                |    [] []                                         |
-     screem             |    []                                            |
-     scrollkeeper       |                                  [] [] []        |
-     sed                |    []                               []           |
-     sh-utils           | [] []                            []              |
-     shared-mime-info   |       []                         [] [] []        |
-     sharutils          | [] []                               []           |
-     silky              |                                     []           |
-     skencil            |                                                  |
-     sketch             |                                                  |
-     solfege            | []                                  []    []     |
-     soundtracker       | []                                               |
-     sp                 |    ()                                            |
-     stardict           |                      []             []           |
-     tar                | [] []                               []           |
-     texinfo            |    []                            [] []           |
-     textutils          |    [] []                         []              |
-     tin                |                                                  |
-     tp-robot           |                                     []           |
-     tuxpaint           | [] [] []       []          []       [] []        |
-     unicode-han-tra... |                                                  |
-     unicode-transla... |                                                  |
-     util-linux         | [] []                               []           |
-     vorbis-tools       |                                     []           |
-     wastesedge         |                                     []           |
-     wdiff              | []                         []    []              |
-     wget               |    []                                            |
-     xchat              | []    []          [] []             []           |
-     xkeyboard-config   |                                     []           |
-     xpad               |                                     []           |
-                        +--------------------------------------------------+
-                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
-                          46 35 11  2  1  1  2  2  3 11  0 15 96  7  5  0
-
-                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
-                        +----------------------------------------------+
-     GNUnet             |                                              |
-     a2ps               |       ()     []      [] []       []    [] [] |
-     aegis              |                      () ()                   |
-     ant-phone          |                      []                      |
-     anubis             |       []             [] []                   |
-     ap-utils           |       ()                                     |
-     aspell             |                      [] []                   |
-     bash               |              []      [] []                   |
-     batchelor          |                      []                      |
-     bfd                |                                              |
-     bibshelf           |                                              |
-     binutils           |                         []                [] |
-     bison              |       []     []      [] []                [] |
-     bluez-pin          |       []     []   [] [] []    []       [] [] |
-     clisp              |                         []                   |
-     console-tools      |                         []                   |
-     coreutils          |       []                []       []       [] |
-     cpio               |       []                                  [] |
-     cpplib             |                                              |
-     darkstat           |       []     []      []       []       [] [] |
-     dialog             |       [] []  []   [] [] [] []                |
-     diffutils          |       []     []      [] []             [] [] |
-     doodle             |                                     []       |
-     e2fsprogs          |       []                                  [] |
-     enscript           |              []      [] []                [] |
-     error              |              []      []       []             |
-     fetchmail          |       []                []    []    []       |
-     fileutils          |       []             [] []       []       [] |
-     findutils          |       [] []          []       []       [] [] |
-     flex               |       []     []      [] []                [] |
-     fslint             |              []      []                []    |
-     gas                |                                              |
-     gawk               |       []     []      []                   [] |
-     gbiff              |                      []                      |
-     gcal               |                                           [] |
-     gcc                |                                              |
-     gettext-examples   |       []             [] []    []       [] [] |
-     gettext-runtime    |       []             [] []    [] []    [] [] |
-     gettext-tools      |       []             [] []    [] []    [] [] |
-     gimp-print         |                               []          [] |
-     gip                |                   []          []       []    |
-     gliv               |              []      []       []             |
-     glunarclock        |              []      [] []    []       [] [] |
-     gmult              |              []   [] []                []    |
-     gnubiff            |                      ()                   [] |
-     gnucash            |       () []             []    []          [] |
-     gnucash-glossary   |          []                   []          [] |
-     gpe-aerial         |          []  []      [] []             [] [] |
-     gpe-beam           |          []  []      [] []             [] [] |
-     gpe-calendar       |          []  []      [] []    []       [] [] |
-     gpe-clock          |          []  []      [] []    []       [] [] |
-     gpe-conf           |          []  []      [] []    []          [] |
-     gpe-contacts       |                      [] []             [] [] |
-     gpe-edit           |          []  []      [] []    []       [] [] |
-     gpe-go             |              []      [] []             [] [] |
-     gpe-login          |          []  []      [] []    []       [] [] |
-     gpe-ownerinfo      |          []  []      [] []    []       [] [] |
-     gpe-sketchbook     |          []  []      [] []    []       [] [] |
-     gpe-su             |          []  []      [] []    []       [] [] |
-     gpe-taskmanager    |          []  []      [] []    []       [] [] |
-     gpe-timesheet      |          []  []      [] []    []       [] [] |
-     gpe-today          |          []  []      [] []    []       [] [] |
-     gpe-todo           |    []    []  []      [] []    []       [] [] |
-     gphoto2            |                      []       []       [] [] |
-     gprof              |              []      []                   [] |
-     gpsdrive           |    []                []                      |
-     gramadoir          |                               []             |
-     grep               |       [] []  []      [] []       []    []    |
-     gretl              |       []                                     |
-     gsasl              |       []             []             [] [] [] |
-     gss                |       []             []                   [] |
-     gst-plugins        | []                                  [] [] [] |
-     gstreamer          |                         []          [] [] [] |
-     gtick              |                      [] []                [] |
-     gtkspell           |              []   [] [] []    []       []    |
-     hello              |       []     []      [] []    []       [] [] |
-     id-utils           |              []      [] []                [] |
-     impost             |                                              |
-     indent             |              []      [] []    []       [] [] |
-     iso_3166           |          []                []       [] [] [] |
-     iso_3166_1         |                               [] [] [] []    |
-     iso_3166_2         |                                              |
-     iso_3166_3         |                      []    []          []    |
-     iso_4217           |                            []          []    |
-     iso_639            |                            []          [] [] |
-     jpilot             |                                              |
-     jtag               |                               []             |
-     jwhois             |       []     []      [] ()                () |
-     kbd                |       []             []                   [] |
-     latrine            |                      []                   [] |
-     ld                 |                                           [] |
-     libc               |       []     []         []    []          [] |
-     libextractor       |                      []                      |
-     libgpewidget       |          []  []      []       []       [] [] |
-     libgphoto2         |                         []                [] |
-     libgphoto2_port    |                         []                   |
-     libgsasl           |       []             []                []    |
-     libiconv           |       []     []   [] [] []    [] [] [] [] [] |
-     libidn             |       []                                  () |
-     lifelines          |       []                                  [] |
-     lilypond           |                                              |
-     lingoteach         |              []                              |
-     lynx               |              []         []                [] |
-     m4                 |       []     []      [] []                [] |
-     mailutils          |       []             [] []                   |
-     make               |       []     []         []                [] |
-     man-db             |                      []                   [] |
-     minicom            |       []     []      [] []                   |
-     mysecretdiary      |              []      [] []                [] |
-     nano               |              []      []                   [] |
-     nano_1_0           |       []             [] []                [] |
-     opcodes            |                      []                   [] |
-     parted             |       [] []  []                           [] |
-     psmisc             |       []             []                      |
-     ptx                |       [] []  []      [] []                [] |
-     pwdutils           |       []                                     |
-     python             |                                              |
-     radius             |       []                []                   |
-     recode             |       []     []      [] []       []       [] |
-     rpm                |       [] []             []                [] |
-     screem             |                                              |
-     scrollkeeper       |       []             [] []    []    [] [] [] |
-     sed                |       [] []  []      [] []    []       [] [] |
-     sh-utils           |                         []       []    []    |
-     shared-mime-info   |          []  []         []          [] [] [] |
-     sharutils          |                         []             [] [] |
-     silky              |                               []             |
-     skencil            |          []  []                           [] |
-     sketch             |          []  []                           [] |
-     solfege            |                                              |
-     soundtracker       |                               []          [] |
-     sp                 |                                              |
-     stardict           |                         []    []             |
-     tar                |       []             [] []                [] |
-     texinfo            |       []             [] []                [] |
-     textutils          |                         []       []       [] |
-     tin                |                                              |
-     tp-robot           |                         []                   |
-     tuxpaint           |       [] []  []      []       []    [] [] [] |
-     unicode-han-tra... |                                              |
-     unicode-transla... |                                              |
-     util-linux         |              []         []                [] |
-     vorbis-tools       |                      [] []                   |
-     wastesedge         |                                              |
-     wdiff              |       []     []      [] []    []          [] |
-     wget               |                                              |
-     xchat              |    []                   []    [] [] [] [] [] |
-     xkeyboard-config   |                                              |
-     xpad               |                                              |
-                        +----------------------------------------------+
-                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
-                           1  3 47 29  57    6 78 73  5 44 12 12 50 85
-
-                          ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
-                        +-----------------------------------------------+
-     GNUnet             |                                               |  0
-     a2ps               |             [] []     []                      | 19
-     aegis              |                                               |  0
-     ant-phone          |             []        []                      |  5
-     anubis             |             [] []     []                      | 11
-     ap-utils           |                ()     []                      |  2
-     aspell             |                []     [] []                   | 13
-     bash               |                       []                      | 11
-     batchelor          |             []        []                      |  7
-     bfd                |                                               |  1
-     bibshelf           |                       []                      |  5
-     binutils           |             []                                |  6
-     bison              |             []        []                      | 18
-     bluez-pin          |             [] []     [] []     []            | 25
-     clisp              |                                               |  7
-     console-tools      |             []        []                      |  5
-     coreutils          |             []        []                      | 17
-     cpio               |             [] []     []                      |  7
-     cpplib             |             []        []                      |  8
-     darkstat           |                       []        ()    ()      | 15
-     dialog             |             [] []     []                      | 25
-     diffutils          |             []        []        []    []      | 28
-     doodle             |                       []                      |  5
-     e2fsprogs          |             []                                |  8
-     enscript           |             []                                | 12
-     error              |             []        []              []      | 16
-     fetchmail          |             []                                | 12
-     fileutils          |             []                  []    []      | 18
-     findutils          |             []        []                      | 17
-     flex               |             []        []                      | 15
-     fslint             |                       []                      |  7
-     gas                |             []                                |  3
-     gawk               |             []                                | 14
-     gbiff              |                       []                      |  5
-     gcal               |             []                                |  5
-     gcc                |             []                  []            |  4
-     gettext-examples   |             [] []     []        []    []      | 21
-     gettext-runtime    |             [] []     []        []    []      | 25
-     gettext-tools      |             [] []     []        []    []      | 19
-     gimp-print         |                []                             | 11
-     gip                |                       []                      |  8
-     gliv               |             []        []                      |  7
-     glunarclock        |                       [] []                   | 13
-     gmult              |             []        []        []            | 13
-     gnubiff            |                       []                      |  3
-     gnucash            |             ()                        []      | 10
-     gnucash-glossary   |                       []              []      |  9
-     gpe-aerial         |                       []        []            | 13
-     gpe-beam           |                       []        []            | 13
-     gpe-calendar       |                       [] []     []    []      | 18
-     gpe-clock          |             []        [] []     []            | 17
-     gpe-conf           |                       []        []            | 12
-     gpe-contacts       |                       []        []            |  7
-     gpe-edit           |             []        [] []           []      | 15
-     gpe-go             |             []        []                      | 11
-     gpe-login          |             []        [] []     []    []      | 18
-     gpe-ownerinfo      |             []        []        []    []      | 19
-     gpe-sketchbook     |             []        []                      | 14
-     gpe-su             |             []        []        []            | 16
-     gpe-taskmanager    |             []        []        []            | 17
-     gpe-timesheet      |             []        []        []    []      | 17
-     gpe-today          |             []        [] []     []    []      | 19
-     gpe-todo           |                       [] []           []      | 17
-     gphoto2            |                []               []    []      | 18
-     gprof              |             []        []                      | 10
-     gpsdrive           |                                               |  3
-     gramadoir          |                       []                      |  6
-     grep               |             [] []     []              []      | 32
-     gretl              |                                               |  4
-     gsasl              |                       []        []            | 12
-     gss                |                       []                      |  5
-     gst-plugins        |                []     []              []      | 17
-     gstreamer          |             [] []     []              []      | 15
-     gtick              |                       []                      | 11
-     gtkspell           |                       [] []     []    []      | 21
-     hello              |             [] []     []        []            | 37
-     id-utils           |             []        []                      | 13
-     impost             |                       []                      |  3
-     indent             |             []        []        []    []      | 25
-     iso_3166           |          [] []        []                      | 12
-     iso_3166_1         |             []           []                   | 20
-     iso_3166_2         |                                               |  2
-     iso_3166_3         |                          []     []            |  8
-     iso_4217           |             []        []                      | 10
-     iso_639            |                       [] []                   | 12
-     jpilot             |             [] []               []            |  6
-     jtag               |                                               |  2
-     jwhois             |             []        []              []      | 12
-     kbd                |             []        []                      | 12
-     latrine            |             []        []                      |  8
-     ld                 |             []                                |  5
-     libc               |             []                  []            | 22
-     libextractor       |                                               |  1
-     libgpewidget       |                       [] []                   | 17
-     libgphoto2         |                                 []            |  9
-     libgphoto2_port    |                                               |  5
-     libgsasl           |                       []                      |  7
-     libiconv           |             [] []     [] []     []            | 32
-     libidn             |                       []        []            |  6
-     lifelines          |                                               |  4
-     lilypond           |                                               |  1
-     lingoteach         |                       []                      |  6
-     lynx               |             [] []     []                      | 15
-     m4                 |                       []        []            | 17
-     mailutils          |                []                             |  7
-     make               |             []                  []            | 18
-     man-db             |                                               |  5
-     minicom            |                                               | 11
-     mysecretdiary      |             []        []                      | 12
-     nano               |                       []              []      | 13
-     nano_1_0           |             [] []     []                      | 18
-     opcodes            |             []        []                      |  9
-     parted             |             [] []               []            | 18
-     psmisc             |                       []                      |  7
-     ptx                |             []                  []            | 23
-     pwdutils           |                                               |  1
-     python             |                                               |  0
-     radius             |                []                             |  6
-     recode             |             []        []                      | 22
-     rpm                |             [] []                             | 11
-     screem             |                                               |  1
-     scrollkeeper       |             [] []                     []      | 24
-     sed                |             []        []              []      | 21
-     sh-utils           |             []                                | 15
-     shared-mime-info   |                []               []    []      | 21
-     sharutils          |             []        []              []      | 20
-     silky              |                                               |  3
-     skencil            |                                               |  6
-     sketch             |                                               |  6
-     solfege            |                                               |  4
-     soundtracker       |             []                                |  8
-     sp                 |             []                                |  3
-     stardict           |                []     []        []    []      | 10
-     tar                |             [] []     []              []      | 15
-     texinfo            |             []                  []            | 14
-     textutils          |             []                  []    []      | 17
-     tin                |                                               |  1
-     tp-robot           |                       []        []    []      |  8
-     tuxpaint           |             []        [] []     []            | 34
-     unicode-han-tra... |                                               |  0
-     unicode-transla... |                                               |  2
-     util-linux         |             [] []     []                      | 18
-     vorbis-tools       |                []                             | 10
-     wastesedge         |                                               |  1
-     wdiff              |             []        []                      | 22
-     wget               |             []        []                      |  7
-     xchat              |                []     []        []    []      | 26
-     xkeyboard-config   |                       []                      |  2
-     xpad               |                       []                      |  5
-                        +-----------------------------------------------+
-       73 teams           ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
-      149 domains          0  0  0  1 77 30  0  92 16  0  42    32    0  1746
-
-   Some counters in the preceding matrix are higher than the number of
-visible blocks let us expect.  This is because a few extra PO files are
-used for implementing regional variants of languages, or language
-dialects.
-
-   For a PO file in the matrix above to be effective, the package to
-which it applies should also have been internationalized and
-distributed as such by its maintainer.  There might be an observable
-lag between the mere existence a PO file and its wide availability in a
-distribution.
-
-   If May 2005 seems to be old, you may fetch a more recent copy of
-this `ABOUT-NLS' file on most GNU archive sites.  The most up-to-date
-matrix with full percentage details can be found at
-`http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html'.
-
-1.6 Using `gettext' in new packages
-===================================
-
-If you are writing a freely available program and want to
-internationalize it you are welcome to use GNU `gettext' in your
-package.  Of course you have to respect the GNU Library General Public
-License which covers the use of the GNU `gettext' library.  This means
-in particular that even non-free programs can use `libintl' as a shared
-library, whereas only free software can use `libintl' as a static
-library or use modified versions of `libintl'.
-
-   Once the sources are changed appropriately and the setup can handle
-the use of `gettext' the only thing missing are the translations.  The
-Free Translation Project is also available for packages which are not
-developed inside the GNU project.  Therefore the information given above
-applies also for every other Free Software Project.  Contact
-`translation at iro.umontreal.ca' to make the `.pot' files available to
-the translation teams.
-

Deleted: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/Makefile.am	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,18 +0,0 @@
-## Process this file with automake to produce Makefile.in
-
-SUBDIRS = po src doc
-
-EXTRA_DIST = config.rpath po m4 \
-	autogen.sh sst.spec ChangeLog.old
-
-maintainer-clean-local:
-	rm -f configure
-	rm -f aclocal.m4
-	rm -f `find . -name Makefile.in`
-	rm -f `find . -name *~`
-	rm -f src/include/config.h.in
-
-clean-local:
-	rm -rf autom4te*.cache
-
-ACLOCAL_AMFLAGS = -I m4

Deleted: trunk/autogen.sh
===================================================================
--- trunk/autogen.sh	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/autogen.sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,4 +0,0 @@
-#!/bin/sh
-# Run this to generate all the initial makefiles, etc.
-
-autoreconf -v

Copied: trunk/c-version/ABOUT-NLS (from rev 809, trunk/ABOUT-NLS)
===================================================================
--- trunk/c-version/ABOUT-NLS	                        (rev 0)
+++ trunk/c-version/ABOUT-NLS	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,996 @@
+1 Notes on the Free Translation Project
+***************************************
+
+Free software is going international!  The Free Translation Project is
+a way to get maintainers of free software, translators, and users all
+together, so that free software will gradually become able to speak many
+languages.  A few packages already provide translations for their
+messages.
+
+   If you found this `ABOUT-NLS' file inside a distribution, you may
+assume that the distributed package does use GNU `gettext' internally,
+itself available at your nearest GNU archive site.  But you do _not_
+need to install GNU `gettext' prior to configuring, installing or using
+this package with messages translated.
+
+   Installers will find here some useful hints.  These notes also
+explain how users should proceed for getting the programs to use the
+available translations.  They tell how people wanting to contribute and
+work on translations can contact the appropriate team.
+
+   When reporting bugs in the `intl/' directory or bugs which may be
+related to internationalization, you should tell about the version of
+`gettext' which is used.  The information can be found in the
+`intl/VERSION' file, in internationalized packages.
+
+1.1 Quick configuration advice
+==============================
+
+If you want to exploit the full power of internationalization, you
+should configure it using
+
+     ./configure --with-included-gettext
+
+to force usage of internationalizing routines provided within this
+package, despite the existence of internationalizing capabilities in the
+operating system where this package is being installed.  So far, only
+the `gettext' implementation in the GNU C library version 2 provides as
+many features (such as locale alias, message inheritance, automatic
+charset conversion or plural form handling) as the implementation here.
+It is also not possible to offer this additional functionality on top
+of a `catgets' implementation.  Future versions of GNU `gettext' will
+very likely convey even more functionality.  So it might be a good idea
+to change to GNU `gettext' as soon as possible.
+
+   So you need _not_ provide this option if you are using GNU libc 2 or
+you have installed a recent copy of the GNU gettext package with the
+included `libintl'.
+
+1.2 INSTALL Matters
+===================
+
+Some packages are "localizable" when properly installed; the programs
+they contain can be made to speak your own native language.  Most such
+packages use GNU `gettext'.  Other packages have their own ways to
+internationalization, predating GNU `gettext'.
+
+   By default, this package will be installed to allow translation of
+messages.  It will automatically detect whether the system already
+provides the GNU `gettext' functions.  If not, the included GNU
+`gettext' library will be used.  This library is wholly contained
+within this package, usually in the `intl/' subdirectory, so prior
+installation of the GNU `gettext' package is _not_ required.
+Installers may use special options at configuration time for changing
+the default behaviour.  The commands:
+
+     ./configure --with-included-gettext
+     ./configure --disable-nls
+
+will, respectively, bypass any pre-existing `gettext' to use the
+internationalizing routines provided within this package, or else,
+_totally_ disable translation of messages.
+
+   When you already have GNU `gettext' installed on your system and run
+configure without an option for your new package, `configure' will
+probably detect the previously built and installed `libintl.a' file and
+will decide to use this.  This might not be desirable.  You should use
+the more recent version of the GNU `gettext' library.  I.e. if the file
+`intl/VERSION' shows that the library which comes with this package is
+more recent, you should use
+
+     ./configure --with-included-gettext
+
+to prevent auto-detection.
+
+   The configuration process will not test for the `catgets' function
+and therefore it will not be used.  The reason is that even an
+emulation of `gettext' on top of `catgets' could not provide all the
+extensions of the GNU `gettext' library.
+
+   Internationalized packages usually have many `po/LL.po' files, where
+LL gives an ISO 639 two-letter code identifying the language.  Unless
+translations have been forbidden at `configure' time by using the
+`--disable-nls' switch, all available translations are installed
+together with the package.  However, the environment variable `LINGUAS'
+may be set, prior to configuration, to limit the installed set.
+`LINGUAS' should then contain a space separated list of two-letter
+codes, stating which languages are allowed.
+
+1.3 Using This Package
+======================
+
+As a user, if your language has been installed for this package, you
+only have to set the `LANG' environment variable to the appropriate
+`LL_CC' combination.  Here `LL' is an ISO 639 two-letter language code,
+and `CC' is an ISO 3166 two-letter country code.  For example, let's
+suppose that you speak German and live in Germany.  At the shell
+prompt, merely execute `setenv LANG de_DE' (in `csh'),
+`export LANG; LANG=de_DE' (in `sh') or `export LANG=de_DE' (in `bash').
+This can be done from your `.login' or `.profile' file, once and for
+all.
+
+   You might think that the country code specification is redundant.
+But in fact, some languages have dialects in different countries.  For
+example, `de_AT' is used for Austria, and `pt_BR' for Brazil.  The
+country code serves to distinguish the dialects.
+
+   The locale naming convention of `LL_CC', with `LL' denoting the
+language and `CC' denoting the country, is the one use on systems based
+on GNU libc.  On other systems, some variations of this scheme are
+used, such as `LL' or `LL_CC.ENCODING'.  You can get the list of
+locales supported by your system for your country by running the command
+`locale -a | grep '^LL''.
+
+   Not all programs have translations for all languages.  By default, an
+English message is shown in place of a nonexistent translation.  If you
+understand other languages, you can set up a priority list of languages.
+This is done through a different environment variable, called
+`LANGUAGE'.  GNU `gettext' gives preference to `LANGUAGE' over `LANG'
+for the purpose of message handling, but you still need to have `LANG'
+set to the primary language; this is required by other parts of the
+system libraries.  For example, some Swedish users who would rather
+read translations in German than English for when Swedish is not
+available, set `LANGUAGE' to `sv:de' while leaving `LANG' to `sv_SE'.
+
+   Special advice for Norwegian users: The language code for Norwegian
+bokma*l changed from `no' to `nb' recently (in 2003).  During the
+transition period, while some message catalogs for this language are
+installed under `nb' and some older ones under `no', it's recommended
+for Norwegian users to set `LANGUAGE' to `nb:no' so that both newer and
+older translations are used.
+
+   In the `LANGUAGE' environment variable, but not in the `LANG'
+environment variable, `LL_CC' combinations can be abbreviated as `LL'
+to denote the language's main dialect.  For example, `de' is equivalent
+to `de_DE' (German as spoken in Germany), and `pt' to `pt_PT'
+(Portuguese as spoken in Portugal) in this context.
+
+1.4 Translating Teams
+=====================
+
+For the Free Translation Project to be a success, we need interested
+people who like their own language and write it well, and who are also
+able to synergize with other translators speaking the same language.
+Each translation team has its own mailing list.  The up-to-date list of
+teams can be found at the Free Translation Project's homepage,
+`http://www.iro.umontreal.ca/contrib/po/HTML/', in the "National teams"
+area.
+
+   If you'd like to volunteer to _work_ at translating messages, you
+should become a member of the translating team for your own language.
+The subscribing address is _not_ the same as the list itself, it has
+`-request' appended.  For example, speakers of Swedish can send a
+message to `sv-request at li.org', having this message body:
+
+     subscribe
+
+   Keep in mind that team members are expected to participate
+_actively_ in translations, or at solving translational difficulties,
+rather than merely lurking around.  If your team does not exist yet and
+you want to start one, or if you are unsure about what to do or how to
+get started, please write to `translation at iro.umontreal.ca' to reach the
+coordinator for all translator teams.
+
+   The English team is special.  It works at improving and uniformizing
+the terminology in use.  Proven linguistic skill are praised more than
+programming skill, here.
+
+1.5 Available Packages
+======================
+
+Languages are not equally supported in all packages.  The following
+matrix shows the current state of internationalization, as of May 2005.
+The matrix shows, in regard of each package, for which languages PO
+files have been submitted to translation coordination, with a
+translation percentage of at least 50%.
+
+     Ready PO files       af am ar az be bg bs ca cs cy da de el en en_GB
+                        +-------------------------------------------------+
+     GNUnet             |                                                 |
+     a2ps               |             []                [] [] []     []   |
+     aegis              |                                  ()             |
+     ant-phone          |                                  ()             |
+     anubis             |                                  []             |
+     ap-utils           |                                                 |
+     aspell             |                         []    [] []        []   |
+     bash               |                      []          []             |
+     batchelor          |                                  []             |
+     bfd                |                                                 |
+     bibshelf           |                                  []             |
+     binutils           |                               []                |
+     bison              |                               [] []             |
+     bluez-pin          | []                      []       [] []          |
+     clisp              |                                  []    []       |
+     console-tools      |                         []       []             |
+     coreutils          |                []    []       [] []             |
+     cpio               |                                                 |
+     cpplib             |                      []       [] []             |
+     darkstat           |                []             () []             |
+     dialog             |                      [] [] [] [] [] []          |
+     diffutils          |                      [] []    [] [] []          |
+     doodle             |                                  []             |
+     e2fsprogs          |                         []       []             |
+     enscript           |                      []       [] []        []   |
+     error              |                      []       [] []        []   |
+     fetchmail          |                      []       [] () []          |
+     fileutils          |                               [] []             |
+     findutils          |                      []       []    []          |
+     flex               |                      []       [] []             |
+     fslint             |                                  []             |
+     gas                |                                                 |
+     gawk               |                      []       [] []             |
+     gbiff              |                                  []             |
+     gcal               |                      []                         |
+     gcc                |                                  []             |
+     gettext-examples   | []                   []          [] []          |
+     gettext-runtime    |             []       []       [] []             |
+     gettext-tools      |                      []          []             |
+     gimp-print         |                         []    [] []        []   |
+     gip                |                                                 |
+     gliv               |                                  []             |
+     glunarclock        |                                                 |
+     gmult              | []                               []             |
+     gnubiff            |                                  ()             |
+     gnucash            |                         []       () ()     []   |
+     gnucash-glossary   |                               [] ()             |
+     gpe-aerial         |                         []       []             |
+     gpe-beam           |                         []       []             |
+     gpe-calendar       |                         []       []             |
+     gpe-clock          |                         []       []             |
+     gpe-conf           |                         []       []             |
+     gpe-contacts       |                                                 |
+     gpe-edit           |                         []                      |
+     gpe-go             |                         []                      |
+     gpe-login          |                         []       []             |
+     gpe-ownerinfo      |                         []       []             |
+     gpe-sketchbook     |                         []       []             |
+     gpe-su             |                         []       []             |
+     gpe-taskmanager    |                         []       []             |
+     gpe-timesheet      |                         []                      |
+     gpe-today          |                         []       []             |
+     gpe-todo           |                         []       []             |
+     gphoto2            |                         []    [] []        []   |
+     gprof              |                               [] []             |
+     gpsdrive           |                                  ()    ()       |
+     gramadoir          | []                               []             |
+     grep               | []          [] []    []          [] []          |
+     gretl              |                                                 |
+     gsasl              |                                  []             |
+     gss                |                                                 |
+     gst-plugins        | []       []          [] []       []        []   |
+     gstreamer          | []                   [] []       []        []   |
+     gtick              | []                               ()             |
+     gtkspell           |             []                   [] []          |
+     hello              |                      []       [] [] []          |
+     id-utils           |                               [] []             |
+     impost             |                                                 |
+     indent             |                      []          []             |
+     iso_3166           |                                                 |
+     iso_3166_1         |                      [] []    [] [] []          |
+     iso_3166_2         |                                                 |
+     iso_3166_3         |                                  []             |
+     iso_4217           |                                                 |
+     iso_639            |                                                 |
+     jpilot             |                         []                      |
+     jtag               |                                                 |
+     jwhois             |                                                 |
+     kbd                |                         []    [] [] []          |
+     latrine            |                                  ()             |
+     ld                 |                               []                |
+     libc               |                      [] []    [] [] []          |
+     libextractor       |                                                 |
+     libgpewidget       |                         []    [] []             |
+     libgphoto2         |                                  []             |
+     libgphoto2_port    |                                  []             |
+     libgsasl           |                                                 |
+     libiconv           | []                   []       [] [] []          |
+     libidn             |                                                 |
+     lifelines          |                               [] ()             |
+     lilypond           |                                  []             |
+     lingoteach         |                                                 |
+     lynx               |                      [] []    [] []             |
+     m4                 |                         []    [] [] []          |
+     mailutils          |                      []                         |
+     make               |                               [] []             |
+     man-db             |                      [] ()    [] []             |
+     minicom            |                         []       []             |
+     mysecretdiary      |                               [] []             |
+     nano               |                      [] ()       []             |
+     nano_1_0           |                      [] ()    [] []             |
+     opcodes            |                                  []             |
+     parted             |                      [] []    [] []             |
+     psmisc             |                                                 |
+     ptx                |                      []       [] []             |
+     pwdutils           |                                                 |
+     python             |                                                 |
+     radius             |                      []                         |
+     recode             |             []       []       [] [] []          |
+     rpm                |                         []    []                |
+     screem             |                                                 |
+     scrollkeeper       |          [] []       [] [] [] [] []        []   |
+     sed                |                      []          []             |
+     sh-utils           |                               [] []             |
+     shared-mime-info   |                []       []                      |
+     sharutils          |                      [] []    [] [] []          |
+     silky              |                                                 |
+     skencil            |                               [] ()             |
+     sketch             |                               [] ()             |
+     solfege            |                                  []             |
+     soundtracker       |                               [] []             |
+     sp                 |                                  []             |
+     stardict           |                         []                      |
+     tar                |                                                 |
+     texinfo            |                               [] []             |
+     textutils          |                      []       [] []             |
+     tin                |                                  ()        ()   |
+     tp-robot           |                                  []             |
+     tuxpaint           | []                   [] []    [] [] []     []   |
+     unicode-han-tra... |                                                 |
+     unicode-transla... |                                                 |
+     util-linux         |                      [] []    [] []             |
+     vorbis-tools       |             []          []    []           []   |
+     wastesedge         |                                  ()             |
+     wdiff              |                      []       [] []        []   |
+     wget               |                                                 |
+     xchat              |                []    []          [] []     []   |
+     xkeyboard-config   |                                                 |
+     xpad               |                                                 |
+                        +-------------------------------------------------+
+                          af am ar az be bg bs ca cs cy da de el en en_GB
+                          10  0  0  2  7  5  0 40 43  2 51 91 19  1  14
+
+                          eo es et eu fa fi fr  ga gl he hi hr hu id is
+                        +-----------------------------------------------+
+     GNUnet             |                                               |
+     a2ps               |       []       [] []                          |
+     aegis              |                                               |
+     ant-phone          |                   []                          |
+     anubis             |                   []                          |
+     ap-utils           |                   []                          |
+     aspell             |                   []  []                      |
+     bash               | [] []             []                 []       |
+     batchelor          |                   []  []                      |
+     bfd                |    []                                         |
+     bibshelf           |    []                 []                      |
+     binutils           |    []             []                          |
+     bison              |    [] []          []  []                []    |
+     bluez-pin          | []             [] []  []             [] []    |
+     clisp              |    []             []                          |
+     console-tools      |                                               |
+     coreutils          |    [] []       [] []  []                      |
+     cpio               |    []             []                          |
+     cpplib             |    []             []                          |
+     darkstat           |    []             ()  []             [] []    |
+     dialog             |    [] [] []    [] []  []             []       |
+     diffutils          | [] []          [] []  [] [] []       [] []    |
+     doodle             |                       []                      |
+     e2fsprogs          |    []             []                          |
+     enscript           |                   []              []          |
+     error              |    []          [] []  []             []       |
+     fetchmail          |    []                                         |
+     fileutils          |    [] []          []  []             []       |
+     findutils          |    [] []          []  []                      |
+     flex               |    []             []  []                      |
+     fslint             |                   []                          |
+     gas                |    []             []                          |
+     gawk               |    []             []  []    []                |
+     gbiff              |                   []                          |
+     gcal               |    []             []                          |
+     gcc                |    []                                         |
+     gettext-examples   |    []             []  []                      |
+     gettext-runtime    |    []          [] []  []                []    |
+     gettext-tools      |    []             []                          |
+     gimp-print         |    []             []                          |
+     gip                |    []    []       []                          |
+     gliv               |                   ()                          |
+     glunarclock        |                []     []             []       |
+     gmult              |          []       []                          |
+     gnubiff            |                   ()                          |
+     gnucash            |    []                                ()       |
+     gnucash-glossary   |    []                                         |
+     gpe-aerial         |    []             []                          |
+     gpe-beam           |    []             []                          |
+     gpe-calendar       |    []             []                 [] []    |
+     gpe-clock          |    []          [] []                          |
+     gpe-conf           |                   []                          |
+     gpe-contacts       |                   []                          |
+     gpe-edit           |                   []                    []    |
+     gpe-go             |    []             []                          |
+     gpe-login          |    []             []                 []       |
+     gpe-ownerinfo      |    []          [] []                 [] []    |
+     gpe-sketchbook     |    []             []                          |
+     gpe-su             |    []          [] []                          |
+     gpe-taskmanager    |    []          [] []                          |
+     gpe-timesheet      |    []             []  []                []    |
+     gpe-today          |    []          [] []  []                      |
+     gpe-todo           |    []             []                    []    |
+     gphoto2            |    []          [] []                 []       |
+     gprof              |    []             []                    []    |
+     gpsdrive           |    ()             ()                 []       |
+     gramadoir          |                   []  []                      |
+     grep               |    [] [] []    [] []  [] [] []    [] [] []    |
+     gretl              |    []             []                          |
+     gsasl              |          []       []  []                      |
+     gss                |                   []                          |
+     gst-plugins        |                   []                 []       |
+     gstreamer          |                                               |
+     gtick              |          []    [] []  []                      |
+     gtkspell           | [] []    []       []  []                      |
+     hello              | [] [] [] [] [] [] []  [] [] []    [] [] []    |
+     id-utils           |                   []                 [] []    |
+     impost             |                   []  []                      |
+     indent             | [] [] [] []    [] []  [] []          [] []    |
+     iso_3166           | []             [] []                          |
+     iso_3166_1         |    []    []    [] []  []             [] []    |
+     iso_3166_2         |                   []                          |
+     iso_3166_3         |                   []                          |
+     iso_4217           |       []       []        []                   |
+     iso_639            | []          [] [] []                          |
+     jpilot             |    []             []                          |
+     jtag               |                   []                          |
+     jwhois             |    []             []                 [] []    |
+     kbd                |    []             []                          |
+     latrine            |                   []  []                      |
+     ld                 |    []             []                          |
+     libc               |    []          [] []     []          []       |
+     libextractor       |                                               |
+     libgpewidget       |    []             []  []             [] []    |
+     libgphoto2         |    []             []                 []       |
+     libgphoto2_port    |                   []                          |
+     libgsasl           |                   []  []                      |
+     libiconv           | [] [] []       [] []  [] []       [] [] []    |
+     libidn             | []                []                          |
+     lifelines          |                   ()                          |
+     lilypond           |                                               |
+     lingoteach         |                   []                    []    |
+     lynx               |       []                             []       |
+     m4                 |                   []  [] []             []    |
+     mailutils          |    []             []                          |
+     make               |    []          [] []  [] [] []    []          |
+     man-db             |    ()                                         |
+     minicom            |    []          [] []                 []       |
+     mysecretdiary      |    []             []                    []    |
+     nano               |    []    []    () []                          |
+     nano_1_0           |    []             []     []             []    |
+     opcodes            |    []          [] []                          |
+     parted             |    []             []     []                   |
+     psmisc             |          []                                   |
+     ptx                | [] [] []       [] []  [] []          [] []    |
+     pwdutils           |                                               |
+     python             |                                               |
+     radius             |    []             []                          |
+     recode             | [] []             []     [] []       [] []    |
+     rpm                |                   []                          |
+     screem             |                                               |
+     scrollkeeper       |    []          []                    []       |
+     sed                | [] [] []          []  []             []       |
+     sh-utils           |    [] []       [] []  []             []       |
+     shared-mime-info   | [] []    []    [] []                 []       |
+     sharutils          |    [] []       [] []     []          []       |
+     silky              |                   []                          |
+     skencil            |    []             []                          |
+     sketch             |    []             []                          |
+     solfege            |                                               |
+     soundtracker       |    []             []                          |
+     sp                 |                   []                          |
+     stardict           |                                      []       |
+     tar                |    [] []          []  []                      |
+     texinfo            | []                []        []                |
+     textutils          |    []             []  [] []          []       |
+     tin                |       []          ()                          |
+     tp-robot           |                   []                 []       |
+     tuxpaint           |    []          [] []  []    []       [] [] [] |
+     unicode-han-tra... |                                               |
+     unicode-transla... |                   []  []                      |
+     util-linux         |    [] []       [] []                 []       |
+     vorbis-tools       |    []             []                          |
+     wastesedge         |                   ()                          |
+     wdiff              |    [] []          []  [] []          [] []    |
+     wget               |       [] []           []          []          |
+     xchat              |    []    []    [] []           []             |
+     xkeyboard-config   |                                               |
+     xpad               |    []                 []             []       |
+                        +-----------------------------------------------+
+                          eo es et eu fa fi fr  ga gl he hi hr hu id is
+                          15 85 21 15  2 35 115 45 16  8  1  6 40 27  1
+
+                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
+                        +--------------------------------------------------+
+     GNUnet             |                                                  |
+     a2ps               | ()    ()                   []       []    ()     |
+     aegis              |                                     ()           |
+     ant-phone          |                                     []           |
+     anubis             |                            []    [] []           |
+     ap-utils           |                                                  |
+     aspell             |                         []          []           |
+     bash               |                                     []           |
+     batchelor          |                                     []           |
+     bfd                |                                                  |
+     bibshelf           | []                                               |
+     binutils           |                                                  |
+     bison              | []                         []    [] []           |
+     bluez-pin          |          []                         []           |
+     clisp              |                                     []           |
+     console-tools      |                                                  |
+     coreutils          |    []                               []           |
+     cpio               |                                                  |
+     cpplib             |                                     []           |
+     darkstat           |                            []       []           |
+     dialog             | []                                  []           |
+     diffutils          | [] []                      []       []           |
+     doodle             | []                                               |
+     e2fsprogs          | []                                               |
+     enscript           |                                     []           |
+     error              |                                     []           |
+     fetchmail          |    []                               []           |
+     fileutils          | [] []       []                                   |
+     findutils          | []                                  []           |
+     flex               |       []                            []           |
+     fslint             |                                     []           |
+     gas                |                                                  |
+     gawk               |    []                               []           |
+     gbiff              |                                     []           |
+     gcal               |                                                  |
+     gcc                |                                                  |
+     gettext-examples   | [] []                               []           |
+     gettext-runtime    | [] [] []                            []           |
+     gettext-tools      | [] [] []                                         |
+     gimp-print         |    []                               []           |
+     gip                |                                     []           |
+     gliv               |                                     []           |
+     glunarclock        |                            []       []           |
+     gmult              | [] []                                            |
+     gnubiff            | ()                                               |
+     gnucash            | [] ()                            () []           |
+     gnucash-glossary   | []                                  []           |
+     gpe-aerial         |                                     []           |
+     gpe-beam           |                                     []           |
+     gpe-calendar       |                                     []           |
+     gpe-clock          |                                     []           |
+     gpe-conf           |                                     []           |
+     gpe-contacts       |                                                  |
+     gpe-edit           |                                     []           |
+     gpe-go             |                                     []           |
+     gpe-login          |                                     []           |
+     gpe-ownerinfo      |                                     []           |
+     gpe-sketchbook     |                                     []           |
+     gpe-su             |                                     []           |
+     gpe-taskmanager    |          []                         []           |
+     gpe-timesheet      |                                     []           |
+     gpe-today          |                                     []           |
+     gpe-todo           |                                     []           |
+     gphoto2            | [] []                               []           |
+     gprof              |                                                  |
+     gpsdrive           | () ()                               ()    ()     |
+     gramadoir          |                                     ()           |
+     grep               | [] []                            [] []           |
+     gretl              | []                                               |
+     gsasl              |                                     []           |
+     gss                |                                                  |
+     gst-plugins        | []                                  []           |
+     gstreamer          | []                                  []           |
+     gtick              | []                                  []           |
+     gtkspell           | []                      []          []           |
+     hello              | [] [] []          []       []    [] [] [] []     |
+     id-utils           | []                                  []           |
+     impost             |                                                  |
+     indent             | [] []                               []           |
+     iso_3166           |                                     []           |
+     iso_3166_1         |                                     []    []     |
+     iso_3166_2         |                                     []           |
+     iso_3166_3         |                                     []           |
+     iso_4217           |    []                   []          []           |
+     iso_639            |    []                               [] []        |
+     jpilot             |    ()                               ()    ()     |
+     jtag               |                                                  |
+     jwhois             | []                                  []           |
+     kbd                |                                     []           |
+     latrine            | []                                  []           |
+     ld                 |                                                  |
+     libc               |    [] []                         [] []    []     |
+     libextractor       |                                                  |
+     libgpewidget       |                                     []           |
+     libgphoto2         | [] []                                            |
+     libgphoto2_port    | [] []                                            |
+     libgsasl           |                                     []           |
+     libiconv           | []                                  []           |
+     libidn             | []                                               |
+     lifelines          |                                     []           |
+     lilypond           |                                                  |
+     lingoteach         | []                                  []           |
+     lynx               | [] []                               []           |
+     m4                 |    []                               []           |
+     mailutils          |                                                  |
+     make               |    [] []                            []           |
+     man-db             |    ()                                            |
+     minicom            |    []                                            |
+     mysecretdiary      |                                     []           |
+     nano               | []                         []    []              |
+     nano_1_0           | []                         []    []    []        |
+     opcodes            |                                     []           |
+     parted             | [] []                               [] []        |
+     psmisc             | []                               [] []           |
+     ptx                |                                  [] []    []     |
+     pwdutils           |                                                  |
+     python             |                                                  |
+     radius             |                                                  |
+     recode             | []                                  []           |
+     rpm                |    [] []                                         |
+     screem             |    []                                            |
+     scrollkeeper       |                                  [] [] []        |
+     sed                |    []                               []           |
+     sh-utils           | [] []                            []              |
+     shared-mime-info   |       []                         [] [] []        |
+     sharutils          | [] []                               []           |
+     silky              |                                     []           |
+     skencil            |                                                  |
+     sketch             |                                                  |
+     solfege            | []                                  []    []     |
+     soundtracker       | []                                               |
+     sp                 |    ()                                            |
+     stardict           |                      []             []           |
+     tar                | [] []                               []           |
+     texinfo            |    []                            [] []           |
+     textutils          |    [] []                         []              |
+     tin                |                                                  |
+     tp-robot           |                                     []           |
+     tuxpaint           | [] [] []       []          []       [] []        |
+     unicode-han-tra... |                                                  |
+     unicode-transla... |                                                  |
+     util-linux         | [] []                               []           |
+     vorbis-tools       |                                     []           |
+     wastesedge         |                                     []           |
+     wdiff              | []                         []    []              |
+     wget               |    []                                            |
+     xchat              | []    []          [] []             []           |
+     xkeyboard-config   |                                     []           |
+     xpad               |                                     []           |
+                        +--------------------------------------------------+
+                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
+                          46 35 11  2  1  1  2  2  3 11  0 15 96  7  5  0
+
+                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
+                        +----------------------------------------------+
+     GNUnet             |                                              |
+     a2ps               |       ()     []      [] []       []    [] [] |
+     aegis              |                      () ()                   |
+     ant-phone          |                      []                      |
+     anubis             |       []             [] []                   |
+     ap-utils           |       ()                                     |
+     aspell             |                      [] []                   |
+     bash               |              []      [] []                   |
+     batchelor          |                      []                      |
+     bfd                |                                              |
+     bibshelf           |                                              |
+     binutils           |                         []                [] |
+     bison              |       []     []      [] []                [] |
+     bluez-pin          |       []     []   [] [] []    []       [] [] |
+     clisp              |                         []                   |
+     console-tools      |                         []                   |
+     coreutils          |       []                []       []       [] |
+     cpio               |       []                                  [] |
+     cpplib             |                                              |
+     darkstat           |       []     []      []       []       [] [] |
+     dialog             |       [] []  []   [] [] [] []                |
+     diffutils          |       []     []      [] []             [] [] |
+     doodle             |                                     []       |
+     e2fsprogs          |       []                                  [] |
+     enscript           |              []      [] []                [] |
+     error              |              []      []       []             |
+     fetchmail          |       []                []    []    []       |
+     fileutils          |       []             [] []       []       [] |
+     findutils          |       [] []          []       []       [] [] |
+     flex               |       []     []      [] []                [] |
+     fslint             |              []      []                []    |
+     gas                |                                              |
+     gawk               |       []     []      []                   [] |
+     gbiff              |                      []                      |
+     gcal               |                                           [] |
+     gcc                |                                              |
+     gettext-examples   |       []             [] []    []       [] [] |
+     gettext-runtime    |       []             [] []    [] []    [] [] |
+     gettext-tools      |       []             [] []    [] []    [] [] |
+     gimp-print         |                               []          [] |
+     gip                |                   []          []       []    |
+     gliv               |              []      []       []             |
+     glunarclock        |              []      [] []    []       [] [] |
+     gmult              |              []   [] []                []    |
+     gnubiff            |                      ()                   [] |
+     gnucash            |       () []             []    []          [] |
+     gnucash-glossary   |          []                   []          [] |
+     gpe-aerial         |          []  []      [] []             [] [] |
+     gpe-beam           |          []  []      [] []             [] [] |
+     gpe-calendar       |          []  []      [] []    []       [] [] |
+     gpe-clock          |          []  []      [] []    []       [] [] |
+     gpe-conf           |          []  []      [] []    []          [] |
+     gpe-contacts       |                      [] []             [] [] |
+     gpe-edit           |          []  []      [] []    []       [] [] |
+     gpe-go             |              []      [] []             [] [] |
+     gpe-login          |          []  []      [] []    []       [] [] |
+     gpe-ownerinfo      |          []  []      [] []    []       [] [] |
+     gpe-sketchbook     |          []  []      [] []    []       [] [] |
+     gpe-su             |          []  []      [] []    []       [] [] |
+     gpe-taskmanager    |          []  []      [] []    []       [] [] |
+     gpe-timesheet      |          []  []      [] []    []       [] [] |
+     gpe-today          |          []  []      [] []    []       [] [] |
+     gpe-todo           |    []    []  []      [] []    []       [] [] |
+     gphoto2            |                      []       []       [] [] |
+     gprof              |              []      []                   [] |
+     gpsdrive           |    []                []                      |
+     gramadoir          |                               []             |
+     grep               |       [] []  []      [] []       []    []    |
+     gretl              |       []                                     |
+     gsasl              |       []             []             [] [] [] |
+     gss                |       []             []                   [] |
+     gst-plugins        | []                                  [] [] [] |
+     gstreamer          |                         []          [] [] [] |
+     gtick              |                      [] []                [] |
+     gtkspell           |              []   [] [] []    []       []    |
+     hello              |       []     []      [] []    []       [] [] |
+     id-utils           |              []      [] []                [] |
+     impost             |                                              |
+     indent             |              []      [] []    []       [] [] |
+     iso_3166           |          []                []       [] [] [] |
+     iso_3166_1         |                               [] [] [] []    |
+     iso_3166_2         |                                              |
+     iso_3166_3         |                      []    []          []    |
+     iso_4217           |                            []          []    |
+     iso_639            |                            []          [] [] |
+     jpilot             |                                              |
+     jtag               |                               []             |
+     jwhois             |       []     []      [] ()                () |
+     kbd                |       []             []                   [] |
+     latrine            |                      []                   [] |
+     ld                 |                                           [] |
+     libc               |       []     []         []    []          [] |
+     libextractor       |                      []                      |
+     libgpewidget       |          []  []      []       []       [] [] |
+     libgphoto2         |                         []                [] |
+     libgphoto2_port    |                         []                   |
+     libgsasl           |       []             []                []    |
+     libiconv           |       []     []   [] [] []    [] [] [] [] [] |
+     libidn             |       []                                  () |
+     lifelines          |       []                                  [] |
+     lilypond           |                                              |
+     lingoteach         |              []                              |
+     lynx               |              []         []                [] |
+     m4                 |       []     []      [] []                [] |
+     mailutils          |       []             [] []                   |
+     make               |       []     []         []                [] |
+     man-db             |                      []                   [] |
+     minicom            |       []     []      [] []                   |
+     mysecretdiary      |              []      [] []                [] |
+     nano               |              []      []                   [] |
+     nano_1_0           |       []             [] []                [] |
+     opcodes            |                      []                   [] |
+     parted             |       [] []  []                           [] |
+     psmisc             |       []             []                      |
+     ptx                |       [] []  []      [] []                [] |
+     pwdutils           |       []                                     |
+     python             |                                              |
+     radius             |       []                []                   |
+     recode             |       []     []      [] []       []       [] |
+     rpm                |       [] []             []                [] |
+     screem             |                                              |
+     scrollkeeper       |       []             [] []    []    [] [] [] |
+     sed                |       [] []  []      [] []    []       [] [] |
+     sh-utils           |                         []       []    []    |
+     shared-mime-info   |          []  []         []          [] [] [] |
+     sharutils          |                         []             [] [] |
+     silky              |                               []             |
+     skencil            |          []  []                           [] |
+     sketch             |          []  []                           [] |
+     solfege            |                                              |
+     soundtracker       |                               []          [] |
+     sp                 |                                              |
+     stardict           |                         []    []             |
+     tar                |       []             [] []                [] |
+     texinfo            |       []             [] []                [] |
+     textutils          |                         []       []       [] |
+     tin                |                                              |
+     tp-robot           |                         []                   |
+     tuxpaint           |       [] []  []      []       []    [] [] [] |
+     unicode-han-tra... |                                              |
+     unicode-transla... |                                              |
+     util-linux         |              []         []                [] |
+     vorbis-tools       |                      [] []                   |
+     wastesedge         |                                              |
+     wdiff              |       []     []      [] []    []          [] |
+     wget               |                                              |
+     xchat              |    []                   []    [] [] [] [] [] |
+     xkeyboard-config   |                                              |
+     xpad               |                                              |
+                        +----------------------------------------------+
+                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
+                           1  3 47 29  57    6 78 73  5 44 12 12 50 85
+
+                          ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
+                        +-----------------------------------------------+
+     GNUnet             |                                               |  0
+     a2ps               |             [] []     []                      | 19
+     aegis              |                                               |  0
+     ant-phone          |             []        []                      |  5
+     anubis             |             [] []     []                      | 11
+     ap-utils           |                ()     []                      |  2
+     aspell             |                []     [] []                   | 13
+     bash               |                       []                      | 11
+     batchelor          |             []        []                      |  7
+     bfd                |                                               |  1
+     bibshelf           |                       []                      |  5
+     binutils           |             []                                |  6
+     bison              |             []        []                      | 18
+     bluez-pin          |             [] []     [] []     []            | 25
+     clisp              |                                               |  7
+     console-tools      |             []        []                      |  5
+     coreutils          |             []        []                      | 17
+     cpio               |             [] []     []                      |  7
+     cpplib             |             []        []                      |  8
+     darkstat           |                       []        ()    ()      | 15
+     dialog             |             [] []     []                      | 25
+     diffutils          |             []        []        []    []      | 28
+     doodle             |                       []                      |  5
+     e2fsprogs          |             []                                |  8
+     enscript           |             []                                | 12
+     error              |             []        []              []      | 16
+     fetchmail          |             []                                | 12
+     fileutils          |             []                  []    []      | 18
+     findutils          |             []        []                      | 17
+     flex               |             []        []                      | 15
+     fslint             |                       []                      |  7
+     gas                |             []                                |  3
+     gawk               |             []                                | 14
+     gbiff              |                       []                      |  5
+     gcal               |             []                                |  5
+     gcc                |             []                  []            |  4
+     gettext-examples   |             [] []     []        []    []      | 21
+     gettext-runtime    |             [] []     []        []    []      | 25
+     gettext-tools      |             [] []     []        []    []      | 19
+     gimp-print         |                []                             | 11
+     gip                |                       []                      |  8
+     gliv               |             []        []                      |  7
+     glunarclock        |                       [] []                   | 13
+     gmult              |             []        []        []            | 13
+     gnubiff            |                       []                      |  3
+     gnucash            |             ()                        []      | 10
+     gnucash-glossary   |                       []              []      |  9
+     gpe-aerial         |                       []        []            | 13
+     gpe-beam           |                       []        []            | 13
+     gpe-calendar       |                       [] []     []    []      | 18
+     gpe-clock          |             []        [] []     []            | 17
+     gpe-conf           |                       []        []            | 12
+     gpe-contacts       |                       []        []            |  7
+     gpe-edit           |             []        [] []           []      | 15
+     gpe-go             |             []        []                      | 11
+     gpe-login          |             []        [] []     []    []      | 18
+     gpe-ownerinfo      |             []        []        []    []      | 19
+     gpe-sketchbook     |             []        []                      | 14
+     gpe-su             |             []        []        []            | 16
+     gpe-taskmanager    |             []        []        []            | 17
+     gpe-timesheet      |             []        []        []    []      | 17
+     gpe-today          |             []        [] []     []    []      | 19
+     gpe-todo           |                       [] []           []      | 17
+     gphoto2            |                []               []    []      | 18
+     gprof              |             []        []                      | 10
+     gpsdrive           |                                               |  3
+     gramadoir          |                       []                      |  6
+     grep               |             [] []     []              []      | 32
+     gretl              |                                               |  4
+     gsasl              |                       []        []            | 12
+     gss                |                       []                      |  5
+     gst-plugins        |                []     []              []      | 17
+     gstreamer          |             [] []     []              []      | 15
+     gtick              |                       []                      | 11
+     gtkspell           |                       [] []     []    []      | 21
+     hello              |             [] []     []        []            | 37
+     id-utils           |             []        []                      | 13
+     impost             |                       []                      |  3
+     indent             |             []        []        []    []      | 25
+     iso_3166           |          [] []        []                      | 12
+     iso_3166_1         |             []           []                   | 20
+     iso_3166_2         |                                               |  2
+     iso_3166_3         |                          []     []            |  8
+     iso_4217           |             []        []                      | 10
+     iso_639            |                       [] []                   | 12
+     jpilot             |             [] []               []            |  6
+     jtag               |                                               |  2
+     jwhois             |             []        []              []      | 12
+     kbd                |             []        []                      | 12
+     latrine            |             []        []                      |  8
+     ld                 |             []                                |  5
+     libc               |             []                  []            | 22
+     libextractor       |                                               |  1
+     libgpewidget       |                       [] []                   | 17
+     libgphoto2         |                                 []            |  9
+     libgphoto2_port    |                                               |  5
+     libgsasl           |                       []                      |  7
+     libiconv           |             [] []     [] []     []            | 32
+     libidn             |                       []        []            |  6
+     lifelines          |                                               |  4
+     lilypond           |                                               |  1
+     lingoteach         |                       []                      |  6
+     lynx               |             [] []     []                      | 15
+     m4                 |                       []        []            | 17
+     mailutils          |                []                             |  7
+     make               |             []                  []            | 18
+     man-db             |                                               |  5
+     minicom            |                                               | 11
+     mysecretdiary      |             []        []                      | 12
+     nano               |                       []              []      | 13
+     nano_1_0           |             [] []     []                      | 18
+     opcodes            |             []        []                      |  9
+     parted             |             [] []               []            | 18
+     psmisc             |                       []                      |  7
+     ptx                |             []                  []            | 23
+     pwdutils           |                                               |  1
+     python             |                                               |  0
+     radius             |                []                             |  6
+     recode             |             []        []                      | 22
+     rpm                |             [] []                             | 11
+     screem             |                                               |  1
+     scrollkeeper       |             [] []                     []      | 24
+     sed                |             []        []              []      | 21
+     sh-utils           |             []                                | 15
+     shared-mime-info   |                []               []    []      | 21
+     sharutils          |             []        []              []      | 20
+     silky              |                                               |  3
+     skencil            |                                               |  6
+     sketch             |                                               |  6
+     solfege            |                                               |  4
+     soundtracker       |             []                                |  8
+     sp                 |             []                                |  3
+     stardict           |                []     []        []    []      | 10
+     tar                |             [] []     []              []      | 15
+     texinfo            |             []                  []            | 14
+     textutils          |             []                  []    []      | 17
+     tin                |                                               |  1
+     tp-robot           |                       []        []    []      |  8
+     tuxpaint           |             []        [] []     []            | 34
+     unicode-han-tra... |                                               |  0
+     unicode-transla... |                                               |  2
+     util-linux         |             [] []     []                      | 18
+     vorbis-tools       |                []                             | 10
+     wastesedge         |                                               |  1
+     wdiff              |             []        []                      | 22
+     wget               |             []        []                      |  7
+     xchat              |                []     []        []    []      | 26
+     xkeyboard-config   |                       []                      |  2
+     xpad               |                       []                      |  5
+                        +-----------------------------------------------+
+       73 teams           ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
+      149 domains          0  0  0  1 77 30  0  92 16  0  42    32    0  1746
+
+   Some counters in the preceding matrix are higher than the number of
+visible blocks let us expect.  This is because a few extra PO files are
+used for implementing regional variants of languages, or language
+dialects.
+
+   For a PO file in the matrix above to be effective, the package to
+which it applies should also have been internationalized and
+distributed as such by its maintainer.  There might be an observable
+lag between the mere existence a PO file and its wide availability in a
+distribution.
+
+   If May 2005 seems to be old, you may fetch a more recent copy of
+this `ABOUT-NLS' file on most GNU archive sites.  The most up-to-date
+matrix with full percentage details can be found at
+`http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html'.
+
+1.6 Using `gettext' in new packages
+===================================
+
+If you are writing a freely available program and want to
+internationalize it you are welcome to use GNU `gettext' in your
+package.  Of course you have to respect the GNU Library General Public
+License which covers the use of the GNU `gettext' library.  This means
+in particular that even non-free programs can use `libintl' as a shared
+library, whereas only free software can use `libintl' as a static
+library or use modified versions of `libintl'.
+
+   Once the sources are changed appropriately and the setup can handle
+the use of `gettext' the only thing missing are the translations.  The
+Free Translation Project is also available for packages which are not
+developed inside the GNU project.  Therefore the information given above
+applies also for every other Free Software Project.  Contact
+`translation at iro.umontreal.ca' to make the `.pot' files available to
+the translation teams.
+

Copied: trunk/c-version/Makefile.am (from rev 809, trunk/Makefile.am)
===================================================================
--- trunk/c-version/Makefile.am	                        (rev 0)
+++ trunk/c-version/Makefile.am	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,18 @@
+## Process this file with automake to produce Makefile.in
+
+SUBDIRS = po src doc
+
+EXTRA_DIST = config.rpath po m4 \
+	autogen.sh sst.spec ChangeLog.old
+
+maintainer-clean-local:
+	rm -f configure
+	rm -f aclocal.m4
+	rm -f `find . -name Makefile.in`
+	rm -f `find . -name *~`
+	rm -f src/include/config.h.in
+
+clean-local:
+	rm -rf autom4te*.cache
+
+ACLOCAL_AMFLAGS = -I m4

Copied: trunk/c-version/autogen.sh (from rev 809, trunk/autogen.sh)
===================================================================
--- trunk/c-version/autogen.sh	                        (rev 0)
+++ trunk/c-version/autogen.sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,4 @@
+#!/bin/sh
+# Run this to generate all the initial makefiles, etc.
+
+autoreconf -v

Copied: trunk/c-version/compile (from rev 809, trunk/compile)
===================================================================
--- trunk/c-version/compile	                        (rev 0)
+++ trunk/c-version/compile	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,142 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand `-c -o'.
+
+scriptversion=2005-05-14.22
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
+# Written by Tom Tromey <tromey at cygnus.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake at gnu.org> or send patches to
+# <automake-patches at gnu.org>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand `-c -o'.
+Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file `INSTALL'.
+
+Report bugs to <bug-automake at gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "compile $scriptversion"
+    exit $?
+    ;;
+esac
+
+ofile=
+cfile=
+eat=
+
+for arg
+do
+  if test -n "$eat"; then
+    eat=
+  else
+    case $1 in
+      -o)
+	# configure might choose to run compile as `compile cc -o foo foo.c'.
+	# So we strip `-o arg' only if arg is an object.
+	eat=1
+	case $2 in
+	  *.o | *.obj)
+	    ofile=$2
+	    ;;
+	  *)
+	    set x "$@" -o "$2"
+	    shift
+	    ;;
+	esac
+	;;
+      *.c)
+	cfile=$1
+	set x "$@" "$1"
+	shift
+	;;
+      *)
+	set x "$@" "$1"
+	shift
+	;;
+    esac
+  fi
+  shift
+done
+
+if test -z "$ofile" || test -z "$cfile"; then
+  # If no `-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # `.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec "$@"
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo "$cfile" | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use `[/.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo "$cofile" | sed -e 's|[/.-]|_|g'`.d
+while true; do
+  if mkdir "$lockdir" >/dev/null 2>&1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap "rmdir '$lockdir'; exit 1" 1 2 15
+
+# Run the compile.
+"$@"
+ret=$?
+
+if test -f "$cofile"; then
+  mv "$cofile" "$ofile"
+elif test -f "${cofile}bj"; then
+  mv "${cofile}bj" "$ofile"
+fi
+
+rmdir "$lockdir"
+exit $ret
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:

Copied: trunk/c-version/config.guess (from rev 809, trunk/config.guess)
===================================================================
--- trunk/c-version/config.guess	                        (rev 0)
+++ trunk/c-version/config.guess	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,1463 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-07-08'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Originally written by Per Bothner <per at bothner.com>.
+# Please send patches to <config-patches at gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches at gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi at noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee at wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_targets" in
+	  elf32-i386)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  a.out-i386-linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit ;;
+	  "")
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#ifdef __INTEL_COMPILER
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && { echo i486-ncr-sysv4; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel at ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes at openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf at swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green at stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green at stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    *86) UNAME_PROCESSOR=i686 ;;
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    c34*)
+	echo c34-convex-bsd
+	exit ;;
+    c38*)
+	echo c38-convex-bsd
+	exit ;;
+    c4*)
+	echo c4-convex-bsd
+	exit ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches at gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:

Copied: trunk/c-version/config.rpath (from rev 809, trunk/config.rpath)
===================================================================
--- trunk/c-version/config.rpath	                        (rev 0)
+++ trunk/c-version/config.rpath	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,571 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2005 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord at gnu.ai.mit.edu>, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except M$VC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+cc_basename=`echo "$CC" | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case "$cc_basename" in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux*)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    sco3.2v5*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja at dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris* | sysv5*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    linux*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = yes; then
+    # Unlike libtool, we use -rpath here, not --rpath, since the documented
+    # option of GNU ld is called -rpath, not --rpath.
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            hardcode_direct=yes
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' > conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z "$aix_libpath"; then
+        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z "$aix_libpath"; then
+        aix_libpath="/usr/lib:/lib"
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test "$GCC" = yes ; then
+        :
+      else
+        case "$cc_basename" in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | kfreebsd*-gnu | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10* | hpux11*)
+      if test "$with_gnu_ld" = no; then
+        case "$host_cpu" in
+          hppa*64*)
+            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+            hardcode_libdir_separator=:
+            hardcode_direct=no
+            ;;
+          ia64*)
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_direct=no
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+          *)
+            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+            hardcode_libdir_separator=:
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      hardcode_direct=yes
+      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      else
+        case "$host_os" in
+          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+            hardcode_libdir_flag_spec='-R$libdir'
+            ;;
+          *)
+            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+            ;;
+        esac
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    sco3.2v5*)
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4.2uw2*)
+      hardcode_direct=yes
+      hardcode_minus_L=no
+      ;;
+    sysv5OpenUNIX8* | sysv5UnixWare7* |  sysv5uw[78]* | unixware7*)
+      ;;
+    sysv5*)
+      hardcode_libdir_flag_spec=
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+libname_spec='lib$name'
+case "$host_os" in
+  aix3*)
+    ;;
+  aix4* | aix5*)
+    ;;
+  amigaos*)
+    ;;
+  beos*)
+    ;;
+  bsdi[45]*)
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    ;;
+  dgux*)
+    ;;
+  freebsd1*)
+    ;;
+  kfreebsd*-gnu)
+    ;;
+  freebsd*)
+    ;;
+  gnu*)
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case "$host_cpu" in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    ;;
+  irix5* | irix6* | nonstopux*)
+    case "$host_os" in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux*)
+    ;;
+  knetbsd*-gnu)
+    ;;
+  netbsd*)
+    ;;
+  newsos6)
+    ;;
+  nto-qnx*)
+    ;;
+  openbsd*)
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    ;;
+  osf3* | osf4* | osf5*)
+    ;;
+  sco3.2v5*)
+    ;;
+  solaris*)
+    ;;
+  sunos4*)
+    ;;
+  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+    ;;
+  sysv4*MP*)
+    ;;
+  uts4*)
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+EOF

Copied: trunk/c-version/config.sub (from rev 809, trunk/config.sub)
===================================================================
--- trunk/c-version/config.sub	                        (rev 0)
+++ trunk/c-version/config.sub	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,1579 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-07-08'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Please send patches to <config-patches at gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches at gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
+  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| ms1 \
+	| msp430 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m32c)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| ms1-* \
+	| msp430-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	m32c-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16c)
+		basic_machine=cr16c-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+        -tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:

Copied: trunk/c-version/configure.ac (from rev 809, trunk/configure.ac)
===================================================================
--- trunk/c-version/configure.ac	                        (rev 0)
+++ trunk/c-version/configure.ac	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,52 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ(2.57)
+AC_INIT(sst, 2.0, stsp)
+AM_INIT_AUTOMAKE([])
+AM_GNU_GETTEXT([external])
+AM_GNU_GETTEXT_VERSION(0.14.5)
+AM_CONFIG_HEADER([src/config.h])
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_LN_S
+
+AC_CHECK_TOOL(have_xmlto, xmlto, "no")
+if test "$have_xmlto" = "no";
+then
+    AC_MSG_ERROR([xmlto is not installed])
+fi
+AC_CHECK_TOOL(have_python, python, "no")
+if test "$have_python" = "no";
+then
+    AC_MSG_ERROR([python is not installed])
+fi
+
+# Checks for libraries.
+AC_CHECK_LIB(m, floor, [],
+    AC_MSG_ERROR([math library is missing on your system.]))
+AC_CHECK_LIB(ncursesw, newwin, [],
+    AC_MSG_ERROR([ncurses library is missing on your system.]))
+
+# Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS([curses.h],
+    [], AC_MSG_ERROR([curses headers are missing on your system.]))
+AC_CHECK_HEADERS([fcntl.h sys/ioctl.h linux/kd.h])
+# Checks for typedefs, structures, and compiler characteristics.
+
+# Checks for library functions.
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_VPRINTF
+AC_CHECK_FUNCS([pow sqrt floor strcasecmp strncasecmp strchr strstr atexit], [],
+    AC_MSG_ERROR([some functions are missing on your system.]))
+
+AC_CONFIG_FILES([
+    Makefile
+    src/Makefile
+    po/Makefile.in
+    doc/Makefile
+])
+AC_OUTPUT

Copied: trunk/c-version/depcomp (from rev 809, trunk/depcomp)
===================================================================
--- trunk/c-version/depcomp	                        (rev 0)
+++ trunk/c-version/depcomp	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,530 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2005-07-09.11
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva at dcc.unicamp.br>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake at gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+  "$@" -MT "$object" -MD -MP -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' < "$tmpdepfile" |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' < "$tmpdepfile" \
+    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' >> $depfile
+    echo >> $depfile
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' < "$tmpdepfile" \
+   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   >> $depfile
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  stripped=`echo "$object" | sed 's/\(.*\)\..*$/\1/'`
+  tmpdepfile="$stripped.u"
+  if test "$libtool" = yes; then
+    "$@" -Wc,-M
+  else
+    "$@" -M
+  fi
+  stat=$?
+
+  if test -f "$tmpdepfile"; then :
+  else
+    stripped=`echo "$stripped" | sed 's,^.*/,,'`
+    tmpdepfile="$stripped.u"
+  fi
+
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+
+  if test -f "$tmpdepfile"; then
+    outname="$stripped.o"
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e "s,^$outname:,$object :," < "$tmpdepfile" > "$depfile"
+    sed -e "s,^$outname: \(.*\)$,\1:," < "$tmpdepfile" >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
+    sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+   test "x$dir" = "x$object" && dir=
+   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test "$libtool" = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mecanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      "$@" -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      "$@" -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+      exit $stat
+   fi
+
+   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+   do
+     test -f "$tmpdepfile" && break
+   done
+   if test -f "$tmpdepfile"; then
+      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+   else
+      echo "#dummy" > "$depfile"
+   fi
+   rm -f "$tmpdepfile"
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  "$@" $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  tr ' ' '
+' < "$tmpdepfile" | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no
+  for arg in "$@"; do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix="`echo $object | sed 's/^.*\././'`"
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  sed '1,2d' "$tmpdepfile" | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E |
+    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o,
+  # because we must use -o when running libtool.
+  "$@" || exit $?
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+	set fnord "$@"
+	shift
+	shift
+	;;
+    *)
+	set fnord "$@" "$arg"
+	shift
+	shift
+	;;
+    esac
+  done
+  "$@" -E |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::echo "`cygpath -u \\"\1\\"`":p' | sort | uniq > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
+  echo "	" >> "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:

Copied: trunk/c-version/install-sh (from rev 809, trunk/install-sh)
===================================================================
--- trunk/c-version/install-sh	                        (rev 0)
+++ trunk/c-version/install-sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,323 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2005-05-14.22
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+chmodcmd="$chmodprog 0755"
+chowncmd=
+chgrpcmd=
+stripcmd=
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=
+dst=
+dir_arg=
+dstarg=
+no_target_directory=
+
+usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+-c         (ignored)
+-d         create directories instead of installing files.
+-g GROUP   $chgrpprog installed files to GROUP.
+-m MODE    $chmodprog installed files to MODE.
+-o USER    $chownprog installed files to USER.
+-s         $stripprog installed files.
+-t DIRECTORY  install into DIRECTORY.
+-T         report an error if DSTFILE is a directory.
+--help     display this help and exit.
+--version  display version info and exit.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
+"
+
+while test -n "$1"; do
+  case $1 in
+    -c) shift
+        continue;;
+
+    -d) dir_arg=true
+        shift
+        continue;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+        shift
+        shift
+        continue;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) chmodcmd="$chmodprog $2"
+        shift
+        shift
+        continue;;
+
+    -o) chowncmd="$chownprog $2"
+        shift
+        shift
+        continue;;
+
+    -s) stripcmd=$stripprog
+        shift
+        continue;;
+
+    -t) dstarg=$2
+	shift
+	shift
+	continue;;
+
+    -T) no_target_directory=true
+	shift
+	continue;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    *)  # When -d is used, all remaining arguments are directories to create.
+	# When -t is used, the destination is already specified.
+	test -n "$dir_arg$dstarg" && break
+        # Otherwise, the last argument is the destination.  Remove it from $@.
+	for arg
+	do
+          if test -n "$dstarg"; then
+	    # $@ is not empty: it contains at least $arg.
+	    set fnord "$@" "$dstarg"
+	    shift # fnord
+	  fi
+	  shift # arg
+	  dstarg=$arg
+	done
+	break;;
+  esac
+done
+
+if test -z "$1"; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src ;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    src=
+
+    if test -d "$dst"; then
+      mkdircmd=:
+      chmodcmd=
+    else
+      mkdircmd=$mkdirprog
+    fi
+  else
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dstarg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dstarg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst ;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dstarg: Is a directory" >&2
+	exit 1
+      fi
+      dst=$dst/`basename "$src"`
+    fi
+  fi
+
+  # This sed command emulates the dirname command.
+  dstdir=`echo "$dst" | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`
+
+  # Make sure that the destination directory exists.
+
+  # Skip lots of stat calls in the usual case.
+  if test ! -d "$dstdir"; then
+    defaultIFS='
+	 '
+    IFS="${IFS-$defaultIFS}"
+
+    oIFS=$IFS
+    # Some sh's can't handle IFS=/ for some reason.
+    IFS='%'
+    set x `echo "$dstdir" | sed -e 's@/@%@g' -e 's@^%@/@'`
+    shift
+    IFS=$oIFS
+
+    pathcomp=
+
+    while test $# -ne 0 ; do
+      pathcomp=$pathcomp$1
+      shift
+      if test ! -d "$pathcomp"; then
+        $mkdirprog "$pathcomp"
+	# mkdir can fail with a `File exist' error in case several
+	# install-sh are creating the directory concurrently.  This
+	# is OK.
+	test -d "$pathcomp" || exit
+      fi
+      pathcomp=$pathcomp/
+    done
+  fi
+
+  if test -n "$dir_arg"; then
+    $doit $mkdircmd "$dst" \
+      && { test -z "$chowncmd" || $doit $chowncmd "$dst"; } \
+      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } \
+      && { test -z "$stripcmd" || $doit $stripcmd "$dst"; } \
+      && { test -z "$chmodcmd" || $doit $chmodcmd "$dst"; }
+
+  else
+    dstfile=`basename "$dst"`
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+    trap '(exit $?); exit' 1 2 13 15
+
+    # Copy the file name to the temp name.
+    $doit $cpprog "$src" "$dsttmp" &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
+      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
+      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
+      && { test -z "$chmodcmd" || $doit $chmodcmd "$dsttmp"; } &&
+
+    # Now rename the file to the real destination.
+    { $doit $mvcmd -f "$dsttmp" "$dstdir/$dstfile" 2>/dev/null \
+      || {
+	   # The rename failed, perhaps because mv can't rename something else
+	   # to itself, or perhaps because mv is so ancient that it does not
+	   # support -f.
+
+	   # Now remove or move aside any old file at destination location.
+	   # We try this two ways since rm can't unlink itself on some
+	   # systems and the destination file might be busy for other
+	   # reasons.  In this case, the final cleanup might fail but the new
+	   # file should still install successfully.
+	   {
+	     if test -f "$dstdir/$dstfile"; then
+	       $doit $rmcmd -f "$dstdir/$dstfile" 2>/dev/null \
+	       || $doit $mvcmd -f "$dstdir/$dstfile" "$rmtmp" 2>/dev/null \
+	       || {
+		 echo "$0: cannot unlink or rename $dstdir/$dstfile" >&2
+		 (exit 1); exit 1
+	       }
+	     else
+	       :
+	     fi
+	   } &&
+
+	   # Now rename the file to the real destination.
+	   $doit $mvcmd "$dsttmp" "$dstdir/$dstfile"
+	 }
+    }
+  fi || { (exit 1); exit 1; }
+done
+
+# The final little trick to "correctly" pass the exit status to the exit trap.
+{
+  (exit 0); exit 0
+}
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:

Copied: trunk/c-version/missing (from rev 809, trunk/missing)
===================================================================
--- trunk/c-version/missing	                        (rev 0)
+++ trunk/c-version/missing	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,360 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2005-06-08.21
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005
+#   Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard at iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+run=:
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg="missing on your system"
+
+case "$1" in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg="probably too old"
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Send bug reports to <bug-automake at gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).
+case "$1" in
+  lex|yacc)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar)
+    if test -n "$run"; then
+       echo 1>&2 "ERROR: \`tar' requires --run"
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case "$1" in
+  aclocal*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case "$f" in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  autom4te)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
+    test -z "$file" && file=`echo "$*" | sed -n 's/.*-o[ ]*\([^ ]*\).*/\1/p'`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if [ $# -ne 1 ]; then
+        eval LASTARG="\${$#}"
+	case "$LASTARG" in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f y.tab.h ]; then
+	echo >y.tab.h
+    fi
+    if [ ! -f y.tab.c ]; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if [ $# -ne 1 ]; then
+        eval LASTARG="\${$#}"
+	case "$LASTARG" in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f lex.yy.c ]; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  help2man)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z "$file"; then
+	file=`echo "$*" | sed -n 's/.*--output=\([^ ]*\).*/\1/p'`
+    fi
+    if [ -f "$file" ]; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit 1
+    fi
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    # The file to touch is that specified with -o ...
+    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z "$file"; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case "$firstarg" in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case "$firstarg" in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:

Copied: trunk/c-version/mkinstalldirs (from rev 809, trunk/mkinstalldirs)
===================================================================
--- trunk/c-version/mkinstalldirs	                        (rev 0)
+++ trunk/c-version/mkinstalldirs	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,150 @@
+#! /bin/sh
+# mkinstalldirs --- make directory hierarchy
+
+scriptversion=2004-02-15.20
+
+# Original author: Noah Friedman <friedman at prep.ai.mit.edu>
+# Created: 1993-05-16
+# Public domain.
+#
+# This file is maintained in Automake, please report
+# bugs to <bug-automake at gnu.org> or send patches to
+# <automake-patches at gnu.org>.
+
+errstatus=0
+dirmode=""
+
+usage="\
+Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
+
+Create each directory DIR (with mode MODE, if specified), including all
+leading file name components.
+
+Report bugs to <bug-automake at gnu.org>."
+
+# process command line arguments
+while test $# -gt 0 ; do
+  case $1 in
+    -h | --help | --h*)         # -h for help
+      echo "$usage"
+      exit 0
+      ;;
+    -m)                         # -m PERM arg
+      shift
+      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
+      dirmode=$1
+      shift
+      ;;
+    --version)
+      echo "$0 $scriptversion"
+      exit 0
+      ;;
+    --)                         # stop option processing
+      shift
+      break
+      ;;
+    -*)                         # unknown option
+      echo "$usage" 1>&2
+      exit 1
+      ;;
+    *)                          # first non-opt arg
+      break
+      ;;
+  esac
+done
+
+for file
+do
+  if test -d "$file"; then
+    shift
+  else
+    break
+  fi
+done
+
+case $# in
+  0) exit 0 ;;
+esac
+
+# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
+# mkdir -p a/c at the same time, both will detect that a is missing,
+# one will create a, then the other will try to create a and die with
+# a "File exists" error.  This is a problem when calling mkinstalldirs
+# from a parallel make.  We use --version in the probe to restrict
+# ourselves to GNU mkdir, which is thread-safe.
+case $dirmode in
+  '')
+    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+      echo "mkdir -p -- $*"
+      exec mkdir -p -- "$@"
+    else
+      # On NextStep and OpenStep, the `mkdir' command does not
+      # recognize any option.  It will interpret all options as
+      # directories to create, and then abort because `.' already
+      # exists.
+      test -d ./-p && rmdir ./-p
+      test -d ./--version && rmdir ./--version
+    fi
+    ;;
+  *)
+    if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
+       test ! -d ./--version; then
+      echo "mkdir -m $dirmode -p -- $*"
+      exec mkdir -m "$dirmode" -p -- "$@"
+    else
+      # Clean up after NextStep and OpenStep mkdir.
+      for d in ./-m ./-p ./--version "./$dirmode";
+      do
+        test -d $d && rmdir $d
+      done
+    fi
+    ;;
+esac
+
+for file
+do
+  set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+  shift
+
+  pathcomp=
+  for d
+  do
+    pathcomp="$pathcomp$d"
+    case $pathcomp in
+      -*) pathcomp=./$pathcomp ;;
+    esac
+
+    if test ! -d "$pathcomp"; then
+      echo "mkdir $pathcomp"
+
+      mkdir "$pathcomp" || lasterr=$?
+
+      if test ! -d "$pathcomp"; then
+	errstatus=$lasterr
+      else
+	if test ! -z "$dirmode"; then
+	  echo "chmod $dirmode $pathcomp"
+	  lasterr=""
+	  chmod "$dirmode" "$pathcomp" || lasterr=$?
+
+	  if test ! -z "$lasterr"; then
+	    errstatus=$lasterr
+	  fi
+	fi
+      fi
+    fi
+
+    pathcomp="$pathcomp/"
+  done
+done
+
+exit $errstatus
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:

Deleted: trunk/c-version/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/c-version/src/sst.py	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,6339 +0,0 @@
-#!/usr/bin/env python
-"""
-sst.py -- Super Star Trek 2K
-
-SST2K is a Python translation of a C translation of a FORTRAN
-original dating back to 1973.  Beautiful Python it is not, but it
-works.  Translation by Eric S. Raymond; original game by David Matuszek
-and Paul Reynolds, with modifications by Don Smith, Tom Almy,
-Stas Sergeev, and Eric S. Raymond.
-
-See the doc/HACKING file in the distribution for designers notes and advice
-on how to modify (and how not to modify!) this code.
-"""
-import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
-
-docpath  	= (".", "../doc", "/usr/share/doc/sst")
-
-def _(str): return gettext.gettext(str)
-
-GALSIZE 	= 8		# Galaxy size in quadrants
-NINHAB  	= (GALSIZE * GALSIZE / 2)	# Number of inhabited worlds
-MAXUNINHAB	= 10		# Maximum uninhabited worlds
-QUADSIZE	= 10		# Quadrant size in sectors
-BASEMIN		= 2				# Minimum starbases
-BASEMAX 	= (GALSIZE * GALSIZE / 12)	# Maximum starbases
-MAXKLGAME	= 127		# Maximum Klingons per game
-MAXKLQUAD	= 9		# Maximum Klingons per quadrant
-FULLCREW	= 428		# Crew size. BSD Trek was 387, that's wrong 
-FOREVER 	= 1e30		# Time for the indefinite future
-MAXBURST	= 3		# Max # of torps you can launch in one turn
-MINCMDR 	= 10		# Minimum number of Klingon commanders
-DOCKFAC		= 0.25		# Repair faster when docked
-PHASEFAC	= 2.0		# Unclear what this is, it was in the C version
-
-DEFAULT      = -1
-BLACK        = 0
-BLUE         = 1
-GREEN        = 2
-CYAN         = 3
-RED          = 4
-MAGENTA      = 5
-BROWN        = 6
-LIGHTGRAY    = 7
-DARKGRAY     = 8
-LIGHTBLUE    = 9
-LIGHTGREEN   = 10
-LIGHTCYAN    = 11
-LIGHTRED     = 12
-LIGHTMAGENTA = 13
-YELLOW       = 14
-WHITE        = 15
-
-class TrekError:
-    pass
-
-class coord:
-    def __init__(self, x=None, y=None):
-        self.i = x
-        self.j = y
-    def valid_quadrant(self):
-        return self.i>=0 and self.i<GALSIZE and self.j>=0 and self.j<GALSIZE
-    def valid_sector(self):
-	return self.i>=0 and self.i<QUADSIZE and self.j>=0 and self.j<QUADSIZE
-    def invalidate(self):
-        self.i = self.j = None
-    def is_valid(self):
-        return self.i != None and self.j != None
-    def __eq__(self, other):
-        return other != None and self.i == other.i and self.j == other.j
-    def __ne__(self, other):
-        return other == None or self.i != other.i or self.j != other.j
-    def __add__(self, other):
-        return coord(self.i+other.i, self.j+other.j)
-    def __sub__(self, other):
-        return coord(self.i-other.i, self.j-other.j)
-    def __mul__(self, other):
-        return coord(self.i*other, self.j*other)
-    def __rmul__(self, other):
-        return coord(self.i*other, self.j*other)
-    def __div__(self, other):
-        return coord(self.i/other, self.j/other)
-    def __mod__(self, other):
-        return coord(self.i % other, self.j % other)
-    def __rdiv__(self, other):
-        return coord(self.i/other, self.j/other)
-    def roundtogrid(self):
-        return coord(int(round(self.i)), int(round(self.j)))
-    def distance(self, other=None):
-        if not other: other = coord(0, 0)
-        return math.sqrt((self.i - other.i)**2 + (self.j - other.j)**2)
-    def bearing(self):
-        return 1.90985*math.atan2(self.j, self.i)
-    def sgn(self):
-        s = coord()
-        if self.i == 0:
-            s.i = 0
-        else:
-            s.i = self.i / abs(self.i)
-        if self.j == 0:
-            s.j = 0
-        else:
-            s.j = self.j / abs(self.j)
-        return s
-    def quadrant(self):
-        #print "Location %s -> %s" % (self, (self / QUADSIZE).roundtogrid())
-        return self.roundtogrid() / QUADSIZE
-    def sector(self):
-        return self.roundtogrid() % QUADSIZE
-    def scatter(self):
-        s = coord()
-        s.i = self.i + randrange(-1, 2)
-        s.j = self.j + randrange(-1, 2)
-        return s
-    def __str__(self):
-        if self.i == None or self.j == None:
-            return "Nowhere"
-        return "%s - %s" % (self.i+1, self.j+1)
-    __repr__ = __str__
-
-class planet:
-    def __init__(self):
-        self.name = None	# string-valued if inhabited
-        self.quadrant = coord()	# quadrant located
-        self.pclass = None	# could be ""M", "N", "O", or "destroyed"
-        self.crystals = "absent"# could be "mined", "present", "absent"
-        self.known = "unknown"	# could be "unknown", "known", "shuttle_down"
-        self.inhabited = False	# is it inhabites?
-    def __str__(self):
-        return self.name
-
-class quadrant:
-    def __init__(self):
-        self.stars = 0
-        self.planet = None
-	self.starbase = False
-	self.klingons = 0
-	self.romulans = 0
-	self.supernova = False
-	self.charted = False
-        self.status = "secure"	# Could be "secure", "distressed", "enslaved"
-
-class page:
-    def __init__(self):
-	self.stars = None
-	self.starbase = None
-	self.klingons = None
-
-def fill2d(size, fillfun):
-    "Fill an empty list in 2D."
-    lst = []
-    for i in range(size):
-        lst.append([]) 
-        for j in range(size):
-            lst[i].append(fillfun(i, j))
-    return lst
-
-class snapshot:
-    def __init__(self):
-        self.snap = False	# snapshot taken
-        self.crew = 0   	# crew complement
-	self.remkl = 0  	# remaining klingons
-	self.nscrem = 0		# remaining super commanders
-	self.starkl = 0 	# destroyed stars
-	self.basekl = 0 	# destroyed bases
-	self.nromrem = 0	# Romulans remaining
-	self.nplankl = 0	# destroyed uninhabited planets
-	self.nworldkl = 0	# destroyed inhabited planets
-        self.planets = []	# Planet information
-        self.date = 0.0   	# stardate
-	self.remres = 0 	# remaining resources
-	self.remtime = 0	# remaining time
-        self.baseq = [] 	# Base quadrant coordinates
-        self.kcmdr = [] 	# Commander quadrant coordinates
-	self.kscmdr = coord()	# Supercommander quadrant coordinates
-        # the galaxy
-        self.galaxy = fill2d(GALSIZE, lambda i, j: quadrant())
-        # the starchart
-    	self.chart = fill2d(GALSIZE, lambda i, j: page())
-
-class event:
-    def __init__(self):
-        self.date = None	# A real number
-        self.quadrant = None	# A coord structure
-
-# game options 
-OPTION_ALL	= 0xffffffff
-OPTION_TTY	= 0x00000001	# old interface 
-OPTION_CURSES	= 0x00000002	# new interface 
-OPTION_IOMODES	= 0x00000003	# cover both interfaces 
-OPTION_PLANETS	= 0x00000004	# planets and mining 
-OPTION_THOLIAN	= 0x00000008	# Tholians and their webs (UT 1979 version)
-OPTION_THINGY	= 0x00000010	# Space Thingy can shoot back (Stas, 2005)
-OPTION_PROBE	= 0x00000020	# deep-space probes (DECUS version, 1980)
-OPTION_SHOWME	= 0x00000040	# bracket Enterprise in chart 
-OPTION_RAMMING	= 0x00000080	# enemies may ram Enterprise (Almy)
-OPTION_MVBADDY	= 0x00000100	# more enemies can move (Almy)
-OPTION_BLKHOLE	= 0x00000200	# black hole may timewarp you (Stas, 2005) 
-OPTION_BASE	= 0x00000400	# bases have good shields (Stas, 2005)
-OPTION_WORLDS	= 0x00000800	# logic for inhabited worlds (ESR, 2006)
-OPTION_AUTOSCAN	= 0x00001000	# automatic LRSCAN before CHART (ESR, 2006)
-OPTION_PLAIN	= 0x01000000	# user chose plain game 
-OPTION_ALMY	= 0x02000000	# user chose Almy variant 
-OPTION_COLOR    = 0x04000000	# enable color display (experimental, ESR, 2010)
-
-# Define devices 
-DSRSENS	= 0
-DLRSENS	= 1
-DPHASER	= 2
-DPHOTON	= 3
-DLIFSUP	= 4
-DWARPEN	= 5
-DIMPULS	= 6
-DSHIELD	= 7
-DRADIO	= 0
-DSHUTTL = 9
-DCOMPTR = 10
-DNAVSYS	= 11
-DTRANSP = 12
-DSHCTRL	= 13
-DDRAY	= 14
-DDSP	= 15
-NDEVICES= 16	# Number of devices
-
-SKILL_NONE	= 0
-SKILL_NOVICE	= 1
-SKILL_FAIR	= 2
-SKILL_GOOD	= 3
-SKILL_EXPERT	= 4
-SKILL_EMERITUS	= 5
-
-def damaged(dev):	return (game.damage[dev] != 0.0)
-def communicating():	return not damaged(DRADIO) or game.condition=="docked"
-
-# Define future events 
-FSPY	= 0	# Spy event happens always (no future[] entry)
-		# can cause SC to tractor beam Enterprise
-FSNOVA  = 1	# Supernova
-FTBEAM  = 2	# Commander tractor beams Enterprise
-FSNAP   = 3	# Snapshot for time warp
-FBATTAK = 4	# Commander attacks base
-FCDBAS  = 5	# Commander destroys base
-FSCMOVE = 6	# Supercommander moves (might attack base)
-FSCDBAS = 7	# Supercommander destroys base
-FDSPROB = 8	# Move deep space probe
-FDISTR	= 9	# Emit distress call from an inhabited world 
-FENSLV	= 10	# Inhabited word is enslaved */
-FREPRO	= 11	# Klingons build a ship in an enslaved system
-NEVENTS	= 12
-
-# Abstract out the event handling -- underlying data structures will change
-# when we implement stateful events 
-def findevent(evtype):	return game.future[evtype]
-
-class enemy:
-    def __init__(self, type=None, loc=None, power=None):
-        self.type = type
-        self.location = coord()
-        if loc:
-            self.move(loc)
-        self.power = power	# enemy energy level
-        game.enemies.append(self)
-    def move(self, loc):
-        motion = (loc != self.location)
-        if self.location.i is not None and self.location.j is not None:
-            if motion:
-                if self.type == 'T':
-                    game.quad[self.location.i][self.location.j] = '#'
-                else:
-                    game.quad[self.location.i][self.location.j] = '.'
-        if loc:
-            self.location = copy.copy(loc)
-            game.quad[self.location.i][self.location.j] = self.type
-            self.kdist = self.kavgd = (game.sector - loc).distance()
-        else:
-            self.location = coord()
-            self.kdist = self.kavgd = None
-            game.enemies.remove(self)
-        return motion
-    def __repr__(self):
-        return "<%s,%s.%f>" % (self.type, self.location, self.power)	# For debugging
-
-class gamestate:
-    def __init__(self):
-        self.options = None	# Game options
-        self.state = snapshot()	# A snapshot structure
-        self.snapsht = snapshot()	# Last snapshot taken for time-travel purposes
-        self.quad = None	# contents of our quadrant
-        self.damage = [0.0] * NDEVICES	# damage encountered
-        self.future = []		# future events
-        for i in range(NEVENTS):
-            self.future.append(event())
-        self.passwd  = None;		# Self Destruct password
-        self.enemies = []
-        self.quadrant = None	# where we are in the large
-        self.sector = None	# where we are in the small
-        self.tholian = None	# Tholian enemy object
-        self.base = None	# position of base in current quadrant
-        self.battle = None	# base coordinates being attacked
-        self.plnet = None	# location of planet in quadrant
-        self.gamewon = False	# Finished!
-        self.ididit = False	# action taken -- allows enemy to attack
-        self.alive = False	# we are alive (not killed)
-        self.justin = False	# just entered quadrant
-        self.shldup = False	# shields are up
-        self.shldchg = False	# shield is changing (affects efficiency)
-        self.iscate = False	# super commander is here
-        self.ientesc = False	# attempted escape from supercommander
-        self.resting = False	# rest time
-        self.icraft = False	# Kirk in Galileo
-        self.landed = False	# party on planet (true), on ship (false)
-        self.alldone = False	# game is now finished
-        self.neutz = False	# Romulan Neutral Zone
-        self.isarmed = False	# probe is armed
-        self.inorbit = False	# orbiting a planet
-        self.imine = False	# mining
-        self.icrystl = False	# dilithium crystals aboard
-        self.iseenit = False	# seen base attack report
-        self.thawed = False	# thawed game
-        self.condition = None	# "green", "yellow", "red", "docked", "dead"
-        self.iscraft = None	# "onship", "offship", "removed"
-        self.skill = None	# Player skill level
-        self.inkling = 0	# initial number of klingons
-        self.inbase = 0		# initial number of bases
-        self.incom = 0		# initial number of commanders
-        self.inscom = 0		# initial number of commanders
-        self.inrom = 0		# initial number of commanders
-        self.instar = 0		# initial stars
-        self.intorps = 0	# initial/max torpedoes
-        self.torps = 0		# number of torpedoes
-        self.ship = 0		# ship type -- 'E' is Enterprise
-        self.abandoned = 0	# count of crew abandoned in space
-        self.length = 0		# length of game
-        self.klhere = 0		# klingons here
-        self.casual = 0		# causalties
-        self.nhelp = 0		# calls for help
-        self.nkinks = 0		# count of energy-barrier crossings
-        self.iplnet = None	# planet # in quadrant
-        self.inplan = 0		# initial planets
-        self.irhere = 0		# Romulans in quadrant
-        self.isatb = 0		# =2 if super commander is attacking base
-        self.tourn = None	# tournament number
-        self.nprobes = 0	# number of probes available
-        self.inresor = 0.0	# initial resources
-        self.intime = 0.0	# initial time
-        self.inenrg = 0.0	# initial/max energy
-        self.inshld = 0.0	# initial/max shield
-        self.inlsr = 0.0	# initial life support resources
-        self.indate = 0.0	# initial date
-        self.energy = 0.0	# energy level
-        self.shield = 0.0	# shield level
-        self.warpfac = 0.0	# warp speed
-        self.lsupres = 0.0	# life support reserves
-        self.optime = 0.0	# time taken by current operation
-        self.damfac = 0.0	# damage factor
-        self.lastchart = 0.0	# time star chart was last updated
-        self.cryprob = 0.0	# probability that crystal will work
-        self.probe = None	# object holding probe course info
-        self.height = 0.0	# height of orbit around planet
-    def recompute(self):
-        # Stas thinks this should be (C expression): 
-        # game.state.remkl + len(game.state.kcmdr) > 0 ?
-	#	game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr)) : 99
-        # He says the existing expression is prone to divide-by-zero errors
-        # after killing the last klingon when score is shown -- perhaps also
-        # if the only remaining klingon is SCOM.
-        game.state.remtime = game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr))
-
-FWON = 0
-FDEPLETE = 1
-FLIFESUP = 2
-FNRG = 3
-FBATTLE = 4
-FNEG3 = 5
-FNOVA = 6
-FSNOVAED = 7
-FABANDN = 8
-FDILITHIUM = 9
-FMATERIALIZE = 10
-FPHASER = 11
-FLOST = 12
-FMINING = 13
-FDPLANET = 14
-FPNOVA = 15
-FSSC = 16
-FSTRACTOR = 17
-FDRAY = 18
-FTRIBBLE = 19
-FHOLE = 20
-FCREW = 21
-
-def withprob(p):
-    return random.random() < p
-
-def randrange(*args):
-    return random.randrange(*args)
-
-def randreal(*args):
-    v = random.random()
-    if len(args) == 1:
-        v *= args[0] 		# from [0, args[0])
-    elif len(args) == 2:
-        v = args[0] + v*(args[1]-args[0])	# from [args[0], args[1])
-    return v
-
-# Code from ai.c begins here
-
-def welcoming(iq):
-    "Would this quadrant welcome another Klingon?"
-    return iq.valid_quadrant() and \
-	not game.state.galaxy[iq.i][iq.j].supernova and \
-	game.state.galaxy[iq.i][iq.j].klingons < MAXKLQUAD
-
-def tryexit(enemy, look, irun):
-    "A bad guy attempts to bug out."
-    iq = coord()
-    iq.i = game.quadrant.i+(look.i+(QUADSIZE-1))/QUADSIZE - 1
-    iq.j = game.quadrant.j+(look.j+(QUADSIZE-1))/QUADSIZE - 1
-    if not welcoming(iq):
-	return False;
-    if enemy.type == 'R':
-	return False; # Romulans cannot escape! 
-    if not irun:
-	# avoid intruding on another commander's territory 
-	if enemy.type == 'C':
-            if iq in game.state.kcmdr:
-                return False
-	    # refuse to leave if currently attacking starbase 
-	    if game.battle == game.quadrant:
-		return False
-	# don't leave if over 1000 units of energy 
-	if enemy.power > 1000.0:
-	    return False
-    # emit escape message and move out of quadrant.
-    # we know this if either short or long range sensors are working
-    if not damaged(DSRSENS) or not damaged(DLRSENS) or \
-	game.condition == "docked":
-	prout(crmena(True, enemy.type, "sector", enemy.location) + \
-              (_(" escapes to Quadrant %s (and regains strength).") % q))
-    # handle local matters related to escape
-    enemy.move(None)
-    game.klhere -= 1
-    if game.condition != "docked":
-	newcnd()
-    # Handle global matters related to escape 
-    game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
-    game.state.galaxy[iq.i][iq.j].klingons += 1
-    if enemy.type=='S':
-	game.iscate = False
-	game.ientesc = False
-	game.isatb = 0
-	schedule(FSCMOVE, 0.2777)
-	unschedule(FSCDBAS)
-	game.state.kscmdr=iq
-    else:
-	for cmdr in game.state.kcmdr:
-	    if cmdr == game.quadrant:
-		game.state.kcmdr[n] = iq
-		break
-    return True; # success 
-
-# The bad-guy movement algorithm:
-# 
-# 1. Enterprise has "force" based on condition of phaser and photon torpedoes.
-# If both are operating full strength, force is 1000. If both are damaged,
-# force is -1000. Having shields down subtracts an additional 1000.
-# 
-# 2. Enemy has forces equal to the energy of the attacker plus
-# 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
-# 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
-# 
-# Attacker Initial energy levels (nominal):
-# Klingon   Romulan   Commander   Super-Commander
-# Novice    400        700        1200        
-# Fair      425        750        1250
-# Good      450        800        1300        1750
-# Expert    475        850        1350        1875
-# Emeritus  500        900        1400        2000
-# VARIANCE   75        200         200         200
-# 
-# Enemy vessels only move prior to their attack. In Novice - Good games
-# only commanders move. In Expert games, all enemy vessels move if there
-# is a commander present. In Emeritus games all enemy vessels move.
-# 
-# 3. If Enterprise is not docked, an aggressive action is taken if enemy
-# forces are 1000 greater than Enterprise.
-# 
-# Agressive action on average cuts the distance between the ship and
-# the enemy to 1/4 the original.
-# 
-# 4.  At lower energy advantage, movement units are proportional to the
-# advantage with a 650 advantage being to hold ground, 800 to move forward
-# 1, 950 for two, 150 for back 4, etc. Variance of 100.
-# 
-# If docked, is reduced by roughly 1.75*game.skill, generally forcing a
-# retreat, especially at high skill levels.
-# 
-# 5.  Motion is limited to skill level, except for SC hi-tailing it out.
-
-def movebaddy(enemy):
-    "Tactical movement for the bad guys."
-    next = coord(); look = coord()
-    irun = False
-    # This should probably be just (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant) 
-    if game.skill >= SKILL_EXPERT:
-	nbaddys = (((game.quadrant in game.state.kcmdr)*2 + (game.state.kscmdr==game.quadrant)*2+game.klhere*1.23+game.irhere*1.5)/2.0)
-    else:
-	nbaddys = (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant)
-    dist1 = enemy.kdist
-    mdist = int(dist1 + 0.5); # Nearest integer distance 
-    # If SC, check with spy to see if should hi-tail it 
-    if enemy.type=='S' and \
-	(enemy.power <= 500.0 or (game.condition=="docked" and not damaged(DPHOTON))):
-	irun = True
-	motion = -QUADSIZE
-    else:
-	# decide whether to advance, retreat, or hold position 
-	forces = enemy.power+100.0*len(game.enemies)+400*(nbaddys-1)
-	if not game.shldup:
-	    forces += 1000; # Good for enemy if shield is down! 
-	if not damaged(DPHASER) or not damaged(DPHOTON):
-            if damaged(DPHASER): # phasers damaged 
-		forces += 300.0
-	    else:
-		forces -= 0.2*(game.energy - 2500.0)
-	    if damaged(DPHOTON): # photon torpedoes damaged 
-		forces += 300.0
-	    else:
-		forces -= 50.0*game.torps
-	else:
-	    # phasers and photon tubes both out! 
-	    forces += 1000.0
-	motion = 0
-        if forces <= 1000.0 and game.condition != "docked": # Typical situation 
-	    motion = ((forces + randreal(200))/150.0) - 5.0
-	else:
-            if forces > 1000.0: # Very strong -- move in for kill 
-		motion = (1.0 - randreal())**2 * dist1 + 1.0
-	    if game.condition=="docked" and (game.options & OPTION_BASE): # protected by base -- back off ! 
-		motion -= game.skill*(2.0-randreal()**2)
-	if idebug:
-	    proutn("=== MOTION = %d, FORCES = %1.2f, " % (motion, forces))
-	# don't move if no motion 
-	if motion==0:
-	    return
-	# Limit motion according to skill 
-	if abs(motion) > game.skill:
-            if motion < 0:
-                motion = -game.skill
-            else:
-                motion = game.skill
-    # calculate preferred number of steps 
-    nsteps = abs(int(motion))
-    if motion > 0 and nsteps > mdist:
-	nsteps = mdist; # don't overshoot 
-    if nsteps > QUADSIZE:
-	nsteps = QUADSIZE; # This shouldn't be necessary 
-    if nsteps < 1:
-	nsteps = 1; # This shouldn't be necessary 
-    if idebug:
-	proutn("NSTEPS = %d:" % nsteps)
-    # Compute preferred values of delta X and Y 
-    m = game.sector - enemy.location
-    if 2.0 * abs(m.i) < abs(m.j):
-	m.i = 0
-    if 2.0 * abs(m.j) < abs(game.sector.i-enemy.location.i):
-	m.j = 0
-    m = (motion * m).sgn()
-    next = enemy.location
-    # main move loop 
-    for ll in range(nsteps):
-	if idebug:
-	    proutn(" %d" % (ll+1))
-	# Check if preferred position available 
-	look = next + m
-        if m.i < 0:
-            krawli = 1
-        else:
-            krawli = -1
-        if m.j < 0:
-            krawlj = 1
-        else:
-            krawlj = -1
-	success = False
-	attempts = 0; # Settle mysterious hang problem 
-	while attempts < 20 and not success:
-            attempts += 1
-	    if look.i < 0 or look.i >= QUADSIZE:
-		if motion < 0 and tryexit(enemy, look, irun):
-		    return
-		if krawli == m.i or m.j == 0:
-		    break
-		look.i = next.i + krawli
-		krawli = -krawli
-	    elif look.j < 0 or look.j >= QUADSIZE:
-		if motion < 0 and tryexit(enemy, look, irun):
-		    return
-		if krawlj == m.j or m.i == 0:
-		    break
-		look.j = next.j + krawlj
-		krawlj = -krawlj
-	    elif (game.options & OPTION_RAMMING) and game.quad[look.i][look.j] != '.':
-		# See if enemy should ram ship 
-		if game.quad[look.i][look.j] == game.ship and \
-		    (enemy.type == 'C' or enemy.type == 'S'):
-		    collision(rammed=True, enemy=enemy)
-		    return
-		if krawli != m.i and m.j != 0:
-		    look.i = next.i + krawli
-		    krawli = -krawli
-		elif krawlj != m.j and m.i != 0:
-		    look.j = next.j + krawlj
-		    krawlj = -krawlj
-		else:
-		    break; # we have failed 
-	    else:
-		success = True
-	if success:
-	    next = look
-	    if idebug:
-		proutn(`next`)
-	else:
-	    break; # done early 
-    if idebug:
-	skip(1)
-    if enemy.move(next):
-	if not damaged(DSRSENS) or game.condition == "docked":
-	    proutn(_("*** %s from Sector %s") % (cramen(enemy.type), enemy.location))
-	    if enemy.kdist < dist1:
-		proutn(_(" advances to "))
-	    else:
-		proutn(_(" retreats to "))
-	    prout("Sector %s." % next)
-
-def moveklings():
-    "Sequence Klingon tactical movement."
-    if idebug:
-	prout("== MOVCOM")
-    # Figure out which Klingon is the commander (or Supercommander)
-    # and do move
-    if game.quadrant in game.state.kcmdr:
-        for enemy in game.enemies:
-	    if enemy.type == 'C':
-		movebaddy(enemy)
-    if game.state.kscmdr==game.quadrant:
-        for enemy in game.enemies:
-	    if enemy.type == 'S':
-		movebaddy(enemy)
-		break
-    # If skill level is high, move other Klingons and Romulans too!
-    # Move these last so they can base their actions on what the
-    # commander(s) do.
-    if game.skill >= SKILL_EXPERT and (game.options & OPTION_MVBADDY):
-        for enemy in game.enemies:
-            if enemy.type in ('K', 'R'):
-		movebaddy(enemy)
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-
-def movescom(iq, avoid):
-    "Commander movement helper." 
-    # Avoid quadrants with bases if we want to avoid Enterprise 
-    if not welcoming(iq) or (avoid and iq in game.state.baseq):
-	return False
-    if game.justin and not game.iscate:
-	return False
-    # do the move 
-    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons -= 1
-    game.state.kscmdr = iq
-    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons += 1
-    if game.state.kscmdr==game.quadrant:
-	# SC has scooted, remove him from current quadrant 
-	game.iscate=False
-	game.isatb=0
-	game.ientesc = False
-	unschedule(FSCDBAS)
-	for enemy in game.enemies:
-	    if enemy.type == 'S':
-		break
-	enemy.move(None)
-	game.klhere -= 1
-	if game.condition != "docked":
-	    newcnd()
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # check for a helpful planet 
-    for i in range(game.inplan):
-	if game.state.planets[i].quadrant == game.state.kscmdr and \
-	    game.state.planets[i].crystals == "present":
-	    # destroy the planet 
-	    game.state.planets[i].pclass = "destroyed"
-	    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].planet = None
-	    if communicating():
-		announce()
-		prout(_("Lt. Uhura-  \"Captain, Starfleet Intelligence reports"))
-		proutn(_("   a planet in Quadrant %s has been destroyed") % game.state.kscmdr)
-		prout(_("   by the Super-commander.\""))
-	    break
-    return True; # looks good! 
-			
-def supercommander():
-    "Move the Super Commander." 
-    iq = coord(); sc = coord(); ibq = coord(); idelta = coord()
-    basetbl = []
-    if idebug:
-	prout("== SUPERCOMMANDER")
-    # Decide on being active or passive 
-    avoid = ((game.incom - len(game.state.kcmdr) + game.inkling - game.state.remkl)/(game.state.date+0.01-game.indate) < 0.1*game.skill*(game.skill+1.0) or \
-	    (game.state.date-game.indate) < 3.0)
-    if not game.iscate and avoid:
-	# compute move away from Enterprise 
-	idelta = game.state.kscmdr-game.quadrant
-	if idelta.distance() > 2.0:
-	    # circulate in space 
-	    idelta.i = game.state.kscmdr.j-game.quadrant.j
-	    idelta.j = game.quadrant.i-game.state.kscmdr.i
-    else:
-	# compute distances to starbases 
-	if not game.state.baseq:
-	    # nothing left to do 
-	    unschedule(FSCMOVE)
-	    return
-	sc = game.state.kscmdr
-        for base in game.state.baseq:
-	    basetbl.append((i, (base - sc).distance()))
-	if game.state.baseq > 1:
-            basetbl.sort(lambda x, y: cmp(x[1]. y[1]))
-	# look for nearest base without a commander, no Enterprise, and
-        # without too many Klingons, and not already under attack. 
-	ifindit = iwhichb = 0
-	for (i2, base) in enumerate(game.state.baseq):
-	    i = basetbl[i2][0];	# bug in original had it not finding nearest
-	    if base==game.quadrant or base==game.battle or not welcoming(base):
-		continue
-	    # if there is a commander, and no other base is appropriate,
-	    # we will take the one with the commander
-            for cmdr in game.state.kcmdr:
-		if base == cmdr and ifindit != 2:
-		    ifindit = 2
-		    iwhichb = i
-		    break
-	    else:	# no commander -- use this one 
-		ifindit = 1
-		iwhichb = i
-		break
-	if ifindit==0:
-	    return # Nothing suitable -- wait until next time
-	ibq = game.state.baseq[iwhichb]
-	# decide how to move toward base 
-	idelta = ibq - game.state.kscmdr
-    # Maximum movement is 1 quadrant in either or both axes 
-    idelta = idelta.sgn()
-    # try moving in both x and y directions
-    # there was what looked like a bug in the Almy C code here,
-    # but it might be this translation is just wrong.
-    iq = game.state.kscmdr + idelta
-    if not movescom(iq, avoid):
-	# failed -- try some other maneuvers 
-	if idelta.i==0 or idelta.j==0:
-	    # attempt angle move 
-	    if idelta.i != 0:
-		iq.j = game.state.kscmdr.j + 1
-		if not movescom(iq, avoid):
-		    iq.j = game.state.kscmdr.j - 1
-		    movescom(iq, avoid)
-	    elif idelta.j != 0:
-		iq.i = game.state.kscmdr.i + 1
-		if not movescom(iq, avoid):
-		    iq.i = game.state.kscmdr.i - 1
-		    movescom(iq, avoid)
-	else:
-	    # try moving just in x or y 
-	    iq.j = game.state.kscmdr.j
-	    if not movescom(iq, avoid):
-		iq.j = game.state.kscmdr.j + idelta.j
-		iq.i = game.state.kscmdr.i
-		movescom(iq, avoid)
-    # check for a base 
-    if len(game.state.baseq) == 0:
-	unschedule(FSCMOVE)
-    else:
-        for ibq in game.state.baseq:
-	    if ibq == game.state.kscmdr and game.state.kscmdr == game.battle:
-		# attack the base 
-		if avoid:
-		    return # no, don't attack base! 
-		game.iseenit = False
-		game.isatb = 1
-		schedule(FSCDBAS, randreal(1.0, 3.0))
-		if is_scheduled(FCDBAS):
-		    postpone(FSCDBAS, scheduled(FCDBAS)-game.state.date)
-		if not communicating():
-		    return # no warning 
-		game.iseenit = True
-		announce()
-		prout(_("Lt. Uhura-  \"Captain, the starbase in Quadrant %s") \
-                      % game.state.kscmdr)
-		prout(_("   reports that it is under attack from the Klingon Super-commander."))
-		proutn(_("   It can survive until stardate %d.\"") \
-                       % int(scheduled(FSCDBAS)))
-		if not game.resting:
-		    return
-		prout(_("Mr. Spock-  \"Captain, shall we cancel the rest period?\""))
-		if ja() == False:
-		    return
-		game.resting = False
-		game.optime = 0.0; # actually finished 
-		return
-    # Check for intelligence report 
-    if not idebug and \
-	(withprob(0.8) or \
-	 (not communicating()) or \
-	 not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].charted):
-	return
-    announce()
-    prout(_("Lt. Uhura-  \"Captain, Starfleet Intelligence reports"))
-    proutn(_("   the Super-commander is in Quadrant %s,") % game.state.kscmdr)
-    return
-
-def movetholian():
-    "Move the Tholian."
-    if not game.tholian or game.justin:
-	return
-    id = coord()
-    if game.tholian.location.i == 0 and game.tholian.location.j == 0:
-	id.i = 0; id.j = QUADSIZE-1
-    elif game.tholian.location.i == 0 and game.tholian.location.j == QUADSIZE-1:
-	id.i = QUADSIZE-1; id.j = QUADSIZE-1
-    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == QUADSIZE-1:
-	id.i = QUADSIZE-1; id.j = 0
-    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == 0:
-	id.i = 0; id.j = 0
-    else:
-	# something is wrong! 
-	game.tholian.move(None)
-        prout("***Internal error: Tholian in a bad spot.")
-	return
-    # do nothing if we are blocked 
-    if game.quad[id.i][id.j] not in ('.', '#'):
-	return
-    here = copy.copy(game.tholian.location)
-    delta = (id - game.tholian.location).sgn()
-    # move in x axis 
-    while here.i != id.i:
-        here.i += delta.i
-        if game.quad[here.i][here.j]=='.':
-            game.tholian.move(here)
-    # move in y axis 
-    while here.j != id.j:
-        here.j += delta.j
-        if game.quad[here.i][here.j]=='.':
-            game.tholian.move(here)
-    # check to see if all holes plugged 
-    for i in range(QUADSIZE):
-	if game.quad[0][i]!='#' and game.quad[0][i]!='T':
-	    return
-	if game.quad[QUADSIZE-1][i]!='#' and game.quad[QUADSIZE-1][i]!='T':
-	    return
-	if game.quad[i][0]!='#' and game.quad[i][0]!='T':
-	    return
-	if game.quad[i][QUADSIZE-1]!='#' and game.quad[i][QUADSIZE-1]!='T':
-	    return
-    # All plugged up -- Tholian splits 
-    game.quad[game.tholian.location.i][game.tholian.location.j]='#'
-    dropin(' ')
-    prout(crmena(True, 'T', "sector", game.tholian) + _(" completes web."))
-    game.tholian.move(None)
-    return
-
-# Code from battle.c begins here
-
-def doshield(shraise):
-    "Change shield status."
-    action = "NONE"
-    game.ididit = False
-    if shraise:
-	action = "SHUP"
-    else:
-	key = scanner.next()
-	if key == "IHALPHA":
-	    if scanner.sees("transfer"):
-		action = "NRG"
-	    else:
-		if damaged(DSHIELD):
-		    prout(_("Shields damaged and down."))
-		    return
-		if scanner.sees("up"):
-		    action = "SHUP"
-		elif scanner.sees("down"):
-		    action = "SHDN"
-	if action=="NONE":
-	    proutn(_("Do you wish to change shield energy? "))
-	    if ja() == True:
-		action = "NRG"
-	    elif damaged(DSHIELD):
-		prout(_("Shields damaged and down."))
-		return
-	    elif game.shldup:
-		proutn(_("Shields are up. Do you want them down? "))
-		if ja() == True:
-		    action = "SHDN"
-		else:
-		    scanner.chew()
-		    return
-	    else:
-		proutn(_("Shields are down. Do you want them up? "))
-		if ja() == True:
-		    action = "SHUP"
-		else:
-		    scanner.chew()
-		    return    
-    if action == "SHUP": # raise shields 
-	if game.shldup:
-	    prout(_("Shields already up."))
-	    return
-	game.shldup = True
-	game.shldchg = True
-	if game.condition != "docked":
-	    game.energy -= 50.0
-	prout(_("Shields raised."))
-	if game.energy <= 0:
-	    skip(1)
-	    prout(_("Shields raising uses up last of energy."))
-	    finish(FNRG)
-	    return
-	game.ididit=True
-	return
-    elif action == "SHDN":
-	if not game.shldup:
-	    prout(_("Shields already down."))
-	    return
-	game.shldup=False
-	game.shldchg=True
-	prout(_("Shields lowered."))
-	game.ididit = True
-	return
-    elif action == "NRG":
-	while scanner.next() != "IHREAL":
-	    scanner.chew()
-	    proutn(_("Energy to transfer to shields- "))
-        nrg = scanner.real
-	scanner.chew()
-	if nrg == 0:
-	    return
-	if nrg > game.energy:
-	    prout(_("Insufficient ship energy."))
-	    return
-	game.ididit = True
-	if game.shield+nrg >= game.inshld:
-	    prout(_("Shield energy maximized."))
-	    if game.shield+nrg > game.inshld:
-		prout(_("Excess energy requested returned to ship energy"))
-	    game.energy -= game.inshld-game.shield
-	    game.shield = game.inshld
-	    return
-	if nrg < 0.0 and game.energy-nrg > game.inenrg:
-	    # Prevent shield drain loophole 
-	    skip(1)
-	    prout(_("Engineering to bridge--"))
-	    prout(_("  Scott here. Power circuit problem, Captain."))
-	    prout(_("  I can't drain the shields."))
-	    game.ididit = False
-	    return
-	if game.shield+nrg < 0:
-	    prout(_("All shield energy transferred to ship."))
-	    game.energy += game.shield
-	    game.shield = 0.0
-	    return
-	proutn(_("Scotty- \""))
-	if nrg > 0:
-	    prout(_("Transferring energy to shields.\""))
-	else:
-	    prout(_("Draining energy from shields.\""))
-	game.shield += nrg
-	game.energy -= nrg
-	return
-
-def randdevice():
-    "Choose a device to damage, at random."
-    weights = (
-	105,	# DSRSENS: short range scanners	10.5% 
-	105,	# DLRSENS: long range scanners		10.5% 
-	120,	# DPHASER: phasers			12.0% 
-	120,	# DPHOTON: photon torpedoes		12.0% 
-	25,	# DLIFSUP: life support			 2.5% 
-	65,	# DWARPEN: warp drive			 6.5% 
-	70,	# DIMPULS: impulse engines		 6.5% 
-	145,	# DSHIELD: deflector shields		14.5% 
-	30,	# DRADIO:  subspace radio		 3.0% 
-	45,	# DSHUTTL: shuttle			 4.5% 
-	15,	# DCOMPTR: computer			 1.5% 
-	20,	# NAVCOMP: navigation system		 2.0% 
-	75,	# DTRANSP: transporter			 7.5% 
-	20,	# DSHCTRL: high-speed shield controller  2.0% 
-	10,	# DDRAY: death ray			 1.0% 
-	30,	# DDSP: deep-space probes		 3.0% 
-    )
-    assert(sum(weights) == 1000)
-    idx = randrange(1000)
-    sum = 0
-    for (i, w) in enumerate(weights):
-	sum += w
-	if idx < sum:
-	    return i
-    return None;	# we should never get here
-
-def collision(rammed, enemy):
-    "Collision handling fot rammong events."
-    prouts(_("***RED ALERT!  RED ALERT!"))
-    skip(1)
-    prout(_("***COLLISION IMMINENT."))
-    skip(2)
-    proutn("***")
-    proutn(crmshp())
-    hardness = {'R':1.5, 'C':2.0, 'S':2.5, 'T':0.5, '?':4.0}.get(enemy.type, 1.0)
-    if rammed:
-        proutn(_(" rammed by "))
-    else:
-        proutn(_(" rams "))
-    proutn(crmena(False, enemy.type, "sector", enemy.location))
-    if rammed:
-	proutn(_(" (original position)"))
-    skip(1)
-    deadkl(enemy.location, enemy.type, game.sector)
-    proutn("***" + crmship() + " heavily damaged.")
-    icas = randrange(10, 30)
-    prout(_("***Sickbay reports %d casualties"), icas)
-    game.casual += icas
-    game.state.crew -= icas
-    # In the pre-SST2K version, all devices got equiprobably damaged,
-    # which was silly.  Instead, pick up to half the devices at
-    # random according to our weighting table,
-    ncrits = randrange(NDEVICES/2)
-    for m in range(ncrits):
-	dev = randdevice()
-	if game.damage[dev] < 0:
-	    continue
-	extradm = (10.0*hardness*randreal()+1.0)*game.damfac
-	# Damage for at least time of travel! 
-	game.damage[dev] += game.optime + extradm
-    game.shldup = False
-    prout(_("***Shields are down."))
-    if game.state.remkl + len(game.state.kcmdr) + game.state.nscrem:
-	announce()
-	damagereport()
-    else:
-	finish(FWON)
-    return
-
-def torpedo(origin, bearing, dispersion, number, nburst):
-    "Let a photon torpedo fly" 
-    if not damaged(DSRSENS) or game.condition=="docked":
-	setwnd(srscan_window)
-    else: 
-	setwnd(message_window)
-    ac = bearing + 0.25*dispersion	# dispersion is a random variable
-    bullseye = (15.0 - bearing)*0.5235988
-    track = course(bearing=ac, distance=QUADSIZE, origin=cartesian(origin)) 
-    bumpto = coord(0, 0)
-    # Loop to move a single torpedo 
-    setwnd(message_window)
-    for step in range(1, QUADSIZE*2):
-        if not track.next(): break
-        w = track.sector()
-	if not w.valid_sector():
-	    break
-	iquad=game.quad[w.i][w.j]
-	tracktorpedo(origin, w, step, number, nburst, iquad)
-	if iquad=='.':
-	    continue
-	# hit something 
-	if not damaged(DSRSENS) or game.condition == "docked":
-	    skip(1);	# start new line after text track 
-	if iquad in ('E', 'F'): # Hit our ship 
-	    skip(1)
-	    prout(_("Torpedo hits %s.") % crmshp())
-	    hit = 700.0 + randreal(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
-	    newcnd(); # we're blown out of dock 
-	    if game.landed or game.condition=="docked":
-		return hit # Cheat if on a planet 
-            # In the C/FORTRAN version, dispersion was 2.5 radians, which
-            # is 143 degrees, which is almost exactly 4.8 clockface units
-            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
-            displacement.next()
-            bumpto = displacement.sector()
-	    if not bumpto.valid_sector():
-		return hit
-	    if game.quad[bumpto.i][bumpto.j]==' ':
-		finish(FHOLE)
-		return hit
-	    if game.quad[bumpto.i][bumpto.j]!='.':
-		# can't move into object 
-		return hit
-	    game.sector = bumpto
-	    proutn(crmshp())
-            game.quad[w.i][w.j]='.'
-            game.quad[bumpto.i][bumpto.j]=iquad
-            prout(_(" displaced by blast to Sector %s ") % bumpto)
-            for enemy in game.enemies:
-                enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
-            game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-            return None
-	elif iquad in ('C', 'S', 'R', 'K'): # Hit a regular enemy 
-	    # find the enemy 
-	    if iquad in ('C', 'S') and withprob(0.05):
-		prout(crmena(True, iquad, "sector", w) + _(" uses anti-photon device;"))
-		prout(_("   torpedo neutralized."))
-		return None
-            for enemy in game.enemies:
-		if w == enemy.location:
-		    break
-	    kp = math.fabs(enemy.power)
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
-	    h1 = math.fabs(h1)
-	    if kp < h1:
-		h1 = kp
-            if enemy.power < 0:
-                enemy.power -= -h1
-            else:
-                enemy.power -= h1
-	    if enemy.power == 0:
-		deadkl(w, iquad, w)
-		return None
-	    proutn(crmena(True, iquad, "sector", w))
-            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
-            displacement.next()
-            bumpto = displacement.sector()
-            if not bumpto.valid_sector():
-		prout(_(" damaged but not destroyed."))
-		return
-	    if game.quad[bumpto.i][bumpto.j] == ' ':
-		prout(_(" buffeted into black hole."))
-		deadkl(w, iquad, bumpto)
-	    if game.quad[bumpto.i][bumpto.j] != '.':
-		prout(_(" damaged but not destroyed."))
-            else:
-                prout(_(" damaged-- displaced by blast to Sector %s ")%bumpto)
-                enemy.location = bumpto
-                game.quad[w.i][w.j]='.'
-                game.quad[bumpto.i][bumpto.j]=iquad
-                for enemy in game.enemies:
-                    enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
-                game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-            return None
-	elif iquad == 'B': # Hit a base 
-	    skip(1)
-	    prout(_("***STARBASE DESTROYED.."))
-            game.state.baseq = filter(lambda x: x != game.quadrant, game.state.baseq)
-	    game.quad[w.i][w.j]='.'
-	    game.base.invalidate()
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase -= 1
-	    game.state.chart[game.quadrant.i][game.quadrant.j].starbase -= 1
-	    game.state.basekl += 1
-	    newcnd()
-	    return None
-	elif iquad == 'P': # Hit a planet 
-	    prout(crmena(True, iquad, "sector", w) + _(" destroyed."))
-	    game.state.nplankl += 1
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-	    game.iplnet.pclass = "destroyed"
-	    game.iplnet = None
-	    game.plnet.invalidate()
-	    game.quad[w.i][w.j] = '.'
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    return None
-	elif iquad == '@': # Hit an inhabited world -- very bad! 
-	    prout(crmena(True, iquad, "sector", w) + _(" destroyed."))
-	    game.state.nworldkl += 1
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-	    game.iplnet.pclass = "destroyed"
-	    game.iplnet = None
-	    game.plnet.invalidate()
-	    game.quad[w.i][w.j] = '.'
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    prout(_("The torpedo destroyed an inhabited planet."))
-	    return None
-	elif iquad == '*': # Hit a star 
-	    if withprob(0.9):
-		nova(w)
-            else:
-                prout(crmena(True, '*', "sector", w) + _(" unaffected by photon blast."))
-	    return None
-	elif iquad == '?': # Hit a thingy 
-	    if not (game.options & OPTION_THINGY) or withprob(0.3):
-		skip(1)
-		prouts(_("AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!"))
-		skip(1)
-		prouts(_("    HACK!     HACK!    HACK!        *CHOKE!*  "))
-		skip(1)
-		proutn(_("Mr. Spock-"))
-		prouts(_("  \"Fascinating!\""))
-		skip(1)
-		deadkl(w, iquad, w)
-	    else:
-		# Stas Sergeev added the possibility that
-		# you can shove the Thingy and piss it off.
-		# It then becomes an enemy and may fire at you.
-		thing.angry = True
-		shoved = True
-	    return None
-	elif iquad == ' ': # Black hole 
-	    skip(1)
-	    prout(crmena(True, ' ', "sector", w) + _(" swallows torpedo."))
-	    return None
-	elif iquad == '#': # hit the web 
-	    skip(1)
-	    prout(_("***Torpedo absorbed by Tholian web."))
-	    return None
-	elif iquad == 'T':  # Hit a Tholian 
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-angle))
-	    h1 = math.fabs(h1)
-	    if h1 >= 600:
-		game.quad[w.i][w.j] = '.'
-		deadkl(w, iquad, w)
-		game.tholian = None
-		return None
-	    skip(1)
-	    proutn(crmena(True, 'T', "sector", w))
-	    if withprob(0.05):
-		prout(_(" survives photon blast."))
-		return None
-	    prout(_(" disappears."))
-	    game.tholian.move(None)
-	    game.quad[w.i][w.j] = '#'
-	    dropin(' ')
-	    return None
-        else: # Problem!
-	    skip(1)
-	    proutn("Don't know how to handle torpedo collision with ")
-	    proutn(crmena(True, iquad, "sector", w))
-	    skip(1)
-	    return None
-	break
-    skip(1)
-    prout(_("Torpedo missed."))
-    return None;
-
-def fry(hit):
-    "Critical-hit resolution." 
-    if hit < (275.0-25.0*game.skill)*randreal(1.0, 1.5):
-	return
-    ncrit = int(1.0 + hit/(500.0+randreal(100)))
-    proutn(_("***CRITICAL HIT--"))
-    # Select devices and cause damage
-    cdam = []
-    for loop1 in range(ncrit):
-        while True:
-	    j = randdevice()
-	    # Cheat to prevent shuttle damage unless on ship 
-            if not (game.damage[j]<0.0 or (j==DSHUTTL and game.iscraft != "onship")):
-                break
-	cdam.append(j)
-	extradm = (hit*game.damfac)/(ncrit*randreal(75, 100))
-	game.damage[j] += extradm
-    skipcount = 0
-    for (i, j) in enumerate(cdam):
-	proutn(device[j])
-        if skipcount % 3 == 2 and i < len(cdam)-1:
-            skip(1)
-        skipcount += 1
-        if i < len(cdam)-1:
-            proutn(_(" and "))
-    prout(_(" damaged."))
-    if damaged(DSHIELD) and game.shldup:
-	prout(_("***Shields knocked down."))
-	game.shldup=False
-
-def attack(torps_ok):
-    # bad guy attacks us 
-    # torps_ok == False forces use of phasers in an attack 
-    # game could be over at this point, check
-    if game.alldone:
-	return
-    attempt = False; ihurt = False;
-    hitmax=0.0; hittot=0.0; chgfac=1.0
-    where = "neither"
-    if idebug:
-	prout("=== ATTACK!")
-    # Tholian gets to move before attacking 
-    if game.tholian:
-	movetholian()
-    # if you have just entered the RNZ, you'll get a warning 
-    if game.neutz: # The one chance not to be attacked 
-	game.neutz = False
-	return
-    # commanders get a chance to tac-move towards you 
-    if (((game.quadrant in game.state.kcmdr or game.state.kscmdr==game.quadrant) and not game.justin) or game.skill == SKILL_EMERITUS) and torps_ok:
-	moveklings()
-    # if no enemies remain after movement, we're done 
-    if len(game.enemies)==0 or (len(game.enemies)==1 and thing == game.quadrant and not thing.angry):
-	return
-    # set up partial hits if attack happens during shield status change 
-    pfac = 1.0/game.inshld
-    if game.shldchg:
-	chgfac = 0.25 + randreal(0.5)
-    skip(1)
-    # message verbosity control 
-    if game.skill <= SKILL_FAIR:
-	where = "sector"
-    for enemy in game.enemies:
-	if enemy.power < 0:
-	    continue;	# too weak to attack 
-	# compute hit strength and diminish shield power 
-	r = randreal()
-	# Increase chance of photon torpedos if docked or enemy energy is low 
-	if game.condition == "docked":
-	    r *= 0.25
-	if enemy.power < 500:
-	    r *= 0.25; 
-	if enemy.type=='T' or (enemy.type=='?' and not thing.angry):
-	    continue
-	# different enemies have different probabilities of throwing a torp 
-	usephasers = not torps_ok or \
-	    (enemy.type == 'K' and r > 0.0005) or \
-	    (enemy.type=='C' and r > 0.015) or \
-	    (enemy.type=='R' and r > 0.3) or \
-	    (enemy.type=='S' and r > 0.07) or \
-	    (enemy.type=='?' and r > 0.05)
-	if usephasers:	    # Enemy uses phasers 
-	    if game.condition == "docked":
-		continue; # Don't waste the effort! 
-	    attempt = True; # Attempt to attack 
-	    dustfac = randreal(0.8, 0.85)
-	    hit = enemy.power*math.pow(dustfac,enemy.kavgd)
-	    enemy.power *= 0.75
-	else: # Enemy uses photon torpedo 
-	    # We should be able to make the bearing() method work here
-	    course = 1.90985*math.atan2(game.sector.j-enemy.location.j, enemy.location.i-game.sector.i)
-	    hit = 0
-	    proutn(_("***TORPEDO INCOMING"))
-	    if not damaged(DSRSENS):
-		proutn(_(" From ") + crmena(False, enemy.type, where, enemy.location))
-	    attempt = True
-	    prout("  ")
-	    dispersion = (randreal()+randreal())*0.5 - 0.5
-	    dispersion += 0.002*enemy.power*dispersion
-	    hit = torpedo(enemy.location, course, dispersion, number=1, nburst=1)
-	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-		finish(FWON); # Klingons did themselves in! 
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.alldone:
-		return # Supernova or finished 
-	    if hit == None:
-		continue
-	# incoming phaser or torpedo, shields may dissipate it 
-	if game.shldup or game.shldchg or game.condition=="docked":
-	    # shields will take hits 
-	    propor = pfac * game.shield
-            if game.condition =="docked":
-                propr *= 2.1
-	    if propor < 0.1:
-		propor = 0.1
-	    hitsh = propor*chgfac*hit+1.0
-	    absorb = 0.8*hitsh
-	    if absorb > game.shield:
-		absorb = game.shield
-	    game.shield -= absorb
-	    hit -= hitsh
-	    # taking a hit blasts us out of a starbase dock 
-	    if game.condition == "docked":
-		dock(False)
-	    # but the shields may take care of it 
-	    if propor > 0.1 and hit < 0.005*game.energy:
-		continue
-	# hit from this opponent got through shields, so take damage 
-	ihurt = True
-	proutn(_("%d unit hit") % int(hit))
-	if (damaged(DSRSENS) and usephasers) or game.skill<=SKILL_FAIR:
-	    proutn(_(" on the ") + crmshp())
-	if not damaged(DSRSENS) and usephasers:
-	    prout(_(" from ") + crmena(False, enemy.type, where, enemy.location))
-	skip(1)
-	# Decide if hit is critical 
-	if hit > hitmax:
-	    hitmax = hit
-	hittot += hit
-	fry(hit)
-	game.energy -= hit
-    if game.energy <= 0:
-	# Returning home upon your shield, not with it... 
-	finish(FBATTLE)
-	return
-    if not attempt and game.condition == "docked":
-	prout(_("***Enemies decide against attacking your ship."))
-    percent = 100.0*pfac*game.shield+0.5
-    if not ihurt:
-	# Shields fully protect ship 
-	proutn(_("Enemy attack reduces shield strength to "))
-    else:
-	# Emit message if starship suffered hit(s) 
-	skip(1)
-	proutn(_("Energy left %2d    shields ") % int(game.energy))
-	if game.shldup:
-	    proutn(_("up "))
-	elif not damaged(DSHIELD):
-	    proutn(_("down "))
-	else:
-	    proutn(_("damaged, "))
-    prout(_("%d%%,   torpedoes left %d") % (percent, game.torps))
-    # Check if anyone was hurt 
-    if hitmax >= 200 or hittot >= 500:
-	icas = randrange(int(hittot * 0.015))
-	if icas >= 2:
-	    skip(1)
-	    prout(_("Mc Coy-  \"Sickbay to bridge.  We suffered %d casualties") % icas)
-	    prout(_("   in that last attack.\""))
-	    game.casual += icas
-	    game.state.crew -= icas
-    # After attack, reset average distance to enemies 
-    for enemy in game.enemies:
-	enemy.kavgd = enemy.kdist
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    return
-		
-def deadkl(w, type, mv):
-    "Kill a Klingon, Tholian, Romulan, or Thingy." 
-    # Added mv to allow enemy to "move" before dying 
-    proutn(crmena(True, type, "sector", mv))
-    # Decide what kind of enemy it is and update appropriately 
-    if type == 'R':
-        # Chalk up a Romulan 
-        game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans -= 1
-        game.irhere -= 1
-        game.state.nromrem -= 1
-    elif type == 'T':
-        # Killed a Tholian 
-        game.tholian = None
-    elif type == '?':
-        # Killed a Thingy
-        global thing
-        thing = None
-    else:
-        # Killed some type of Klingon 
-        game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
-        game.klhere -= 1
-        if type == 'C':
-            game.state.kcmdr.remove(game.quadrant)
-            unschedule(FTBEAM)
-            if game.state.kcmdr:
-                schedule(FTBEAM, expran(1.0*game.incom/len(game.state.kcmdr)))
-            if is_scheduled(FCDBAS) and game.battle == game.quadrant:
-                unschedule(FCDBAS)    
-        elif type ==  'K':
-            game.state.remkl -= 1
-        elif type ==  'S':
-            game.state.nscrem -= 1
-            game.state.kscmdr.invalidate()
-            game.isatb = 0
-            game.iscate = False
-            unschedule(FSCMOVE)
-            unschedule(FSCDBAS)
-    # For each kind of enemy, finish message to player 
-    prout(_(" destroyed."))
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-	return
-    game.recompute()
-    # Remove enemy ship from arrays describing local conditions
-    for e in game.enemies:
-	if e.location == w:
-            e.move(None)
-	    break
-    return
-
-def targetcheck(w):
-    "Return None if target is invalid, otherwise return a course angle."
-    if not w.valid_sector():
-	huh()
-	return None
-    delta = coord()
-    # FIXME: C code this was translated from is wacky -- why the sign reversal?
-    delta.j = (w.j - game.sector.j);
-    delta.i = (game.sector.i - w.i);
-    if delta == coord(0, 0):
-	skip(1)
-	prout(_("Spock-  \"Bridge to sickbay.  Dr. McCoy,"))
-	prout(_("  I recommend an immediate review of"))
-	prout(_("  the Captain's psychological profile.\""))
-	scanner.chew()
-	return None
-    return delta.bearing()
-
-def torps():
-    "Launch photon torpedo salvo."
-    course = []
-    game.ididit = False
-    if damaged(DPHOTON):
-	prout(_("Photon tubes damaged."))
-	scanner.chew()
-	return
-    if game.torps == 0:
-	prout(_("No torpedoes left."))
-	scanner.chew()
-	return
-    # First, get torpedo count
-    while True:
-        scanner.next()
-	if scanner.token == "IHALPHA":
-	    huh()
-	    return
-	elif scanner.token == "IHEOL" or not scanner.waiting():
-	    prout(_("%d torpedoes left.") % game.torps)
-            scanner.chew()
-	    proutn(_("Number of torpedoes to fire- "))
-            continue	# Go back around to get a number
-	else: # key == "IHREAL"
-	    n = scanner.int()
-	    if n <= 0: # abort command 
-		scanner.chew()
-		return
-	    if n > MAXBURST:
-		scanner.chew()
-		prout(_("Maximum of %d torpedoes per burst.") % MAXBURST)
-		return
-            if n > game.torps:
-                scanner.chew()	# User requested more torps than available
-                continue	# Go back around
-            break	# All is good, go to next stage
-    # Next, get targets
-    target = []
-    for i in range(n):
-	key = scanner.next()
-	if i==0 and key == "IHEOL":
-	    break;	# no coordinate waiting, we will try prompting 
-	if i==1 and key == "IHEOL":
-	    # direct all torpedoes at one target 
-	    while i < n:
-		target.append(target[0])
-		course.append(course[0])
-		i += 1
-	    break
-        scanner.push(scanner.token)
-        target.append(scanner.getcoord())
-        if target[-1] == None:
-            return
-        course.append(targetcheck(target[-1]))
-        if course[-1] == None:
-	    return
-    scanner.chew()
-    if len(target) == 0:
-	# prompt for each one 
-	for i in range(n):
-	    proutn(_("Target sector for torpedo number %d- ") % (i+1))
-	    scanner.chew()
-            target.append(scanner.getcoord())
-            if target[-1] == None:
-                return
-            course.append(targetcheck(target[-1]))
-            if course[-1] == None:
-                return
-    game.ididit = True
-    # Loop for moving <n> torpedoes 
-    for i in range(n):
-	if game.condition != "docked":
-	    game.torps -= 1
-	dispersion = (randreal()+randreal())*0.5 -0.5
-	if math.fabs(dispersion) >= 0.47:
-	    # misfire! 
-	    dispersion *= randreal(1.2, 2.2)
-	    if n > 0:
-		prouts(_("***TORPEDO NUMBER %d MISFIRES") % (i+1))
-	    else:
-		prouts(_("***TORPEDO MISFIRES."))
-	    skip(1)
-	    if i < n:
-		prout(_("  Remainder of burst aborted."))
-	    if withprob(0.2):
-		prout(_("***Photon tubes damaged by misfire."))
-		game.damage[DPHOTON] = game.damfac * randreal(1.0, 3.0)
-	    break
-	if game.shldup or game.condition == "docked":
-	    dispersion *= 1.0 + 0.0001*game.shield
-	torpedo(game.sector, course[i], dispersion, number=i, nburst=n)
-	if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-	    return
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-	finish(FWON);
-
-def overheat(rpow):
-    "Check for phasers overheating."
-    if rpow > 1500:
-        checkburn = (rpow-1500.0)*0.00038
-        if withprob(checkburn):
-	    prout(_("Weapons officer Sulu-  \"Phasers overheated, sir.\""))
-	    game.damage[DPHASER] = game.damfac* randreal(1.0, 2.0) * (1.0+checkburn)
-
-def checkshctrl(rpow):
-    "Check shield control."
-    skip(1)
-    if withprob(0.998):
-	prout(_("Shields lowered."))
-	return False
-    # Something bad has happened 
-    prouts(_("***RED ALERT!  RED ALERT!"))
-    skip(2)
-    hit = rpow*game.shield/game.inshld
-    game.energy -= rpow+hit*0.8
-    game.shield -= hit*0.2
-    if game.energy <= 0.0:
-	prouts(_("Sulu-  \"Captain! Shield malf***********************\""))
-	skip(1)
-	stars()
-	finish(FPHASER)
-	return True
-    prouts(_("Sulu-  \"Captain! Shield malfunction! Phaser fire contained!\""))
-    skip(2)
-    prout(_("Lt. Uhura-  \"Sir, all decks reporting damage.\""))
-    icas = randrange(int(hit*0.012))
-    skip(1)
-    fry(0.8*hit)
-    if icas:
-	skip(1)
-	prout(_("McCoy to bridge- \"Severe radiation burns, Jim."))
-	prout(_("  %d casualties so far.\"") % icas)
-	game.casual += icas
-	game.state.crew -= icas
-    skip(1)
-    prout(_("Phaser energy dispersed by shields."))
-    prout(_("Enemy unaffected."))
-    overheat(rpow)
-    return True;
-
-def hittem(hits):
-    "Register a phaser hit on Klingons and Romulans."
-    nenhr2 = len(game.enemies); kk=0
-    w = coord()
-    skip(1)
-    for (k, wham) in enumerate(hits):
-	if wham==0:
-	    continue
-	dustfac = randreal(0.9, 1.0)
-	hit = wham*math.pow(dustfac,game.enemies[kk].kdist)
-	kpini = game.enemies[kk].power
-	kp = math.fabs(kpini)
-	if PHASEFAC*hit < kp:
-	    kp = PHASEFAC*hit
-        if game.enemies[kk].power < 0:
-            game.enemies[kk].power -= -kp
-        else:
-            game.enemies[kk].power -= kp
-	kpow = game.enemies[kk].power
-	w = game.enemies[kk].location
-	if hit > 0.005:
-	    if not damaged(DSRSENS):
-		boom(w)
-	    proutn(_("%d unit hit on ") % int(hit))
-	else:
-	    proutn(_("Very small hit on "))
-	ienm = game.quad[w.i][w.j]
-	if ienm=='?':
-	    thing.angry = True
-	proutn(crmena(False, ienm, "sector", w))
-	skip(1)
-	if kpow == 0:
-	    deadkl(w, ienm, w)
-	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-		finish(FWON);		
-	    if game.alldone:
-		return
-	    kk -= 1	# don't do the increment
-            continue
-	else: # decide whether or not to emasculate klingon 
-	    if kpow>0 and withprob(0.9) and kpow <= randreal(0.4, 0.8)*kpini:
-		prout(_("***Mr. Spock-  \"Captain, the vessel at Sector %s")%w)
-		prout(_("   has just lost its firepower.\""))
-		game.enemies[kk].power = -kpow
-        kk += 1
-    return
-
-def phasers():
-    "Fire phasers at bad guys."
-    hits = []
-    kz = 0; k = 1; irec=0 # Cheating inhibitor 
-    ifast = False; no = False; itarg = True; msgflag = True; rpow=0
-    automode = "NOTSET"
-    key=0
-    skip(1)
-    # SR sensors and Computer are needed for automode 
-    if damaged(DSRSENS) or damaged(DCOMPTR):
-	itarg = False
-    if game.condition == "docked":
-	prout(_("Phasers can't be fired through base shields."))
-	scanner.chew()
-	return
-    if damaged(DPHASER):
-	prout(_("Phaser control damaged."))
-	scanner.chew()
-	return
-    if game.shldup:
-	if damaged(DSHCTRL):
-	    prout(_("High speed shield control damaged."))
-	    scanner.chew()
-	    return
-	if game.energy <= 200.0:
-	    prout(_("Insufficient energy to activate high-speed shield control."))
-	    scanner.chew()
-	    return
-	prout(_("Weapons Officer Sulu-  \"High-speed shield control enabled, sir.\""))
-	ifast = True
-    # Original code so convoluted, I re-did it all
-    # (That was Tom Almy talking about the C code, I think -- ESR)
-    while automode=="NOTSET":
-	key=scanner.next()
-	if key == "IHALPHA":
-	    if scanner.sees("manual"):
-		if len(game.enemies)==0:
-		    prout(_("There is no enemy present to select."))
-		    scanner.chew()
-		    key = "IHEOL"
-		    automode="AUTOMATIC"
-		else:
-		    automode = "MANUAL"
-		    key = scanner.next()
-	    elif scanner.sees("automatic"):
-		if (not itarg) and len(game.enemies) != 0:
-		    automode = "FORCEMAN"
-		else:
-		    if len(game.enemies)==0:
-			prout(_("Energy will be expended into space."))
-		    automode = "AUTOMATIC"
-		    key = scanner.next()
-	    elif scanner.sees("no"):
-		no = True
-	    else:
-		huh()
-		return
-	elif key == "IHREAL":
-	    if len(game.enemies)==0:
-		prout(_("Energy will be expended into space."))
-		automode = "AUTOMATIC"
-	    elif not itarg:
-		automode = "FORCEMAN"
-	    else:
-		automode = "AUTOMATIC"
-	else:
-	    # "IHEOL" 
-	    if len(game.enemies)==0:
-		prout(_("Energy will be expended into space."))
-		automode = "AUTOMATIC"
-	    elif not itarg:
-		automode = "FORCEMAN"
-	    else: 
-		proutn(_("Manual or automatic? "))
-                scanner.chew()
-    avail = game.energy
-    if ifast:
-        avail -= 200.0
-    if automode == "AUTOMATIC":
-	if key == "IHALPHA" and scanner.sees("no"):
-	    no = True
-	    key = scanner.next()
-	if key != "IHREAL" and len(game.enemies) != 0:
-	    prout(_("Phasers locked on target. Energy available: %.2f")%avail)
-	irec=0
-        while True:
-	    scanner.chew()
-	    if not kz:
-		for i in range(len(game.enemies)):
-		    irec += math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))*randreal(1.01, 1.06) + 1.0
-	    kz=1
-	    proutn(_("%d units required. ") % irec)
-	    scanner.chew()
-	    proutn(_("Units to fire= "))
-	    key = scanner.next()
-	    if key!="IHREAL":
-		return
-	    rpow = scanner.real
-	    if rpow > avail:
-		proutn(_("Energy available= %.2f") % avail)
-		skip(1)
-		key = "IHEOL"
-            if not rpow > avail:
-                break
-	if rpow<=0:
-	    # chicken out 
-	    scanner.chew()
-	    return
-        key=scanner.next()
-	if key == "IHALPHA" and scanner.sees("no"):
-	    no = True
-	if ifast:
-	    game.energy -= 200; # Go and do it! 
-	    if checkshctrl(rpow):
-		return
-	scanner.chew()
-	game.energy -= rpow
-	extra = rpow
-	if len(game.enemies):
-	    extra = 0.0
-	    powrem = rpow
-	    for i in range(len(game.enemies)):
-		hits.append(0.0)
-		if powrem <= 0:
-		    continue
-		hits[i] = math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))
-		over = randreal(1.01, 1.06) * hits[i]
-		temp = powrem
-		powrem -= hits[i] + over
-		if powrem <= 0 and temp < hits[i]:
-		    hits[i] = temp
-		if powrem <= 0:
-		    over = 0.0
-		extra += over
-	    if powrem > 0.0:
-		extra += powrem
-	    hittem(hits)
-	    game.ididit = True
-	if extra > 0 and not game.alldone:
-	    if game.tholian:
-		proutn(_("*** Tholian web absorbs "))
-		if len(game.enemies)>0:
-		    proutn(_("excess "))
-		prout(_("phaser energy."))
-	    else:
-		prout(_("%d expended on empty space.") % int(extra))
-    elif automode == "FORCEMAN":
-	scanner.chew()
-	key = "IHEOL"
-	if damaged(DCOMPTR):
-	    prout(_("Battle computer damaged, manual fire only."))
-	else:
-	    skip(1)
-	    prouts(_("---WORKING---"))
-	    skip(1)
-	    prout(_("Short-range-sensors-damaged"))
-	    prout(_("Insufficient-data-for-automatic-phaser-fire"))
-	    prout(_("Manual-fire-must-be-used"))
-	    skip(1)
-    elif automode == "MANUAL":
-	rpow = 0.0
-        for k in range(len(game.enemies)):
-	    aim = game.enemies[k].location
-	    ienm = game.quad[aim.i][aim.j]
-	    if msgflag:
-		proutn(_("Energy available= %.2f") % (avail-0.006))
-		skip(1)
-		msgflag = False
-		rpow = 0.0
-	    if damaged(DSRSENS) and \
-               not game.sector.distance(aim)<2**0.5 and ienm in ('C', 'S'):
-		prout(cramen(ienm) + _(" can't be located without short range scan."))
-		scanner.chew()
-		key = "IHEOL"
-		hits[k] = 0; # prevent overflow -- thanks to Alexei Voitenko 
-		k += 1
-		continue
-	    if key == "IHEOL":
-		scanner.chew()
-		if itarg and k > kz:
-		    irec=(abs(game.enemies[k].power)/(PHASEFAC*math.pow(0.9,game.enemies[k].kdist))) *	randreal(1.01, 1.06) + 1.0
-		kz = k
-		proutn("(")
-		if not damaged(DCOMPTR):
-		    proutn("%d" % irec)
-		else:
-		    proutn("??")
-		proutn(")  ")
-		proutn(_("units to fire at %s-  ") % crmena(False, ienm, "sector", aim))		
-		key = scanner.next()
-	    if key == "IHALPHA" and scanner.sees("no"):
-		no = True
-		key = scanner.next()
-		continue
-	    if key == "IHALPHA":
-		huh()
-		return
-	    if key == "IHEOL":
-		if k==1: # Let me say I'm baffled by this 
-		    msgflag = True
-		continue
-	    if scanner.real < 0:
-		# abort out 
-		scanner.chew()
-		return
-	    hits[k] = scanner.real
-	    rpow += scanner.real
-	    # If total requested is too much, inform and start over 
-            if rpow > avail:
-		prout(_("Available energy exceeded -- try again."))
-		scanner.chew()
-		return
-	    key = scanner.next(); # scan for next value 
-	    k += 1
-	if rpow == 0.0:
-	    # zero energy -- abort 
-	    scanner.chew()
-	    return
-	if key == "IHALPHA" and scanner.sees("no"):
-	    no = True
-	game.energy -= rpow
-	scanner.chew()
-	if ifast:
-	    game.energy -= 200.0
-	    if checkshctrl(rpow):
-		return
-	hittem(hits)
-	game.ididit = True
-     # Say shield raised or malfunction, if necessary 
-    if game.alldone:
-	return
-    if ifast:
-	skip(1)
-	if no == 0:
-	    if withprob(0.01):
-		prout(_("Sulu-  \"Sir, the high-speed shield control has malfunctioned . . ."))
-		prouts(_("         CLICK   CLICK   POP  . . ."))
-		prout(_(" No response, sir!"))
-		game.shldup = False
-	    else:
-		prout(_("Shields raised."))
-	else:
-	    game.shldup = False
-    overheat(rpow);
-
-# Code from events,c begins here.
-
-# This isn't a real event queue a la BSD Trek yet -- you can only have one 
-# event of each type active at any given time.  Mostly these means we can 
-# only have one FDISTR/FENSLV/FREPRO sequence going at any given time
-# BSD Trek, from which we swiped the idea, can have up to 5.
-
-def unschedule(evtype):
-    "Remove an event from the schedule."
-    game.future[evtype].date = FOREVER
-    return game.future[evtype]
-
-def is_scheduled(evtype):
-    "Is an event of specified type scheduled."
-    return game.future[evtype].date != FOREVER
-
-def scheduled(evtype):
-    "When will this event happen?"
-    return game.future[evtype].date
-
-def schedule(evtype, offset):
-    "Schedule an event of specified type."
-    game.future[evtype].date = game.state.date + offset
-    return game.future[evtype]
-
-def postpone(evtype, offset):
-    "Postpone a scheduled event."
-    game.future[evtype].date += offset
-
-def cancelrest():
-    "Rest period is interrupted by event."
-    if game.resting:
-	skip(1)
-	proutn(_("Mr. Spock-  \"Captain, shall we cancel the rest period?\""))
-	if ja() == True:
-	    game.resting = False
-	    game.optime = 0.0
-	    return True
-    return False
-
-def events():
-    "Run through the event queue looking for things to do."
-    i=0
-    fintim = game.state.date + game.optime; yank=0
-    ictbeam = False; istract = False
-    w = coord(); hold = coord()
-    ev = event(); ev2 = event()
-
-    def tractorbeam(yank):
-        "Tractor-beaming cases merge here." 
-        announce()
-        game.optime = (10.0/(7.5*7.5))*yank # 7.5 is yank rate (warp 7.5) 
-        skip(1)
-        prout("***" + crmshp() + _(" caught in long range tractor beam--"))
-        # If Kirk & Co. screwing around on planet, handle 
-        atover(True) # atover(true) is Grab 
-        if game.alldone:
-            return
-        if game.icraft: # Caught in Galileo? 
-            finish(FSTRACTOR)
-            return
-        # Check to see if shuttle is aboard 
-        if game.iscraft == "offship":
-            skip(1)
-            if withprob(0.5):
-                prout(_("Galileo, left on the planet surface, is captured"))
-                prout(_("by aliens and made into a flying McDonald's."))
-                game.damage[DSHUTTL] = -10
-                game.iscraft = "removed"
-            else:
-                prout(_("Galileo, left on the planet surface, is well hidden."))
-        if evcode == FSPY:
-            game.quadrant = game.state.kscmdr
-        else:
-            game.quadrant = game.state.kcmdr[i]
-        game.sector = randplace(QUADSIZE)
-        prout(crmshp() + _(" is pulled to Quadrant %s, Sector %s") \
-               % (game.quadrant, game.sector))
-        if game.resting:
-            prout(_("(Remainder of rest/repair period cancelled.)"))
-            game.resting = False
-        if not game.shldup:
-            if not damaged(DSHIELD) and game.shield > 0:
-                doshield(shraise=True) # raise shields 
-                game.shldchg = False
-            else:
-                prout(_("(Shields not currently useable.)"))
-        newqad()
-        # Adjust finish time to time of tractor beaming 
-        fintim = game.state.date+game.optime
-        attack(torps_ok=False)
-        if not game.state.kcmdr:
-            unschedule(FTBEAM)
-        else: 
-            schedule(FTBEAM, game.optime+expran(1.5*game.intime/len(game.state.kcmdr)))
-
-    def destroybase():
-        "Code merges here for any commander destroying a starbase." 
-        # Not perfect, but will have to do 
-        # Handle case where base is in same quadrant as starship 
-        if game.battle == game.quadrant:
-            game.state.chart[game.battle.i][game.battle.j].starbase = False
-            game.quad[game.base.i][game.base.j] = '.'
-            game.base.invalidate()
-            newcnd()
-            skip(1)
-            prout(_("Spock-  \"Captain, I believe the starbase has been destroyed.\""))
-        elif game.state.baseq and communicating():
-            # Get word via subspace radio 
-            announce()
-            skip(1)
-            prout(_("Lt. Uhura-  \"Captain, Starfleet Command reports that"))
-            proutn(_("   the starbase in Quadrant %s has been destroyed by") % game.battle)
-            if game.isatb == 2: 
-                prout(_("the Klingon Super-Commander"))
-            else:
-                prout(_("a Klingon Commander"))
-            game.state.chart[game.battle.i][game.battle.j].starbase = False
-        # Remove Starbase from galaxy 
-        game.state.galaxy[game.battle.i][game.battle.j].starbase = False
-        game.state.baseq = filter(lambda x: x != game.battle, game.state.baseq)
-        if game.isatb == 2:
-            # reinstate a commander's base attack 
-            game.battle = hold
-            game.isatb = 0
-        else:
-            game.battle.invalidate()
-    if idebug:
-	prout("=== EVENTS from %.2f to %.2f:" % (game.state.date, fintim))
-	for i in range(1, NEVENTS):
-	    if   i == FSNOVA:  proutn("=== Supernova       ")
-	    elif i == FTBEAM:  proutn("=== T Beam          ")
-	    elif i == FSNAP:   proutn("=== Snapshot        ")
-	    elif i == FBATTAK: proutn("=== Base Attack     ")
-	    elif i == FCDBAS:  proutn("=== Base Destroy    ")
-	    elif i == FSCMOVE: proutn("=== SC Move         ")
-	    elif i == FSCDBAS: proutn("=== SC Base Destroy ")
-	    elif i == FDSPROB: proutn("=== Probe Move      ")
-	    elif i == FDISTR:  proutn("=== Distress Call   ")
-	    elif i == FENSLV:  proutn("=== Enslavement     ")
-	    elif i == FREPRO:  proutn("=== Klingon Build   ")
-	    if is_scheduled(i):
-		prout("%.2f" % (scheduled(i)))
-	    else:
-		prout("never")
-    radio_was_broken = damaged(DRADIO)
-    hold.i = hold.j = 0
-    while True:
-	# Select earliest extraneous event, evcode==0 if no events 
-	evcode = FSPY
-	if game.alldone:
-	    return
-	datemin = fintim
-	for l in range(1, NEVENTS):
-	    if game.future[l].date < datemin:
-		evcode = l
-		if idebug:
-		    prout("== Event %d fires" % evcode)
-		datemin = game.future[l].date
-	xtime = datemin-game.state.date
-	game.state.date = datemin
-	# Decrement Federation resources and recompute remaining time 
-	game.state.remres -= (game.state.remkl+4*len(game.state.kcmdr))*xtime
-        game.recompute()
-	if game.state.remtime <=0:
-	    finish(FDEPLETE)
-	    return
-	# Any crew left alive? 
-	if game.state.crew <=0:
-	    finish(FCREW)
-	    return
-	# Is life support adequate? 
-	if damaged(DLIFSUP) and game.condition != "docked":
-	    if game.lsupres < xtime and game.damage[DLIFSUP] > game.lsupres:
-		finish(FLIFESUP)
-		return
-	    game.lsupres -= xtime
-	    if game.damage[DLIFSUP] <= xtime:
-		game.lsupres = game.inlsr
-	# Fix devices 
-	repair = xtime
-	if game.condition == "docked":
-	    repair /= DOCKFAC
-	# Don't fix Deathray here 
-	for l in range(NDEVICES):
-	    if game.damage[l] > 0.0 and l != DDRAY:
-                if game.damage[l]-repair > 0.0:
-                    game.damage[l] -= repair
-                else:
-                    game.damage[l] = 0.0
-	# If radio repaired, update star chart and attack reports 
-	if radio_was_broken and not damaged(DRADIO):
-	    prout(_("Lt. Uhura- \"Captain, the sub-space radio is working and"))
-	    prout(_("   surveillance reports are coming in."))
-	    skip(1)
-	    if not game.iseenit:
-		attackreport(False)
-		game.iseenit = True
-	    rechart()
-	    prout(_("   The star chart is now up to date.\""))
-	    skip(1)
-	# Cause extraneous event EVCODE to occur 
-	game.optime -= xtime
-	if evcode == FSNOVA: # Supernova 
-	    announce()
-	    supernova(None)
-	    schedule(FSNOVA, expran(0.5*game.intime))
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		return
-	elif evcode == FSPY: # Check with spy to see if SC should tractor beam 
-	    if game.state.nscrem == 0 or \
-		ictbeam or istract or \
-                game.condition=="docked" or game.isatb==1 or game.iscate:
-		return
-	    if game.ientesc or \
-		(game.energy<2000 and game.torps<4 and game.shield < 1250) or \
-		(damaged(DPHASER) and (damaged(DPHOTON) or game.torps<4)) or \
-		(damaged(DSHIELD) and \
-		 (game.energy < 2500 or damaged(DPHASER)) and \
-                 (game.torps < 5 or damaged(DPHOTON))):
-		# Tractor-beam her! 
-		istract = ictbeam = True
-                tractorbeam((game.state.kscmdr-game.quadrant).distance())
-	    else:
-		return
-	elif evcode == FTBEAM: # Tractor beam 
-            if not game.state.kcmdr:
-                unschedule(FTBEAM)
-                continue
-            i = randrange(len(game.state.kcmdr))
-            yank = (game.state.kcmdr[i]-game.quadrant).distance()
-            if istract or game.condition == "docked" or yank == 0:
-                # Drats! Have to reschedule 
-                schedule(FTBEAM, 
-                         game.optime + expran(1.5*game.intime/len(game.state.kcmdr)))
-                continue
-            ictbeam = True
-            tractorbeam(yank)
-	elif evcode == FSNAP: # Snapshot of the universe (for time warp) 
-	    game.snapsht = copy.deepcopy(game.state)
-	    game.state.snap = True
-	    schedule(FSNAP, expran(0.5 * game.intime))
-	elif evcode == FBATTAK: # Commander attacks starbase 
-	    if not game.state.kcmdr or not game.state.baseq:
-		# no can do 
-		unschedule(FBATTAK)
-		unschedule(FCDBAS)
-                continue
-            try:
-                for ibq in game.state.baseq:
-                   for cmdr in game.state.kcmdr: 
-                       if ibq == cmdr and ibq != game.quadrant and ibq != game.state.kscmdr:
-                           raise ibq
-                else:
-                    # no match found -- try later 
-                    schedule(FBATTAK, expran(0.3*game.intime))
-                    unschedule(FCDBAS)
-                    continue
-            except coord:
-                pass
-	    # commander + starbase combination found -- launch attack 
-	    game.battle = ibq
-	    schedule(FCDBAS, randreal(1.0, 4.0))
-	    if game.isatb: # extra time if SC already attacking 
-		postpone(FCDBAS, scheduled(FSCDBAS)-game.state.date)
-	    game.future[FBATTAK].date = game.future[FCDBAS].date + expran(0.3*game.intime)
-	    game.iseenit = False
-            if not communicating():
-		continue # No warning :-( 
-	    game.iseenit = True
-	    announce()
-	    skip(1)
-	    prout(_("Lt. Uhura-  \"Captain, the starbase in Quadrant %s") % game.battle)
-	    prout(_("   reports that it is under attack and that it can"))
-	    prout(_("   hold out only until stardate %d.\"") % (int(scheduled(FCDBAS))))
-	    if cancelrest():
-                return
-	elif evcode == FSCDBAS: # Supercommander destroys base 
-	    unschedule(FSCDBAS)
-	    game.isatb = 2
-	    if not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].starbase: 
-		continue # WAS RETURN! 
-	    hold = game.battle
-	    game.battle = game.state.kscmdr
-	    destroybase()
-	elif evcode == FCDBAS: # Commander succeeds in destroying base 
-	    if evcode==FCDBAS:
-		unschedule(FCDBAS)
-                if not game.state.baseq() \
-                       or not game.state.galaxy[game.battle.i][game.battle.j].starbase:
-		    game.battle.invalidate()
-                    continue
-		# find the lucky pair 
-		for cmdr in game.state.kcmdr:
-		    if cmdr == game.battle: 
-			break
-                else:
-		    # No action to take after all 
-		    continue
-            destroybase()
-	elif evcode == FSCMOVE: # Supercommander moves 
-	    schedule(FSCMOVE, 0.2777)
-	    if not game.ientesc and not istract and game.isatb != 1 and \
-                   (not game.iscate or not game.justin): 
-		supercommander()
-	elif evcode == FDSPROB: # Move deep space probe 
-	    schedule(FDSPROB, 0.01)
-            if not game.probe.next():
-		if not game.probe.quadrant().valid_quadrant() or \
-		    game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j].supernova:
-		    # Left galaxy or ran into supernova
-                    if communicating():
-			announce()
-			skip(1)
-			proutn(_("Lt. Uhura-  \"The deep space probe "))
-			if not game.probe.quadrant().valid_quadrant():
-			    prout(_("has left the galaxy.\""))
-			else:
-			    prout(_("is no longer transmitting.\""))
-		    unschedule(FDSPROB)
-		    continue
-                if communicating():
-		    #announce()
-		    skip(1)
-		    prout(_("Lt. Uhura-  \"The deep space probe is now in Quadrant %s.\"") % game.probe.quadrant())
-	    pdest = game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j]
-	    if communicating():
-		chp = game.state.chart[game.probe.quadrant().i][game.probe.quadrant().j]
-		chp.klingons = pdest.klingons
-		chp.starbase = pdest.starbase
-		chp.stars = pdest.stars
-		pdest.charted = True
-	    game.probe.moves -= 1 # One less to travel
-	    if game.probe.arrived() and game.isarmed and pdest.stars:
-		supernova(game.probe)		# fire in the hole!
-		unschedule(FDSPROB)
-		if game.state.galaxy[game.quadrant().i][game.quadrant().j].supernova: 
-		    return
-	elif evcode == FDISTR: # inhabited system issues distress call 
-	    unschedule(FDISTR)
-	    # try a whole bunch of times to find something suitable 
-            for i in range(100):
-		# need a quadrant which is not the current one,
-		# which has some stars which are inhabited and
-		# not already under attack, which is not
-		# supernova'ed, and which has some Klingons in it
-		w = randplace(GALSIZE)
-		q = game.state.galaxy[w.i][w.j]
-                if not (game.quadrant == w or q.planet == None or \
-		      not q.planet.inhabited or \
-		      q.supernova or q.status!="secure" or q.klingons<=0):
-                    break
-            else:
-		# can't seem to find one; ignore this call 
-		if idebug:
-		    prout("=== Couldn't find location for distress event.")
-		continue
-	    # got one!!  Schedule its enslavement 
-	    ev = schedule(FENSLV, expran(game.intime))
-	    ev.quadrant = w
-	    q.status = "distressed"
-	    # tell the captain about it if we can 
-	    if communicating():
-		prout(_("Uhura- Captain, %s in Quadrant %s reports it is under attack") \
-                        % (q.planet, `w`))
-		prout(_("by a Klingon invasion fleet."))
-		if cancelrest():
-		    return
-	elif evcode == FENSLV:		# starsystem is enslaved 
-	    ev = unschedule(FENSLV)
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
-	    if q.klingons <= 0:
-		q.status = "secure"
-		continue
-	    q.status = "enslaved"
-
-	    # play stork and schedule the first baby 
-	    ev2 = schedule(FREPRO, expran(2.0 * game.intime))
-	    ev2.quadrant = ev.quadrant
-
-	    # report the disaster if we can 
-	    if communicating():
-		prout(_("Uhura- We've lost contact with starsystem %s") % \
-                        q.planet)
-		prout(_("in Quadrant %s.\n") % ev.quadrant)
-	elif evcode == FREPRO:		# Klingon reproduces 
-	    # If we ever switch to a real event queue, we'll need to
-	    # explicitly retrieve and restore the x and y.
-	    ev = schedule(FREPRO, expran(1.0 * game.intime))
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
-	    if q.klingons <= 0:
-		q.status = "secure"
-		continue
-	    if game.state.remkl >=MAXKLGAME:
-		continue		# full right now 
-	    # reproduce one Klingon 
-	    w = ev.quadrant
-            m = coord()
-	    if game.klhere >= MAXKLQUAD:
-                try:
-                    # this quadrant not ok, pick an adjacent one 
-                    for m.i in range(w.i - 1, w.i + 2):
-                        for m.j in range(w.j - 1, w.j + 2):
-                            if not m.valid_quadrant():
-                                continue
-                            q = game.state.galaxy[m.i][m.j]
-                            # check for this quad ok (not full & no snova) 
-                            if q.klingons >= MAXKLQUAD or q.supernova:
-                                continue
-                            raise "FOUNDIT"
-                    else:
-                        continue	# search for eligible quadrant failed
-                except "FOUNDIT":
-                    w = m
-	    # deliver the child 
-	    game.state.remkl += 1
-	    q.klingons += 1
-	    if game.quadrant == w:
-                game.klhere += 1
-		game.enemies.append(newkling())
-	    # recompute time left
-            game.recompute()
-	    if communicating():
-		if game.quadrant == w:
-		    prout(_("Spock- sensors indicate the Klingons have"))
-		    prout(_("launched a warship from %s.") % q.planet)
-		else:
-		    prout(_("Uhura- Starfleet reports increased Klingon activity"))
-		    if q.planet != None:
-			proutn(_("near %s ") % q.planet)
-		    prout(_("in Quadrant %s.") % w)
-				
-def wait():
-    "Wait on events."
-    game.ididit = False
-    while True:
-	key = scanner.next()
-	if key  != "IHEOL":
-	    break
-	proutn(_("How long? "))
-    scanner.chew()
-    if key != "IHREAL":
-	huh()
-	return
-    origTime = delay = scanner.real
-    if delay <= 0.0:
-	return
-    if delay >= game.state.remtime or len(game.enemies) != 0:
-	proutn(_("Are you sure? "))
-	if ja() == False:
-	    return
-    # Alternate resting periods (events) with attacks 
-    game.resting = True
-    while True:
-	if delay <= 0:
-	    game.resting = False
-	if not game.resting:
-	    prout(_("%d stardates left.") % int(game.state.remtime))
-	    return
-	temp = game.optime = delay
-	if len(game.enemies):
-	    rtime = randreal(1.0, 2.0)
-	    if rtime < temp:
-		temp = rtime
-	    game.optime = temp
-	if game.optime < delay:
-	    attack(torps_ok=False)
-	if game.alldone:
-	    return
-	events()
-	game.ididit = True
-	if game.alldone:
-	    return
-	delay -= temp
-	# Repair Deathray if long rest at starbase 
-	if origTime-delay >= 9.99 and game.condition == "docked":
-	    game.damage[DDRAY] = 0.0
-	# leave if quadrant supernovas
-        if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            break
-    game.resting = False
-    game.optime = 0
-
-def nova(nov):
-    "Star goes nova." 
-    course = (0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5)
-    newc = coord(); neighbor = coord(); bump = coord(0, 0)
-    if withprob(0.05):
-	# Wow! We've supernova'ed 
-	supernova(game.quadrant)
-	return
-    # handle initial nova 
-    game.quad[nov.i][nov.j] = '.'
-    prout(crmena(False, '*', "sector", nov) + _(" novas."))
-    game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
-    game.state.starkl += 1
-    # Set up queue to recursively trigger adjacent stars 
-    hits = [nov]
-    kount = 0
-    while hits:
-        offset = coord()
-        start = hits.pop()
-        for offset.i in range(-1, 1+1):
-            for offset.j in range(-1, 1+1):
-                if offset.j==0 and offset.i==0:
-                    continue
-                neighbor = start + offset
-                if not neighbor.valid_sector():
-                    continue
-                iquad = game.quad[neighbor.i][neighbor.j]
-                # Empty space ends reaction
-                if iquad in ('.', '?', ' ', 'T', '#'):
-                    pass
-                elif iquad == '*': # Affect another star 
-                    if withprob(0.05):
-                        # This star supernovas 
-                        supernova(game.quadrant)
-                        return
-                    else:
-                        hits.append(neighbor)
-			game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
-			game.state.starkl += 1
-			proutn(crmena(True, '*', "sector", neighbor))
-			prout(_(" novas."))
-                        game.quad[neighbor.i][neighbor.j] = '.'
-                        kount += 1
-                elif iquad in ('P', '@'): # Destroy planet 
-                    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-                    if iquad == 'P':
-                        game.state.nplankl += 1
-                    else:
-                        game.state.worldkl += 1
-                    prout(crmena(True, 'B', "sector", neighbor) + _(" destroyed."))
-                    game.iplnet.pclass = "destroyed"
-                    game.iplnet = None
-                    game.plnet.invalidate()
-                    if game.landed:
-                        finish(FPNOVA)
-                        return
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                elif iquad == 'B': # Destroy base 
-                    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase = False
-                    game.state.baseq = filter(lambda x: x!= game.quadrant, game.state.baseq)
-                    game.base.invalidate()
-                    game.state.basekl += 1
-                    newcnd()
-                    prout(crmena(True, 'B', "sector", neighbor) + _(" destroyed."))
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                elif iquad in ('E', 'F'): # Buffet ship 
-                    prout(_("***Starship buffeted by nova."))
-                    if game.shldup:
-                        if game.shield >= 2000.0:
-                            game.shield -= 2000.0
-                        else:
-                            diff = 2000.0 - game.shield
-                            game.energy -= diff
-                            game.shield = 0.0
-                            game.shldup = False
-                            prout(_("***Shields knocked out."))
-                            game.damage[DSHIELD] += 0.005*game.damfac*randreal()*diff
-                    else:
-                        game.energy -= 2000.0
-                    if game.energy <= 0:
-                        finish(FNOVA)
-                        return
-                    # add in course nova contributes to kicking starship
-                    bump += (game.sector-hits[mm]).sgn()
-                elif iquad == 'K': # kill klingon 
-                    deadkl(neighbor, iquad, neighbor)
-                elif iquad in ('C','S','R'): # Damage/destroy big enemies 
-                    for ll in range(len(game.enemies)):
-                        if game.enemies[ll].location == neighbor:
-                            break
-                    game.enemies[ll].power -= 800.0 # If firepower is lost, die 
-                    if game.enemies[ll].power <= 0.0:
-                        deadkl(neighbor, iquad, neighbor)
-                        break
-                    newc = neighbor + neighbor - hits[mm]
-                    proutn(crmena(True, iquad, "sector", neighbor) + _(" damaged"))
-                    if not newc.valid_sector():
-                        # can't leave quadrant 
-                        skip(1)
-                        break
-                    iquad1 = game.quad[newc.i][newc.j]
-                    if iquad1 == ' ':
-                        proutn(_(", blasted into ") + crmena(False, ' ', "sector", newc))
-                        skip(1)
-                        deadkl(neighbor, iquad, newc)
-                        break
-                    if iquad1 != '.':
-                        # can't move into something else 
-                        skip(1)
-                        break
-                    proutn(_(", buffeted to Sector %s") % newc)
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                    game.quad[newc.i][newc.j] = iquad
-                    game.enemies[ll].move(newc)
-    # Starship affected by nova -- kick it away. 
-    dist = kount*0.1
-    direc = course[3*(bump.i+1)+bump.j+2]
-    if direc == 0.0:
-	dist = 0.0
-    if dist == 0.0:
-	return
-    course = course(bearing=direc, distance=dist)
-    game.optime = course.time(warp=4)
-    skip(1)
-    prout(_("Force of nova displaces starship."))
-    imove(course, noattack=True)
-    game.optime = course.time(warp=4)
-    return
-	
-def supernova(w):
-    "Star goes supernova."
-    num = 0; npdead = 0
-    if w != None: 
-	nq = copy.copy(w)
-    else:
-	# Scheduled supernova -- select star at random. 
-	stars = 0
-        nq = coord()
-	for nq.i in range(GALSIZE):
-	    for nq.j in range(GALSIZE):
-		stars += game.state.galaxy[nq.i][nq.j].stars
-	if stars == 0:
-	    return # nothing to supernova exists 
-	num = randrange(stars) + 1
-	for nq.i in range(GALSIZE):
-	    for nq.j in range(GALSIZE):
-		num -= game.state.galaxy[nq.i][nq.j].stars
-		if num <= 0:
-		    break
-	    if num <=0:
-		break
-	if idebug:
-	    proutn("=== Super nova here?")
-	    if ja() == True:
-		nq = game.quadrant
-    if not nq == game.quadrant or game.justin:
-	# it isn't here, or we just entered (treat as enroute) 
-	if communicating():
-	    skip(1)
-	    prout(_("Message from Starfleet Command       Stardate %.2f") % game.state.date)
-	    prout(_("     Supernova in Quadrant %s; caution advised.") % nq)
-    else:
-	ns = coord()
-	# we are in the quadrant! 
-	num = randrange(game.state.galaxy[nq.i][nq.j].stars) + 1
-	for ns.i in range(QUADSIZE):
-	    for ns.j in range(QUADSIZE):
-		if game.quad[ns.i][ns.j]=='*':
-		    num -= 1
-		    if num==0:
-			break
-	    if num==0:
-		break
-	skip(1)
-	prouts(_("***RED ALERT!  RED ALERT!"))
-	skip(1)
-	prout(_("***Incipient supernova detected at Sector %s") % ns)
-	if (ns.i-game.sector.i)**2 + (ns.j-game.sector.j)**2 <= 2.1:
-	    proutn(_("Emergency override attempts t"))
-	    prouts("***************")
-	    skip(1)
-	    stars()
-	    game.alldone = True
-    # destroy any Klingons in supernovaed quadrant
-    kldead = game.state.galaxy[nq.i][nq.j].klingons
-    game.state.galaxy[nq.i][nq.j].klingons = 0
-    if nq == game.state.kscmdr:
-	# did in the Supercommander! 
-	game.state.nscrem = game.state.kscmdr.i = game.state.kscmdr.j = game.isatb =  0
-	game.iscate = False
-	unschedule(FSCMOVE)
-	unschedule(FSCDBAS)
-    survivors = filter(lambda w: w != nq, game.state.kcmdr)
-    comkills = len(game.state.kcmdr) - len(survivors)
-    game.state.kcmdr = survivors
-    kldead -= comkills
-    if not game.state.kcmdr:
-        unschedule(FTBEAM)
-    game.state.remkl -= kldead
-    # destroy Romulans and planets in supernovaed quadrant 
-    nrmdead = game.state.galaxy[nq.i][nq.j].romulans
-    game.state.galaxy[nq.i][nq.j].romulans = 0
-    game.state.nromrem -= nrmdead
-    # Destroy planets 
-    for loop in range(game.inplan):
-	if game.state.planets[loop].quadrant == nq:
-	    game.state.planets[loop].pclass = "destroyed"
-	    npdead += 1
-    # Destroy any base in supernovaed quadrant
-    game.state.baseq = filter(lambda x: x != nq, game.state.baseq)
-    # If starship caused supernova, tally up destruction 
-    if w != None:
-	game.state.starkl += game.state.galaxy[nq.i][nq.j].stars
-	game.state.basekl += game.state.galaxy[nq.i][nq.j].starbase
-	game.state.nplankl += npdead
-    # mark supernova in galaxy and in star chart 
-    if game.quadrant == nq or communicating():
-	game.state.galaxy[nq.i][nq.j].supernova = True
-    # If supernova destroys last Klingons give special message 
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0 and not nq == game.quadrant:
-	skip(2)
-	if w == None:
-	    prout(_("Lucky you!"))
-	proutn(_("A supernova in %s has just destroyed the last Klingons.") % nq)
-	finish(FWON)
-	return
-    # if some Klingons remain, continue or die in supernova 
-    if game.alldone:
-	finish(FSNOVAED)
-    return
-
-# Code from finish.c ends here.
-
-def selfdestruct():
-    "Self-destruct maneuver. Finish with a BANG!" 
-    scanner.chew()
-    if damaged(DCOMPTR):
-	prout(_("Computer damaged; cannot execute destruct sequence."))
-	return
-    prouts(_("---WORKING---")); skip(1)
-    prouts(_("SELF-DESTRUCT-SEQUENCE-ACTIVATED")); skip(1)
-    prouts("   10"); skip(1)
-    prouts("       9"); skip(1)
-    prouts("          8"); skip(1)
-    prouts("             7"); skip(1)
-    prouts("                6"); skip(1)
-    skip(1)
-    prout(_("ENTER-CORRECT-PASSWORD-TO-CONTINUE-"))
-    skip(1)
-    prout(_("SELF-DESTRUCT-SEQUENCE-OTHERWISE-"))
-    skip(1)
-    prout(_("SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED"))
-    skip(1)
-    scanner.next()
-    scanner.chew()
-    if game.passwd != scanner.token:
-	prouts(_("PASSWORD-REJECTED;"))
-	skip(1)
-	prouts(_("CONTINUITY-EFFECTED"))
-	skip(2)
-	return
-    prouts(_("PASSWORD-ACCEPTED")); skip(1)
-    prouts("                   5"); skip(1)
-    prouts("                      4"); skip(1)
-    prouts("                         3"); skip(1)
-    prouts("                            2"); skip(1)
-    prouts("                              1"); skip(1)
-    if withprob(0.15):
-	prouts(_("GOODBYE-CRUEL-WORLD"))
-	skip(1)
-    kaboom()
-
-def kaboom():
-    stars()
-    if game.ship=='E':
-	prouts("***")
-    prouts(_("********* Entropy of %s maximized *********") % crmshp())
-    skip(1)
-    stars()
-    skip(1)
-    if len(game.enemies) != 0:
-	whammo = 25.0 * game.energy
-	l=1
-	while l <= len(game.enemies):
-	    if game.enemies[l].power*game.enemies[l].kdist <= whammo: 
-		deadkl(game.enemies[l].location, game.quad[game.enemies[l].location.i][game.enemies[l].location.j], game.enemies[l].location)
-	    l += 1
-    finish(FDILITHIUM)
-				
-def killrate():
-    "Compute our rate of kils over time."
-    elapsed = game.state.date - game.indate
-    if elapsed == 0:	# Avoid divide-by-zero error if calculated on turn 0
-        return 0
-    else:
-        starting = (game.inkling + game.incom + game.inscom)
-        remaining = (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)
-        return (starting - remaining)/elapsed
-
-def badpoints():
-    "Compute demerits."
-    badpt = 5.0*game.state.starkl + \
-            game.casual + \
-            10.0*game.state.nplankl + \
-            300*game.state.nworldkl + \
-            45.0*game.nhelp +\
-            100.0*game.state.basekl +\
-            3.0*game.abandoned
-    if game.ship == 'F':
-        badpt += 100.0
-    elif game.ship == None:
-        badpt += 200.0
-    return badpt
-
-def finish(ifin):
-    # end the game, with appropriate notfications 
-    igotit = False
-    game.alldone = True
-    skip(3)
-    prout(_("It is stardate %.1f.") % game.state.date)
-    skip(1)
-    if ifin == FWON: # Game has been won
-	if game.state.nromrem != 0:
-	    prout(_("The remaining %d Romulans surrender to Starfleet Command.") %
-		  game.state.nromrem)
-
-	prout(_("You have smashed the Klingon invasion fleet and saved"))
-	prout(_("the Federation."))
-	game.gamewon = True
-	if game.alive:
-            badpt = badpoints()
-            if badpt < 100.0:
-                badpt = 0.0	# Close enough!
-            # killsPerDate >= RateMax
-	    if game.state.date-game.indate < 5.0 or \
-                killrate() >= 0.1*game.skill*(game.skill+1.0) + 0.1 + 0.008*badpt:
-		skip(1)
-		prout(_("In fact, you have done so well that Starfleet Command"))
-		if game.skill == SKILL_NOVICE:
-		    prout(_("promotes you one step in rank from \"Novice\" to \"Fair\"."))
-		elif game.skill == SKILL_FAIR:
-		    prout(_("promotes you one step in rank from \"Fair\" to \"Good\"."))
-		elif game.skill == SKILL_GOOD:
-		    prout(_("promotes you one step in rank from \"Good\" to \"Expert\"."))
-		elif game.skill == SKILL_EXPERT:
-		    prout(_("promotes you to Commodore Emeritus."))
-		    skip(1)
-		    prout(_("Now that you think you're really good, try playing"))
-		    prout(_("the \"Emeritus\" game. It will splatter your ego."))
-		elif game.skill == SKILL_EMERITUS:
-		    skip(1)
-		    proutn(_("Computer-  "))
-		    prouts(_("ERROR-ERROR-ERROR-ERROR"))
-		    skip(2)
-		    prouts(_("  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM"))
-		    skip(1)
-		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
-		    skip(1)
-		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
-		    skip(1)
-		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
-		    skip(1)
-		    prouts(_("  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI"))
-		    skip(2)
-		    prout(_("Now you can retire and write your own Star Trek game!"))
-		    skip(1)
-		elif game.skill >= SKILL_EXPERT:
-		    if game.thawed and not idebug:
-			prout(_("You cannot get a citation, so..."))
-		    else:
-			proutn(_("Do you want your Commodore Emeritus Citation printed? "))
-			scanner.chew()
-			if ja() == True:
-			    igotit = True
-	    # Only grant long life if alive (original didn't!)
-	    skip(1)
-	    prout(_("LIVE LONG AND PROSPER."))
-	score()
-	if igotit:
-	    plaque()	    
-	return
-    elif ifin == FDEPLETE: # Federation Resources Depleted
-	prout(_("Your time has run out and the Federation has been"))
-	prout(_("conquered.  Your starship is now Klingon property,"))
-	prout(_("and you are put on trial as a war criminal.  On the"))
-	proutn(_("basis of your record, you are "))
-	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)*3.0 > (game.inkling + game.incom + game.inscom):
-	    prout(_("acquitted."))
-	    skip(1)
-	    prout(_("LIVE LONG AND PROSPER."))
-	else:
-	    prout(_("found guilty and"))
-	    prout(_("sentenced to death by slow torture."))
-	    game.alive = False
-	score()
-	return
-    elif ifin == FLIFESUP:
-	prout(_("Your life support reserves have run out, and"))
-	prout(_("you die of thirst, starvation, and asphyxiation."))
-	prout(_("Your starship is a derelict in space."))
-    elif ifin == FNRG:
-	prout(_("Your energy supply is exhausted."))
-	skip(1)
-	prout(_("Your starship is a derelict in space."))
-    elif ifin == FBATTLE:
-	prout(_("The %s has been destroyed in battle.") % crmshp())
-	skip(1)
-	prout(_("Dulce et decorum est pro patria mori."))
-    elif ifin == FNEG3:
-	prout(_("You have made three attempts to cross the negative energy"))
-	prout(_("barrier which surrounds the galaxy."))
-	skip(1)
-	prout(_("Your navigation is abominable."))
-	score()
-    elif ifin == FNOVA:
-	prout(_("Your starship has been destroyed by a nova."))
-	prout(_("That was a great shot."))
-	skip(1)
-    elif ifin == FSNOVAED:
-	prout(_("The %s has been fried by a supernova.") % crmshp())
-	prout(_("...Not even cinders remain..."))
-    elif ifin == FABANDN:
-	prout(_("You have been captured by the Klingons. If you still"))
-	prout(_("had a starbase to be returned to, you would have been"))
-	prout(_("repatriated and given another chance. Since you have"))
-	prout(_("no starbases, you will be mercilessly tortured to death."))
-    elif ifin == FDILITHIUM:
-	prout(_("Your starship is now an expanding cloud of subatomic particles"))
-    elif ifin == FMATERIALIZE:
-	prout(_("Starbase was unable to re-materialize your starship."))
-	prout(_("Sic transit gloria mundi"))
-    elif ifin == FPHASER:
-	prout(_("The %s has been cremated by its own phasers.") % crmshp())
-    elif ifin == FLOST:
-	prout(_("You and your landing party have been"))
-	prout(_("converted to energy, disipating through space."))
-    elif ifin == FMINING:
-	prout(_("You are left with your landing party on"))
-	prout(_("a wild jungle planet inhabited by primitive cannibals."))
-	skip(1)
-	prout(_("They are very fond of \"Captain Kirk\" soup."))
-	skip(1)
-	prout(_("Without your leadership, the %s is destroyed.") % crmshp())
-    elif ifin == FDPLANET:
-	prout(_("You and your mining party perish."))
-	skip(1)
-	prout(_("That was a great shot."))
-	skip(1)
-    elif ifin == FSSC:
-	prout(_("The Galileo is instantly annihilated by the supernova."))
-	prout(_("You and your mining party are atomized."))
-	skip(1)
-	prout(_("Mr. Spock takes command of the %s and") % crmshp())
-	prout(_("joins the Romulans, wreaking terror on the Federation."))
-    elif ifin == FPNOVA:
-	prout(_("You and your mining party are atomized."))
-	skip(1)
-	prout(_("Mr. Spock takes command of the %s and") % crmshp())
-	prout(_("joins the Romulans, wreaking terror on the Federation."))
-    elif ifin == FSTRACTOR:
-	prout(_("The shuttle craft Galileo is also caught,"))
-	prout(_("and breaks up under the strain."))
-	skip(1)
-	prout(_("Your debris is scattered for millions of miles."))
-	prout(_("Without your leadership, the %s is destroyed.") % crmshp())
-    elif ifin == FDRAY:
-	prout(_("The mutants attack and kill Spock."))
-	prout(_("Your ship is captured by Klingons, and"))
-	prout(_("your crew is put on display in a Klingon zoo."))
-    elif ifin == FTRIBBLE:
-	prout(_("Tribbles consume all remaining water,"))
-	prout(_("food, and oxygen on your ship."))
-	skip(1)
-	prout(_("You die of thirst, starvation, and asphyxiation."))
-	prout(_("Your starship is a derelict in space."))
-    elif ifin == FHOLE:
-	prout(_("Your ship is drawn to the center of the black hole."))
-	prout(_("You are crushed into extremely dense matter."))
-    elif ifin == FCREW:
-	prout(_("Your last crew member has died."))
-    if game.ship == 'F':
-	game.ship = None
-    elif game.ship == 'E':
-	game.ship = 'F'
-    game.alive = False
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0:
-	goodies = game.state.remres/game.inresor
-	baddies = (game.state.remkl + 2.0*len(game.state.kcmdr))/(game.inkling+2.0*game.incom)
-	if goodies/baddies >= randreal(1.0, 1.5):
-	    prout(_("As a result of your actions, a treaty with the Klingon"))
-	    prout(_("Empire has been signed. The terms of the treaty are"))
-	    if goodies/baddies >= randreal(3.0):
-		prout(_("favorable to the Federation."))
-		skip(1)
-		prout(_("Congratulations!"))
-	    else:
-		prout(_("highly unfavorable to the Federation."))
-	else:
-	    prout(_("The Federation will be destroyed."))
-    else:
-	prout(_("Since you took the last Klingon with you, you are a"))
-	prout(_("martyr and a hero. Someday maybe they'll erect a"))
-	prout(_("statue in your memory. Rest in peace, and try not"))
-	prout(_("to think about pigeons."))
-	game.gamewon = True
-    score()
-
-def score():
-    "Compute player's score."
-    timused = game.state.date - game.indate
-    iskill = game.skill
-    if (timused == 0 or (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0) and timused < 5.0:
-	timused = 5.0
-    perdate = killrate()
-    ithperd = 500*perdate + 0.5
-    iwon = 0
-    if game.gamewon:
-	iwon = 100*game.skill
-    if game.ship == 'E': 
-	klship = 0
-    elif game.ship == 'F': 
-	klship = 1
-    else:
-	klship = 2
-    iscore = 10*(game.inkling - game.state.remkl) \
-             + 50*(game.incom - len(game.state.kcmdr)) \
-             + ithperd + iwon \
-             + 20*(game.inrom - game.state.nromrem) \
-             + 200*(game.inscom - game.state.nscrem) \
-    	     - game.state.nromrem \
-             - badpoints()
-    if not game.alive:
-	iscore -= 200
-    skip(2)
-    prout(_("Your score --"))
-    if game.inrom - game.state.nromrem:
-	prout(_("%6d Romulans destroyed                 %5d") %
-	      (game.inrom - game.state.nromrem, 20*(game.inrom - game.state.nromrem)))
-    if game.state.nromrem and game.gamewon:
-	prout(_("%6d Romulans captured                  %5d") %
-	      (game.state.nromrem, game.state.nromrem))
-    if game.inkling - game.state.remkl:
-	prout(_("%6d ordinary Klingons destroyed        %5d") %
-	      (game.inkling - game.state.remkl, 10*(game.inkling - game.state.remkl)))
-    if game.incom - len(game.state.kcmdr):
-	prout(_("%6d Klingon commanders destroyed       %5d") %
-	      (game.incom - len(game.state.kcmdr), 50*(game.incom - len(game.state.kcmdr))))
-    if game.inscom - game.state.nscrem:
-	prout(_("%6d Super-Commander destroyed          %5d") %
-	      (game.inscom - game.state.nscrem, 200*(game.inscom - game.state.nscrem)))
-    if ithperd:
-	prout(_("%6.2f Klingons per stardate              %5d") %
-	      (perdate, ithperd))
-    if game.state.starkl:
-	prout(_("%6d stars destroyed by your action     %5d") %
-	      (game.state.starkl, -5*game.state.starkl))
-    if game.state.nplankl:
-	prout(_("%6d planets destroyed by your action   %5d") %
-	      (game.state.nplankl, -10*game.state.nplankl))
-    if (game.options & OPTION_WORLDS) and game.state.nworldkl:
-	prout(_("%6d inhabited planets destroyed by your action   %5d") %
-	      (game.state.nworldkl, -300*game.state.nworldkl))
-    if game.state.basekl:
-	prout(_("%6d bases destroyed by your action     %5d") %
-	      (game.state.basekl, -100*game.state.basekl))
-    if game.nhelp:
-	prout(_("%6d calls for help from starbase       %5d") %
-	      (game.nhelp, -45*game.nhelp))
-    if game.casual:
-	prout(_("%6d casualties incurred                %5d") %
-	      (game.casual, -game.casual))
-    if game.abandoned:
-	prout(_("%6d crew abandoned in space            %5d") %
-	      (game.abandoned, -3*game.abandoned))
-    if klship:
-	prout(_("%6d ship(s) lost or destroyed          %5d") %
-	      (klship, -100*klship))
-    if not game.alive:
-	prout(_("Penalty for getting yourself killed        -200"))
-    if game.gamewon:
-	proutn(_("Bonus for winning "))
-	if game.skill   == SKILL_NOVICE:	proutn(_("Novice game  "))
-	elif game.skill == SKILL_FAIR:  	proutn(_("Fair game    "))
-	elif game.skill ==  SKILL_GOOD: 	proutn(_("Good game    "))
-	elif game.skill ==  SKILL_EXPERT:	proutn(_("Expert game  "))
-	elif game.skill ==  SKILL_EMERITUS:	proutn(_("Emeritus game"))
-	prout("           %5d" % iwon)
-    skip(1)
-    prout(_("TOTAL SCORE                               %5d") % iscore)
-
-def plaque():
-    "Emit winner's commemmorative plaque." 
-    skip(2)
-    while True:
-        proutn(_("File or device name for your plaque: "))
-        winner = cgetline()
-        try:
-            fp = open(winner, "w")
-            break
-        except IOError:
-            prout(_("Invalid name."))
-
-    proutn(_("Enter name to go on plaque (up to 30 characters): "))
-    winner = cgetline()
-    # The 38 below must be 64 for 132-column paper 
-    nskip = 38 - len(winner)/2
-    fp.write("\n\n\n\n")
-    # --------DRAW ENTERPRISE PICTURE. 
-    fp.write("                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n" )
-    fp.write("                                      EEE                      E  : :                                         :  E\n" )
-    fp.write("                                    EE   EEE                   E  : :                   NCC-1701              :  E\n")
-    fp.write("EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n")
-    fp.write(" E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n")
-    fp.write("                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n")
-    fp.write("                               EEEEEEE   EEEEE    E          E              E  E\n")
-    fp.write("                                      EEE           E          E            E  E\n")
-    fp.write("                                                       E         E          E  E\n")
-    fp.write("                                                         EEEEEEEEEEEEE      E  E\n")
-    fp.write("                                                      EEE :           EEEEEEE  EEEEEEEE\n")
-    fp.write("                                                    :E    :                 EEEE       E\n")
-    fp.write("                                                   .-E   -:-----                       E\n")
-    fp.write("                                                    :E    :                            E\n")
-    fp.write("                                                      EE  :                    EEEEEEEE\n")
-    fp.write("                                                       EEEEEEEEEEEEEEEEEEEEEEE\n")
-    fp.write("\n\n\n")
-    fp.write(_("                                                       U. S. S. ENTERPRISE\n"))
-    fp.write("\n\n\n\n")
-    fp.write(_("                                  For demonstrating outstanding ability as a starship captain\n"))
-    fp.write("\n")
-    fp.write(_("                                                Starfleet Command bestows to you\n"))
-    fp.write("\n")
-    fp.write("%*s%s\n\n" % (nskip, "", winner))
-    fp.write(_("                                                           the rank of\n\n"))
-    fp.write(_("                                                       \"Commodore Emeritus\"\n\n"))
-    fp.write("                                                          ")
-    if game.skill ==  SKILL_EXPERT:
-        fp.write(_(" Expert level\n\n"))
-    elif game.skill == SKILL_EMERITUS:
-        fp.write(_("Emeritus level\n\n"))
-    else:
-        fp.write(_(" Cheat level\n\n"))
-    timestring = time.ctime()
-    fp.write(_("                                                 This day of %.6s %.4s, %.8s\n\n") %
-                    (timestring+4, timestring+20, timestring+11))
-    fp.write(_("                                                        Your score:  %d\n\n") % iscore)
-    fp.write(_("                                                    Klingons per stardate:  %.2f\n") % perdate)
-    fp.close()
-
-# Code from io.c begins here
-
-rows = linecount = 0	# for paging 
-stdscr = None
-replayfp = None
-fullscreen_window = None
-srscan_window     = None
-report_window     = None
-status_window     = None
-lrscan_window     = None
-message_window    = None
-prompt_window     = None
-curwnd = None
-
-def iostart():
-    global stdscr, rows
-    "for some recent versions of python2, the following enables UTF8"
-    "for the older ones we probably need to set C locale, and the python3"
-    "has no problems at all"
-    if sys.version_info.major < 3:
-	import locale
-	locale.setlocale(locale.LC_ALL, "")
-    gettext.bindtextdomain("sst", "/usr/local/share/locale")
-    gettext.textdomain("sst")
-    if not (game.options & OPTION_CURSES):
-	ln_env = os.getenv("LINES")
-        if ln_env:
-            rows = ln_env
-        else:
-            rows = 25
-    else:
-	stdscr = curses.initscr()
-	stdscr.keypad(True)
-	curses.nonl()
-	curses.cbreak()
-        if game.options & OPTION_COLOR:
-            curses.start_color();
-            curses.use_default_colors()
-            curses.init_pair(curses.COLOR_BLACK,   curses.COLOR_BLACK, -1);
-            curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN, -1);
-            curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED, -1);
-            curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN, -1);
-            curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE, -1);
-            curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1);
-            curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE, -1);
-            curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW, -1);
-        global fullscreen_window, srscan_window, report_window, status_window
-        global lrscan_window, message_window, prompt_window
-        (rows, columns)   = stdscr.getmaxyx()
-	fullscreen_window = stdscr
-	srscan_window     = curses.newwin(12, 25, 0,       0)
-	report_window     = curses.newwin(11, 0,  1,       25)
-	status_window     = curses.newwin(10, 0,  1,       39)
-	lrscan_window     = curses.newwin(5,  0,  0,       64) 
-	message_window    = curses.newwin(0,  0,  12,      0)
-	prompt_window     = curses.newwin(1,  0,  rows-2,  0) 
-	message_window.scrollok(True)
-	setwnd(fullscreen_window)
-
-def ioend():
-    "Wrap up I/O."
-    if game.options & OPTION_CURSES:
-        stdscr.keypad(False)
-        curses.echo()
-        curses.nocbreak()
-        curses.endwin()
-
-def waitfor():
-    "Wait for user action -- OK to do nothing if on a TTY"
-    if game.options & OPTION_CURSES:
-	stdscr.getch()
-
-def announce():
-    skip(1)
-    prouts(_("[ANNOUNCEMENT ARRIVING...]"))
-    skip(1)
-
-def pause_game():
-    if game.skill > SKILL_FAIR:
-        prompt = _("[CONTINUE?]")
-    else:
-        prompt = _("[PRESS ENTER TO CONTINUE]")
-
-    if game.options & OPTION_CURSES:
-        drawmaps(0)
-        setwnd(prompt_window)
-        prompt_window.clear()
-        prompt_window.addstr(prompt)
-        prompt_window.getstr()
-        prompt_window.clear()
-        prompt_window.refresh()
-        setwnd(message_window)
-    else:
-        global linecount
-        sys.stdout.write('\n')
-        proutn(prompt)
-        raw_input()
-        for j in range(rows):
-            sys.stdout.write('\n')
-        linecount = 0
-
-def skip(i):
-    "Skip i lines.  Pause game if this would cause a scrolling event."
-    for dummy in range(i):
-	if game.options & OPTION_CURSES:
-            (y, x) = curwnd.getyx()
-            (my, mx) = curwnd.getmaxyx()
-	    if curwnd == message_window and y >= my - 2:
-		pause_game()
-		clrscr()
-	    else:
-                try:
-                    curwnd.move(y+1, 0)
-                except curses.error:
-                    pass
-	else:
-            global linecount
-	    linecount += 1
-	    if rows and linecount >= rows:
-		pause_game()
-	    else:
-		sys.stdout.write('\n')
-
-def proutn(line):
-    "Utter a line with no following line feed."
-    if game.options & OPTION_CURSES:
-	curwnd.addstr(line)
-	curwnd.refresh()
-    else:
-	sys.stdout.write(line)
-        sys.stdout.flush()
-
-def prout(line):
-    proutn(line)
-    skip(1)
-
-def prouts(line):
-    "Emit slowly!" 
-    for c in line:
-        if not replayfp or replayfp.closed:	# Don't slow down replays
-            time.sleep(0.03)
-	proutn(c)
-	if game.options & OPTION_CURSES:
-	    curwnd.refresh()
-	else:
-	    sys.stdout.flush()
-    if not replayfp or replayfp.closed:
-        time.sleep(0.03)
-
-def cgetline():
-    "Get a line of input."
-    if game.options & OPTION_CURSES:
-	line = curwnd.getstr() + "\n"
-	curwnd.refresh()
-    else:
-	if replayfp and not replayfp.closed:
-            while True:
-                line = replayfp.readline()
-                proutn(line)
-                if line == '':
-                    prout("*** Replay finished")
-                    replayfp.close()
-                    break
-                elif line[0] != "#":
-                    break
-	else:
-	    line = raw_input() + "\n"
-    if logfp:
-	logfp.write(line)
-    return line
-
-def setwnd(wnd):
-    "Change windows -- OK for this to be a no-op in tty mode."
-    global curwnd
-    if game.options & OPTION_CURSES:
-        curwnd = wnd
-        curses.curs_set(wnd == fullscreen_window or wnd == message_window or wnd == prompt_window)
-
-def clreol():
-    "Clear to end of line -- can be a no-op in tty mode" 
-    if game.options & OPTION_CURSES:
-        curwnd.clrtoeol()
-        curwnd.refresh()
-
-def clrscr():
-    "Clear screen -- can be a no-op in tty mode."
-    global linecount
-    if game.options & OPTION_CURSES:
-       curwnd.clear()
-       curwnd.move(0, 0)
-       curwnd.refresh()
-    linecount = 0
-
-def textcolor(color=DEFAULT):
-    if game.options & OPTION_COLOR:
-	if color == DEFAULT: 
-	    curwnd.attrset(0);
-	elif color ==  BLACK: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK));
-	elif color ==  BLUE: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE));
-	elif color ==  GREEN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN));
-	elif color ==  CYAN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN));
-	elif color ==  RED: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_RED));
-	elif color ==  MAGENTA: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA));
-	elif color ==  BROWN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW));
-	elif color ==  LIGHTGRAY: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE));
-	elif color ==  DARKGRAY: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK) | curses.A_BOLD);
-	elif color ==  LIGHTBLUE: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE) | curses.A_BOLD);
-	elif color ==  LIGHTGREEN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN) | curses.A_BOLD);
-	elif color ==  LIGHTCYAN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN) | curses.A_BOLD);
-	elif color ==  LIGHTRED: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_RED) | curses.A_BOLD);
-	elif color ==  LIGHTMAGENTA: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA) | curses.A_BOLD);
-	elif color ==  YELLOW: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW) | curses.A_BOLD);
-	elif color ==  WHITE:
-	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE) | curses.A_BOLD);
-
-def highvideo():
-    if game.options & OPTION_COLOR:
-        curwnd.attron(curses.A_REVERSE)
-
-#
-# Things past this point have policy implications.
-# 
-
-def drawmaps(mode):
-    "Hook to be called after moving to redraw maps."
-    if game.options & OPTION_CURSES:
-	if mode == 1:
-	    sensor()
-        setwnd(srscan_window)
-        curwnd.move(0, 0)
-        srscan()
-	if mode != 2:
-	    setwnd(status_window)
-	    status_window.clear()
-	    status_window.move(0, 0)
-	    setwnd(report_window)
-	    report_window.clear()
-	    report_window.move(0, 0)
-	    status()
-	    setwnd(lrscan_window)
-	    lrscan_window.clear()
-	    lrscan_window.move(0, 0)
-	    lrscan(silent=False)
-
-def put_srscan_sym(w, sym):
-    "Emit symbol for short-range scan."
-    srscan_window.move(w.i+1, w.j*2+2)
-    srscan_window.addch(sym)
-    srscan_window.refresh()
-
-def boom(w):
-    "Enemy fall down, go boom."  
-    if game.options & OPTION_CURSES:
-	drawmaps(2)
-	setwnd(srscan_window)
-	srscan_window.attron(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.i][w.j])
-	#sound(500)
-	#time.sleep(1.0)
-	#nosound()
-	srscan_window.attroff(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.i][w.j])
-	curses.delay_output(500)
-	setwnd(message_window) 
-
-def warble():
-    "Sound and visual effects for teleportation."
-    if game.options & OPTION_CURSES:
-	drawmaps(2)
-	setwnd(message_window)
-	#sound(50)
-    prouts("     . . . . .     ")
-    if game.options & OPTION_CURSES:
-	#curses.delay_output(1000)
-	#nosound()
-        pass
-
-def tracktorpedo(origin, w, step, i, n, iquad):
-    "Torpedo-track animation." 
-    if not game.options & OPTION_CURSES:
-	if step == 1:
-	    if n != 1:
-		skip(1)
-		proutn(_("Track for torpedo number %d-  ") % (i+1))
-	    else:
-		skip(1)
-		proutn(_("Torpedo track- "))
-	elif step==4 or step==9: 
-	    skip(1)
-	proutn("%s   " % w)
-    else:
-	if not damaged(DSRSENS) or game.condition=="docked":
-	    if i != 0 and step == 1:
-		drawmaps(2)
-		time.sleep(0.4)
-	    if (iquad=='.') or (iquad==' '):
-		put_srscan_sym(w, '+')
-		#sound(step*10)
-		#time.sleep(0.1)
-		#nosound()
-		put_srscan_sym(w, iquad)
-	    else:
-		curwnd.attron(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-		#sound(500)
-		#time.sleep(1.0)
-		#nosound()
-		curwnd.attroff(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-	else:
-	    proutn("%s   " % w)
-
-def makechart():
-    "Display the current galaxy chart."
-    if game.options & OPTION_CURSES:
-	setwnd(message_window)
-	message_window.clear()
-    chart()
-    if game.options & OPTION_TTY:
-	skip(1)
-
-NSYM	= 14
-
-def prstat(txt, data):
-    proutn(txt)
-    if game.options & OPTION_CURSES:
-	skip(1)
-	setwnd(status_window)
-    else:
-        proutn(" " * (NSYM - len(txt)))
-    proutn(data)
-    skip(1)
-    if game.options & OPTION_CURSES:
-	setwnd(report_window)
-
-# Code from moving.c begins here
-
-def imove(course=None, noattack=False):
-    "Movement execution for warp, impulse, supernova, and tractor-beam events."
-    w = coord()
-
-    def newquadrant(noattack):
-        # Leaving quadrant -- allow final enemy attack 
-        # Don't do it if being pushed by Nova 
-        if len(game.enemies) != 0 and not noattack:
-            newcnd()
-            for enemy in game.enemies:
-                finald = (w - enemy.location).distance()
-                enemy.kavgd = 0.5 * (finald + enemy.kdist)
-            # Stas Sergeev added the condition
-            # that attacks only happen if Klingons
-            # are present and your skill is good.
-            if game.skill > SKILL_GOOD and game.klhere > 0 and not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-                attack(torps_ok=False)
-            if game.alldone:
-                return
-        # check for edge of galaxy 
-        kinks = 0
-        while True:
-            kink = False
-            if course.final.i < 0:
-                course.final.i = -course.final.i
-                kink = True
-            if course.final.j < 0:
-                course.final.j = -course.final.j
-                kink = True
-            if course.final.i >= GALSIZE*QUADSIZE:
-                course.final.i = (GALSIZE*QUADSIZE*2) - course.final.i
-                kink = True
-            if course.final.j >= GALSIZE*QUADSIZE:
-                course.final.j = (GALSIZE*QUADSIZE*2) - course.final.j
-                kink = True
-            if kink:
-                kinks += 1
-            else:
-                break
-        if kinks:
-            game.nkinks += 1
-            if game.nkinks == 3:
-                # Three strikes -- you're out! 
-                finish(FNEG3)
-                return
-            skip(1)
-            prout(_("YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER"))
-            prout(_("AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,"))
-            prout(_("YOU WILL BE DESTROYED."))
-        # Compute final position in new quadrant 
-        if trbeam: # Don't bother if we are to be beamed 
-            return
-        game.quadrant = course.final.quadrant()
-        game.sector = course.final.sector()
-        skip(1)
-        prout(_("Entering Quadrant %s.") % game.quadrant)
-        game.quad[game.sector.i][game.sector.j] = game.ship
-        newqad()
-        if game.skill>SKILL_NOVICE:
-            attack(torps_ok=False)  
-
-    def check_collision(h):
-        iquad = game.quad[h.i][h.j]
-        if iquad != '.':
-            # object encountered in flight path 
-            stopegy = 50.0*course.distance/game.optime
-            if iquad in ('T', 'K', 'C', 'S', 'R', '?'):
-                for enemy in game.enemies:
-                    if enemy.location == game.sector:
-                        break
-                collision(rammed=False, enemy=enemy)
-                return True
-            elif iquad == ' ':
-                skip(1)
-                prouts(_("***RED ALERT!  RED ALERT!"))
-                skip(1)
-                proutn("***" + crmshp())
-                proutn(_(" pulled into black hole at Sector %s") % h)
-                # Getting pulled into a black hole was certain
-                # death in Almy's original.  Stas Sergeev added a
-                # possibility that you'll get timewarped instead.
-                n=0
-                for m in range(NDEVICES):
-                    if game.damage[m]>0: 
-                        n += 1
-                probf=math.pow(1.4,(game.energy+game.shield)/5000.0-1.0)*math.pow(1.3,1.0/(n+1)-1.0)
-                if (game.options & OPTION_BLKHOLE) and withprob(1-probf): 
-                    timwrp()
-                else: 
-                    finish(FHOLE)
-                return True
-            else:
-                # something else 
-                skip(1)
-                proutn(crmshp())
-                if iquad == '#':
-                    prout(_(" encounters Tholian web at %s;") % h)
-                else:
-                    prout(_(" blocked by object at %s;") % h)
-                proutn(_("Emergency stop required "))
-                prout(_("%2d units of energy.") % int(stopegy))
-                game.energy -= stopegy
-                if game.energy <= 0:
-                    finish(FNRG)
-                return True
-        return False
-
-    trbeam = False
-    if game.inorbit:
-	prout(_("Helmsman Sulu- \"Leaving standard orbit.\""))
-	game.inorbit = False
-    # If tractor beam is to occur, don't move full distance 
-    if game.state.date+game.optime >= scheduled(FTBEAM):
-	trbeam = True
-	game.condition = "red"
-	course.distance = course.distance*(scheduled(FTBEAM)-game.state.date)/game.optime + 0.1
-	game.optime = scheduled(FTBEAM) - game.state.date + 1e-5
-    # Move out
-    game.quad[game.sector.i][game.sector.j] = '.'
-    for m in range(course.moves):
-        course.next()
-        w = course.sector()
-        if course.origin.quadrant() != course.location.quadrant():
-            newquadrant(noattack)
-            break
-        elif check_collision(w):
-            print "Collision detected"
-            break
-        else:
-            game.sector = w
-    # We're in destination quadrant -- compute new average enemy distances
-    game.quad[game.sector.i][game.sector.j] = game.ship
-    if game.enemies:
-        for enemy in game.enemies:
-            finald = (w-enemy.location).distance()
-            enemy.kavgd = 0.5 * (finald + enemy.kdist)
-            enemy.kdist = finald
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            attack(torps_ok=False)
-        for enemy in game.enemies:
-            enemy.kavgd = enemy.kdist
-    newcnd()
-    drawmaps(0)
-    setwnd(message_window)
-    return
-
-def dock(verbose):
-    "Dock our ship at a starbase."
-    scanner.chew()
-    if game.condition == "docked" and verbose:
-	prout(_("Already docked."))
-	return
-    if game.inorbit:
-	prout(_("You must first leave standard orbit."))
-	return
-    if not game.base.is_valid() or abs(game.sector.i-game.base.i) > 1 or abs(game.sector.j-game.base.j) > 1:
-	prout(crmshp() + _(" not adjacent to base."))
-	return
-    game.condition = "docked"
-    if "verbose":
-	prout(_("Docked."))
-    game.ididit = True
-    if game.energy < game.inenrg:
-	game.energy = game.inenrg
-    game.shield = game.inshld
-    game.torps = game.intorps
-    game.lsupres = game.inlsr
-    game.state.crew = FULLCREW
-    if not damaged(DRADIO) and \
-	((is_scheduled(FCDBAS) or game.isatb == 1) and not game.iseenit):
-	# get attack report from base 
-	prout(_("Lt. Uhura- \"Captain, an important message from the starbase:\""))
-	attackreport(False)
-	game.iseenit = True
-
-def cartesian(loc1=None, loc2=None):
-    if loc1 is None:
-        return game.quadrant * QUADSIZE + game.sector
-    elif loc2 is None:
-        return game.quadrant * QUADSIZE + loc1
-    else:
-        return loc1 * QUADSIZE + loc2
-
-def getcourse(isprobe):
-    "Get a course and distance from the user."
-    key = 0
-    dquad = copy.copy(game.quadrant)
-    navmode = "unspecified"
-    itemp = "curt"
-    dsect = coord()
-    iprompt = False
-    if game.landed and not isprobe:
-	prout(_("Dummy! You can't leave standard orbit until you"))
-	proutn(_("are back aboard the ship."))
-	scanner.chew()
-	raise TrekError
-    while navmode == "unspecified":
-	if damaged(DNAVSYS):
-	    if isprobe:
-		prout(_("Computer damaged; manual navigation only"))
-	    else:
-		prout(_("Computer damaged; manual movement only"))
-	    scanner.chew()
-	    navmode = "manual"
-	    key = "IHEOL"
-	    break
-        key = scanner.next()
-	if key == "IHEOL":
-	    proutn(_("Manual or automatic- "))
-	    iprompt = True
-	    scanner.chew()
-	elif key == "IHALPHA":
-            if scanner.sees("manual"):
-		navmode = "manual"
-		key = scanner.next()
-		break
-            elif scanner.sees("automatic"):
-		navmode = "automatic"
-		key = scanner.next()
-		break
-	    else:
-		huh()
-		scanner.chew()
-		raise TrekError
-	else: # numeric 
-	    if isprobe:
-		prout(_("(Manual navigation assumed.)"))
-	    else:
-		prout(_("(Manual movement assumed.)"))
-	    navmode = "manual"
-	    break
-    delta = coord()
-    if navmode == "automatic":
-	while key == "IHEOL":
-	    if isprobe:
-		proutn(_("Target quadrant or quadrant&sector- "))
-	    else:
-		proutn(_("Destination sector or quadrant&sector- "))
-	    scanner.chew()
-	    iprompt = True
-	    key = scanner.next()
-	if key != "IHREAL":
-	    huh()
-	    raise TrekError
-	xi = int(round(scanner.real))-1
-	key = scanner.next()
-	if key != "IHREAL":
-	    huh()
-	    raise TrekError
-	xj = int(round(scanner.real))-1
-	key = scanner.next()
-	if key == "IHREAL":
-	    # both quadrant and sector specified 
-	    xk = int(round(scanner.real))-1
-	    key = scanner.next()
-	    if key != "IHREAL":
-		huh()
-		raise TrekError
-	    xl = int(round(scanner.real))-1
-	    dquad.i = xi
-	    dquad.j = xj
-	    dsect.i = xk
-	    dsect.j = xl
-	else:
-            # only one pair of numbers was specified
-	    if isprobe:
-		# only quadrant specified -- go to center of dest quad 
-		dquad.i = xi
-		dquad.j = xj
-		dsect.j = dsect.i = 4	# preserves 1-origin behavior
-	    else:
-                # only sector specified
-		dsect.i = xi
-		dsect.j = xj
-	    itemp = "normal"
-	if not dquad.valid_quadrant() or not dsect.valid_sector():
-	    huh()
-	    raise TrekError
-	skip(1)
-	if not isprobe:
-	    if itemp > "curt":
-		if iprompt:
-		    prout(_("Helmsman Sulu- \"Course locked in for Sector %s.\"") % dsect)
-	    else:
-		prout(_("Ensign Chekov- \"Course laid in, Captain.\""))
-        # the actual deltas get computed here
-	delta.j = dquad.j-game.quadrant.j + (dsect.j-game.sector.j)/(QUADSIZE*1.0)
-	delta.i = game.quadrant.i-dquad.i + (game.sector.i-dsect.i)/(QUADSIZE*1.0)
-    else: # manual 
-	while key == "IHEOL":
-	    proutn(_("X and Y displacements- "))
-	    scanner.chew()
-	    iprompt = True
-	    key = scanner.next()
-	itemp = "verbose"
-	if key != "IHREAL":
-	    huh()
-	    raise TrekError
-	delta.j = scanner.real
-	key = scanner.next()
-	if key != "IHREAL":
-	    huh()
-	    raise TrekError
-	delta.i = scanner.real
-    # Check for zero movement 
-    if delta.i == 0 and delta.j == 0:
-	scanner.chew()
-	raise TrekError
-    if itemp == "verbose" and not isprobe:
-	skip(1)
-	prout(_("Helmsman Sulu- \"Aye, Sir.\""))
-    scanner.chew()
-    return course(bearing=delta.bearing(), distance=delta.distance())
-
-class course:
-    def __init__(self, bearing, distance, origin=None): 
-        self.distance = distance
-        self.bearing = bearing
-        if origin is None:
-            self.origin = cartesian(game.quadrant, game.sector)
-        else:
-            self.origin = origin
-        # The bearing() code we inherited from FORTRAN is actually computing
-        # clockface directions!
-        if self.bearing < 0.0:
-            self.bearing += 12.0
-        self.angle = ((15.0 - self.bearing) * 0.5235988)
-        if origin is None:
-            self.origin = cartesian(game.quadrant, game.sector)
-        else:
-            self.origin = cartesian(game.quadrant, origin)
-        self.increment = coord(-math.sin(self.angle), math.cos(self.angle))
-        bigger = max(abs(self.increment.i), abs(self.increment.j))
-        self.increment /= bigger
-        self.moves = int(round(10*self.distance*bigger))
-        self.reset()
-        self.final = (self.location + self.moves*self.increment).roundtogrid()
-    def reset(self):
-        self.location = self.origin
-        self.step = 0
-    def arrived(self):
-        return self.location.roundtogrid() == self.final
-    def next(self):
-        "Next step on course."
-        self.step += 1
-        self.nextlocation = self.location + self.increment
-        samequad = (self.location.quadrant() == self.nextlocation.quadrant())
-        self.location = self.nextlocation
-        return samequad
-    def quadrant(self):
-        return self.location.quadrant()
-    def sector(self):
-        return self.location.sector()
-    def power(self, warp):
-	return self.distance*(warp**3)*(game.shldup+1)
-    def time(self, warp):
-        return 10.0*self.distance/warp**2
-
-def impulse():
-    "Move under impulse power."
-    game.ididit = False
-    if damaged(DIMPULS):
-	scanner.chew()
-	skip(1)
-	prout(_("Engineer Scott- \"The impulse engines are damaged, Sir.\""))
-	return
-    if game.energy > 30.0:
-        try:
-            course = getcourse(isprobe=False)
-        except TrekError:
-	    return
-	power = 20.0 + 100.0*course.distance
-    else:
-	power = 30.0
-    if power >= game.energy:
-	# Insufficient power for trip 
-	skip(1)
-	prout(_("First Officer Spock- \"Captain, the impulse engines"))
-	prout(_("require 20.0 units to engage, plus 100.0 units per"))
-	if game.energy > 30:
-	    proutn(_("quadrant.  We can go, therefore, a maximum of %d") %
-                     int(0.01 * (game.energy-20.0)-0.05))
-	    prout(_(" quadrants.\""))
-	else:
-	    prout(_("quadrant.  They are, therefore, useless.\""))
-	scanner.chew()
-	return
-    # Make sure enough time is left for the trip 
-    game.optime = course.dist/0.095
-    if game.optime >= game.state.remtime:
-	prout(_("First Officer Spock- \"Captain, our speed under impulse"))
-	prout(_("power is only 0.95 sectors per stardate. Are you sure"))
-	proutn(_("we dare spend the time?\" "))
-	if ja() == False:
-	    return
-    # Activate impulse engines and pay the cost 
-    imove(course, noattack=False)
-    game.ididit = True
-    if game.alldone:
-	return
-    power = 20.0 + 100.0*course.dist
-    game.energy -= power
-    game.optime = course.dist/0.095
-    if game.energy <= 0:
-	finish(FNRG)
-    return
-
-def warp(course, involuntary):
-    "ove under warp drive."
-    blooey = False; twarp = False
-    if not involuntary: # Not WARPX entry 
-	game.ididit = False
-	if game.damage[DWARPEN] > 10.0:
-	    scanner.chew()
-	    skip(1)
-	    prout(_("Engineer Scott- \"The warp engines are damaged, Sir.\""))
-	    return
-	if damaged(DWARPEN) and game.warpfac > 4.0:
-	    scanner.chew()
-	    skip(1)
-	    prout(_("Engineer Scott- \"Sorry, Captain. Until this damage"))
-	    prout(_("  is repaired, I can only give you warp 4.\""))
-	    return
-       	# Read in course and distance
-        if course==None:
-            try:
-                course = getcourse(isprobe=False)
-            except TrekError:
-                return
-	# Make sure starship has enough energy for the trip
-        # Note: this formula is slightly different from the C version,
-        # and lets you skate a bit closer to the edge.
-	if course.power(game.warpfac) >= game.energy:
-	    # Insufficient power for trip 
-	    game.ididit = False
-	    skip(1)
-	    prout(_("Engineering to bridge--"))
-	    if not game.shldup or 0.5*power > game.energy:
-		iwarp = (game.energy/(course.dist+0.05)) ** 0.333333333
-		if iwarp <= 0:
-		    prout(_("We can't do it, Captain. We don't have enough energy."))
-		else:
-		    proutn(_("We don't have enough energy, but we could do it at warp %d") % iwarp)
-		    if game.shldup:
-			prout(",")
-			prout(_("if you'll lower the shields."))
-		    else:
-			prout(".")
-	    else:
-		prout(_("We haven't the energy to go that far with the shields up."))
-	    return				
-	# Make sure enough time is left for the trip 
-	game.optime = course.time(game.warpfac)
-	if game.optime >= 0.8*game.state.remtime:
-	    skip(1)
-	    prout(_("First Officer Spock- \"Captain, I compute that such"))
-	    proutn(_("  a trip would require approximately %2.0f") %
-		   (100.0*game.optime/game.state.remtime))
-	    prout(_(" percent of our"))
-	    proutn(_("  remaining time.  Are you sure this is wise?\" "))
-	    if ja() == False:
-		game.ididit = False
-		game.optime=0 
-		return
-    # Entry WARPX 
-    if game.warpfac > 6.0:
-	# Decide if engine damage will occur
-        # ESR: Seems wrong. Probability of damage goes *down* with distance? 
-	prob = course.distance*(6.0-game.warpfac)**2/66.666666666
-	if prob > randreal():
-	    blooey = True
-	    course.distance = randreal(course.distance)
-	# Decide if time warp will occur 
-	if 0.5*course.distance*math.pow(7.0,game.warpfac-10.0) > randreal():
-	    twarp = True
-	if idebug and game.warpfac==10 and not twarp:
-	    blooey = False
-	    proutn("=== Force time warp? ")
-	    if ja() == True:
-		twarp = True
-	if blooey or twarp:
-	    # If time warp or engine damage, check path 
-	    # If it is obstructed, don't do warp or damage 
-            for m in range(course.moves):
-                course.next()
-                w = course.sector()
-                if not w.valid_sector():
-                    break
-		if game.quad[w.i][w.j] != '.':
-		    blooey = False
-		    twarp = False
-            course.reset()
-    # Activate Warp Engines and pay the cost 
-    imove(course, noattack=False)
-    if game.alldone:
-	return
-    game.energy -= course.power(game.warpfac)
-    if game.energy <= 0:
-	finish(FNRG)
-    game.optime = course.time(game.warpfac)
-    if twarp:
-	timwrp()
-    if blooey:
-	game.damage[DWARPEN] = game.damfac * randreal(1.0, 4.0)
-	skip(1)
-	prout(_("Engineering to bridge--"))
-	prout(_("  Scott here.  The warp engines are damaged."))
-	prout(_("  We'll have to reduce speed to warp 4."))
-    game.ididit = True
-    return
-
-def setwarp():
-    "Change the warp factor."
-    while True:
-        key=scanner.next()
-        if key != "IHEOL":
-            break
-	scanner.chew()
-	proutn(_("Warp factor- "))
-    if key != "IHREAL":
-	huh()
-	return
-    if game.damage[DWARPEN] > 10.0:
-	prout(_("Warp engines inoperative."))
-	return
-    if damaged(DWARPEN) and scanner.real > 4.0:
-	prout(_("Engineer Scott- \"I'm doing my best, Captain,"))
-	prout(_("  but right now we can only go warp 4.\""))
-	return
-    if scanner.real > 10.0:
-	prout(_("Helmsman Sulu- \"Our top speed is warp 10, Captain.\""))
-	return
-    if scanner.real < 1.0:
-	prout(_("Helmsman Sulu- \"We can't go below warp 1, Captain.\""))
-	return
-    oldfac = game.warpfac
-    game.warpfac = scanner.real
-    if game.warpfac <= oldfac or game.warpfac <= 6.0:
-	prout(_("Helmsman Sulu- \"Warp factor %d, Captain.\"") %
-	       int(game.warpfac))
-	return
-    if game.warpfac < 8.00:
-	prout(_("Engineer Scott- \"Aye, but our maximum safe speed is warp 6.\""))
-	return
-    if game.warpfac == 10.0:
-	prout(_("Engineer Scott- \"Aye, Captain, we'll try it.\""))
-	return
-    prout(_("Engineer Scott- \"Aye, Captain, but our engines may not take it.\""))
-    return
-
-def atover(igrab):
-    "Cope with being tossed out of quadrant by supernova or yanked by beam."
-    scanner.chew()
-    # is captain on planet? 
-    if game.landed:
-	if damaged(DTRANSP):
-	    finish(FPNOVA)
-	    return
-	prout(_("Scotty rushes to the transporter controls."))
-	if game.shldup:
-	    prout(_("But with the shields up it's hopeless."))
-	    finish(FPNOVA)
-	prouts(_("His desperate attempt to rescue you . . ."))
-	if withprob(0.5):
-	    prout(_("fails."))
-	    finish(FPNOVA)
-	    return
-	prout(_("SUCCEEDS!"))
-	if game.imine:
-	    game.imine = False
-	    proutn(_("The crystals mined were "))
-	    if withprob(0.25):
-		prout(_("lost."))
-	    else:
-		prout(_("saved."))
-		game.icrystl = True
-    if igrab:
-	return
-    # Check to see if captain in shuttle craft 
-    if game.icraft:
-	finish(FSTRACTOR)
-    if game.alldone:
-	return
-    # Inform captain of attempt to reach safety 
-    skip(1)
-    while True:
-	if game.justin:
-	    prouts(_("***RED ALERT!  RED ALERT!"))
-	    skip(1)
-	    proutn(_("The %s has stopped in a quadrant containing") % crmshp())
-	    prouts(_("   a supernova."))
-	    skip(2)
-	prout(_("***Emergency automatic override attempts to hurl ")+crmshp())
-	prout(_("safely out of quadrant."))
-	if not damaged(DRADIO):
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
-	# Try to use warp engines 
-	if damaged(DWARPEN):
-	    skip(1)
-	    prout(_("Warp engines damaged."))
-	    finish(FSNOVAED)
-	    return
-	game.warpfac = randreal(6.0, 8.0)
-	prout(_("Warp factor set to %d") % int(game.warpfac))
-	power = 0.75*game.energy
-	dist = power/(game.warpfac*game.warpfac*game.warpfac*(game.shldup+1))
-	dist = max(dist, randreal(math.sqrt(2)))
-        bugout = course(bearing=randreal(12), distance=dist)	# How dumb!
-	game.optime = bugout.time(game.warpfac)
-	game.justin = False
-	game.inorbit = False
-	warp(bugout, involuntary=True)
-	if not game.justin:
-	    # This is bad news, we didn't leave quadrant. 
-	    if game.alldone:
-		return
-	    skip(1)
-	    prout(_("Insufficient energy to leave quadrant."))
-	    finish(FSNOVAED)
-	    return
-	# Repeat if another snova
-        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            break
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0: 
-	finish(FWON) # Snova killed remaining enemy. 
-
-def timwrp():
-    "Let's do the time warp again."
-    prout(_("***TIME WARP ENTERED."))
-    if game.state.snap and withprob(0.5):
-	# Go back in time 
-	prout(_("You are traveling backwards in time %d stardates.") %
-	      int(game.state.date-game.snapsht.date))
-	game.state = game.snapsht
-	game.state.snap = False
-	if len(game.state.kcmdr):
-	    schedule(FTBEAM, expran(game.intime/len(game.state.kcmdr)))
-	    schedule(FBATTAK, expran(0.3*game.intime))
-	schedule(FSNOVA, expran(0.5*game.intime))
-	# next snapshot will be sooner 
-	schedule(FSNAP, expran(0.25*game.state.remtime))
-				
-	if game.state.nscrem:
-	    schedule(FSCMOVE, 0.2777)	    
-	game.isatb = 0
-	unschedule(FCDBAS)
-	unschedule(FSCDBAS)
-	game.battle.invalidate()
-	# Make sure Galileo is consistant -- Snapshot may have been taken
-        # when on planet, which would give us two Galileos! 
-	gotit = False
-	for l in range(game.inplan):
-	    if game.state.planets[l].known == "shuttle_down":
-		gotit = True
-		if game.iscraft == "onship" and game.ship=='E':
-		    prout(_("Chekov-  \"Security reports the Galileo has disappeared, Sir!"))
-		    game.iscraft = "offship"
-	# Likewise, if in the original time the Galileo was abandoned, but
-	# was on ship earlier, it would have vanished -- let's restore it.
-	if game.iscraft == "offship" and not gotit and game.damage[DSHUTTL] >= 0.0:
-	    prout(_("Chekov-  \"Security reports the Galileo has reappeared in the dock!\""))
-	    game.iscraft = "onship"
-        # There used to be code to do the actual reconstrction here,
-        # but the starchart is now part of the snapshotted galaxy state.
-	prout(_("Spock has reconstructed a correct star chart from memory"))
-    else:
-	# Go forward in time 
-	game.optime = expran(0.5*game.intime)
-	prout(_("You are traveling forward in time %d stardates.") % int(game.optime))
-	# cheat to make sure no tractor beams occur during time warp 
-	postpone(FTBEAM, game.optime)
-	game.damage[DRADIO] += game.optime
-    newqad()
-    events()	# Stas Sergeev added this -- do pending events 
-
-def probe():
-    "Launch deep-space probe." 
-    # New code to launch a deep space probe 
-    if game.nprobes == 0:
-	scanner.chew()
-	skip(1)
-	if game.ship == 'E': 
-	    prout(_("Engineer Scott- \"We have no more deep space probes, Sir.\""))
-	else:
-	    prout(_("Ye Faerie Queene has no deep space probes."))
-	return
-    if damaged(DDSP):
-	scanner.chew()
-	skip(1)
-	prout(_("Engineer Scott- \"The probe launcher is damaged, Sir.\""))
-	return
-    if is_scheduled(FDSPROB):
-	scanner.chew()
-	skip(1)
-	if damaged(DRADIO) and game.condition != "docked":
-	    prout(_("Spock-  \"Records show the previous probe has not yet"))
-	    prout(_("   reached its destination.\""))
-	else:
-	    prout(_("Uhura- \"The previous probe is still reporting data, Sir.\""))
-	return
-    key = scanner.next()
-    if key == "IHEOL":
-        if game.nprobes == 1:
-            prout(_("1 probe left."))
-        else:
-            prout(_("%d probes left") % game.nprobes)
-	proutn(_("Are you sure you want to fire a probe? "))
-	if ja() == False:
-	    return
-    game.isarmed = False
-    if key == "IHALPHA" and scanner.token == "armed":
-	game.isarmed = True
-	key = scanner.next()
-    elif key == "IHEOL":
-	proutn(_("Arm NOVAMAX warhead? "))
-	game.isarmed = ja()
-    elif key == "IHREAL":		# first element of course
-        scanner.push(scanner.token)
-    try:
-        game.probe = getcourse(isprobe=True)
-    except TrekError:
-        return
-    game.nprobes -= 1
-    schedule(FDSPROB, 0.01) # Time to move one sector
-    prout(_("Ensign Chekov-  \"The deep space probe is launched, Captain.\""))
-    game.ididit = True
-    return
-
-def mayday():
-    "Yell for help from nearest starbase."
-    # There's more than one way to move in this game! 
-    scanner.chew()
-    # Test for conditions which prevent calling for help 
-    if game.condition == "docked":
-	prout(_("Lt. Uhura-  \"But Captain, we're already docked.\""))
-	return
-    if damaged(DRADIO):
-	prout(_("Subspace radio damaged."))
-	return
-    if not game.state.baseq:
-	prout(_("Lt. Uhura-  \"Captain, I'm not getting any response from Starbase.\""))
-	return
-    if game.landed:
-	prout(_("You must be aboard the %s.") % crmshp())
-	return
-    # OK -- call for help from nearest starbase 
-    game.nhelp += 1
-    if game.base.i!=0:
-	# There's one in this quadrant 
-	ddist = (game.base - game.sector).distance()
-    else:
-	ddist = FOREVER
-        for ibq in game.state.baseq:
-	    xdist = QUADSIZE * (ibq - game.quadrant).distance()
-	    if xdist < ddist:
-		ddist = xdist
-	# Since starbase not in quadrant, set up new quadrant 
-	game.quadrant = ibq
-	newqad()
-    # dematerialize starship 
-    game.quad[game.sector.i][game.sector.j]='.'
-    proutn(_("Starbase in Quadrant %s responds--%s dematerializes") \
-           % (game.quadrant, crmshp()))
-    game.sector.invalidate()
-    for m in range(1, 5+1):
-        w = game.base.scatter() 
-	if w.valid_sector() and game.quad[w.i][w.j]=='.':
-	    # found one -- finish up 
-            game.sector = w
-	    break
-    if not game.sector.is_valid():
-	prout(_("You have been lost in space..."))
-	finish(FMATERIALIZE)
-	return
-    # Give starbase three chances to rematerialize starship 
-    probf = math.pow((1.0 - math.pow(0.98,ddist)), 0.33333333)
-    for m in range(1, 3+1):
-	if m == 1: proutn(_("1st"))
-	elif m == 2: proutn(_("2nd"))
-	elif m == 3: proutn(_("3rd"))
-	proutn(_(" attempt to re-materialize ") + crmshp())
-	game.quad[ix][iy]=('-','o','O')[m-1]
-        textcolor(RED)
-	warble()
-	if randreal() > probf:
-	    break
-	prout(_("fails."))
-        textcolor(DEFAULT)
-	curses.delay_output(500)
-    if m > 3:
-	game.quad[ix][iy]='?'
-	game.alive = False
-	drawmaps(1)
-	setwnd(message_window)
-	finish(FMATERIALIZE)
-	return
-    game.quad[ix][iy]=game.ship
-    textcolor(GREEN);
-    prout(_("succeeds."))
-    textcolor(DEFAULT);
-    dock(False)
-    skip(1)
-    prout(_("Lt. Uhura-  \"Captain, we made it!\""))
-
-def abandon():
-    "Abandon ship."
-    scanner.chew()
-    if game.condition=="docked":
-	if game.ship!='E':
-	    prout(_("You cannot abandon Ye Faerie Queene."))
-	    return
-    else:
-	# Must take shuttle craft to exit 
-	if game.damage[DSHUTTL]==-1:
-	    prout(_("Ye Faerie Queene has no shuttle craft."))
-	    return
-	if game.damage[DSHUTTL]<0:
-	    prout(_("Shuttle craft now serving Big Macs."))
-	    return
-	if game.damage[DSHUTTL]>0:
-	    prout(_("Shuttle craft damaged."))
-	    return
-	if game.landed:
-	    prout(_("You must be aboard the ship."))
-	    return
-	if game.iscraft != "onship":
-	    prout(_("Shuttle craft not currently available."))
-	    return
-	# Emit abandon ship messages 
-	skip(1)
-	prouts(_("***ABANDON SHIP!  ABANDON SHIP!"))
-	skip(1)
-	prouts(_("***ALL HANDS ABANDON SHIP!"))
-	skip(2)
-	prout(_("Captain and crew escape in shuttle craft."))
-	if not game.state.baseq:
-	    # Oops! no place to go... 
-	    finish(FABANDN)
-	    return
-	q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
-	# Dispose of crew 
-	if not (game.options & OPTION_WORLDS) and not damaged(DTRANSP):
-	    prout(_("Remainder of ship's complement beam down"))
-	    prout(_("to nearest habitable planet."))
-	elif q.planet != None and not damaged(DTRANSP):
-	    prout(_("Remainder of ship's complement beam down to %s.") %
-		    q.planet)
-	else:
-	    prout(_("Entire crew of %d left to die in outer space.") %
-		    game.state.crew)
-	    game.casual += game.state.crew
-	    game.abandoned += game.state.crew
-	# If at least one base left, give 'em the Faerie Queene 
-	skip(1)
-	game.icrystl = False # crystals are lost 
-	game.nprobes = 0 # No probes 
-	prout(_("You are captured by Klingons and released to"))
-	prout(_("the Federation in a prisoner-of-war exchange."))
-	nb = randrange(len(game.state.baseq))
-	# Set up quadrant and position FQ adjacient to base 
-	if not game.quadrant == game.state.baseq[nb]:
-	    game.quadrant = game.state.baseq[nb]
-	    game.sector.i = game.sector.j = 5
-	    newqad()
-	while True:
-	    # position next to base by trial and error 
-	    game.quad[game.sector.i][game.sector.j] = '.'
-	    for l in range(QUADSIZE):
-		game.sector = game.base.scatter()
-		if game.sector.valid_sector() and \
-                       game.quad[game.sector.i][game.sector.j] == '.':
-                    break
-	    if l < QUADSIZE+1:
-		break # found a spot 
-	    game.sector.i=QUADSIZE/2
-	    game.sector.j=QUADSIZE/2
-	    newqad()
-    # Get new commission 
-    game.quad[game.sector.i][game.sector.j] = game.ship = 'F'
-    game.state.crew = FULLCREW
-    prout(_("Starfleet puts you in command of another ship,"))
-    prout(_("the Faerie Queene, which is antiquated but,"))
-    prout(_("still useable."))
-    if game.icrystl:
-	prout(_("The dilithium crystals have been moved."))
-    game.imine = False
-    game.iscraft = "offship" # Galileo disappears 
-    # Resupply ship 
-    game.condition="docked"
-    for l in range(NDEVICES): 
-	game.damage[l] = 0.0
-    game.damage[DSHUTTL] = -1
-    game.energy = game.inenrg = 3000.0
-    game.shield = game.inshld = 1250.0
-    game.torps = game.intorps = 6
-    game.lsupres=game.inlsr=3.0
-    game.shldup=False
-    game.warpfac=5.0
-    return
-
-# Code from planets.c begins here.
-
-def consumeTime():
-    "Abort a lengthy operation if an event interrupts it." 
-    game.ididit = True
-    events()
-    if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.justin: 
-	return True
-    return False
-
-def survey():
-    "Report on (uninhabited) planets in the galaxy."
-    iknow = False
-    skip(1)
-    scanner.chew()
-    prout(_("Spock-  \"Planet report follows, Captain.\""))
-    skip(1)
-    for i in range(game.inplan):
-	if game.state.planets[i].pclass == "destroyed":
-	    continue
-	if (game.state.planets[i].known != "unknown" \
-            and not game.state.planets[i].inhabited) \
-            or idebug:
-	    iknow = True
-	    if idebug and game.state.planets[i].known=="unknown":
-		proutn("(Unknown) ")
-	    proutn(_("Quadrant %s") % game.state.planets[i].quadrant)
-	    proutn(_("   class "))
-	    proutn(game.state.planets[i].pclass)
-	    proutn("   ")
-	    if game.state.planets[i].crystals != present:
-		proutn(_("no "))
-	    prout(_("dilithium crystals present."))
-	    if game.state.planets[i].known=="shuttle_down": 
-		prout(_("    Shuttle Craft Galileo on surface."))
-    if not iknow:
-	prout(_("No information available."))
-
-def orbit():
-    "Enter standard orbit." 
-    skip(1)
-    scanner.chew()
-    if game.inorbit:
-	prout(_("Already in standard orbit."))
-	return
-    if damaged(DWARPEN) and damaged(DIMPULS):
-	prout(_("Both warp and impulse engines damaged."))
-	return
-    if not game.plnet.is_valid():
-        prout("There is no planet in this sector.")
-        return
-    if abs(game.sector.i-game.plnet.i)>1 or abs(game.sector.j-game.plnet.j)>1:
-	prout(crmshp() + _(" not adjacent to planet."))
-	skip(1)
-	return
-    game.optime = randreal(0.02, 0.05)
-    prout(_("Helmsman Sulu-  \"Entering standard orbit, Sir.\""))
-    newcnd()
-    if consumeTime():
-	return
-    game.height = randreal(1400, 8600)
-    prout(_("Sulu-  \"Entered orbit at altitude %.2f kilometers.\"") % game.height)
-    game.inorbit = True
-    game.ididit = True
-
-def sensor():
-    "Examine planets in this quadrant."
-    if damaged(DSRSENS):
-	if game.options & OPTION_TTY:
-	    prout(_("Short range sensors damaged."))
-	return
-    if game.iplnet == None:
-	if game.options & OPTION_TTY:
-	    prout(_("Spock- \"No planet in this quadrant, Captain.\""))
-	return
-    if game.iplnet.known == "unknown":
-	prout(_("Spock-  \"Sensor scan for Quadrant %s-") % game.quadrant)
-	skip(1)
-	prout(_("         Planet at Sector %s is of class %s.") %
-	      (game.plnet, game.iplnet.pclass))
-	if game.iplnet.known=="shuttle_down": 
-	    prout(_("         Sensors show Galileo still on surface."))
-	proutn(_("         Readings indicate"))
-	if game.iplnet.crystals != "present":
-	    proutn(_(" no"))
-	prout(_(" dilithium crystals present.\""))
-	if game.iplnet.known == "unknown":
-	    game.iplnet.known = "known"
-    elif game.iplnet.inhabited:
-        prout(_("Spock-  \"The inhabited planet %s ") % game.iplnet.name)
-        prout(_("        is located at Sector %s, Captain.\"") % game.plnet)
-
-def beam():
-    "Use the transporter."
-    nrgneed = 0
-    scanner.chew()
-    skip(1)
-    if damaged(DTRANSP):
-	prout(_("Transporter damaged."))
-	if not damaged(DSHUTTL) and (game.iplnet.known=="shuttle_down" or game.iscraft == "onship"):
-	    skip(1)
-	    proutn(_("Spock-  \"May I suggest the shuttle craft, Sir?\" "))
-	    if ja() == True:
-		shuttle()
-	return
-    if not game.inorbit:
-	prout(crmshp() + _(" not in standard orbit."))
-	return
-    if game.shldup:
-	prout(_("Impossible to transport through shields."))
-	return
-    if game.iplnet.known=="unknown":
-	prout(_("Spock-  \"Captain, we have no information on this planet"))
-	prout(_("  and Starfleet Regulations clearly state that in this situation"))
-	prout(_("  you may not go down.\""))
-	return
-    if not game.landed and game.iplnet.crystals=="absent":
-	prout(_("Spock-  \"Captain, I fail to see the logic in"))
-	prout(_("  exploring a planet with no dilithium crystals."))
-	proutn(_("  Are you sure this is wise?\" "))
-	if ja() == False:
-	    scanner.chew()
-	    return
-    if not (game.options & OPTION_PLAIN):
-	nrgneed = 50 * game.skill + game.height / 100.0
-	if nrgneed > game.energy:
-    	    prout(_("Engineering to bridge--"))
-	    prout(_("  Captain, we don't have enough energy for transportation."))
-	    return
-	if not game.landed and nrgneed * 2 > game.energy:
-    	    prout(_("Engineering to bridge--"))
-	    prout(_("  Captain, we have enough energy only to transport you down to"))
-	    prout(_("  the planet, but there wouldn't be an energy for the trip back."))
-	    if game.iplnet.known == "shuttle_down":
-		prout(_("  Although the Galileo shuttle craft may still be on a surface."))
-	    proutn(_("  Are you sure this is wise?\" "))
-	    if ja() == False:
-		scanner.chew()
-		return
-    if game.landed:
-	# Coming from planet 
-	if game.iplnet.known=="shuttle_down":
-	    proutn(_("Spock-  \"Wouldn't you rather take the Galileo?\" "))
-	    if ja() == True:
-		scanner.chew()
-		return
-	    prout(_("Your crew hides the Galileo to prevent capture by aliens."))
-	prout(_("Landing party assembled, ready to beam up."))
-	skip(1)
-	prout(_("Kirk whips out communicator..."))
-	prouts(_("BEEP  BEEP  BEEP"))
-	skip(2)
-	prout(_("\"Kirk to enterprise-  Lock on coordinates...energize.\""))
-    else:
-	# Going to planet 
-	prout(_("Scotty-  \"Transporter room ready, Sir.\""))
-	skip(1)
-	prout(_("Kirk and landing party prepare to beam down to planet surface."))
-	skip(1)
-	prout(_("Kirk-  \"Energize.\""))
-    game.ididit = True
-    skip(1)
-    prouts("WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .")
-    skip(2)
-    if withprob(0.98):
-	prouts("BOOOIIIOOOIIOOOOIIIOIING . . .")
-	skip(2)
-	prout(_("Scotty-  \"Oh my God!  I've lost them.\""))
-	finish(FLOST)
-	return
-    prouts(".    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW")
-    game.landed = not game.landed
-    game.energy -= nrgneed
-    skip(2)
-    prout(_("Transport complete."))
-    if game.landed and game.iplnet.known=="shuttle_down":
-	prout(_("The shuttle craft Galileo is here!"))
-    if not game.landed and game.imine:
-	game.icrystl = True
-	game.cryprob = 0.05
-    game.imine = False
-    return
-
-def mine():
-    "Strip-mine a world for dilithium."
-    skip(1)
-    scanner.chew()
-    if not game.landed:
-	prout(_("Mining party not on planet."))
-	return
-    if game.iplnet.crystals == "mined":
-	prout(_("This planet has already been strip-mined for dilithium."))
-	return
-    elif game.iplnet.crystals == "absent":
-	prout(_("No dilithium crystals on this planet."))
-	return
-    if game.imine:
-	prout(_("You've already mined enough crystals for this trip."))
-	return
-    if game.icrystl and game.cryprob == 0.05:
-	prout(_("With all those fresh crystals aboard the ") + crmshp())
-	prout(_("there's no reason to mine more at this time."))
-	return
-    game.optime = randreal(0.1, 0.3)*(ord(game.iplnet.pclass)-ord("L"))
-    if consumeTime():
-	return
-    prout(_("Mining operation complete."))
-    game.iplnet.crystals = "mined"
-    game.imine = game.ididit = True
-
-def usecrystals():
-    "Use dilithium crystals."
-    game.ididit = False
-    skip(1)
-    scanner.chew()
-    if not game.icrystl:
-	prout(_("No dilithium crystals available."))
-	return
-    if game.energy >= 1000:
-	prout(_("Spock-  \"Captain, Starfleet Regulations prohibit such an operation"))
-	prout(_("  except when Condition Yellow exists."))
-	return
-    prout(_("Spock- \"Captain, I must warn you that loading"))
-    prout(_("  raw dilithium crystals into the ship's power"))
-    prout(_("  system may risk a severe explosion."))
-    proutn(_("  Are you sure this is wise?\" "))
-    if ja() == False:
-	scanner.chew()
-	return
-    skip(1)
-    prout(_("Engineering Officer Scott-  \"(GULP) Aye Sir."))
-    prout(_("  Mr. Spock and I will try it.\""))
-    skip(1)
-    prout(_("Spock-  \"Crystals in place, Sir."))
-    prout(_("  Ready to activate circuit.\""))
-    skip(1)
-    prouts(_("Scotty-  \"Keep your fingers crossed, Sir!\""))
-    skip(1)
-    if withprob(game.cryprob):
-	prouts(_("  \"Activating now! - - No good!  It's***"))
-	skip(2)
-	prouts(_("***RED ALERT!  RED A*L********************************"))
-	skip(1)
-	stars()
-	prouts(_("******************   KA-BOOM!!!!   *******************"))
-	skip(1)
-	kaboom()
-	return
-    game.energy += randreal(5000.0, 5500.0)
-    prouts(_("  \"Activating now! - - "))
-    prout(_("The instruments"))
-    prout(_("   are going crazy, but I think it's"))
-    prout(_("   going to work!!  Congratulations, Sir!\""))
-    game.cryprob *= 2.0
-    game.ididit = True
-
-def shuttle():
-    "Use shuttlecraft for planetary jaunt."
-    scanner.chew()
-    skip(1)
-    if damaged(DSHUTTL):
-	if game.damage[DSHUTTL] == -1.0:
-	    if game.inorbit and game.iplnet.known == "shuttle_down":
-		prout(_("Ye Faerie Queene has no shuttle craft bay to dock it at."))
-	    else:
-		prout(_("Ye Faerie Queene had no shuttle craft."))
-	elif game.damage[DSHUTTL] > 0:
-	    prout(_("The Galileo is damaged."))
-	else: # game.damage[DSHUTTL] < 0  
-	    prout(_("Shuttle craft is now serving Big Macs."))
-	return
-    if not game.inorbit:
-	prout(crmshp() + _(" not in standard orbit."))
-	return
-    if (game.iplnet.known != "shuttle_down") and game.iscraft != "onship":
-	prout(_("Shuttle craft not currently available."))
-	return
-    if not game.landed and game.iplnet.known=="shuttle_down":
-	prout(_("You will have to beam down to retrieve the shuttle craft."))
-	return
-    if game.shldup or game.condition == "docked":
-	prout(_("Shuttle craft cannot pass through shields."))
-	return
-    if game.iplnet.known=="unknown":
-	prout(_("Spock-  \"Captain, we have no information on this planet"))
-	prout(_("  and Starfleet Regulations clearly state that in this situation"))
-	prout(_("  you may not fly down.\""))
-	return
-    game.optime = 3.0e-5*game.height
-    if game.optime >= 0.8*game.state.remtime:
-	prout(_("First Officer Spock-  \"Captain, I compute that such"))
-	proutn(_("  a maneuver would require approximately %2d%% of our") % \
-	       int(100*game.optime/game.state.remtime))
-	prout(_("remaining time."))
-	proutn(_("Are you sure this is wise?\" "))
-	if ja() == False:
-	    game.optime = 0.0
-	    return
-    if game.landed:
-	# Kirk on planet 
-	if game.iscraft == "onship":
-	    # Galileo on ship! 
-	    if not damaged(DTRANSP):
-		proutn(_("Spock-  \"Would you rather use the transporter?\" "))
-		if ja() == True:
-		    beam()
-		    return
-		proutn(_("Shuttle crew"))
-	    else:
-		proutn(_("Rescue party"))
-	    prout(_(" boards Galileo and swoops toward planet surface."))
-	    game.iscraft = "offship"
-	    skip(1)
-	    if consumeTime():
-		return
-	    game.iplnet.known="shuttle_down"
-	    prout(_("Trip complete."))
-	    return
-	else:
-	    # Ready to go back to ship 
-	    prout(_("You and your mining party board the"))
-	    prout(_("shuttle craft for the trip back to the Enterprise."))
-	    skip(1)
-	    prouts(_("The short hop begins . . ."))
-	    skip(1)
-	    game.iplnet.known="known"
-	    game.icraft = True
-	    skip(1)
-	    game.landed = False
-	    if consumeTime():
-		return
-	    game.iscraft = "onship"
-	    game.icraft = False
-	    if game.imine:
-		game.icrystl = True
-		game.cryprob = 0.05
-	    game.imine = False
-	    prout(_("Trip complete."))
-	    return
-    else:
-	# Kirk on ship and so is Galileo 
-	prout(_("Mining party assembles in the hangar deck,"))
-	prout(_("ready to board the shuttle craft \"Galileo\"."))
-	skip(1)
-	prouts(_("The hangar doors open; the trip begins."))
-	skip(1)
-	game.icraft = True
-	game.iscraft = "offship"
-	if consumeTime():
-	    return
-	game.iplnet.known = "shuttle_down"
-	game.landed = True
-	game.icraft = False
-	prout(_("Trip complete."))
-	return
-
-def deathray():
-    "Use the big zapper."
-    game.ididit = False
-    skip(1)
-    scanner.chew()
-    if game.ship != 'E':
-	prout(_("Ye Faerie Queene has no death ray."))
-	return
-    if len(game.enemies)==0:
-	prout(_("Sulu-  \"But Sir, there are no enemies in this quadrant.\""))
-	return
-    if damaged(DDRAY):
-	prout(_("Death Ray is damaged."))
-	return
-    prout(_("Spock-  \"Captain, the 'Experimental Death Ray'"))
-    prout(_("  is highly unpredictible.  Considering the alternatives,"))
-    proutn(_("  are you sure this is wise?\" "))
-    if ja() == False:
-	return
-    prout(_("Spock-  \"Acknowledged.\""))
-    skip(1)
-    game.ididit = True
-    prouts(_("WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE"))
-    skip(1)
-    prout(_("Crew scrambles in emergency preparation."))
-    prout(_("Spock and Scotty ready the death ray and"))
-    prout(_("prepare to channel all ship's power to the device."))
-    skip(1)
-    prout(_("Spock-  \"Preparations complete, sir.\""))
-    prout(_("Kirk-  \"Engage!\""))
-    skip(1)
-    prouts(_("WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR"))
-    skip(1)
-    dprob = 0.30
-    if game.options & OPTION_PLAIN:
-	dprob = 0.5
-    r = randreal()
-    if r > dprob:
-	prouts(_("Sulu- \"Captain!  It's working!\""))
-	skip(2)
-	while len(game.enemies) > 0:
-	    deadkl(game.enemies[1].location, game.quad[game.enemies[1].location.i][game.enemies[1].location.j],game.enemies[1].location)
-	prout(_("Ensign Chekov-  \"Congratulations, Captain!\""))
-	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) == 0:
-	    finish(FWON)    
-	if (game.options & OPTION_PLAIN) == 0:
-	    prout(_("Spock-  \"Captain, I believe the `Experimental Death Ray'"))
-	    if withprob(0.05):
-		prout(_("   is still operational.\""))
-	    else:
-		prout(_("   has been rendered nonfunctional.\""))
-		game.damage[DDRAY] = 39.95
-	return
-    r = randreal()	# Pick failure method 
-    if r <= 0.30:
-	prouts(_("Sulu- \"Captain!  It's working!\""))
-	skip(1)
-	prouts(_("***RED ALERT!  RED ALERT!"))
-	skip(1)
-	prout(_("***MATTER-ANTIMATTER IMPLOSION IMMINENT!"))
-	skip(1)
-	prouts(_("***RED ALERT!  RED A*L********************************"))
-	skip(1)
-	stars()
-	prouts(_("******************   KA-BOOM!!!!   *******************"))
-	skip(1)
-	kaboom()
-	return
-    if r <= 0.55:
-	prouts(_("Sulu- \"Captain!  Yagabandaghangrapl, brachriigringlanbla!\""))
-	skip(1)
-	prout(_("Lt. Uhura-  \"Graaeek!  Graaeek!\""))
-	skip(1)
-	prout(_("Spock-  \"Fascinating!  . . . All humans aboard"))
-	prout(_("  have apparently been transformed into strange mutations."))
-	prout(_("  Vulcans do not seem to be affected."))
-	skip(1)
-	prout(_("Kirk-  \"Raauch!  Raauch!\""))
-	finish(FDRAY)
-	return
-    if r <= 0.75:
-	intj
-	prouts(_("Sulu- \"Captain!  It's   --WHAT?!?!\""))
-	skip(2)
-	proutn(_("Spock-  \"I believe the word is"))
-	prouts(_(" *ASTONISHING*"))
-	prout(_(" Mr. Sulu."))
-	for i in range(QUADSIZE):
-	    for j in range(QUADSIZE):
-		if game.quad[i][j] == '.':
-		    game.quad[i][j] = '?'
-	prout(_("  Captain, our quadrant is now infested with"))
-	prouts(_(" - - - - - -  *THINGS*."))
-	skip(1)
-	prout(_("  I have no logical explanation.\""))
-	return
-    prouts(_("Sulu- \"Captain!  The Death Ray is creating tribbles!\""))
-    skip(1)
-    prout(_("Scotty-  \"There are so many tribbles down here"))
-    prout(_("  in Engineering, we can't move for 'em, Captain.\""))
-    finish(FTRIBBLE)
-    return
-
-# Code from reports.c begins here
-
-def attackreport(curt):
-    "eport status of bases under attack."
-    if not curt:
-	if is_scheduled(FCDBAS):
-	    prout(_("Starbase in Quadrant %s is currently under Commander attack.") % game.battle)
-	    prout(_("It can hold out until Stardate %d.") % int(scheduled(FCDBAS)))
-	elif game.isatb == 1:
-	    prout(_("Starbase in Quadrant %s is under Super-commander attack.") % game.state.kscmdr)
-	    prout(_("It can hold out until Stardate %d.") % int(scheduled(FSCDBAS)))
-	else:
-	    prout(_("No Starbase is currently under attack."))
-    else:
-        if is_scheduled(FCDBAS):
-	    proutn(_("Base in %s attacked by C. Alive until %.1f") % (game.battle, scheduled(FCDBAS)))
-        if game.isatb:
-	    proutn(_("Base in %s attacked by S. Alive until %.1f") % (game.state.kscmdr, scheduled(FSCDBAS)))
-	clreol()
-
-def report():
-    # report on general game status 
-    scanner.chew()
-    s1 = "" and game.thawed and _("thawed ")
-    s2 = {1:"short", 2:"medium", 4:"long"}[game.length]
-    s3 = (None, _("novice"), _("fair"),
-          _("good"), _("expert"), _("emeritus"))[game.skill]
-    prout(_("You %s a %s%s %s game.") % ((_("were playing"), _("are playing"))[game.alldone], s1, s2, s3))
-    if game.skill>SKILL_GOOD and game.thawed and not game.alldone:
-	prout(_("No plaque is allowed."))
-    if game.tourn:
-	prout(_("This is tournament game %d.") % game.tourn)
-    prout(_("Your secret password is \"%s\"") % game.passwd)
-    proutn(_("%d of %d Klingons have been killed") % (((game.inkling + game.incom + game.inscom) - (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)), 
-	   (game.inkling + game.incom + game.inscom)))
-    if game.incom - len(game.state.kcmdr):
-	prout(_(", including %d Commander%s.") % (game.incom - len(game.state.kcmdr), (_("s"), "")[(game.incom - len(game.state.kcmdr))==1]))
-    elif game.inkling - game.state.remkl + (game.inscom - game.state.nscrem) > 0:
-	prout(_(", but no Commanders."))
-    else:
-	prout(".")
-    if game.skill > SKILL_FAIR:
-	prout(_("The Super Commander has %sbeen destroyed.") % ("", _("not "))[game.state.nscrem])
-    if len(game.state.baseq) != game.inbase:
-	proutn(_("There "))
-	if game.inbase-len(game.state.baseq)==1:
-	    proutn(_("has been 1 base"))
-	else:
-	    proutn(_("have been %d bases") % (game.inbase-len(game.state.baseq)))
-	prout(_(" destroyed, %d remaining.") % len(game.state.baseq))
-    else:
-	prout(_("There are %d bases.") % game.inbase)
-    if communicating() or game.iseenit:
-	# Don't report this if not seen and
-	# either the radio is dead or not at base!
-	attackreport(False)
-	game.iseenit = True
-    if game.casual: 
-	prout(_("%d casualt%s suffered so far.") % (game.casual, ("y", "ies")[game.casual!=1]))
-    if game.nhelp:
-	prout(_("There were %d call%s for help.") % (game.nhelp,  ("" , _("s"))[game.nhelp!=1]))
-    if game.ship == 'E':
-	proutn(_("You have "))
-	if game.nprobes:
-	    proutn("%d" % (game.nprobes))
-	else:
-	    proutn(_("no"))
-	proutn(_(" deep space probe"))
-	if game.nprobes!=1:
-	    proutn(_("s"))
-	prout(".")
-    if communicating() and is_scheduled(FDSPROB):
-	if game.isarmed: 
-	    proutn(_("An armed deep space probe is in "))
-	else:
-	    proutn(_("A deep space probe is in "))
-	prout("Quadrant %s." % game.probec)
-    if game.icrystl:
-	if game.cryprob <= .05:
-	    prout(_("Dilithium crystals aboard ship... not yet used."))
-	else:
-	    i=0
-	    ai = 0.05
-	    while game.cryprob > ai:
-		ai *= 2.0
-		i += 1
-	    prout(_("Dilithium crystals have been used %d time%s.") % \
-                  (i, (_("s"), "")[i==1]))
-    skip(1)
-	
-def lrscan(silent):
-    "Long-range sensor scan."
-    if damaged(DLRSENS):
-	# Now allow base's sensors if docked 
-	if game.condition != "docked":
-            if not silent:
-                prout(_("LONG-RANGE SENSORS DAMAGED."))
-	    return
-        if not silent:
-            prout(_("Starbase's long-range scan"))
-    elif not silent:
-	prout(_("Long-range scan"))
-    for x in range(game.quadrant.i-1, game.quadrant.i+2):
-        if not silent:
-            proutn(" ")
-        for y in range(game.quadrant.j-1, game.quadrant.j+2):
-	    if not coord(x, y).valid_quadrant():
-                if not silent:
-                    proutn("  -1")
-	    else:
-		if not damaged(DRADIO):
-		    game.state.galaxy[x][y].charted = True
-		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons
-		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase
-		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars
-		if not silent and game.state.galaxy[x][y].supernova: 
-		    proutn(" ***")
-		elif not silent:
-		    proutn(" %3d" % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
-	if not silent:
-	    prout(" ")
-
-def damagereport():
-    "Damage report."
-    jdam = False
-    scanner.chew()
-    for i in range(NDEVICES):
-	if damaged(i):
-	    if not jdam:
-		prout(_("\tDEVICE\t\t\t-REPAIR TIMES-"))
-		prout(_("\t\t\tIN FLIGHT\t\tDOCKED"))
-		jdam = True
-	    prout("  %-26s\t%8.2f\t\t%8.2f" % (device[i],
-                                               game.damage[i]+0.05,
-                                               DOCKFAC*game.damage[i]+0.005))
-    if not jdam:
-	prout(_("All devices functional."))
-
-def rechart():
-    "Update the chart in the Enterprise's computer from galaxy data."
-    game.lastchart = game.state.date
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    if game.state.galaxy[i][j].charted:
-		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons
-		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase
-		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars
-
-def chart():
-    "Display the star chart."
-    scanner.chew()
-    if (game.options & OPTION_AUTOSCAN):
-        lrscan(silent=True)
-    if not damaged(DRADIO):
-	rechart()
-    if game.lastchart < game.state.date and game.condition == "docked":
-	prout(_("Spock-  \"I revised the Star Chart from the starbase's records.\""))
-	rechart()
-    prout(_("       STAR CHART FOR THE KNOWN GALAXY"))
-    if game.state.date > game.lastchart:
-	prout(_("(Last surveillance update %d stardates ago).") % ((int)(game.state.date-game.lastchart)))
-    prout("      1    2    3    4    5    6    7    8")
-    for i in range(GALSIZE):
-	proutn("%d |" % (i+1))
-	for j in range(GALSIZE):
-	    if (game.options & OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
-		proutn("<")
-	    else:
-		proutn(" ")
-	    if game.state.galaxy[i][j].supernova:
-		show = "***"
-	    elif not game.state.galaxy[i][j].charted and game.state.galaxy[i][j].starbase:
-		show = ".1."
-	    elif game.state.galaxy[i][j].charted:
-		show = "%3d" % (game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars)
-	    else:
-		show = "..."
-	    proutn(show)
-	    if (game.options & OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
-		proutn(">")
-	    else:
-		proutn(" ")
-	proutn("  |")
-	if i<GALSIZE:
-	    skip(1)
-
-def sectscan(goodScan, i, j):
-    "Light up an individual dot in a sector."
-    if goodScan or (abs(i-game.sector.i)<= 1 and abs(j-game.sector.j) <= 1):
-        textcolor({"green":GREEN,
-                   "yellow":YELLOW,
-                   "red":RED,
-                   "docked":CYAN,
-                   "dead":BROWN}[game.condition]) 
-        if game.quad[i][j] != game.ship: 
-            highvideo();
-	proutn("%c " % game.quad[i][j])
-        textcolor(DEFAULT)
-    else:
-	proutn("- ")
-
-def status(req=0):
-    "Emit status report lines"
-    if not req or req == 1:
-	prstat(_("Stardate"), _("%.1f, Time Left %.2f") \
-               % (game.state.date, game.state.remtime))
-    if not req or req == 2:
-	if game.condition != "docked":
-	    newcnd()
-	prstat(_("Condition"), _("%s, %i DAMAGES") % \
-               (game.condition.upper(), sum(map(lambda x: x > 0, game.damage))))
-    if not req or req == 3:
-	prstat(_("Position"), "%s , %s" % (game.quadrant, game.sector))
-    if not req or req == 4:
-	if damaged(DLIFSUP):
-	    if game.condition == "docked":
-		s = _("DAMAGED, Base provides")
-	    else:
-		s = _("DAMAGED, reserves=%4.2f") % game.lsupres
-	else:
-	    s = _("ACTIVE")
-	prstat(_("Life Support"), s)
-    if not req or req == 5:
-	prstat(_("Warp Factor"), "%.1f" % game.warpfac)
-    if not req or req == 6:
-        extra = ""
-        if game.icrystl and (game.options & OPTION_SHOWME):
-            extra = _(" (have crystals)")
-	prstat(_("Energy"), "%.2f%s" % (game.energy, extra))
-    if not req or req == 7:
-	prstat(_("Torpedoes"), "%d" % (game.torps))
-    if not req or req == 8:
-	if damaged(DSHIELD):
-	    s = _("DAMAGED,")
-	elif game.shldup:
-	    s = _("UP,")
-	else:
-	    s = _("DOWN,")
-	data = _(" %d%% %.1f units") \
-               % (int((100.0*game.shield)/game.inshld + 0.5), game.shield)
-	prstat(_("Shields"), s+data)
-    if not req or req == 9:
-        prstat(_("Klingons Left"), "%d" \
-               % (game.state.remkl+len(game.state.kcmdr)+game.state.nscrem))
-    if not req or req == 10:
-	if game.options & OPTION_WORLDS:
-	    plnet = game.state.galaxy[game.quadrant.i][game.quadrant.j].planet
-	    if plnet and plnet.inhabited:
-		prstat(_("Major system"), plnet.name)
-	    else:
-		prout(_("Sector is uninhabited"))
-    elif not req or req == 11:
-	attackreport(not req)
-
-def request():
-    "Request specified status data, a historical relic from slow TTYs."
-    requests = ("da","co","po","ls","wa","en","to","sh","kl","sy", "ti")
-    while scanner.next() == "IHEOL":
-	proutn(_("Information desired? "))
-    scanner.chew()
-    if scanner.token in requests:
-        status(requests.index(scanner.token))
-    else:
-	prout(_("UNRECOGNIZED REQUEST. Legal requests are:"))
-	prout(("  date, condition, position, lsupport, warpfactor,"))
-	prout(("  energy, torpedoes, shields, klingons, system, time."))
-		
-def srscan():
-    "Short-range scan." 
-    goodScan=True
-    if damaged(DSRSENS):
-	# Allow base's sensors if docked 
-	if game.condition != "docked":
-	    prout(_("   S.R. SENSORS DAMAGED!"))
-	    goodScan=False
-	else:
-	    prout(_("  [Using Base's sensors]"))
-    else:
-	prout(_("     Short-range scan"))
-    if goodScan and not damaged(DRADIO): 
-	game.state.chart[game.quadrant.i][game.quadrant.j].klingons = game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons
-	game.state.chart[game.quadrant.i][game.quadrant.j].starbase = game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase
-	game.state.chart[game.quadrant.i][game.quadrant.j].stars = game.state.galaxy[game.quadrant.i][game.quadrant.j].stars
-	game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
-    prout("    1 2 3 4 5 6 7 8 9 10")
-    if game.condition != "docked":
-	newcnd()
-    for i in range(QUADSIZE):
-	proutn("%2d  " % (i+1))
-	for j in range(QUADSIZE):
-	    sectscan(goodScan, i, j)
-	skip(1)
-		
-def eta():
-    "Use computer to get estimated time of arrival for a warp jump."
-    w1 = coord(); w2 = coord()
-    prompt = False
-    if damaged(DCOMPTR):
-	prout(_("COMPUTER DAMAGED, USE A POCKET CALCULATOR."))
-	skip(1)
-	return
-    if scanner.next() != "IHREAL":
-	prompt = True
-	scanner.chew()
-	proutn(_("Destination quadrant and/or sector? "))
-	if scanner.next()!="IHREAL":
-	    huh()
-	    return
-    w1.j = int(scanner.real-0.5)
-    if scanner.next() != "IHREAL":
-	huh()
-	return
-    w1.i = int(scanner.real-0.5)
-    if scanner.next() == "IHREAL":
-	w2.j = int(scanner.real-0.5)
-	if scanner.next() != "IHREAL":
-	    huh()
-	    return
-	w2.i = int(scanner.real-0.5)
-    else:
-	if game.quadrant.j>w1.i:
-	    w2.i = 0
-	else:
-	    w2.i=QUADSIZE-1
-	if game.quadrant.i>w1.j:
-	    w2.j = 0
-	else:
-	    w2.j=QUADSIZE-1
-    if not w1.valid_quadrant() or not w2.valid_sector():
-	huh()
-	return
-    dist = math.sqrt((w1.j-game.quadrant.j+(w2.j-game.sector.j)/(QUADSIZE*1.0))**2+
-		(w1.i-game.quadrant.i+(w2.i-game.sector.i)/(QUADSIZE*1.0))**2)
-    wfl = False
-    if prompt:
-	prout(_("Answer \"no\" if you don't know the value:"))
-    while True:
-	scanner.chew()
-	proutn(_("Time or arrival date? "))
-	if scanner.next()=="IHREAL":
-	    ttime = scanner.real
-	    if ttime > game.state.date:
-		ttime -= game.state.date # Actually a star date
-            twarp=(math.floor(math.sqrt((10.0*dist)/ttime)*10.0)+1.0)/10.0
-            if ttime <= 1e-10 or twarp > 10:
-		prout(_("We'll never make it, sir."))
-		scanner.chew()
-		return
-	    if twarp < 1.0:
-		twarp = 1.0
-	    break
-	scanner.chew()
-	proutn(_("Warp factor? "))
-	if scanner.next()== "IHREAL":
-	    wfl = True
-	    twarp = scanner.real
-	    if twarp<1.0 or twarp > 10.0:
-		huh()
-		return
-	    break
-	prout(_("Captain, certainly you can give me one of these."))
-    while True:
-	scanner.chew()
-	ttime = (10.0*dist)/twarp**2
-	tpower = dist*twarp*twarp*twarp*(game.shldup+1)
-	if tpower >= game.energy:
-	    prout(_("Insufficient energy, sir."))
-	    if not game.shldup or tpower > game.energy*2.0:
-		if not wfl:
-		    return
-		proutn(_("New warp factor to try? "))
-		if scanner.next() == "IHREAL":
-		    wfl = True
-		    twarp = scanner.real
-		    if twarp<1.0 or twarp > 10.0:
-			huh()
-			return
-		    continue
-		else:
-		    scanner.chew()
-		    skip(1)
-		    return
-	    prout(_("But if you lower your shields,"))
-	    proutn(_("remaining"))
-	    tpower /= 2
-	else:
-	    proutn(_("Remaining"))
-	prout(_(" energy will be %.2f.") % (game.energy-tpower))
-	if wfl:
-	    prout(_("And we will arrive at stardate %.2f.") % (game.state.date+ttime))
-	elif twarp==1.0:
-	    prout(_("Any warp speed is adequate."))
-	else:
-	    prout(_("Minimum warp needed is %.2f,") % (twarp))
-	    prout(_("and we will arrive at stardate %.2f.") % (game.state.date+ttime))
-	if game.state.remtime < ttime:
-	    prout(_("Unfortunately, the Federation will be destroyed by then."))
-	if twarp > 6.0:
-	    prout(_("You'll be taking risks at that speed, Captain"))
-	if (game.isatb==1 and game.state.kscmdr == w1 and \
-	     scheduled(FSCDBAS)< ttime+game.state.date) or \
-	    (scheduled(FCDBAS)<ttime+game.state.date and game.battle == w1):
-	    prout(_("The starbase there will be destroyed by then."))
-	proutn(_("New warp factor to try? "))
-	if scanner.next() == "IHREAL":
-	    wfl = True
-	    twarp = scanner.real
-	    if twarp<1.0 or twarp > 10.0:
-		huh()
-		return
-	else:
-	    scanner.chew()
-	    skip(1)
-	    return
-
-# Code from setup.c begins here
-
-def prelim():
-    "Issue a historically correct banner."
-    skip(2)
-    prout(_("-SUPER- STAR TREK"))
-    skip(1)
-# From the FORTRAN original
-#    prout(_("Latest update-21 Sept 78"))
-#    skip(1)
-
-def freeze(boss):
-    "Save game."
-    if boss:
-	scanner.push("emsave.trk")
-    key = scanner.next()
-    if key == "IHEOL":
-        proutn(_("File name: "))
-        key = scanner.next()
-    if key != "IHALPHA":
-        huh()
-        return
-    scanner.chew()
-    if '.' not in scanner.token:
-        scanner.token += ".trk"
-    try:
-        fp = open(scanner.token, "wb")
-    except IOError:
-	prout(_("Can't freeze game as file %s") % scanner.token)
-	return
-    cPickle.dump(game, fp)
-    fp.close()
-
-def thaw():
-    "Retrieve saved game." 
-    game.passwd[0] = '\0'
-    key = scanner.next()
-    if key == "IHEOL":
-	proutn(_("File name: "))
-	key = scanner.next()
-    if key != "IHALPHA":
-	huh()
-	return True
-    scanner.chew()
-    if '.' not in scanner.token:
-        scanner.token += ".trk"
-    try:
-        fp = open(scanner.token, "rb")
-    except IOError:
-	prout(_("Can't thaw game in %s") % scanner.token)
-	return
-    game = cPickle.load(fp)
-    fp.close()
-    return False
-
-# I used <http://www.memory-alpha.org> to find planets
-# with references in ST:TOS.  Eath and the Alpha Centauri
-# Colony have been omitted.
-# 
-# Some planets marked Class G and P here will be displayed as class M
-# because of the way planets are generated. This is a known bug.
-systnames = (
-    # Federation Worlds 
-    _("Andoria (Fesoan)"),	# several episodes 
-    _("Tellar Prime (Miracht)"),	# TOS: "Journey to Babel" 
-    _("Vulcan (T'Khasi)"),	# many episodes 
-    _("Medusa"),		# TOS: "Is There in Truth No Beauty?" 
-    _("Argelius II (Nelphia)"),	# TOS: "Wolf in the Fold" ("IV" in BSD) 
-    _("Ardana"),		# TOS: "The Cloud Minders" 
-    _("Catulla (Cendo-Prae)"),	# TOS: "The Way to Eden" 
-    _("Gideon"),		# TOS: "The Mark of Gideon" 
-    _("Aldebaran III"),		# TOS: "The Deadly Years" 
-    _("Alpha Majoris I"),	# TOS: "Wolf in the Fold" 
-    _("Altair IV"),		# TOS: "Amok Time 
-    _("Ariannus"),		# TOS: "Let That Be Your Last Battlefield" 
-    _("Benecia"),		# TOS: "The Conscience of the King" 
-    _("Beta Niobe I (Sarpeidon)"),	# TOS: "All Our Yesterdays" 
-    _("Alpha Carinae II"),	# TOS: "The Ultimate Computer" 
-    _("Capella IV (Kohath)"),	# TOS: "Friday's Child" (Class G) 
-    _("Daran V"),		# TOS: "For the World is Hollow and I Have Touched the Sky" 
-    _("Deneb II"),		# TOS: "Wolf in the Fold" ("IV" in BSD) 
-    _("Eminiar VII"),		# TOS: "A Taste of Armageddon" 
-    _("Gamma Canaris IV"),	# TOS: "Metamorphosis" 
-    _("Gamma Tranguli VI (Vaalel)"),	# TOS: "The Apple" 
-    _("Ingraham B"),		# TOS: "Operation: Annihilate" 
-    _("Janus IV"),		# TOS: "The Devil in the Dark" 
-    _("Makus III"),		# TOS: "The Galileo Seven" 
-    _("Marcos XII"),		# TOS: "And the Children Shall Lead", 
-    _("Omega IV"),		# TOS: "The Omega Glory" 
-    _("Regulus V"),		# TOS: "Amok Time 
-    _("Deneva"),		# TOS: "Operation -- Annihilate!" 
-    # Worlds from BSD Trek 
-    _("Rigel II"),		# TOS: "Shore Leave" ("III" in BSD) 
-    _("Beta III"),		# TOS: "The Return of the Archons" 
-    _("Triacus"),		# TOS: "And the Children Shall Lead", 
-    _("Exo III"),		# TOS: "What Are Little Girls Made Of?" (Class P) 
-#	# Others 
-#    _("Hansen's Planet"),	# TOS: "The Galileo Seven" 
-#    _("Taurus IV"),		# TOS: "The Galileo Seven" (class G) 
-#    _("Antos IV (Doraphane)"),	# TOS: "Whom Gods Destroy", "Who Mourns for Adonais?" 
-#    _("Izar"),			# TOS: "Whom Gods Destroy" 
-#    _("Tiburon"),		# TOS: "The Way to Eden" 
-#    _("Merak II"),		# TOS: "The Cloud Minders" 
-#    _("Coridan (Desotriana)"),	# TOS: "Journey to Babel" 
-#    _("Iotia"),		# TOS: "A Piece of the Action" 
-)
-
-device = (
-	_("S. R. Sensors"), \
-	_("L. R. Sensors"), \
-	_("Phasers"), \
-	_("Photon Tubes"), \
-	_("Life Support"), \
-	_("Warp Engines"), \
-	_("Impulse Engines"), \
-	_("Shields"), \
-	_("Subspace Radio"), \
-	_("Shuttle Craft"), \
-	_("Computer"), \
-	_("Navigation System"), \
-	_("Transporter"), \
-	_("Shield Control"), \
-	_("Death Ray"), \
-	_("D. S. Probe"), \
-)
-
-def setup():
-    "Prepare to play, set up cosmos."
-    w = coord()
-    #  Decide how many of everything
-    if choose():
-	return # frozen game
-    # Prepare the Enterprise
-    game.alldone = game.gamewon = game.shldchg = game.shldup = False
-    game.ship = 'E'
-    game.state.crew = FULLCREW
-    game.energy = game.inenrg = 5000.0
-    game.shield = game.inshld = 2500.0
-    game.inlsr = 4.0
-    game.lsupres = 4.0
-    game.quadrant = randplace(GALSIZE)
-    game.sector = randplace(QUADSIZE)
-    game.torps = game.intorps = 10
-    game.nprobes = randrange(2, 5)
-    game.warpfac = 5.0
-    for i in range(NDEVICES): 
-	game.damage[i] = 0.0
-    # Set up assorted game parameters
-    game.battle = coord()
-    game.state.date = game.indate = 100.0 * randreal(20, 51)
-    game.nkinks = game.nhelp = game.casual = game.abandoned = 0
-    game.iscate = game.resting = game.imine = game.icrystl = game.icraft = False
-    game.isatb = game.state.nplankl = 0
-    game.state.starkl = game.state.basekl = 0
-    game.iscraft = "onship"
-    game.landed = False
-    game.alive = True
-    # Starchart is functional but we've never seen it
-    game.lastchart = FOREVER
-    # Put stars in the galaxy
-    game.instar = 0
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    k = randrange(1, QUADSIZE**2/10+1)
-	    game.instar += k
-	    game.state.galaxy[i][j].stars = k
-    # Locate star bases in galaxy
-    for i in range(game.inbase):
-        while True:
-            while True:
-                w = randplace(GALSIZE)
-                if not game.state.galaxy[w.i][w.j].starbase:
-                    break
-	    contflag = False
-            # C version: for (j = i-1; j > 0; j--)
-            # so it did them in the opposite order.
-            for j in range(1, i):
-		# Improved placement algorithm to spread out bases
-		distq = (w - game.state.baseq[j]).distance()
-		if distq < 6.0*(BASEMAX+1-game.inbase) and withprob(0.75):
-		    contflag = True
-		    if idebug:
-			prout("=== Abandoning base #%d at %s" % (i, w))
-		    break
-		elif distq < 6.0 * (BASEMAX+1-game.inbase):
-		    if idebug:
-			prout("=== Saving base #%d, close to #%d" % (i, j))
-            if not contflag:
-                break
-	game.state.baseq.append(w)
-	game.state.galaxy[w.i][w.j].starbase = game.state.chart[w.i][w.j].starbase = True
-    # Position ordinary Klingon Battle Cruisers
-    krem = game.inkling
-    klumper = 0.25*game.skill*(9.0-game.length)+1.0
-    if klumper > MAXKLQUAD: 
-	klumper = MAXKLQUAD
-    while True:
-	r = randreal()
-	klump = (1.0 - r*r)*klumper
-	if klump > krem:
-	    klump = krem
-	krem -= klump
-        while True:
-            w = randplace(GALSIZE)
-            if not game.state.galaxy[w.i][w.j].supernova and \
-               game.state.galaxy[w.i][w.j].klingons + klump <= MAXKLQUAD:
-                break
-	game.state.galaxy[w.i][w.j].klingons += int(klump)
-        if krem <= 0:
-            break
-    # Position Klingon Commander Ships
-    for i in range(game.incom):
-        while True:
-            w = randplace(GALSIZE)
-            if not welcoming(w) or w in game.state.kcmdr:
-                continue
-            if (game.state.galaxy[w.i][w.j].klingons or withprob(0.25)):
-                break
-	game.state.galaxy[w.i][w.j].klingons += 1
-	game.state.kcmdr.append(w)
-    # Locate planets in galaxy
-    for i in range(game.inplan):
-        while True:
-            w = randplace(GALSIZE) 
-            if game.state.galaxy[w.i][w.j].planet == None:
-                break
-        new = planet()
-	new.quadrant = w
-        new.crystals = "absent"
-	if (game.options & OPTION_WORLDS) and i < NINHAB:
-	    new.pclass = "M"	# All inhabited planets are class M
-	    new.crystals = "absent"
-	    new.known = "known"
-            new.name = systnames[i]
-	    new.inhabited = True
-	else:
-	    new.pclass = ("M", "N", "O")[randrange(0, 3)]
-            if withprob(0.33):
-                new.crystals = "present"
-	    new.known = "unknown"
-	    new.inhabited = False
-	game.state.galaxy[w.i][w.j].planet = new
-        game.state.planets.append(new)
-    # Locate Romulans
-    for i in range(game.state.nromrem):
-	w = randplace(GALSIZE)
-	game.state.galaxy[w.i][w.j].romulans += 1
-    # Place the Super-Commander if needed
-    if game.state.nscrem > 0:
-        while True:
-            w = randplace(GALSIZE)
-            if welcoming(w):
-                break
-	game.state.kscmdr = w
-	game.state.galaxy[w.i][w.j].klingons += 1
-    # Initialize times for extraneous events
-    schedule(FSNOVA, expran(0.5 * game.intime))
-    schedule(FTBEAM, expran(1.5 * (game.intime / len(game.state.kcmdr))))
-    schedule(FSNAP, randreal(1.0, 2.0)) # Force an early snapshot
-    schedule(FBATTAK, expran(0.3*game.intime))
-    unschedule(FCDBAS)
-    if game.state.nscrem:
-	schedule(FSCMOVE, 0.2777)
-    else:
-	unschedule(FSCMOVE)
-    unschedule(FSCDBAS)
-    unschedule(FDSPROB)
-    if (game.options & OPTION_WORLDS) and game.skill >= SKILL_GOOD:
-	schedule(FDISTR, expran(1.0 + game.intime))
-    else:
-	unschedule(FDISTR)
-    unschedule(FENSLV)
-    unschedule(FREPRO)
-    # Place thing (in tournament game, we don't want one!)
-    # New in SST2K: never place the Thing near a starbase.
-    # This makes sense and avoids a special case in the old code.
-    global thing
-    if game.tourn is None:
-        while True:
-            thing = randplace(GALSIZE)
-            if thing not in game.state.baseq:
-                break
-    skip(2)
-    game.state.snap = False
-    if game.skill == SKILL_NOVICE:
-	prout(_("It is stardate %d. The Federation is being attacked by") % int(game.state.date))
-	prout(_("a deadly Klingon invasion force. As captain of the United"))
-	prout(_("Starship U.S.S. Enterprise, it is your mission to seek out"))
-	prout(_("and destroy this invasion force of %d battle cruisers.") % ((game.inkling + game.incom + game.inscom)))
-	prout(_("You have an initial allotment of %d stardates to complete") % int(game.intime))
-	prout(_("your mission.  As you proceed you may be given more time."))
-	skip(1)
-	prout(_("You will have %d supporting starbases.") % (game.inbase))
-	proutn(_("Starbase locations-  "))
-    else:
-	prout(_("Stardate %d.") % int(game.state.date))
-	skip(1)
-	prout(_("%d Klingons.") % (game.inkling + game.incom + game.inscom))
-	prout(_("An unknown number of Romulans."))
-	if game.state.nscrem:
-	    prout(_("And one (GULP) Super-Commander."))
-	prout(_("%d stardates.") % int(game.intime))
-	proutn(_("%d starbases in ") % game.inbase)
-    for i in range(game.inbase):
-	proutn(`game.state.baseq[i]`)
-	proutn("  ")
-    skip(2)
-    proutn(_("The Enterprise is currently in Quadrant %s") % game.quadrant)
-    proutn(_(" Sector %s") % game.sector)
-    skip(2)
-    prout(_("Good Luck!"))
-    if game.state.nscrem:
-	prout(_("  YOU'LL NEED IT."))
-    waitfor()
-    newqad()
-    if len(game.enemies) - (thing == game.quadrant) - (game.tholian != None):
-	game.shldup = True
-    if game.neutz:	# bad luck to start in a Romulan Neutral Zone
-	attack(torps_ok=False)
-
-def choose():
-    "Choose your game type."
-    while True:
-	game.tourn = game.length = 0
-	game.thawed = False
-	game.skill = SKILL_NONE
-	if not scanner.inqueue: # Can start with command line options 
-	    proutn(_("Would you like a regular, tournament, or saved game? "))
-        scanner.next()
-        if scanner.sees("tournament"):
-	    while scanner.next() == "IHEOL":
-		proutn(_("Type in tournament number-"))
-	    if scanner.real == 0:
-		scanner.chew()
-		continue # We don't want a blank entry
-	    game.tourn = int(round(scanner.real))
-	    random.seed(scanner.real)
-            if logfp:
-                logfp.write("# random.seed(%d)\n" % scanner.real)
-	    break
-        if scanner.sees("saved") or scanner.sees("frozen"):
-	    if thaw():
-		continue
-	    scanner.chew()
-	    if game.passwd == None:
-		continue
-	    if not game.alldone:
-		game.thawed = True # No plaque if not finished
-	    report()
-	    waitfor()
-	    return True
-        if scanner.sees("regular"):
-	    break
-	proutn(_("What is \"%s\"?") % scanner.token)
-	scanner.chew()
-    while game.length==0 or game.skill==SKILL_NONE:
-	if scanner.next() == "IHALPHA":
-            if scanner.sees("short"):
-		game.length = 1
-	    elif scanner.sees("medium"):
-		game.length = 2
-	    elif scanner.sees("long"):
-		game.length = 4
-	    elif scanner.sees("novice"):
-		game.skill = SKILL_NOVICE
-	    elif scanner.sees("fair"):
-		game.skill = SKILL_FAIR
-	    elif scanner.sees("good"):
-		game.skill = SKILL_GOOD
-	    elif scanner.sees("expert"):
-		game.skill = SKILL_EXPERT
-	    elif scanner.sees("emeritus"):
-		game.skill = SKILL_EMERITUS
-	    else:
-		proutn(_("What is \""))
-		proutn(scanner.token)
-		prout("\"?")
-	else:
-	    scanner.chew()
-	    if game.length==0:
-		proutn(_("Would you like a Short, Medium, or Long game? "))
-	    elif game.skill == SKILL_NONE:
-		proutn(_("Are you a Novice, Fair, Good, Expert, or Emeritus player? "))
-    # Choose game options -- added by ESR for SST2K
-    if scanner.next() != "IHALPHA":
-	scanner.chew()
-	proutn(_("Choose your game style (plain, almy, fancy or just press enter): "))
-	scanner.next()
-    if scanner.sees("plain"):
-	# Approximates the UT FORTRAN version.
-	game.options &=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_PLAIN
-    elif scanner.sees("almy"):
-	# Approximates Tom Almy's version.
-	game.options &=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_ALMY
-    elif scanner.sees("fancy") or scanner.sees("\n"):
-	pass
-    elif len(scanner.token):
-        proutn(_("What is \"%s\"?") % scanner.token)
-    game.options &=~ OPTION_COLOR
-    setpassword()
-    if game.passwd == "debug":
-	idebug = True
-	prout("=== Debug mode enabled.")
-    # Use parameters to generate initial values of things
-    game.damfac = 0.5 * game.skill
-    game.inbase = randrange(BASEMIN, BASEMAX+1)
-    game.inplan = 0
-    if game.options & OPTION_PLANETS:
-	game.inplan += randrange(MAXUNINHAB/2, MAXUNINHAB+1)
-    if game.options & OPTION_WORLDS:
-	game.inplan += int(NINHAB)
-    game.state.nromrem = game.inrom = randrange(2 *game.skill)
-    game.state.nscrem = game.inscom = (game.skill > SKILL_FAIR)
-    game.state.remtime = 7.0 * game.length
-    game.intime = game.state.remtime
-    game.state.remkl = game.inkling = 2.0*game.intime*((game.skill+1 - 2*randreal())*game.skill*0.1+.15)
-    game.incom = min(MINCMDR, int(game.skill + 0.0625*game.inkling*randreal()))
-    game.state.remres = (game.inkling+4*game.incom)*game.intime
-    game.inresor = game.state.remres
-    if game.inkling > 50:
-        game.state.inbase += 1
-    return False
-
-def dropin(iquad=None):
-    "Drop a feature on a random dot in the current quadrant."
-    while True:
-        w = randplace(QUADSIZE)
-        if game.quad[w.i][w.j] == '.':
-            break
-    if iquad is not None:
-        game.quad[w.i][w.j] = iquad
-    return w
-
-def newcnd():
-    "Update our alert status."
-    game.condition = "green"
-    if game.energy < 1000.0:
-	game.condition = "yellow"
-    if game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons or game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans:
-	game.condition = "red"
-    if not game.alive:
-	game.condition="dead"
-
-def newkling():
-    "Drop new Klingon into current quadrant."
-    return enemy('K', loc=dropin(), power=randreal(300,450)+25.0*game.skill)
-
-def newqad():
-    "Set up a new state of quadrant, for when we enter or re-enter it."
-    game.justin = True
-    game.iplnet = None
-    game.neutz = game.inorbit = game.landed = False
-    game.ientesc = game.iseenit = False
-    # Create a blank quadrant
-    game.quad = fill2d(QUADSIZE, lambda i, j: '.')
-    if game.iscate:
-	# Attempt to escape Super-commander, so tbeam back!
-	game.iscate = False
-	game.ientesc = True
-    q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
-    # cope with supernova
-    if q.supernova:
-	return
-    game.klhere = q.klingons
-    game.irhere = q.romulans
-    # Position Starship
-    game.quad[game.sector.i][game.sector.j] = game.ship
-    game.enemies = []
-    if q.klingons:
-	# Position ordinary Klingons
-	for i in range(game.klhere):
-            newkling()
-	# If we need a commander, promote a Klingon
-        for cmdr in game.state.kcmdr:
-	    if cmdr == game.quadrant:
-                e = game.enemies[game.klhere-1]
-                game.quad[e.location.i][e.location.j] = 'C'
-                e.power = randreal(950,1350) + 50.0*game.skill
-		break	
-	# If we need a super-commander, promote a Klingon
-	if game.quadrant == game.state.kscmdr:
-            e = game.enemies[0]
-	    game.quad[e.location.i][e.location.j] = 'S'
-	    e.power = randreal(1175.0,  1575.0) + 125.0*game.skill
-	    game.iscate = (game.state.remkl > 1)
-    # Put in Romulans if needed
-    for i in range(q.romulans):
-        enemy('R', loc=dropin(), power=randreal(400.0,850.0)+50.0*game.skill)
-    # If quadrant needs a starbase, put it in
-    if q.starbase:
-	game.base = dropin('B')
-    # If quadrant needs a planet, put it in
-    if q.planet:
-	game.iplnet = q.planet
-	if not q.planet.inhabited:
-	    game.plnet = dropin('P')
-	else:
-	    game.plnet = dropin('@')
-    # Check for condition
-    newcnd()
-    # Check for RNZ
-    if game.irhere > 0 and game.klhere == 0:
-	game.neutz = True
-	if not damaged(DRADIO):
-	    skip(1)
-	    prout(_("LT. Uhura- \"Captain, an urgent message."))
-	    prout(_("  I'll put it on audio.\"  CLICK"))
-	    skip(1)
-	    prout(_("INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE."))
-	    prout(_("LEAVE AT ONCE, OR YOU WILL BE DESTROYED!"))
-    # Put in THING if needed
-    if thing == game.quadrant:
-        enemy(type='?', loc=dropin(),
-                  power=randreal(6000,6500.0)+250.0*game.skill)
-        if not damaged(DSRSENS):
-            skip(1)
-            prout(_("Mr. Spock- \"Captain, this is most unusual."))
-            prout(_("    Please examine your short-range scan.\""))
-    # Decide if quadrant needs a Tholian; lighten up if skill is low 
-    if game.options & OPTION_THOLIAN:
-	if (game.skill < SKILL_GOOD and withprob(0.02)) or \
-	    (game.skill == SKILL_GOOD and withprob(0.05)) or \
-            (game.skill > SKILL_GOOD and withprob(0.08)):
-            w = coord()
-            while True:
-		w.i = withprob(0.5) * (QUADSIZE-1)
-		w.j = withprob(0.5) * (QUADSIZE-1)
-                if game.quad[w.i][w.j] == '.':
-                    break
-            game.tholian = enemy(type='T', loc=w,
-                                 power=randrange(100, 500) + 25.0*game.skill)
-	    # Reserve unoccupied corners 
-	    if game.quad[0][0]=='.':
-		game.quad[0][0] = 'X'
-	    if game.quad[0][QUADSIZE-1]=='.':
-		game.quad[0][QUADSIZE-1] = 'X'
-	    if game.quad[QUADSIZE-1][0]=='.':
-		game.quad[QUADSIZE-1][0] = 'X'
-	    if game.quad[QUADSIZE-1][QUADSIZE-1]=='.':
-		game.quad[QUADSIZE-1][QUADSIZE-1] = 'X'
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # And finally the stars
-    for i in range(q.stars):
-	dropin('*')
-    # Put in a few black holes
-    for i in range(1, 3+1):
-	if withprob(0.5): 
-	    dropin(' ')
-    # Take out X's in corners if Tholian present
-    if game.tholian:
-	if game.quad[0][0]=='X':
-	    game.quad[0][0] = '.'
-	if game.quad[0][QUADSIZE-1]=='X':
-	    game.quad[0][QUADSIZE-1] = '.'
-	if game.quad[QUADSIZE-1][0]=='X':
-	    game.quad[QUADSIZE-1][0] = '.'
-	if game.quad[QUADSIZE-1][QUADSIZE-1]=='X':
-	    game.quad[QUADSIZE-1][QUADSIZE-1] = '.'
-
-def setpassword():
-    "Set the self-destruct password."
-    if game.options & OPTION_PLAIN:
-	while True:
-	    scanner.chew()
-	    proutn(_("Please type in a secret password- "))
-	    scanner.next()
-	    game.passwd = scanner.token
-	    if game.passwd != None:
-		break
-    else:
-        game.passwd = ""
-        for i in range(3):
-	    game.passwd += chr(ord('a')+randrange(26))
-
-# Code from sst.c begins here
-
-commands = {
-    "SRSCAN":   	OPTION_TTY,
-    "STATUS":   	OPTION_TTY,
-    "REQUEST":  	OPTION_TTY,
-    "LRSCAN":   	OPTION_TTY,
-    "PHASERS":  	0,
-    "TORPEDO":  	0,
-    "PHOTONS":  	0,
-    "MOVE":     	0,
-    "SHIELDS":   	0,
-    "DOCK":     	0,
-    "DAMAGES":   	0,
-    "CHART":    	0,
-    "IMPULSE":  	0,
-    "REST":     	0,
-    "WARP":     	0,
-    "SCORE":    	0,
-    "SENSORS":  	OPTION_PLANETS,
-    "ORBIT":		OPTION_PLANETS,
-    "TRANSPORT":	OPTION_PLANETS,
-    "MINE":		OPTION_PLANETS,
-    "CRYSTALS":  	OPTION_PLANETS,
-    "SHUTTLE":  	OPTION_PLANETS,
-    "PLANETS":  	OPTION_PLANETS,
-    "REPORT":   	0,
-    "COMPUTER": 	0,
-    "COMMANDS": 	0,
-    "EMEXIT":		0,
-    "PROBE":		OPTION_PROBE,
-    "SAVE":		0,
-    "FREEZE":		0,	# Synonym for SAVE
-    "ABANDON":  	0,
-    "DESTRUCT": 	0,
-    "DEATHRAY": 	0,
-    "DEBUG":    	0,
-    "MAYDAY":		0,
-    "SOS":		0,	# Synonym for MAYDAY
-    "CALL":		0,	# Synonym for MAYDAY
-    "QUIT":		0,
-    "HELP":		0,
-}
-
-def listCommands():
-    "Generate a list of legal commands."
-    prout(_("LEGAL COMMANDS ARE:"))
-    emitted = 0
-    for key in commands:
-	if not commands[key] or (commands[key] & game.options):
-            proutn("%-12s " % key)
-            emitted += 1
-            if emitted % 5 == 4:
-                skip(1)
-    skip(1)
-
-def helpme():
-    "Browse on-line help."
-    key = scanner.next()
-    while True:
-	if key == "IHEOL":
-	    setwnd(prompt_window)
-	    proutn(_("Help on what command? "))
-	    key = scanner.next()
-	setwnd(message_window)
-	if key == "IHEOL":
-	    return
-        if scanner.token.upper() in commands or scanner.token == "ABBREV":
-	    break
-	skip(1)
-	listCommands()
-	key = "IHEOL"
-	scanner.chew()
-	skip(1)
-    cmd = scanner.token.upper()
-    for directory in docpath:
-        try:
-            fp = open(os.path.join(directory, "sst.doc"), "r")
-            break
-        except IOError:
-            pass
-    else:
-        prout(_("Spock-  \"Captain, that information is missing from the"))
-        prout(_("   computer. You need to find sst.doc and put it somewhere"))
-        proutn(_("   in these directories: %s") % ":".join(docpath))
-        prout(".\"")
-        # This used to continue: "You need to find SST.DOC and put 
-        # it in the current directory."
-        return
-    while True:
-        linebuf = fp.readline()
-	if linebuf == '':
-	    prout(_("Spock- \"Captain, there is no information on that command.\""))
-	    fp.close()
-	    return
-	if linebuf[0] == '%' and linebuf[1] == '%' and linebuf[2] == ' ':
-            linebuf = linebuf[3:].strip()
-            if cmd.upper() == linebuf:
-		break
-    skip(1)
-    prout(_("Spock- \"Captain, I've found the following information:\""))
-    skip(1)
-    while True:
-        linebuf = fp.readline()
-        if "******" in linebuf:
-	    break
-	proutn(linebuf)
-    fp.close()
-
-def makemoves():
-    "Command-interpretation loop."
-    clrscr()
-    setwnd(message_window)
-    while True: 	# command loop 
-	drawmaps(1)
-        while True:	# get a command 
-	    hitme = False
-	    game.optime = game.justin = False
-	    scanner.chew()
-	    setwnd(prompt_window)
-	    clrscr()
-	    proutn("COMMAND> ")
-	    if scanner.next() == "IHEOL":
-		if game.options & OPTION_CURSES:
-		    makechart()
-		continue
-            elif scanner.token == "":
-                continue
-	    game.ididit = False
-	    clrscr()
-	    setwnd(message_window)
-	    clrscr()
-            candidates = filter(lambda x: x.startswith(scanner.token.upper()),
-                                commands)
-            if len(candidates) == 1:
-                cmd = candidates[0]
-                break
-            elif candidates and not (game.options & OPTION_PLAIN):
-                prout("Commands with prefix '%s': %s" % (scanner.token, " ".join(candidates)))
-            else:
-                listCommands()
-                continue
-	if cmd == "SRSCAN":		# srscan
-	    srscan()
-	elif cmd == "STATUS":		# status
-	    status()
-	elif cmd == "REQUEST":		# status request 
-	    request()
-	elif cmd == "LRSCAN":		# long range scan
-	    lrscan(silent=False)
-	elif cmd == "PHASERS":		# phasers
-	    phasers()
-	    if game.ididit:
-		hitme = True
-	elif cmd in ("TORPEDO", "PHOTONS"):	# photon torpedos
-	    torps()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "MOVE":		# move under warp
-	    warp(course=None, involuntary=False)
-	elif cmd == "SHIELDS":		# shields
-	    doshield(shraise=False)
-	    if game.ididit:
-		hitme = True
-		game.shldchg = False
-	elif cmd == "DOCK":		# dock at starbase
-	    dock(True)
-	    if game.ididit:
-		attack(torps_ok=False)		
-	elif cmd == "DAMAGES":		# damage reports
-	    damagereport()
-	elif cmd == "CHART":		# chart
-	    makechart()
-	elif cmd == "IMPULSE":		# impulse
-	    impulse()
-	elif cmd == "REST":		# rest
-	    wait()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "WARP":		# warp
-	    setwarp()
-	elif cmd == "SCORE":		# score
-	    score()
-	elif cmd == "SENSORS":		# sensors
-	    sensor()
-	elif cmd == "ORBIT":		# orbit
-	    orbit()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "TRANSPORT":		# transport "beam"
-	    beam()
-	elif cmd == "MINE":		# mine
-	    mine()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "CRYSTALS":		# crystals
-	    usecrystals()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "SHUTTLE":		# shuttle
-	    shuttle()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "PLANETS":		# Planet list
-	    survey()
-	elif cmd == "REPORT":		# Game Report 
-	    report()
-	elif cmd == "COMPUTER":		# use COMPUTER!
-	    eta()
-	elif cmd == "COMMANDS":
-	    listCommands()
-	elif cmd == "EMEXIT":		# Emergency exit
-	    clrscr()			# Hide screen
-	    freeze(True)		# forced save
-	    raise SysExit,1			# And quick exit
-	elif cmd == "PROBE":
-	    probe()			# Launch probe
-	    if game.ididit:
-		hitme = True
-	elif cmd == "ABANDON":		# Abandon Ship
-	    abandon()
-	elif cmd == "DESTRUCT":		# Self Destruct
-	    selfdestruct()
-	elif cmd == "SAVE":		# Save Game
-	    freeze(False)
-	    clrscr()
-	    if game.skill > SKILL_GOOD:
-		prout(_("WARNING--Saved games produce no plaques!"))
-	elif cmd == "DEATHRAY":		# Try a desparation measure
-	    deathray()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "DEBUGCMD":		# What do we want for debug???
-	    debugme()
-	elif cmd == "MAYDAY":		# Call for help
-	    mayday()
-	    if game.ididit:
-		hitme = True
-	elif cmd == "QUIT":
-	    game.alldone = True		# quit the game
-	elif cmd == "HELP":
-	    helpme()			# get help
-	while True:
-	    if game.alldone:
-		break		# Game has ended
-	    if game.optime != 0.0:
-		events()
-		if game.alldone:
-		    break	# Events did us in
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		atover(False)
-		continue
-	    if hitme and not game.justin:
-		attack(torps_ok=True)
-		if game.alldone:
-		    break
-		if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		    atover(False)
-		    hitme = True
-		    continue
-	    break
-	if game.alldone:
-	    break
-    if idebug:
-	prout("=== Ending")
-
-def cramen(type):
-    "Emit the name of an enemy or feature." 
-    if   type == 'R': s = _("Romulan")
-    elif type == 'K': s = _("Klingon")
-    elif type == 'C': s = _("Commander")
-    elif type == 'S': s = _("Super-commander")
-    elif type == '*': s = _("Star")
-    elif type == 'P': s = _("Planet")
-    elif type == 'B': s = _("Starbase")
-    elif type == ' ': s = _("Black hole")
-    elif type == 'T': s = _("Tholian")
-    elif type == '#': s = _("Tholian web")
-    elif type == '?': s = _("Stranger")
-    elif type == '@': s = _("Inhabited World")
-    else: s = "Unknown??"
-    return s
-
-def crmena(stars, enemy, loctype, w):
-    "Emit the name of an enemy and his location."
-    buf = ""
-    if stars:
-	buf += "***"
-    buf += cramen(enemy) + _(" at ")
-    if loctype == "quadrant":
-	buf += _("Quadrant ")
-    elif loctype == "sector":
-	buf += _("Sector ")
-    return buf + `w`
-
-def crmshp():
-    "Emit our ship name." 
-    return{'E':_("Enterprise"),'F':_("Faerie Queene")}.get(game.ship,"Ship???")
-
-def stars():
-    "Emit a line of stars" 
-    prouts("******************************************************")
-    skip(1)
-
-def expran(avrage):
-    return -avrage*math.log(1e-7 + randreal())
-
-def randplace(size):
-    "Choose a random location."
-    w = coord()
-    w.i = randrange(size) 
-    w.j = randrange(size)
-    return w
-
-class sstscanner:
-    def __init__(self):
-        self.type = None
-        self.token = None
-        self.real = 0.0
-        self.inqueue = []
-    def next(self):
-        # Get a token from the user
-        self.real = 0.0
-        self.token = ''
-        # Fill the token quue if nothing here
-        while not self.inqueue:
-            line = cgetline()
-            if curwnd==prompt_window:
-                clrscr()
-                setwnd(message_window)
-                clrscr()
-            if line == '':
-                return None
-            if not line:
-                continue
-            else:
-                self.inqueue = line.lstrip().split() + ["\n"]
-        # From here on in it's all looking at the queue
-        self.token = self.inqueue.pop(0)
-        if self.token == "\n":
-            self.type = "IHEOL"
-            return "IHEOL"
-        try:
-            self.real = float(self.token)
-            self.type = "IHREAL"
-            return "IHREAL"
-        except ValueError:
-            pass
-        # Treat as alpha
-        self.token = self.token.lower()
-        self.type = "IHALPHA"
-        self.real = None
-        return "IHALPHA"
-    def append(self, tok):
-        self.inqueue.append(tok)
-    def push(self, tok):
-        self.inqueue.insert(0, tok)
-    def waiting(self):
-        return self.inqueue
-    def chew(self):
-        # Demand input for next scan
-        self.inqueue = []
-        self.real = self.token = None
-    def sees(self, s):
-        # compares s to item and returns true if it matches to the length of s
-        return s.startswith(self.token)
-    def int(self):
-        # Round token value to nearest integer
-        return int(round(scanner.real))
-    def getcoord(self):
-        s = coord()
-        scanner.next()
-    	if scanner.type != "IHREAL":
-	    huh()
-	    return None
-	s.i = scanner.int()-1
-        scanner.next()
-	if scanner.type != "IHREAL":
-	    huh()
-	    return None
-	s.j = scanner.int()-1
-        return s
-    def __repr__(str):
-        return "<sstcanner: token=%s, type=%s, queue=%s>" % (scanner.token, scanner.type, scanner.inqueue)
-
-def ja():
-    "Yes-or-no confirmation."
-    scanner.chew()
-    while True:
-	scanner.next()
-	if scanner.token == 'y':
-	    return True
-	if scanner.token == 'n':
-	    return False
-	scanner.chew()
-	proutn(_("Please answer with \"y\" or \"n\": "))
-
-def huh():
-    "Complain about unparseable input."
-    scanner.chew()
-    skip(1)
-    prout(_("Beg your pardon, Captain?"))
-
-def debugme():
-    "Access to the internals for debugging."
-    proutn("Reset levels? ")
-    if ja() == True:
-	if game.energy < game.inenrg:
-	    game.energy = game.inenrg
-	game.shield = game.inshld
-	game.torps = game.intorps
-	game.lsupres = game.inlsr
-    proutn("Reset damage? ")
-    if ja() == True:
-	for i in range(NDEVICES): 
-	    if game.damage[i] > 0.0: 
-		game.damage[i] = 0.0
-    proutn("Toggle debug flag? ")
-    if ja() == True:
-	idebug = not idebug
-	if idebug:
-	    prout("Debug output ON")	    
-	else:
-	    prout("Debug output OFF")
-    proutn("Cause selective damage? ")
-    if ja() == True:
-	for i in range(NDEVICES):
-	    proutn("Kill %s?" % device[i])
-	    scanner.chew()
-	    key = scanner.next()
-            if key == "IHALPHA" and scanner.sees("y"):
-		game.damage[i] = 10.0
-    proutn("Examine/change events? ")
-    if ja() == True:
-	ev = event()
-	w = coord()
-        legends = {
-            FSNOVA:  "Supernova       ",
-            FTBEAM:  "T Beam          ",
-            FSNAP:   "Snapshot        ",
-            FBATTAK: "Base Attack     ",
-            FCDBAS:  "Base Destroy    ",
-            FSCMOVE: "SC Move         ",
-            FSCDBAS: "SC Base Destroy ",
-            FDSPROB: "Probe Move      ",
-            FDISTR:  "Distress Call   ",
-            FENSLV:  "Enslavement     ",
-            FREPRO:  "Klingon Build   ",
-        }
-	for i in range(1, NEVENTS):
-            proutn(legends[i])
-	    if is_scheduled(i):
-		proutn("%.2f" % (scheduled(i)-game.state.date))
-		if i == FENSLV or i == FREPRO:
-		    ev = findevent(i)
-		    proutn(" in %s" % ev.quadrant)
-	    else:
-		proutn("never")
-	    proutn("? ")
-	    scanner.chew()
-	    key = scanner.next()
-	    if key == 'n':
-		unschedule(i)
-		scanner.chew()
-	    elif key == "IHREAL":
-		ev = schedule(i, scanner.real)
-		if i == FENSLV or i == FREPRO:
-		    scanner.chew()
-		    proutn("In quadrant- ")
-		    key = scanner.next()
-		    # "IHEOL" says to leave coordinates as they are 
-		    if key != "IHEOL":
-			if key != "IHREAL":
-			    prout("Event %d canceled, no x coordinate." % (i))
-			    unschedule(i)
-			    continue
-			w.i = int(round(scanner.real))
-			key = scanner.next()
-			if key != "IHREAL":
-			    prout("Event %d canceled, no y coordinate." % (i))
-			    unschedule(i)
-			    continue
-			w.j = int(round(scanner.real))
-			ev.quadrant = w
-	scanner.chew()
-    proutn("Induce supernova here? ")
-    if ja() == True:
-	game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova = True
-	atover(True)
-
-if __name__ == '__main__':
-    import getopt, socket
-    try:
-        global line, thing, game, idebug
-        game = None
-        thing = coord()
-        thing.angry = False
-        game = gamestate()
-        idebug = 0
-        game.options = OPTION_ALL &~ (OPTION_IOMODES | OPTION_PLAIN | OPTION_ALMY)
-        if os.getenv("TERM"):
-            game.options |= OPTION_CURSES
-        else:
-            game.options |= OPTION_TTY
-        seed = int(time.time())
-        (options, arguments) = getopt.getopt(sys.argv[1:], "r:s:tx")
-        for (switch, val) in options:
-            if switch == '-r':
-                try:
-                    replayfp = open(val, "r")
-                except IOError:
-                    sys.stderr.write("sst: can't open replay file %s\n" % val)
-                    raise SystemExit, 1
-                try:
-                    line = replayfp.readline().strip()
-                    (leader, key, seed) = line.split()
-                    seed = eval(seed)
-                    sys.stderr.write("sst2k: seed set to %s\n" % seed)
-                    line = replayfp.readline().strip()
-                    arguments += line.split()[2:]
-                except ValueError:
-                    sys.stderr.write("sst: replay file %s is ill-formed\n"% val)
-                    raise SystemExit(1)
-                game.options |= OPTION_TTY
-                game.options &=~ OPTION_CURSES
-            elif switch == '-s':
-                seed = int(val)
-            elif switch == '-t':
-                game.options |= OPTION_TTY
-                game.options &=~ OPTION_CURSES
-            elif switch == '-x':
-                idebug = True
-            else:
-                sys.stderr.write("usage: sst [-t] [-x] [startcommand...].\n")
-                raise SystemExit, 1
-        # where to save the input in case of bugs
-        if "TMPDIR" in os.environ:
-            tmpdir = os.environ['TMPDIR']
-        else:
-            tmpdir = "/tmp"
-        try:
-            logfp = open(os.path.join(tmpdir, "sst-input.log"), "w")
-        except IOError:
-            sys.stderr.write("sst: warning, can't open logfile\n")
-            sys.exit(1)
-        if logfp:
-            logfp.write("# seed %s\n" % seed)
-            logfp.write("# options %s\n" % " ".join(arguments))
-            logfp.write("# recorded by %s@%s on %s\n" % \
-                    (getpass.getuser(),socket.gethostname(),time.ctime()))
-        random.seed(seed)
-        scanner = sstscanner()
-        map(scanner.append, arguments)
-        try:
-            iostart()
-            while True: # Play a game 
-                setwnd(fullscreen_window)
-                clrscr()
-                prelim()
-                setup()
-                if game.alldone:
-                    score()
-                    game.alldone = False
-                else:
-                    makemoves()
-                skip(1)
-                stars()
-                skip(1)
-                if game.tourn and game.alldone:
-                    proutn(_("Do you want your score recorded?"))
-                    if ja() == True:
-                        scanner.chew()
-                        scanner.push("\n")
-                        freeze(False)
-                scanner.chew()
-                proutn(_("Do you want to play again? "))
-                if not ja():
-                    break
-            skip(1)
-            prout(_("May the Great Bird of the Galaxy roost upon your home planet."))
-        finally:
-            ioend()
-        raise SystemExit, 0
-    except KeyboardInterrupt:
-        if logfp:
-            logfp.close()
-        print ""

Copied: trunk/c-version/sst.spec (from rev 809, trunk/sst.spec)
===================================================================
--- trunk/c-version/sst.spec	                        (rev 0)
+++ trunk/c-version/sst.spec	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,49 @@
+Name: sst
+Version: 2.0
+Release: 1
+URL: http://sst.berlios.de
+Source0: %{name}-%{version}.tar.gz
+License: GPL
+Group: Games
+Summary: the classic game of Super Star Trek
+BuildRoot: %{_tmppath}/%{name}-root
+#Freshmeat-Name: strek
+
+%description
+Save the Federation from the invading Klingons!  Visit exotic planets and
+strip-mine them for dilithium!  Encounter mysterious space thingies!
+The classic Super Star Trek game from the days of slow teletypes, reloaded.
+
+%prep
+%setup -q
+
+%build
+make %{?_smp_mflags} all sst-doc.html
+
+%install
+[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
+mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
+mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
+cp sst "$RPM_BUILD_ROOT"%{_bindir}
+cp sst.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/
+mkdir -p "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/
+cp sst.doc "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/
+cp sst-doc.html "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/index.html
+
+%clean
+[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
+
+%files
+%doc README COPYING
+%defattr(-,root,root,-)
+%{_mandir}/man6/sst.6*
+%{_bindir}/sst
+%{_defaultdocdir}/sst/sst.doc
+%{_defaultdocdir}/sst/index.html
+
+%changelog
+
+* Thu Apr 14 2005 Eric S. Raymond <esr at snark.thyrsus.com> - 2.0-1
+- First release under new management.
+
+

Deleted: trunk/compile
===================================================================
--- trunk/compile	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/compile	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,142 +0,0 @@
-#! /bin/sh
-# Wrapper for compilers which do not understand `-c -o'.
-
-scriptversion=2005-05-14.22
-
-# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
-# Written by Tom Tromey <tromey at cygnus.com>.
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# This file is maintained in Automake, please report
-# bugs to <bug-automake at gnu.org> or send patches to
-# <automake-patches at gnu.org>.
-
-case $1 in
-  '')
-     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
-     exit 1;
-     ;;
-  -h | --h*)
-    cat <<\EOF
-Usage: compile [--help] [--version] PROGRAM [ARGS]
-
-Wrapper for compilers which do not understand `-c -o'.
-Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
-arguments, and rename the output as expected.
-
-If you are trying to build a whole package this is not the
-right script to run: please start by reading the file `INSTALL'.
-
-Report bugs to <bug-automake at gnu.org>.
-EOF
-    exit $?
-    ;;
-  -v | --v*)
-    echo "compile $scriptversion"
-    exit $?
-    ;;
-esac
-
-ofile=
-cfile=
-eat=
-
-for arg
-do
-  if test -n "$eat"; then
-    eat=
-  else
-    case $1 in
-      -o)
-	# configure might choose to run compile as `compile cc -o foo foo.c'.
-	# So we strip `-o arg' only if arg is an object.
-	eat=1
-	case $2 in
-	  *.o | *.obj)
-	    ofile=$2
-	    ;;
-	  *)
-	    set x "$@" -o "$2"
-	    shift
-	    ;;
-	esac
-	;;
-      *.c)
-	cfile=$1
-	set x "$@" "$1"
-	shift
-	;;
-      *)
-	set x "$@" "$1"
-	shift
-	;;
-    esac
-  fi
-  shift
-done
-
-if test -z "$ofile" || test -z "$cfile"; then
-  # If no `-o' option was seen then we might have been invoked from a
-  # pattern rule where we don't need one.  That is ok -- this is a
-  # normal compilation that the losing compiler can handle.  If no
-  # `.c' file was seen then we are probably linking.  That is also
-  # ok.
-  exec "$@"
-fi
-
-# Name of file we expect compiler to create.
-cofile=`echo "$cfile" | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
-
-# Create the lock directory.
-# Note: use `[/.-]' here to ensure that we don't use the same name
-# that we are using for the .o file.  Also, base the name on the expected
-# object file name, since that is what matters with a parallel build.
-lockdir=`echo "$cofile" | sed -e 's|[/.-]|_|g'`.d
-while true; do
-  if mkdir "$lockdir" >/dev/null 2>&1; then
-    break
-  fi
-  sleep 1
-done
-# FIXME: race condition here if user kills between mkdir and trap.
-trap "rmdir '$lockdir'; exit 1" 1 2 15
-
-# Run the compile.
-"$@"
-ret=$?
-
-if test -f "$cofile"; then
-  mv "$cofile" "$ofile"
-elif test -f "${cofile}bj"; then
-  mv "${cofile}bj" "$ofile"
-fi
-
-rmdir "$lockdir"
-exit $ret
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-end: "$"
-# End:

Deleted: trunk/config.guess
===================================================================
--- trunk/config.guess	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.guess	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,1463 +0,0 @@
-#! /bin/sh
-# Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-timestamp='2005-07-08'
-
-# This file is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner <per at bothner.com>.
-# Please send patches to <config-patches at gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
-#
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION]
-
-Output the configuration name of the system \`$me' is run on.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches at gnu.org>."
-
-version="\
-GNU config.guess ($timestamp)
-
-Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
-    --version | -v )
-       echo "$version" ; exit ;;
-    --help | --h* | -h )
-       echo "$usage"; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help" >&2
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo "$me: too many arguments$help" >&2
-  exit 1
-fi
-
-trap 'exit 1' 1 2 15
-
-# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
-# compiler to aid in system detection is discouraged as it requires
-# temporary files to be created and, as you can see below, it is a
-# headache to deal with in a portable fashion.
-
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
-
-# Portable tmp directory creation inspired by the Autoconf team.
-
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
-
-# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi at noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
-	PATH=$PATH:/.attbin ; export PATH
-fi
-
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
-
-# Note: order is significant - the case branches are not exclusive.
-
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
-    *:NetBSD:*:*)
-	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
-	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
-	# switched to ELF, *-*-netbsd* would select the old
-	# object file format.  This provides both forward
-	# compatibility and a consistent mechanism for selecting the
-	# object file format.
-	#
-	# Note: NetBSD doesn't particularly care about the vendor
-	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
-	    armeb) machine=armeb-unknown ;;
-	    arm*) machine=arm-unknown ;;
-	    sh3el) machine=shl-unknown ;;
-	    sh3eb) machine=sh-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
-	esac
-	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
-		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
-		then
-		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
-		    # Return netbsd for either.  FIX?
-		    os=netbsd
-		else
-		    os=netbsdelf
-		fi
-		;;
-	    *)
-	        os=netbsd
-		;;
-	esac
-	# The OS release
-	# Debian GNU/NetBSD machines have a different userland, and
-	# thus, need a distinct triplet. However, they do not need
-	# kernel version information, so it can be replaced with a
-	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
-	    Debian*)
-		release='-gnu'
-		;;
-	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-		;;
-	esac
-	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
-	# contains redundant information, the shorter form:
-	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
-	exit ;;
-    *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
-	exit ;;
-    *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit ;;
-    macppc:MirBSD:*:*)
-	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    alpha:OSF1:*:*)
-	case $UNAME_RELEASE in
-	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-		;;
-	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
-		;;
-	esac
-	# According to Compaq, /usr/sbin/psrinfo has been available on
-	# OSF/1 and Tru64 systems produced since 1995.  I hope that
-	# covers most systems running today.  This code pipes the CPU
-	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case "$ALPHA_CPU_TYPE" in
-	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
-	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
-	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
-	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
-	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
-	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
-	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
-	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
-	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
-	esac
-	# A Pn.n version is a patched version.
-	# A Vn.n version is a released version.
-	# A Tn.n version is a released field test version.
-	# A Xn.n version is an unreleased experimental baselevel.
-	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
-    Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
-    *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit ;;
-    *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
-	exit ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
-    *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
-    *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit ;;
-    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
-    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
-    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
-	# akee at wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
-    NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
-    DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
-    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
-    sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:6*:*)
-	# According to config.sub, this is the proper way to canonicalize
-	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
-	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
-	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
-		;;
-	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit ;;
-    sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit ;;
-    sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
-	case "`/bin/arch`" in
-	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
-		;;
-	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
-		;;
-	esac
-	exit ;;
-    aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit ;;
-    # The situation for MiNT is a little confusing.  The machine name
-    # can be virtually everything (everything which is not
-    # "atarist" or "atariste" at least should have a processor
-    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
-    # to the lowercase version "mint" (or "freemint").  Finally
-    # the system name "TOS" denotes a system which is actually not
-    # MiNT.  But MiNT is downward compatible to TOS, so this should
-    # be no problem.
-    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
-    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
-    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
-    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
-    m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit ;;
-    powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit ;;
-    RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
-    RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit ;;
-    mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-#ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-	#if defined (host_mips) && defined (MIPSEB)
-	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
-	#endif
-	#endif
-	  exit (-1);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
-	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit ;;
-    Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
-    Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
-    m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
-    m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
-    m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
-    AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
-	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
-	fi
- 	exit ;;
-    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
-    M88*:*:R3*:*)
-	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
-    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
-    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
-    *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit ;;
-    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
-    i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
-    ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:2:3)
-	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
-		#include <sys/systemcfg.h>
-
-		main()
-			{
-			if (!__power_pc())
-				exit(1);
-			puts("powerpc-ibm-aix3.2.5");
-			exit(0);
-			}
-EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
-		then
-			echo "$SYSTEM_NAME"
-		else
-			echo rs6000-ibm-aix3.2.5
-		fi
-	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
-	else
-		echo rs6000-ibm-aix3.2
-	fi
-	exit ;;
-    *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
-		IBM_ARCH=rs6000
-	else
-		IBM_ARCH=powerpc
-	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
-    *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
-    DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
-    9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
-    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
-    9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
-		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
-EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
-		    test -z "$HP_ARCH" && HP_ARCH=hppa
-		fi ;;
-	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
-	then
-	    eval $set_cc_for_build
-
-	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
-	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
-	    # generating 64-bit code.  GNU and HP use different nomenclature:
-	    #
-	    # $ CC_FOR_BUILD=cc ./config.guess
-	    # => hppa2.0w-hp-hpux11.23
-	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
-	    # => hppa64-hp-hpux11.23
-
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
-	    then
-		HP_ARCH="hppa2.0w"
-	    else
-		HP_ARCH="hppa64"
-	    fi
-	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit ;;
-    ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
-	exit ;;
-    3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <unistd.h>
-	int
-	main ()
-	{
-	  long cpu = sysconf (_SC_CPU_VERSION);
-	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
-	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
-	     results, however.  */
-	  if (CPU_IS_PA_RISC (cpu))
-	    {
-	      switch (cpu)
-		{
-		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
-		  default: puts ("hppa-hitachi-hiuxwe2"); break;
-		}
-	    }
-	  else if (CPU_IS_HP_MC68K (cpu))
-	    puts ("m68k-hitachi-hiuxwe2");
-	  else puts ("unknown-hitachi-hiuxwe2");
-	  exit (0);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
-		{ echo "$SYSTEM_NAME"; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit ;;
-    9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
-    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit ;;
-    hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
-    i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
-	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
-	fi
-	exit ;;
-    parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
-    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit ;;
-    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-        exit ;;
-    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit ;;
-    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit ;;
-    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit ;;
-    CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
-	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
-	      -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
-    5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
-    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit ;;
-    sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit ;;
-    i*:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
-	exit ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit ;;
-    x86:Interix*:[34]*)
-	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
-	exit ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
-    i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit ;;
-    amd64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit ;;
-    prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    *:GNU:*:*)
-	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit ;;
-    *:GNU/*:*:*)
-	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit ;;
-    arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit ;;
-    crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
-	exit ;;
-    frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
-	exit ;;
-    ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
-    parisc:Linux:*:* | hppa:Linux:*:*)
-	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
-	esac
-	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit ;;
-    s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit ;;
-    sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit ;;
-	  coff-i386)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#ifdef __INTEL_COMPILER
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
-	;;
-    i*86:DYNIX/ptx:4*:*)
-	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
-	# earlier versions are messed up and put the nodename in both
-	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
-    i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
-	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit ;;
-    i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit ;;
-    i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
-	exit ;;
-    i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
-	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
-	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
-	fi
-	exit ;;
-    i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case `/bin/uname -X | grep "^Machine"` in
-	    *486*)	     UNAME_MACHINE=i486 ;;
-	    *Pentium)	     UNAME_MACHINE=i586 ;;
-	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
-	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit ;;
-    i*86:*:3.2:*)
-	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
-	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
-			&& UNAME_MACHINE=i586
-		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
-	else
-		echo ${UNAME_MACHINE}-pc-sysv32
-	fi
-	exit ;;
-    pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit ;;
-    Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
-    paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
-    i860:*:4.*:*) # i860-SVR4
-	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
-	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
-	fi
-	exit ;;
-    mini*:CTIX:SYS*5:*)
-	# "miniframe"
-	echo m68010-convergent-sysv
-	exit ;;
-    mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
-    M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
-    M68*:*:R3V[5678]*:*)
-	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
-    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
-	OS_REL=''
-	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
-	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
-    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
-    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
-    TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit ;;
-    RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    *:SINIX-*:*:*)
-	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
-	else
-		echo ns32k-sni-sysv
-	fi
-	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel at ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit ;;
-    *:UNIX_System_V:4*:FTX*)
-	# From Gerald Hewes <hewes at openmarket.com>.
-	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
-    *:*:*:FTX*)
-	# From seanf at swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit ;;
-    i*86:VOS:*:*)
-	# From Paul.Green at stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
-	exit ;;
-    *:VOS:*:*)
-	# From Paul.Green at stratus.com.
-	echo hppa1.1-stratus-vos
-	exit ;;
-    mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit ;;
-    news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
-	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
-	fi
-        exit ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
-    SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
-	exit ;;
-    Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit ;;
-    *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
-		UNAME_PROCESSOR=i386
-		UNAME_MACHINE=pc
-	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit ;;
-    *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
-    BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
-    DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit ;;
-    *:Plan9:*:*)
-	# "uname -m" is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test "$cputype" = "386"; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit ;;
-    *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
-    *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
-    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
-    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
-    *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
-    *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
-    SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit ;;
-    *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
-	esac ;;
-    *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
-    i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
-	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
-cat >&2 <<EOF
-$0: unable to guess system type
-
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
-
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
-and
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches at gnu.org> in order to provide the needed
-information to handle your system.
-
-config.guess timestamp = $timestamp
-
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
-
-exit 1
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:

Deleted: trunk/config.rpath
===================================================================
--- trunk/config.rpath	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.rpath	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,571 +0,0 @@
-#! /bin/sh
-# Output a system dependent set of variables, describing how to set the
-# run time search path of shared libraries in an executable.
-#
-#   Copyright 1996-2005 Free Software Foundation, Inc.
-#   Taken from GNU libtool, 2001
-#   Originally by Gordon Matzigkeit <gord at gnu.ai.mit.edu>, 1996
-#
-#   This file is free software; the Free Software Foundation gives
-#   unlimited permission to copy and/or distribute it, with or without
-#   modifications, as long as this notice is preserved.
-#
-# The first argument passed to this file is the canonical host specification,
-#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or
-#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
-# should be set by the caller.
-#
-# The set of defined variables is at the end of this script.
-
-# Known limitations:
-# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
-#   than 256 bytes, otherwise the compiler driver will dump core. The only
-#   known workaround is to choose shorter directory names for the build
-#   directory and/or the installation directory.
-
-# All known linkers require a `.a' archive for static linking (except M$VC,
-# which needs '.lib').
-libext=a
-shrext=.so
-
-host="$1"
-host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
-host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
-host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
-
-cc_basename=`echo "$CC" | sed -e 's%^.*/%%'`
-
-# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
-
-wl=
-if test "$GCC" = yes; then
-  wl='-Wl,'
-else
-  case "$host_os" in
-    aix*)
-      wl='-Wl,'
-      ;;
-    darwin*)
-      case "$cc_basename" in
-        xlc*)
-          wl='-Wl,'
-          ;;
-      esac
-      ;;
-    mingw* | pw32* | os2*)
-      ;;
-    hpux9* | hpux10* | hpux11*)
-      wl='-Wl,'
-      ;;
-    irix5* | irix6* | nonstopux*)
-      wl='-Wl,'
-      ;;
-    newsos6)
-      ;;
-    linux*)
-      case $cc_basename in
-        icc* | ecc*)
-          wl='-Wl,'
-          ;;
-        pgcc | pgf77 | pgf90)
-          wl='-Wl,'
-          ;;
-        ccc*)
-          wl='-Wl,'
-          ;;
-        como)
-          wl='-lopt='
-          ;;
-      esac
-      ;;
-    osf3* | osf4* | osf5*)
-      wl='-Wl,'
-      ;;
-    sco3.2v5*)
-      ;;
-    solaris*)
-      wl='-Wl,'
-      ;;
-    sunos4*)
-      wl='-Qoption ld '
-      ;;
-    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-      wl='-Wl,'
-      ;;
-    sysv4*MP*)
-      ;;
-    unicos*)
-      wl='-Wl,'
-      ;;
-    uts4*)
-      ;;
-  esac
-fi
-
-# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
-
-hardcode_libdir_flag_spec=
-hardcode_libdir_separator=
-hardcode_direct=no
-hardcode_minus_L=no
-
-case "$host_os" in
-  cygwin* | mingw* | pw32*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-esac
-
-ld_shlibs=yes
-if test "$with_gnu_ld" = yes; then
-  case "$host_os" in
-    aix3* | aix4* | aix5*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-        ld_shlibs=no
-      fi
-      ;;
-    amigaos*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      # Samuel A. Falvo II <kc5tja at dolphin.openprojects.net> reports
-      # that the semantics of dynamic libraries on AmigaOS, at least up
-      # to version 4, is to share data among multiple programs linked
-      # with the same dynamic library.  Since this doesn't match the
-      # behavior of shared libraries on other platforms, we cannot use
-      # them.
-      ld_shlibs=no
-      ;;
-    beos*)
-      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    cygwin* | mingw* | pw32*)
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    netbsd*)
-      ;;
-    solaris* | sysv5*)
-      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
-        ld_shlibs=no
-      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    sunos4*)
-      hardcode_direct=yes
-      ;;
-    linux*)
-      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    *)
-      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-  esac
-  if test "$ld_shlibs" = yes; then
-    # Unlike libtool, we use -rpath here, not --rpath, since the documented
-    # option of GNU ld is called -rpath, not --rpath.
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-  fi
-else
-  case "$host_os" in
-    aix3*)
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes; then
-        # Neither direct hardcoding nor static linking is supported with a
-        # broken collect2.
-        hardcode_direct=unsupported
-      fi
-      ;;
-    aix4* | aix5*)
-      if test "$host_cpu" = ia64; then
-        # On IA64, the linker does run time linking by default, so we don't
-        # have to do anything special.
-        aix_use_runtimelinking=no
-      else
-        aix_use_runtimelinking=no
-        # Test if we are trying to use run time linking or normal
-        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-        # need to do runtime linking.
-        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
-          for ld_flag in $LDFLAGS; do
-            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-              aix_use_runtimelinking=yes
-              break
-            fi
-          done
-        esac
-      fi
-      hardcode_direct=yes
-      hardcode_libdir_separator=':'
-      if test "$GCC" = yes; then
-        case $host_os in aix4.[012]|aix4.[012].*)
-          collect2name=`${CC} -print-prog-name=collect2`
-          if test -f "$collect2name" && \
-            strings "$collect2name" | grep resolve_lib_name >/dev/null
-          then
-            # We have reworked collect2
-            hardcode_direct=yes
-          else
-            # We have old collect2
-            hardcode_direct=unsupported
-            hardcode_minus_L=yes
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_libdir_separator=
-          fi
-        esac
-      fi
-      # Begin _LT_AC_SYS_LIBPATH_AIX.
-      echo 'int main () { return 0; }' > conftest.c
-      ${CC} ${LDFLAGS} conftest.c -o conftest
-      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
-}'`
-      if test -z "$aix_libpath"; then
-        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
-}'`
-      fi
-      if test -z "$aix_libpath"; then
-        aix_libpath="/usr/lib:/lib"
-      fi
-      rm -f conftest.c conftest
-      # End _LT_AC_SYS_LIBPATH_AIX.
-      if test "$aix_use_runtimelinking" = yes; then
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-      else
-        if test "$host_cpu" = ia64; then
-          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-        else
-          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        fi
-      fi
-      ;;
-    amigaos*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      # see comment about different semantics on the GNU ld section
-      ld_shlibs=no
-      ;;
-    bsdi[45]*)
-      ;;
-    cygwin* | mingw* | pw32*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      libext=lib
-      ;;
-    darwin* | rhapsody*)
-      hardcode_direct=no
-      if test "$GCC" = yes ; then
-        :
-      else
-        case "$cc_basename" in
-          xlc*)
-            ;;
-          *)
-            ld_shlibs=no
-            ;;
-        esac
-      fi
-      ;;
-    dgux*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      ;;
-    freebsd1*)
-      ld_shlibs=no
-      ;;
-    freebsd2.2*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    freebsd2*)
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      ;;
-    freebsd* | kfreebsd*-gnu | dragonfly*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    hpux9*)
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      ;;
-    hpux10* | hpux11*)
-      if test "$with_gnu_ld" = no; then
-        case "$host_cpu" in
-          hppa*64*)
-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-            hardcode_libdir_separator=:
-            hardcode_direct=no
-            ;;
-          ia64*)
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_direct=no
-            # hardcode_minus_L: Not really in the search PATH,
-            # but as the default location of the library.
-            hardcode_minus_L=yes
-            ;;
-          *)
-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-            hardcode_libdir_separator=:
-            hardcode_direct=yes
-            # hardcode_minus_L: Not really in the search PATH,
-            # but as the default location of the library.
-            hardcode_minus_L=yes
-            ;;
-        esac
-      fi
-      ;;
-    irix5* | irix6* | nonstopux*)
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    netbsd*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    newsos6)
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    openbsd*)
-      hardcode_direct=yes
-      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      else
-        case "$host_os" in
-          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-            hardcode_libdir_flag_spec='-R$libdir'
-            ;;
-          *)
-            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-            ;;
-        esac
-      fi
-      ;;
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      ;;
-    osf3*)
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    osf4* | osf5*)
-      if test "$GCC" = yes; then
-        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-        # Both cc and cxx compiler support -rpath directly
-        hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      hardcode_libdir_separator=:
-      ;;
-    sco3.2v5*)
-      ;;
-    solaris*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      ;;
-    sunos4*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      ;;
-    sysv4)
-      case $host_vendor in
-        sni)
-          hardcode_direct=yes # is this really true???
-          ;;
-        siemens)
-          hardcode_direct=no
-          ;;
-        motorola)
-          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-          ;;
-      esac
-      ;;
-    sysv4.3*)
-      ;;
-    sysv4*MP*)
-      if test -d /usr/nec; then
-        ld_shlibs=yes
-      fi
-      ;;
-    sysv4.2uw2*)
-      hardcode_direct=yes
-      hardcode_minus_L=no
-      ;;
-    sysv5OpenUNIX8* | sysv5UnixWare7* |  sysv5uw[78]* | unixware7*)
-      ;;
-    sysv5*)
-      hardcode_libdir_flag_spec=
-      ;;
-    uts4*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      ;;
-    *)
-      ld_shlibs=no
-      ;;
-  esac
-fi
-
-# Check dynamic linker characteristics
-# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
-libname_spec='lib$name'
-case "$host_os" in
-  aix3*)
-    ;;
-  aix4* | aix5*)
-    ;;
-  amigaos*)
-    ;;
-  beos*)
-    ;;
-  bsdi[45]*)
-    ;;
-  cygwin* | mingw* | pw32*)
-    shrext=.dll
-    ;;
-  darwin* | rhapsody*)
-    shrext=.dylib
-    ;;
-  dgux*)
-    ;;
-  freebsd1*)
-    ;;
-  kfreebsd*-gnu)
-    ;;
-  freebsd*)
-    ;;
-  gnu*)
-    ;;
-  hpux9* | hpux10* | hpux11*)
-    case "$host_cpu" in
-      ia64*)
-        shrext=.so
-        ;;
-      hppa*64*)
-        shrext=.sl
-        ;;
-      *)
-        shrext=.sl
-        ;;
-    esac
-    ;;
-  irix5* | irix6* | nonstopux*)
-    case "$host_os" in
-      irix5* | nonstopux*)
-        libsuff= shlibsuff=
-        ;;
-      *)
-        case $LD in
-          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
-          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
-          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
-          *) libsuff= shlibsuff= ;;
-        esac
-        ;;
-    esac
-    ;;
-  linux*oldld* | linux*aout* | linux*coff*)
-    ;;
-  linux*)
-    ;;
-  knetbsd*-gnu)
-    ;;
-  netbsd*)
-    ;;
-  newsos6)
-    ;;
-  nto-qnx*)
-    ;;
-  openbsd*)
-    ;;
-  os2*)
-    libname_spec='$name'
-    shrext=.dll
-    ;;
-  osf3* | osf4* | osf5*)
-    ;;
-  sco3.2v5*)
-    ;;
-  solaris*)
-    ;;
-  sunos4*)
-    ;;
-  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-    ;;
-  sysv4*MP*)
-    ;;
-  uts4*)
-    ;;
-esac
-
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
-shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
-escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
-
-LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
-
-# How to pass a linker flag through the compiler.
-wl="$escaped_wl"
-
-# Static library suffix (normally "a").
-libext="$libext"
-
-# Shared library suffix (normally "so").
-shlibext="$shlibext"
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
-
-# Whether we need a single -rpath flag with a separated argument.
-hardcode_libdir_separator="$hardcode_libdir_separator"
-
-# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
-# resulting binary.
-hardcode_direct="$hardcode_direct"
-
-# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
-# resulting binary.
-hardcode_minus_L="$hardcode_minus_L"
-
-EOF

Deleted: trunk/config.sub
===================================================================
--- trunk/config.sub	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.sub	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,1579 +0,0 @@
-#! /bin/sh
-# Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-timestamp='2005-07-08'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Please send patches to <config-patches at gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
-# Configuration subroutine to validate and canonicalize a configuration type.
-# Supply the specified configuration type as an argument.
-# If it is invalid, we print an error message on stderr and exit with code 1.
-# Otherwise, we print the canonical config type on stdout and succeed.
-
-# This file is supposed to be the same for all GNU packages
-# and recognize all the CPU types, system types and aliases
-# that are meaningful with *any* GNU software.
-# Each package is responsible for reporting which valid configurations
-# it does not support.  The user should be able to distinguish
-# a failure to support a valid configuration from a meaningless
-# configuration.
-
-# The goal of this file is to map all the various variations of a given
-# machine specification into a single specification in the form:
-#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or in some cases, the newer four-part form:
-#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# It is wrong to echo any other type of specification.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches at gnu.org>."
-
-version="\
-GNU config.sub ($timestamp)
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
-    --version | -v )
-       echo "$version" ; exit ;;
-    --help | --h* | -h )
-       echo "$usage"; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help"
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit ;;
-
-    * )
-       break ;;
-  esac
-done
-
-case $# in
- 0) echo "$me: missing argument$help" >&2
-    exit 1;;
- 1) ;;
- *) echo "$me: too many arguments$help" >&2
-    exit 1;;
-esac
-
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
-  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
-		os=
-		basic_machine=$1
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
-		basic_machine=$1
-		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
-		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
-		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
-		;;
-	-psos*)
-		os=-psos
-		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-esac
-
-# Decode aliases for certain CPU-COMPANY combinations.
-case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| bfin \
-	| c4x | clipper \
-	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
-	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
-	| mips | mipsbe | mipseb | mipsel | mipsle \
-	| mips16 \
-	| mips64 | mips64el \
-	| mips64vr | mips64vrel \
-	| mips64orion | mips64orionel \
-	| mips64vr4100 | mips64vr4100el \
-	| mips64vr4300 | mips64vr4300el \
-	| mips64vr5000 | mips64vr5000el \
-	| mips64vr5900 | mips64vr5900el \
-	| mipsisa32 | mipsisa32el \
-	| mipsisa32r2 | mipsisa32r2el \
-	| mipsisa64 | mipsisa64el \
-	| mipsisa64r2 | mipsisa64r2el \
-	| mipsisa64sb1 | mipsisa64sb1el \
-	| mipsisa64sr71k | mipsisa64sr71kel \
-	| mipstx39 | mipstx39el \
-	| mn10200 | mn10300 \
-	| ms1 \
-	| msp430 \
-	| ns16k | ns32k \
-	| or32 \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
-	| sh64 | sh64le \
-	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
-	| sparcv8 | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
-	| we32k \
-	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k)
-		basic_machine=$basic_machine-unknown
-		;;
-	m32c)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
-		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
-	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
-	| m32r-* | m32rle-* \
-	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* \
-	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
-	| mips16-* \
-	| mips64-* | mips64el-* \
-	| mips64vr-* | mips64vrel-* \
-	| mips64orion-* | mips64orionel-* \
-	| mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* \
-	| mips64vr5000-* | mips64vr5000el-* \
-	| mips64vr5900-* | mips64vr5900el-* \
-	| mipsisa32-* | mipsisa32el-* \
-	| mipsisa32r2-* | mipsisa32r2el-* \
-	| mipsisa64-* | mipsisa64el-* \
-	| mipsisa64r2-* | mipsisa64r2el-* \
-	| mipsisa64sb1-* | mipsisa64sb1el-* \
-	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
-	| mipstx39-* | mipstx39el-* \
-	| mmix-* \
-	| ms1-* \
-	| msp430-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
-	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
-	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
-	| tron-* \
-	| v850-* | v850e-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa-* \
-	| ymp-* \
-	| z8k-*)
-		;;
-	m32c-*)
-		;;
-	# Recognize the various machine names and aliases which stand
-	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
-	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
-		;;
-	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-    	abacus)
-		basic_machine=abacus-unknown
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amd64)
-		basic_machine=x86_64-pc
-		;;
-	amd64-*)
-		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-unknown
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-unknown
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	c90)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | j90)
-		basic_machine=j90-cray
-		os=-unicos
-		;;
-	craynv)
-		basic_machine=craynv-cray
-		os=-unicosmp
-		;;
-	cr16c)
-		basic_machine=cr16c-unknown
-		os=-elf
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	crisv32 | crisv32-* | etraxfs*)
-		basic_machine=crisv32-axis
-		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
-	crx)
-		basic_machine=crx-unknown
-		os=-elf
-		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
-		;;
-	decsystem10* | dec10*)
-		basic_machine=pdp10-dec
-		os=-tops10
-		;;
-	decsystem20* | dec20*)
-		basic_machine=pdp10-dec
-		os=-tops20
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	djgpp)
-		basic_machine=i586-pc
-		os=-msdosdjgpp
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
-		;;
-	encore | umax | mmax)
-		basic_machine=ns32k-encore
-		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
-		;;
-	fx2800)
-		basic_machine=i860-alliant
-		;;
-	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
-		;;
-	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
-		;;
-	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
-		;;
-	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
-		;;
-	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k78[0-9] | hp78[0-9])
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
-		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i*86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
-		;;
-	i*86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
-		;;
-	i*86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
-		;;
-	i*86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
-		;;
-	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
-			;;
-		    *)
-			os=-irix4
-			;;
-		esac
-		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
-	miniframe)
-		basic_machine=m68000-convergent
-		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	morphos)
-		basic_machine=powerpc-unknown
-		os=-morphos
-		;;
-	msdos)
-		basic_machine=i386-pc
-		os=-msdos
-		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-rebel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
-		;;
-	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
-		;;
-	np1)
-		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
-		;;
-	openrisc | openrisc-*)
-		basic_machine=or32-unknown
-		;;
-	os400)
-		basic_machine=powerpc-ibm
-		os=-os400
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
-		;;
-	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	pbd)
-		basic_machine=sparc-tti
-		;;
-	pbb)
-		basic_machine=m68k-tti
-		;;
-	pc532 | pc532-*)
-		basic_machine=ns32k-pc532
-		;;
-	pentium | p5 | k5 | k6 | nexgen | viac3)
-		basic_machine=i586-pc
-		;;
-	pentiumpro | p6 | 6x86 | athlon | athlon_*)
-		basic_machine=i686-pc
-		;;
-	pentiumii | pentium2 | pentiumiii | pentium3)
-		basic_machine=i686-pc
-		;;
-	pentium4)
-		basic_machine=i786-pc
-		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentium4-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pn)
-		basic_machine=pn-gould
-		;;
-	power)	basic_machine=power-ibm
-		;;
-	ppc)	basic_machine=powerpc-unknown
-		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
-		;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64)	basic_machine=powerpc64-unknown
-		;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
-		;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ps2)
-		basic_machine=i386-ibm
-		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	rm[46]00)
-		basic_machine=mips-siemens
-		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
-		;;
-	s390 | s390-*)
-		basic_machine=s390-ibm
-		;;
-	s390x | s390x-*)
-		basic_machine=s390x-ibm
-		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	sb1)
-		basic_machine=mipsisa64sb1-unknown
-		;;
-	sb1el)
-		basic_machine=mipsisa64sb1el-unknown
-		;;
-	sei)
-		basic_machine=mips-sei
-		os=-seiux
-		;;
-	sequent)
-		basic_machine=i386-sequent
-		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
-		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparclite-wrs | simso-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
-		;;
-	spur)
-		basic_machine=spur-unknown
-		;;
-	st2000)
-		basic_machine=m68k-tandem
-		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
-	sun2)
-		basic_machine=m68000-sun
-		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
-		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
-		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
-		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
-		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
-		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
-		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
-		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
-		;;
-	sun4)
-		basic_machine=sparc-sun
-		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
-		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
-		;;
-	t3e)
-		basic_machine=alphaev5-cray
-		os=-unicos
-		;;
-	t90)
-		basic_machine=t90-cray
-		os=-unicos
-		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
-	toad1)
-		basic_machine=pdp10-xkl
-		os=-tops20
-		;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
-		;;
-	tpf)
-		basic_machine=s390x-ibm
-		os=-tpf
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
-		;;
-	vpp*|vx|vx-*)
-		basic_machine=f301-fujitsu
-		;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
-	xbox)
-		basic_machine=i686-pc
-		os=-mingw32
-		;;
-	xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
-	none)
-		basic_machine=none-none
-		os=-none
-		;;
-
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	mmix)
-		basic_machine=mmix-knuth
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
-		;;
-	we32k)
-		basic_machine=we32k-att
-		;;
-	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
-		basic_machine=sh-unknown
-		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b)
-		basic_machine=sparc-sun
-		;;
-	cydra)
-		basic_machine=cydra-cydrome
-		;;
-	orion)
-		basic_machine=orion-highlevel
-		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
-		;;
-	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-esac
-
-# Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
-		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
-		;;
-	*)
-		;;
-esac
-
-# Decode manufacturer-specific aliases for certain operating systems.
-
-if [ x"$os" != x"" ]
-then
-case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware*)
-		os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
-	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
-	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
-		;;
-	-nto-qnx*)
-		;;
-	-nto*)
-		os=`echo $os | sed -e 's|nto|nto-qnx|'`
-		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
-		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
-		;;
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
-		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
-		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
-		;;
-	-opened*)
-		os=-openedition
-		;;
-        -os400*)
-		os=-os400
-		;;
-	-wince*)
-		os=-wince
-		;;
-	-osfrose*)
-		os=-osfrose
-		;;
-	-osf*)
-		os=-osf
-		;;
-	-utek*)
-		os=-bsd
-		;;
-	-dynix*)
-		os=-bsd
-		;;
-	-acis*)
-		os=-aos
-		;;
-	-atheos*)
-		os=-atheos
-		;;
-	-syllable*)
-		os=-syllable
-		;;
-	-386bsd)
-		os=-bsd
-		;;
-	-ctix* | -uts*)
-		os=-sysv
-		;;
-	-nova*)
-		os=-rtmk-nova
-		;;
-	-ns2 )
-		os=-nextstep2
-		;;
-	-nsk*)
-		os=-nsk
-		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
-		;;
-	-sinix*)
-		os=-sysv4
-		;;
-        -tpf*)
-		os=-tpf
-		;;
-	-triton*)
-		os=-sysv3
-		;;
-	-oss*)
-		os=-sysv3
-		;;
-	-svr4)
-		os=-sysv4
-		;;
-	-svr3)
-		os=-sysv3
-		;;
-	-sysvr4)
-		os=-sysv4
-		;;
-	# This must come after -sysvr4.
-	-sysv*)
-		;;
-	-ose*)
-		os=-ose
-		;;
-	-es1800*)
-		os=-ose
-		;;
-	-xenix)
-		os=-xenix
-		;;
-	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-		os=-mint
-		;;
-	-aros*)
-		os=-aros
-		;;
-	-kaos*)
-		os=-kaos
-		;;
-	-zvmoe)
-		os=-zvmoe
-		;;
-	-none)
-		;;
-	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
-		exit 1
-		;;
-esac
-else
-
-# Here we handle the default operating systems that come with various machines.
-# The value should be what the vendor currently ships out the door with their
-# machine or put another way, the most popular os provided with the machine.
-
-# Note that if you're going to try to match "-MANUFACTURER" here (say,
-# "-sun"), then you have to tell the case statement up towards the top
-# that MANUFACTURER isn't an operating system.  Otherwise, code above
-# will signal an error saying that MANUFACTURER isn't an operating
-# system, and we'll never get to this point.
-
-case $basic_machine in
-	*-acorn)
-		os=-riscix1.2
-		;;
-	arm*-rebel)
-		os=-linux
-		;;
-	arm*-semi)
-		os=-aout
-		;;
-    c4x-* | tic4x-*)
-        os=-coff
-        ;;
-	# This must come before the *-dec entry.
-	pdp10-*)
-		os=-tops20
-		;;
-	pdp11-*)
-		os=-none
-		;;
-	*-dec | vax-*)
-		os=-ultrix4.2
-		;;
-	m68*-apollo)
-		os=-domain
-		;;
-	i386-sun)
-		os=-sunos4.0.2
-		;;
-	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
-		;;
-	m68*-cisco)
-		os=-aout
-		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
-	or32-*)
-		os=-coff
-		;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
-		;;
-	sparc-* | *-sun)
-		os=-sunos4.1.1
-		;;
-	*-be)
-		os=-beos
-		;;
-	*-haiku)
-		os=-haiku
-		;;
-	*-ibm)
-		os=-aix
-		;;
-    	*-knuth)
-		os=-mmixware
-		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
-		;;
-	*-oki)
-		os=-proelf
-		;;
-	*-hp)
-		os=-hpux
-		;;
-	*-hitachi)
-		os=-hiux
-		;;
-	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
-		;;
-	*-cbm)
-		os=-amigaos
-		;;
-	*-dg)
-		os=-dgux
-		;;
-	*-dolphin)
-		os=-sysv3
-		;;
-	m68k-ccur)
-		os=-rtu
-		;;
-	m88k-omron*)
-		os=-luna
-		;;
-	*-next )
-		os=-nextstep
-		;;
-	*-sequent)
-		os=-ptx
-		;;
-	*-crds)
-		os=-unos
-		;;
-	*-ns)
-		os=-genix
-		;;
-	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
-		;;
-	*-gould)
-		os=-sysv
-		;;
-	*-highlevel)
-		os=-bsd
-		;;
-	*-encore)
-		os=-bsd
-		;;
-	*-sgi)
-		os=-irix
-		;;
-	*-siemens)
-		os=-sysv4
-		;;
-	*-masscomp)
-		os=-rtu
-		;;
-	f30[01]-fujitsu | f700-fujitsu)
-		os=-uxpv
-		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
-		;;
-	*)
-		os=-none
-		;;
-esac
-fi
-
-# Here we handle the case where we know the os, and the CPU type, but not the
-# manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
-				vendor=acorn
-				;;
-			-sunos*)
-				vendor=sun
-				;;
-			-aix*)
-				vendor=ibm
-				;;
-			-beos*)
-				vendor=be
-				;;
-			-hpux*)
-				vendor=hp
-				;;
-			-mpeix*)
-				vendor=hp
-				;;
-			-hiux*)
-				vendor=hitachi
-				;;
-			-unos*)
-				vendor=crds
-				;;
-			-dgux*)
-				vendor=dg
-				;;
-			-luna*)
-				vendor=omron
-				;;
-			-genix*)
-				vendor=ns
-				;;
-			-mvs* | -opened*)
-				vendor=ibm
-				;;
-			-os400*)
-				vendor=ibm
-				;;
-			-ptx*)
-				vendor=sequent
-				;;
-			-tpf*)
-				vendor=ibm
-				;;
-			-vxsim* | -vxworks* | -windiss*)
-				vendor=wrs
-				;;
-			-aux*)
-				vendor=apple
-				;;
-			-hms*)
-				vendor=hitachi
-				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-				vendor=atari
-				;;
-			-vos*)
-				vendor=stratus
-				;;
-		esac
-		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
-		;;
-esac
-
-echo $basic_machine$os
-exit
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:

Deleted: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/configure.ac	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,52 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ(2.57)
-AC_INIT(sst, 2.0, stsp)
-AM_INIT_AUTOMAKE([])
-AM_GNU_GETTEXT([external])
-AM_GNU_GETTEXT_VERSION(0.14.5)
-AM_CONFIG_HEADER([src/config.h])
-
-# Checks for programs.
-AC_PROG_CC
-AC_PROG_INSTALL
-AC_PROG_LN_S
-
-AC_CHECK_TOOL(have_xmlto, xmlto, "no")
-if test "$have_xmlto" = "no";
-then
-    AC_MSG_ERROR([xmlto is not installed])
-fi
-AC_CHECK_TOOL(have_python, python, "no")
-if test "$have_python" = "no";
-then
-    AC_MSG_ERROR([python is not installed])
-fi
-
-# Checks for libraries.
-AC_CHECK_LIB(m, floor, [],
-    AC_MSG_ERROR([math library is missing on your system.]))
-AC_CHECK_LIB(ncursesw, newwin, [],
-    AC_MSG_ERROR([ncurses library is missing on your system.]))
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([curses.h],
-    [], AC_MSG_ERROR([curses headers are missing on your system.]))
-AC_CHECK_HEADERS([fcntl.h sys/ioctl.h linux/kd.h])
-# Checks for typedefs, structures, and compiler characteristics.
-
-# Checks for library functions.
-AC_PROG_GCC_TRADITIONAL
-AC_FUNC_VPRINTF
-AC_CHECK_FUNCS([pow sqrt floor strcasecmp strncasecmp strchr strstr atexit], [],
-    AC_MSG_ERROR([some functions are missing on your system.]))
-
-AC_CONFIG_FILES([
-    Makefile
-    src/Makefile
-    po/Makefile.in
-    doc/Makefile
-])
-AC_OUTPUT

Deleted: trunk/depcomp
===================================================================
--- trunk/depcomp	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/depcomp	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,530 +0,0 @@
-#! /bin/sh
-# depcomp - compile a program generating dependencies as side-effects
-
-scriptversion=2005-07-09.11
-
-# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-# 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Originally written by Alexandre Oliva <oliva at dcc.unicamp.br>.
-
-case $1 in
-  '')
-     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
-     exit 1;
-     ;;
-  -h | --h*)
-    cat <<\EOF
-Usage: depcomp [--help] [--version] PROGRAM [ARGS]
-
-Run PROGRAMS ARGS to compile a file, generating dependencies
-as side-effects.
-
-Environment variables:
-  depmode     Dependency tracking mode.
-  source      Source file read by `PROGRAMS ARGS'.
-  object      Object file output by `PROGRAMS ARGS'.
-  DEPDIR      directory where to store dependencies.
-  depfile     Dependency file to output.
-  tmpdepfile  Temporary file to use when outputing dependencies.
-  libtool     Whether libtool is used (yes/no).
-
-Report bugs to <bug-automake at gnu.org>.
-EOF
-    exit $?
-    ;;
-  -v | --v*)
-    echo "depcomp $scriptversion"
-    exit $?
-    ;;
-esac
-
-if test -z "$depmode" || test -z "$source" || test -z "$object"; then
-  echo "depcomp: Variables source, object and depmode must be set" 1>&2
-  exit 1
-fi
-
-# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
-depfile=${depfile-`echo "$object" |
-  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
-tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
-
-rm -f "$tmpdepfile"
-
-# Some modes work just like other modes, but use different flags.  We
-# parameterize here, but still list the modes in the big case below,
-# to make depend.m4 easier to write.  Note that we *cannot* use a case
-# here, because this file can only contain one case statement.
-if test "$depmode" = hp; then
-  # HP compiler uses -M and no extra arg.
-  gccflag=-M
-  depmode=gcc
-fi
-
-if test "$depmode" = dashXmstdout; then
-   # This is just like dashmstdout with a different argument.
-   dashmflag=-xM
-   depmode=dashmstdout
-fi
-
-case "$depmode" in
-gcc3)
-## gcc 3 implements dependency tracking that does exactly what
-## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
-## it if -MD -MP comes after the -MF stuff.  Hmm.
-  "$@" -MT "$object" -MD -MP -MF "$tmpdepfile"
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f "$tmpdepfile"
-    exit $stat
-  fi
-  mv "$tmpdepfile" "$depfile"
-  ;;
-
-gcc)
-## There are various ways to get dependency output from gcc.  Here's
-## why we pick this rather obscure method:
-## - Don't want to use -MD because we'd like the dependencies to end
-##   up in a subdir.  Having to rename by hand is ugly.
-##   (We might end up doing this anyway to support other compilers.)
-## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
-##   -MM, not -M (despite what the docs say).
-## - Using -M directly means running the compiler twice (even worse
-##   than renaming).
-  if test -z "$gccflag"; then
-    gccflag=-MD,
-  fi
-  "$@" -Wp,"$gccflag$tmpdepfile"
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f "$tmpdepfile"
-    exit $stat
-  fi
-  rm -f "$depfile"
-  echo "$object : \\" > "$depfile"
-  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
-## The second -e expression handles DOS-style file names with drive letters.
-  sed -e 's/^[^:]*: / /' \
-      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
-## This next piece of magic avoids the `deleted header file' problem.
-## The problem is that when a header file which appears in a .P file
-## is deleted, the dependency causes make to die (because there is
-## typically no way to rebuild the header).  We avoid this by adding
-## dummy dependencies for each header file.  Too bad gcc doesn't do
-## this for us directly.
-  tr ' ' '
-' < "$tmpdepfile" |
-## Some versions of gcc put a space before the `:'.  On the theory
-## that the space means something, we add a space to the output as
-## well.
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
-  rm -f "$tmpdepfile"
-  ;;
-
-hp)
-  # This case exists only to let depend.m4 do its work.  It works by
-  # looking at the text of this script.  This case will never be run,
-  # since it is checked for above.
-  exit 1
-  ;;
-
-sgi)
-  if test "$libtool" = yes; then
-    "$@" "-Wp,-MDupdate,$tmpdepfile"
-  else
-    "$@" -MDupdate "$tmpdepfile"
-  fi
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f "$tmpdepfile"
-    exit $stat
-  fi
-  rm -f "$depfile"
-
-  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
-    echo "$object : \\" > "$depfile"
-
-    # Clip off the initial element (the dependent).  Don't try to be
-    # clever and replace this with sed code, as IRIX sed won't handle
-    # lines with more than a fixed number of characters (4096 in
-    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
-    # the IRIX cc adds comments like `#:fec' to the end of the
-    # dependency line.
-    tr ' ' '
-' < "$tmpdepfile" \
-    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
-    tr '
-' ' ' >> $depfile
-    echo >> $depfile
-
-    # The second pass generates a dummy entry for each header file.
-    tr ' ' '
-' < "$tmpdepfile" \
-   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
-   >> $depfile
-  else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # "include basename.Plo" scheme.
-    echo "#dummy" > "$depfile"
-  fi
-  rm -f "$tmpdepfile"
-  ;;
-
-aix)
-  # The C for AIX Compiler uses -M and outputs the dependencies
-  # in a .u file.  In older versions, this file always lives in the
-  # current directory.  Also, the AIX compiler puts `$object:' at the
-  # start of each line; $object doesn't have directory information.
-  # Version 6 uses the directory in both cases.
-  stripped=`echo "$object" | sed 's/\(.*\)\..*$/\1/'`
-  tmpdepfile="$stripped.u"
-  if test "$libtool" = yes; then
-    "$@" -Wc,-M
-  else
-    "$@" -M
-  fi
-  stat=$?
-
-  if test -f "$tmpdepfile"; then :
-  else
-    stripped=`echo "$stripped" | sed 's,^.*/,,'`
-    tmpdepfile="$stripped.u"
-  fi
-
-  if test $stat -eq 0; then :
-  else
-    rm -f "$tmpdepfile"
-    exit $stat
-  fi
-
-  if test -f "$tmpdepfile"; then
-    outname="$stripped.o"
-    # Each line is of the form `foo.o: dependent.h'.
-    # Do two passes, one to just change these to
-    # `$object: dependent.h' and one to simply `dependent.h:'.
-    sed -e "s,^$outname:,$object :," < "$tmpdepfile" > "$depfile"
-    sed -e "s,^$outname: \(.*\)$,\1:," < "$tmpdepfile" >> "$depfile"
-  else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # "include basename.Plo" scheme.
-    echo "#dummy" > "$depfile"
-  fi
-  rm -f "$tmpdepfile"
-  ;;
-
-icc)
-  # Intel's C compiler understands `-MD -MF file'.  However on
-  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
-  # ICC 7.0 will fill foo.d with something like
-  #    foo.o: sub/foo.c
-  #    foo.o: sub/foo.h
-  # which is wrong.  We want:
-  #    sub/foo.o: sub/foo.c
-  #    sub/foo.o: sub/foo.h
-  #    sub/foo.c:
-  #    sub/foo.h:
-  # ICC 7.1 will output
-  #    foo.o: sub/foo.c sub/foo.h
-  # and will wrap long lines using \ :
-  #    foo.o: sub/foo.c ... \
-  #     sub/foo.h ... \
-  #     ...
-
-  "$@" -MD -MF "$tmpdepfile"
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f "$tmpdepfile"
-    exit $stat
-  fi
-  rm -f "$depfile"
-  # Each line is of the form `foo.o: dependent.h',
-  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
-  # Do two passes, one to just change these to
-  # `$object: dependent.h' and one to simply `dependent.h:'.
-  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
-  # Some versions of the HPUX 10.20 sed can't process this invocation
-  # correctly.  Breaking it into two sed invocations is a workaround.
-  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
-    sed -e 's/$/ :/' >> "$depfile"
-  rm -f "$tmpdepfile"
-  ;;
-
-tru64)
-   # The Tru64 compiler uses -MD to generate dependencies as a side
-   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
-   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
-   # dependencies in `foo.d' instead, so we check for that too.
-   # Subdirectories are respected.
-   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
-   test "x$dir" = "x$object" && dir=
-   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
-
-   if test "$libtool" = yes; then
-      # With Tru64 cc, shared objects can also be used to make a
-      # static library.  This mecanism is used in libtool 1.4 series to
-      # handle both shared and static libraries in a single compilation.
-      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
-      #
-      # With libtool 1.5 this exception was removed, and libtool now
-      # generates 2 separate objects for the 2 libraries.  These two
-      # compilations output dependencies in in $dir.libs/$base.o.d and
-      # in $dir$base.o.d.  We have to check for both files, because
-      # one of the two compilations can be disabled.  We should prefer
-      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
-      # automatically cleaned when .libs/ is deleted, while ignoring
-      # the former would cause a distcleancheck panic.
-      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
-      tmpdepfile2=$dir$base.o.d          # libtool 1.5
-      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
-      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
-      "$@" -Wc,-MD
-   else
-      tmpdepfile1=$dir$base.o.d
-      tmpdepfile2=$dir$base.d
-      tmpdepfile3=$dir$base.d
-      tmpdepfile4=$dir$base.d
-      "$@" -MD
-   fi
-
-   stat=$?
-   if test $stat -eq 0; then :
-   else
-      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
-      exit $stat
-   fi
-
-   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
-   do
-     test -f "$tmpdepfile" && break
-   done
-   if test -f "$tmpdepfile"; then
-      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
-      # That's a tab and a space in the [].
-      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
-   else
-      echo "#dummy" > "$depfile"
-   fi
-   rm -f "$tmpdepfile"
-   ;;
-
-#nosideeffect)
-  # This comment above is used by automake to tell side-effect
-  # dependency tracking mechanisms from slower ones.
-
-dashmstdout)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o.
-  "$@" || exit $?
-
-  # Remove the call to Libtool.
-  if test "$libtool" = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-
-  # Remove `-o $object'.
-  IFS=" "
-  for arg
-  do
-    case $arg in
-    -o)
-      shift
-      ;;
-    $object)
-      shift
-      ;;
-    *)
-      set fnord "$@" "$arg"
-      shift # fnord
-      shift # $arg
-      ;;
-    esac
-  done
-
-  test -z "$dashmflag" && dashmflag=-M
-  # Require at least two characters before searching for `:'
-  # in the target name.  This is to cope with DOS-style filenames:
-  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
-  "$@" $dashmflag |
-    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
-  rm -f "$depfile"
-  cat < "$tmpdepfile" > "$depfile"
-  tr ' ' '
-' < "$tmpdepfile" | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
-  rm -f "$tmpdepfile"
-  ;;
-
-dashXmstdout)
-  # This case only exists to satisfy depend.m4.  It is never actually
-  # run, as this mode is specially recognized in the preamble.
-  exit 1
-  ;;
-
-makedepend)
-  "$@" || exit $?
-  # Remove any Libtool call
-  if test "$libtool" = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-  # X makedepend
-  shift
-  cleared=no
-  for arg in "$@"; do
-    case $cleared in
-    no)
-      set ""; shift
-      cleared=yes ;;
-    esac
-    case "$arg" in
-    -D*|-I*)
-      set fnord "$@" "$arg"; shift ;;
-    # Strip any option that makedepend may not understand.  Remove
-    # the object too, otherwise makedepend will parse it as a source file.
-    -*|$object)
-      ;;
-    *)
-      set fnord "$@" "$arg"; shift ;;
-    esac
-  done
-  obj_suffix="`echo $object | sed 's/^.*\././'`"
-  touch "$tmpdepfile"
-  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
-  rm -f "$depfile"
-  cat < "$tmpdepfile" > "$depfile"
-  sed '1,2d' "$tmpdepfile" | tr ' ' '
-' | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
-  rm -f "$tmpdepfile" "$tmpdepfile".bak
-  ;;
-
-cpp)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout.
-  "$@" || exit $?
-
-  # Remove the call to Libtool.
-  if test "$libtool" = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-
-  # Remove `-o $object'.
-  IFS=" "
-  for arg
-  do
-    case $arg in
-    -o)
-      shift
-      ;;
-    $object)
-      shift
-      ;;
-    *)
-      set fnord "$@" "$arg"
-      shift # fnord
-      shift # $arg
-      ;;
-    esac
-  done
-
-  "$@" -E |
-    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
-       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
-    sed '$ s: \\$::' > "$tmpdepfile"
-  rm -f "$depfile"
-  echo "$object : \\" > "$depfile"
-  cat < "$tmpdepfile" >> "$depfile"
-  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
-  rm -f "$tmpdepfile"
-  ;;
-
-msvisualcpp)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o,
-  # because we must use -o when running libtool.
-  "$@" || exit $?
-  IFS=" "
-  for arg
-  do
-    case "$arg" in
-    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
-	set fnord "$@"
-	shift
-	shift
-	;;
-    *)
-	set fnord "$@" "$arg"
-	shift
-	shift
-	;;
-    esac
-  done
-  "$@" -E |
-  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::echo "`cygpath -u \\"\1\\"`":p' | sort | uniq > "$tmpdepfile"
-  rm -f "$depfile"
-  echo "$object : \\" > "$depfile"
-  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
-  echo "	" >> "$depfile"
-  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' >> "$depfile"
-  rm -f "$tmpdepfile"
-  ;;
-
-none)
-  exec "$@"
-  ;;
-
-*)
-  echo "Unknown depmode $depmode" 1>&2
-  exit 1
-  ;;
-esac
-
-exit 0
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-end: "$"
-# End:

Deleted: trunk/install-sh
===================================================================
--- trunk/install-sh	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/install-sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,323 +0,0 @@
-#!/bin/sh
-# install - install a program, script, or datafile
-
-scriptversion=2005-05-14.22
-
-# This originates from X11R5 (mit/util/scripts/install.sh), which was
-# later released in X11R6 (xc/config/util/install.sh) with the
-# following copyright and license.
-#
-# Copyright (C) 1994 X Consortium
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to
-# deal in the Software without restriction, including without limitation the
-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-# sell copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
-# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#
-# Except as contained in this notice, the name of the X Consortium shall not
-# be used in advertising or otherwise to promote the sale, use or other deal-
-# ings in this Software without prior written authorization from the X Consor-
-# tium.
-#
-#
-# FSF changes to this file are in the public domain.
-#
-# Calling this script install-sh is preferred over install.sh, to prevent
-# `make' implicit rules from creating a file called install from it
-# when there is no Makefile.
-#
-# This script is compatible with the BSD install script, but was written
-# from scratch.  It can only install one file at a time, a restriction
-# shared with many OS's install programs.
-
-# set DOITPROG to echo to test this script
-
-# Don't use :- since 4.3BSD and earlier shells don't like it.
-doit="${DOITPROG-}"
-
-# put in absolute paths if you don't have them in your path; or use env. vars.
-
-mvprog="${MVPROG-mv}"
-cpprog="${CPPROG-cp}"
-chmodprog="${CHMODPROG-chmod}"
-chownprog="${CHOWNPROG-chown}"
-chgrpprog="${CHGRPPROG-chgrp}"
-stripprog="${STRIPPROG-strip}"
-rmprog="${RMPROG-rm}"
-mkdirprog="${MKDIRPROG-mkdir}"
-
-chmodcmd="$chmodprog 0755"
-chowncmd=
-chgrpcmd=
-stripcmd=
-rmcmd="$rmprog -f"
-mvcmd="$mvprog"
-src=
-dst=
-dir_arg=
-dstarg=
-no_target_directory=
-
-usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
-   or: $0 [OPTION]... SRCFILES... DIRECTORY
-   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
-   or: $0 [OPTION]... -d DIRECTORIES...
-
-In the 1st form, copy SRCFILE to DSTFILE.
-In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
-In the 4th, create DIRECTORIES.
-
-Options:
--c         (ignored)
--d         create directories instead of installing files.
--g GROUP   $chgrpprog installed files to GROUP.
--m MODE    $chmodprog installed files to MODE.
--o USER    $chownprog installed files to USER.
--s         $stripprog installed files.
--t DIRECTORY  install into DIRECTORY.
--T         report an error if DSTFILE is a directory.
---help     display this help and exit.
---version  display version info and exit.
-
-Environment variables override the default commands:
-  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
-"
-
-while test -n "$1"; do
-  case $1 in
-    -c) shift
-        continue;;
-
-    -d) dir_arg=true
-        shift
-        continue;;
-
-    -g) chgrpcmd="$chgrpprog $2"
-        shift
-        shift
-        continue;;
-
-    --help) echo "$usage"; exit $?;;
-
-    -m) chmodcmd="$chmodprog $2"
-        shift
-        shift
-        continue;;
-
-    -o) chowncmd="$chownprog $2"
-        shift
-        shift
-        continue;;
-
-    -s) stripcmd=$stripprog
-        shift
-        continue;;
-
-    -t) dstarg=$2
-	shift
-	shift
-	continue;;
-
-    -T) no_target_directory=true
-	shift
-	continue;;
-
-    --version) echo "$0 $scriptversion"; exit $?;;
-
-    *)  # When -d is used, all remaining arguments are directories to create.
-	# When -t is used, the destination is already specified.
-	test -n "$dir_arg$dstarg" && break
-        # Otherwise, the last argument is the destination.  Remove it from $@.
-	for arg
-	do
-          if test -n "$dstarg"; then
-	    # $@ is not empty: it contains at least $arg.
-	    set fnord "$@" "$dstarg"
-	    shift # fnord
-	  fi
-	  shift # arg
-	  dstarg=$arg
-	done
-	break;;
-  esac
-done
-
-if test -z "$1"; then
-  if test -z "$dir_arg"; then
-    echo "$0: no input file specified." >&2
-    exit 1
-  fi
-  # It's OK to call `install-sh -d' without argument.
-  # This can happen when creating conditional directories.
-  exit 0
-fi
-
-for src
-do
-  # Protect names starting with `-'.
-  case $src in
-    -*) src=./$src ;;
-  esac
-
-  if test -n "$dir_arg"; then
-    dst=$src
-    src=
-
-    if test -d "$dst"; then
-      mkdircmd=:
-      chmodcmd=
-    else
-      mkdircmd=$mkdirprog
-    fi
-  else
-    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
-    # might cause directories to be created, which would be especially bad
-    # if $src (and thus $dsttmp) contains '*'.
-    if test ! -f "$src" && test ! -d "$src"; then
-      echo "$0: $src does not exist." >&2
-      exit 1
-    fi
-
-    if test -z "$dstarg"; then
-      echo "$0: no destination specified." >&2
-      exit 1
-    fi
-
-    dst=$dstarg
-    # Protect names starting with `-'.
-    case $dst in
-      -*) dst=./$dst ;;
-    esac
-
-    # If destination is a directory, append the input filename; won't work
-    # if double slashes aren't ignored.
-    if test -d "$dst"; then
-      if test -n "$no_target_directory"; then
-	echo "$0: $dstarg: Is a directory" >&2
-	exit 1
-      fi
-      dst=$dst/`basename "$src"`
-    fi
-  fi
-
-  # This sed command emulates the dirname command.
-  dstdir=`echo "$dst" | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`
-
-  # Make sure that the destination directory exists.
-
-  # Skip lots of stat calls in the usual case.
-  if test ! -d "$dstdir"; then
-    defaultIFS='
-	 '
-    IFS="${IFS-$defaultIFS}"
-
-    oIFS=$IFS
-    # Some sh's can't handle IFS=/ for some reason.
-    IFS='%'
-    set x `echo "$dstdir" | sed -e 's@/@%@g' -e 's@^%@/@'`
-    shift
-    IFS=$oIFS
-
-    pathcomp=
-
-    while test $# -ne 0 ; do
-      pathcomp=$pathcomp$1
-      shift
-      if test ! -d "$pathcomp"; then
-        $mkdirprog "$pathcomp"
-	# mkdir can fail with a `File exist' error in case several
-	# install-sh are creating the directory concurrently.  This
-	# is OK.
-	test -d "$pathcomp" || exit
-      fi
-      pathcomp=$pathcomp/
-    done
-  fi
-
-  if test -n "$dir_arg"; then
-    $doit $mkdircmd "$dst" \
-      && { test -z "$chowncmd" || $doit $chowncmd "$dst"; } \
-      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } \
-      && { test -z "$stripcmd" || $doit $stripcmd "$dst"; } \
-      && { test -z "$chmodcmd" || $doit $chmodcmd "$dst"; }
-
-  else
-    dstfile=`basename "$dst"`
-
-    # Make a couple of temp file names in the proper directory.
-    dsttmp=$dstdir/_inst.$$_
-    rmtmp=$dstdir/_rm.$$_
-
-    # Trap to clean up those temp files at exit.
-    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
-    trap '(exit $?); exit' 1 2 13 15
-
-    # Copy the file name to the temp name.
-    $doit $cpprog "$src" "$dsttmp" &&
-
-    # and set any options; do chmod last to preserve setuid bits.
-    #
-    # If any of these fail, we abort the whole thing.  If we want to
-    # ignore errors from any of these, just make sure not to ignore
-    # errors from the above "$doit $cpprog $src $dsttmp" command.
-    #
-    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
-      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
-      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
-      && { test -z "$chmodcmd" || $doit $chmodcmd "$dsttmp"; } &&
-
-    # Now rename the file to the real destination.
-    { $doit $mvcmd -f "$dsttmp" "$dstdir/$dstfile" 2>/dev/null \
-      || {
-	   # The rename failed, perhaps because mv can't rename something else
-	   # to itself, or perhaps because mv is so ancient that it does not
-	   # support -f.
-
-	   # Now remove or move aside any old file at destination location.
-	   # We try this two ways since rm can't unlink itself on some
-	   # systems and the destination file might be busy for other
-	   # reasons.  In this case, the final cleanup might fail but the new
-	   # file should still install successfully.
-	   {
-	     if test -f "$dstdir/$dstfile"; then
-	       $doit $rmcmd -f "$dstdir/$dstfile" 2>/dev/null \
-	       || $doit $mvcmd -f "$dstdir/$dstfile" "$rmtmp" 2>/dev/null \
-	       || {
-		 echo "$0: cannot unlink or rename $dstdir/$dstfile" >&2
-		 (exit 1); exit 1
-	       }
-	     else
-	       :
-	     fi
-	   } &&
-
-	   # Now rename the file to the real destination.
-	   $doit $mvcmd "$dsttmp" "$dstdir/$dstfile"
-	 }
-    }
-  fi || { (exit 1); exit 1; }
-done
-
-# The final little trick to "correctly" pass the exit status to the exit trap.
-{
-  (exit 0); exit 0
-}
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-end: "$"
-# End:

Deleted: trunk/missing
===================================================================
--- trunk/missing	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/missing	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,360 +0,0 @@
-#! /bin/sh
-# Common stub for a few missing GNU programs while installing.
-
-scriptversion=2005-06-08.21
-
-# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005
-#   Free Software Foundation, Inc.
-# Originally by Fran,cois Pinard <pinard at iro.umontreal.ca>, 1996.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-# 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-if test $# -eq 0; then
-  echo 1>&2 "Try \`$0 --help' for more information"
-  exit 1
-fi
-
-run=:
-
-# In the cases where this matters, `missing' is being run in the
-# srcdir already.
-if test -f configure.ac; then
-  configure_ac=configure.ac
-else
-  configure_ac=configure.in
-fi
-
-msg="missing on your system"
-
-case "$1" in
---run)
-  # Try to run requested program, and just exit if it succeeds.
-  run=
-  shift
-  "$@" && exit 0
-  # Exit code 63 means version mismatch.  This often happens
-  # when the user try to use an ancient version of a tool on
-  # a file that requires a minimum version.  In this case we
-  # we should proceed has if the program had been absent, or
-  # if --run hadn't been passed.
-  if test $? = 63; then
-    run=:
-    msg="probably too old"
-  fi
-  ;;
-
-  -h|--h|--he|--hel|--help)
-    echo "\
-$0 [OPTION]... PROGRAM [ARGUMENT]...
-
-Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
-error status if there is no known handling for PROGRAM.
-
-Options:
-  -h, --help      display this help and exit
-  -v, --version   output version information and exit
-  --run           try to run the given command, and emulate it if it fails
-
-Supported PROGRAM values:
-  aclocal      touch file \`aclocal.m4'
-  autoconf     touch file \`configure'
-  autoheader   touch file \`config.h.in'
-  automake     touch all \`Makefile.in' files
-  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
-  flex         create \`lex.yy.c', if possible, from existing .c
-  help2man     touch the output file
-  lex          create \`lex.yy.c', if possible, from existing .c
-  makeinfo     touch the output file
-  tar          try tar, gnutar, gtar, then tar without non-portable flags
-  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
-
-Send bug reports to <bug-automake at gnu.org>."
-    exit $?
-    ;;
-
-  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
-    echo "missing $scriptversion (GNU Automake)"
-    exit $?
-    ;;
-
-  -*)
-    echo 1>&2 "$0: Unknown \`$1' option"
-    echo 1>&2 "Try \`$0 --help' for more information"
-    exit 1
-    ;;
-
-esac
-
-# Now exit if we have it, but it failed.  Also exit now if we
-# don't have it and --version was passed (most likely to detect
-# the program).
-case "$1" in
-  lex|yacc)
-    # Not GNU programs, they don't have --version.
-    ;;
-
-  tar)
-    if test -n "$run"; then
-       echo 1>&2 "ERROR: \`tar' requires --run"
-       exit 1
-    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
-       exit 1
-    fi
-    ;;
-
-  *)
-    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
-       # We have it, but it failed.
-       exit 1
-    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
-       # Could not run --version or --help.  This is probably someone
-       # running `$TOOL --version' or `$TOOL --help' to check whether
-       # $TOOL exists and not knowing $TOOL uses missing.
-       exit 1
-    fi
-    ;;
-esac
-
-# If it does not exist, or fails to run (possibly an outdated version),
-# try to emulate it.
-case "$1" in
-  aclocal*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
-         to install the \`Automake' and \`Perl' packages.  Grab them from
-         any GNU archive site."
-    touch aclocal.m4
-    ;;
-
-  autoconf)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`${configure_ac}'.  You might want to install the
-         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
-         archive site."
-    touch configure
-    ;;
-
-  autoheader)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
-         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
-         from any GNU archive site."
-    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
-    test -z "$files" && files="config.h"
-    touch_files=
-    for f in $files; do
-      case "$f" in
-      *:*) touch_files="$touch_files "`echo "$f" |
-				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
-      *) touch_files="$touch_files $f.in";;
-      esac
-    done
-    touch $touch_files
-    ;;
-
-  automake*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
-         You might want to install the \`Automake' and \`Perl' packages.
-         Grab them from any GNU archive site."
-    find . -type f -name Makefile.am -print |
-	   sed 's/\.am$/.in/' |
-	   while read f; do touch "$f"; done
-    ;;
-
-  autom4te)
-    echo 1>&2 "\
-WARNING: \`$1' is needed, but is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.
-         You can get \`$1' as part of \`Autoconf' from any GNU
-         archive site."
-
-    file=`echo "$*" | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
-    test -z "$file" && file=`echo "$*" | sed -n 's/.*-o[ ]*\([^ ]*\).*/\1/p'`
-    if test -f "$file"; then
-	touch $file
-    else
-	test -z "$file" || exec >$file
-	echo "#! /bin/sh"
-	echo "# Created by GNU Automake missing as a replacement of"
-	echo "#  $ $@"
-	echo "exit 0"
-	chmod +x $file
-	exit 1
-    fi
-    ;;
-
-  bison|yacc)
-    echo 1>&2 "\
-WARNING: \`$1' $msg.  You should only need it if
-         you modified a \`.y' file.  You may need the \`Bison' package
-         in order for those modifications to take effect.  You can get
-         \`Bison' from any GNU archive site."
-    rm -f y.tab.c y.tab.h
-    if [ $# -ne 1 ]; then
-        eval LASTARG="\${$#}"
-	case "$LASTARG" in
-	*.y)
-	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
-	    if [ -f "$SRCFILE" ]; then
-	         cp "$SRCFILE" y.tab.c
-	    fi
-	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
-	    if [ -f "$SRCFILE" ]; then
-	         cp "$SRCFILE" y.tab.h
-	    fi
-	  ;;
-	esac
-    fi
-    if [ ! -f y.tab.h ]; then
-	echo >y.tab.h
-    fi
-    if [ ! -f y.tab.c ]; then
-	echo 'main() { return 0; }' >y.tab.c
-    fi
-    ;;
-
-  lex|flex)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.l' file.  You may need the \`Flex' package
-         in order for those modifications to take effect.  You can get
-         \`Flex' from any GNU archive site."
-    rm -f lex.yy.c
-    if [ $# -ne 1 ]; then
-        eval LASTARG="\${$#}"
-	case "$LASTARG" in
-	*.l)
-	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
-	    if [ -f "$SRCFILE" ]; then
-	         cp "$SRCFILE" lex.yy.c
-	    fi
-	  ;;
-	esac
-    fi
-    if [ ! -f lex.yy.c ]; then
-	echo 'main() { return 0; }' >lex.yy.c
-    fi
-    ;;
-
-  help2man)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-	 you modified a dependency of a manual page.  You may need the
-	 \`Help2man' package in order for those modifications to take
-	 effect.  You can get \`Help2man' from any GNU archive site."
-
-    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
-    if test -z "$file"; then
-	file=`echo "$*" | sed -n 's/.*--output=\([^ ]*\).*/\1/p'`
-    fi
-    if [ -f "$file" ]; then
-	touch $file
-    else
-	test -z "$file" || exec >$file
-	echo ".ab help2man is required to generate this page"
-	exit 1
-    fi
-    ;;
-
-  makeinfo)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.texi' or \`.texinfo' file, or any other file
-         indirectly affecting the aspect of the manual.  The spurious
-         call might also be the consequence of using a buggy \`make' (AIX,
-         DU, IRIX).  You might want to install the \`Texinfo' package or
-         the \`GNU make' package.  Grab either from any GNU archive site."
-    # The file to touch is that specified with -o ...
-    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
-    if test -z "$file"; then
-      # ... or it is the one specified with @setfilename ...
-      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
-      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $infile`
-      # ... or it is derived from the source name (dir/f.texi becomes f.info)
-      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
-    fi
-    # If the file does not exist, the user really needs makeinfo;
-    # let's fail without touching anything.
-    test -f $file || exit 1
-    touch $file
-    ;;
-
-  tar)
-    shift
-
-    # We have already tried tar in the generic part.
-    # Look for gnutar/gtar before invocation to avoid ugly error
-    # messages.
-    if (gnutar --version > /dev/null 2>&1); then
-       gnutar "$@" && exit 0
-    fi
-    if (gtar --version > /dev/null 2>&1); then
-       gtar "$@" && exit 0
-    fi
-    firstarg="$1"
-    if shift; then
-	case "$firstarg" in
-	*o*)
-	    firstarg=`echo "$firstarg" | sed s/o//`
-	    tar "$firstarg" "$@" && exit 0
-	    ;;
-	esac
-	case "$firstarg" in
-	*h*)
-	    firstarg=`echo "$firstarg" | sed s/h//`
-	    tar "$firstarg" "$@" && exit 0
-	    ;;
-	esac
-    fi
-
-    echo 1>&2 "\
-WARNING: I can't seem to be able to run \`tar' with the given arguments.
-         You may want to install GNU tar or Free paxutils, or check the
-         command line arguments."
-    exit 1
-    ;;
-
-  *)
-    echo 1>&2 "\
-WARNING: \`$1' is needed, and is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.  Check the \`README' file,
-         it often tells you about the needed prerequisites for installing
-         this package.  You may also peek at any GNU archive site, in case
-         some other package would contain this missing \`$1' program."
-    exit 1
-    ;;
-esac
-
-exit 0
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-end: "$"
-# End:

Deleted: trunk/mkinstalldirs
===================================================================
--- trunk/mkinstalldirs	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/mkinstalldirs	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,150 +0,0 @@
-#! /bin/sh
-# mkinstalldirs --- make directory hierarchy
-
-scriptversion=2004-02-15.20
-
-# Original author: Noah Friedman <friedman at prep.ai.mit.edu>
-# Created: 1993-05-16
-# Public domain.
-#
-# This file is maintained in Automake, please report
-# bugs to <bug-automake at gnu.org> or send patches to
-# <automake-patches at gnu.org>.
-
-errstatus=0
-dirmode=""
-
-usage="\
-Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
-
-Create each directory DIR (with mode MODE, if specified), including all
-leading file name components.
-
-Report bugs to <bug-automake at gnu.org>."
-
-# process command line arguments
-while test $# -gt 0 ; do
-  case $1 in
-    -h | --help | --h*)         # -h for help
-      echo "$usage"
-      exit 0
-      ;;
-    -m)                         # -m PERM arg
-      shift
-      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
-      dirmode=$1
-      shift
-      ;;
-    --version)
-      echo "$0 $scriptversion"
-      exit 0
-      ;;
-    --)                         # stop option processing
-      shift
-      break
-      ;;
-    -*)                         # unknown option
-      echo "$usage" 1>&2
-      exit 1
-      ;;
-    *)                          # first non-opt arg
-      break
-      ;;
-  esac
-done
-
-for file
-do
-  if test -d "$file"; then
-    shift
-  else
-    break
-  fi
-done
-
-case $# in
-  0) exit 0 ;;
-esac
-
-# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
-# mkdir -p a/c at the same time, both will detect that a is missing,
-# one will create a, then the other will try to create a and die with
-# a "File exists" error.  This is a problem when calling mkinstalldirs
-# from a parallel make.  We use --version in the probe to restrict
-# ourselves to GNU mkdir, which is thread-safe.
-case $dirmode in
-  '')
-    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
-      echo "mkdir -p -- $*"
-      exec mkdir -p -- "$@"
-    else
-      # On NextStep and OpenStep, the `mkdir' command does not
-      # recognize any option.  It will interpret all options as
-      # directories to create, and then abort because `.' already
-      # exists.
-      test -d ./-p && rmdir ./-p
-      test -d ./--version && rmdir ./--version
-    fi
-    ;;
-  *)
-    if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
-       test ! -d ./--version; then
-      echo "mkdir -m $dirmode -p -- $*"
-      exec mkdir -m "$dirmode" -p -- "$@"
-    else
-      # Clean up after NextStep and OpenStep mkdir.
-      for d in ./-m ./-p ./--version "./$dirmode";
-      do
-        test -d $d && rmdir $d
-      done
-    fi
-    ;;
-esac
-
-for file
-do
-  set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
-  shift
-
-  pathcomp=
-  for d
-  do
-    pathcomp="$pathcomp$d"
-    case $pathcomp in
-      -*) pathcomp=./$pathcomp ;;
-    esac
-
-    if test ! -d "$pathcomp"; then
-      echo "mkdir $pathcomp"
-
-      mkdir "$pathcomp" || lasterr=$?
-
-      if test ! -d "$pathcomp"; then
-	errstatus=$lasterr
-      else
-	if test ! -z "$dirmode"; then
-	  echo "chmod $dirmode $pathcomp"
-	  lasterr=""
-	  chmod "$dirmode" "$pathcomp" || lasterr=$?
-
-	  if test ! -z "$lasterr"; then
-	    errstatus=$lasterr
-	  fi
-	fi
-      fi
-    fi
-
-    pathcomp="$pathcomp/"
-  done
-done
-
-exit $errstatus
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-end: "$"
-# End:

Copied: trunk/sst.py (from rev 809, trunk/src/sst.py)
===================================================================
--- trunk/sst.py	                        (rev 0)
+++ trunk/sst.py	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,6339 @@
+#!/usr/bin/env python
+"""
+sst.py -- Super Star Trek 2K
+
+SST2K is a Python translation of a C translation of a FORTRAN
+original dating back to 1973.  Beautiful Python it is not, but it
+works.  Translation by Eric S. Raymond; original game by David Matuszek
+and Paul Reynolds, with modifications by Don Smith, Tom Almy,
+Stas Sergeev, and Eric S. Raymond.
+
+See the doc/HACKING file in the distribution for designers notes and advice
+on how to modify (and how not to modify!) this code.
+"""
+import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
+
+docpath  	= (".", "../doc", "/usr/share/doc/sst")
+
+def _(str): return gettext.gettext(str)
+
+GALSIZE 	= 8		# Galaxy size in quadrants
+NINHAB  	= (GALSIZE * GALSIZE / 2)	# Number of inhabited worlds
+MAXUNINHAB	= 10		# Maximum uninhabited worlds
+QUADSIZE	= 10		# Quadrant size in sectors
+BASEMIN		= 2				# Minimum starbases
+BASEMAX 	= (GALSIZE * GALSIZE / 12)	# Maximum starbases
+MAXKLGAME	= 127		# Maximum Klingons per game
+MAXKLQUAD	= 9		# Maximum Klingons per quadrant
+FULLCREW	= 428		# Crew size. BSD Trek was 387, that's wrong 
+FOREVER 	= 1e30		# Time for the indefinite future
+MAXBURST	= 3		# Max # of torps you can launch in one turn
+MINCMDR 	= 10		# Minimum number of Klingon commanders
+DOCKFAC		= 0.25		# Repair faster when docked
+PHASEFAC	= 2.0		# Unclear what this is, it was in the C version
+
+DEFAULT      = -1
+BLACK        = 0
+BLUE         = 1
+GREEN        = 2
+CYAN         = 3
+RED          = 4
+MAGENTA      = 5
+BROWN        = 6
+LIGHTGRAY    = 7
+DARKGRAY     = 8
+LIGHTBLUE    = 9
+LIGHTGREEN   = 10
+LIGHTCYAN    = 11
+LIGHTRED     = 12
+LIGHTMAGENTA = 13
+YELLOW       = 14
+WHITE        = 15
+
+class TrekError:
+    pass
+
+class coord:
+    def __init__(self, x=None, y=None):
+        self.i = x
+        self.j = y
+    def valid_quadrant(self):
+        return self.i>=0 and self.i<GALSIZE and self.j>=0 and self.j<GALSIZE
+    def valid_sector(self):
+	return self.i>=0 and self.i<QUADSIZE and self.j>=0 and self.j<QUADSIZE
+    def invalidate(self):
+        self.i = self.j = None
+    def is_valid(self):
+        return self.i != None and self.j != None
+    def __eq__(self, other):
+        return other != None and self.i == other.i and self.j == other.j
+    def __ne__(self, other):
+        return other == None or self.i != other.i or self.j != other.j
+    def __add__(self, other):
+        return coord(self.i+other.i, self.j+other.j)
+    def __sub__(self, other):
+        return coord(self.i-other.i, self.j-other.j)
+    def __mul__(self, other):
+        return coord(self.i*other, self.j*other)
+    def __rmul__(self, other):
+        return coord(self.i*other, self.j*other)
+    def __div__(self, other):
+        return coord(self.i/other, self.j/other)
+    def __mod__(self, other):
+        return coord(self.i % other, self.j % other)
+    def __rdiv__(self, other):
+        return coord(self.i/other, self.j/other)
+    def roundtogrid(self):
+        return coord(int(round(self.i)), int(round(self.j)))
+    def distance(self, other=None):
+        if not other: other = coord(0, 0)
+        return math.sqrt((self.i - other.i)**2 + (self.j - other.j)**2)
+    def bearing(self):
+        return 1.90985*math.atan2(self.j, self.i)
+    def sgn(self):
+        s = coord()
+        if self.i == 0:
+            s.i = 0
+        else:
+            s.i = self.i / abs(self.i)
+        if self.j == 0:
+            s.j = 0
+        else:
+            s.j = self.j / abs(self.j)
+        return s
+    def quadrant(self):
+        #print "Location %s -> %s" % (self, (self / QUADSIZE).roundtogrid())
+        return self.roundtogrid() / QUADSIZE
+    def sector(self):
+        return self.roundtogrid() % QUADSIZE
+    def scatter(self):
+        s = coord()
+        s.i = self.i + randrange(-1, 2)
+        s.j = self.j + randrange(-1, 2)
+        return s
+    def __str__(self):
+        if self.i == None or self.j == None:
+            return "Nowhere"
+        return "%s - %s" % (self.i+1, self.j+1)
+    __repr__ = __str__
+
+class planet:
+    def __init__(self):
+        self.name = None	# string-valued if inhabited
+        self.quadrant = coord()	# quadrant located
+        self.pclass = None	# could be ""M", "N", "O", or "destroyed"
+        self.crystals = "absent"# could be "mined", "present", "absent"
+        self.known = "unknown"	# could be "unknown", "known", "shuttle_down"
+        self.inhabited = False	# is it inhabites?
+    def __str__(self):
+        return self.name
+
+class quadrant:
+    def __init__(self):
+        self.stars = 0
+        self.planet = None
+	self.starbase = False
+	self.klingons = 0
+	self.romulans = 0
+	self.supernova = False
+	self.charted = False
+        self.status = "secure"	# Could be "secure", "distressed", "enslaved"
+
+class page:
+    def __init__(self):
+	self.stars = None
+	self.starbase = None
+	self.klingons = None
+
+def fill2d(size, fillfun):
+    "Fill an empty list in 2D."
+    lst = []
+    for i in range(size):
+        lst.append([]) 
+        for j in range(size):
+            lst[i].append(fillfun(i, j))
+    return lst
+
+class snapshot:
+    def __init__(self):
+        self.snap = False	# snapshot taken
+        self.crew = 0   	# crew complement
+	self.remkl = 0  	# remaining klingons
+	self.nscrem = 0		# remaining super commanders
+	self.starkl = 0 	# destroyed stars
+	self.basekl = 0 	# destroyed bases
+	self.nromrem = 0	# Romulans remaining
+	self.nplankl = 0	# destroyed uninhabited planets
+	self.nworldkl = 0	# destroyed inhabited planets
+        self.planets = []	# Planet information
+        self.date = 0.0   	# stardate
+	self.remres = 0 	# remaining resources
+	self.remtime = 0	# remaining time
+        self.baseq = [] 	# Base quadrant coordinates
+        self.kcmdr = [] 	# Commander quadrant coordinates
+	self.kscmdr = coord()	# Supercommander quadrant coordinates
+        # the galaxy
+        self.galaxy = fill2d(GALSIZE, lambda i, j: quadrant())
+        # the starchart
+    	self.chart = fill2d(GALSIZE, lambda i, j: page())
+
+class event:
+    def __init__(self):
+        self.date = None	# A real number
+        self.quadrant = None	# A coord structure
+
+# game options 
+OPTION_ALL	= 0xffffffff
+OPTION_TTY	= 0x00000001	# old interface 
+OPTION_CURSES	= 0x00000002	# new interface 
+OPTION_IOMODES	= 0x00000003	# cover both interfaces 
+OPTION_PLANETS	= 0x00000004	# planets and mining 
+OPTION_THOLIAN	= 0x00000008	# Tholians and their webs (UT 1979 version)
+OPTION_THINGY	= 0x00000010	# Space Thingy can shoot back (Stas, 2005)
+OPTION_PROBE	= 0x00000020	# deep-space probes (DECUS version, 1980)
+OPTION_SHOWME	= 0x00000040	# bracket Enterprise in chart 
+OPTION_RAMMING	= 0x00000080	# enemies may ram Enterprise (Almy)
+OPTION_MVBADDY	= 0x00000100	# more enemies can move (Almy)
+OPTION_BLKHOLE	= 0x00000200	# black hole may timewarp you (Stas, 2005) 
+OPTION_BASE	= 0x00000400	# bases have good shields (Stas, 2005)
+OPTION_WORLDS	= 0x00000800	# logic for inhabited worlds (ESR, 2006)
+OPTION_AUTOSCAN	= 0x00001000	# automatic LRSCAN before CHART (ESR, 2006)
+OPTION_PLAIN	= 0x01000000	# user chose plain game 
+OPTION_ALMY	= 0x02000000	# user chose Almy variant 
+OPTION_COLOR    = 0x04000000	# enable color display (experimental, ESR, 2010)
+
+# Define devices 
+DSRSENS	= 0
+DLRSENS	= 1
+DPHASER	= 2
+DPHOTON	= 3
+DLIFSUP	= 4
+DWARPEN	= 5
+DIMPULS	= 6
+DSHIELD	= 7
+DRADIO	= 0
+DSHUTTL = 9
+DCOMPTR = 10
+DNAVSYS	= 11
+DTRANSP = 12
+DSHCTRL	= 13
+DDRAY	= 14
+DDSP	= 15
+NDEVICES= 16	# Number of devices
+
+SKILL_NONE	= 0
+SKILL_NOVICE	= 1
+SKILL_FAIR	= 2
+SKILL_GOOD	= 3
+SKILL_EXPERT	= 4
+SKILL_EMERITUS	= 5
+
+def damaged(dev):	return (game.damage[dev] != 0.0)
+def communicating():	return not damaged(DRADIO) or game.condition=="docked"
+
+# Define future events 
+FSPY	= 0	# Spy event happens always (no future[] entry)
+		# can cause SC to tractor beam Enterprise
+FSNOVA  = 1	# Supernova
+FTBEAM  = 2	# Commander tractor beams Enterprise
+FSNAP   = 3	# Snapshot for time warp
+FBATTAK = 4	# Commander attacks base
+FCDBAS  = 5	# Commander destroys base
+FSCMOVE = 6	# Supercommander moves (might attack base)
+FSCDBAS = 7	# Supercommander destroys base
+FDSPROB = 8	# Move deep space probe
+FDISTR	= 9	# Emit distress call from an inhabited world 
+FENSLV	= 10	# Inhabited word is enslaved */
+FREPRO	= 11	# Klingons build a ship in an enslaved system
+NEVENTS	= 12
+
+# Abstract out the event handling -- underlying data structures will change
+# when we implement stateful events 
+def findevent(evtype):	return game.future[evtype]
+
+class enemy:
+    def __init__(self, type=None, loc=None, power=None):
+        self.type = type
+        self.location = coord()
+        if loc:
+            self.move(loc)
+        self.power = power	# enemy energy level
+        game.enemies.append(self)
+    def move(self, loc):
+        motion = (loc != self.location)
+        if self.location.i is not None and self.location.j is not None:
+            if motion:
+                if self.type == 'T':
+                    game.quad[self.location.i][self.location.j] = '#'
+                else:
+                    game.quad[self.location.i][self.location.j] = '.'
+        if loc:
+            self.location = copy.copy(loc)
+            game.quad[self.location.i][self.location.j] = self.type
+            self.kdist = self.kavgd = (game.sector - loc).distance()
+        else:
+            self.location = coord()
+            self.kdist = self.kavgd = None
+            game.enemies.remove(self)
+        return motion
+    def __repr__(self):
+        return "<%s,%s.%f>" % (self.type, self.location, self.power)	# For debugging
+
+class gamestate:
+    def __init__(self):
+        self.options = None	# Game options
+        self.state = snapshot()	# A snapshot structure
+        self.snapsht = snapshot()	# Last snapshot taken for time-travel purposes
+        self.quad = None	# contents of our quadrant
+        self.damage = [0.0] * NDEVICES	# damage encountered
+        self.future = []		# future events
+        for i in range(NEVENTS):
+            self.future.append(event())
+        self.passwd  = None;		# Self Destruct password
+        self.enemies = []
+        self.quadrant = None	# where we are in the large
+        self.sector = None	# where we are in the small
+        self.tholian = None	# Tholian enemy object
+        self.base = None	# position of base in current quadrant
+        self.battle = None	# base coordinates being attacked
+        self.plnet = None	# location of planet in quadrant
+        self.gamewon = False	# Finished!
+        self.ididit = False	# action taken -- allows enemy to attack
+        self.alive = False	# we are alive (not killed)
+        self.justin = False	# just entered quadrant
+        self.shldup = False	# shields are up
+        self.shldchg = False	# shield is changing (affects efficiency)
+        self.iscate = False	# super commander is here
+        self.ientesc = False	# attempted escape from supercommander
+        self.resting = False	# rest time
+        self.icraft = False	# Kirk in Galileo
+        self.landed = False	# party on planet (true), on ship (false)
+        self.alldone = False	# game is now finished
+        self.neutz = False	# Romulan Neutral Zone
+        self.isarmed = False	# probe is armed
+        self.inorbit = False	# orbiting a planet
+        self.imine = False	# mining
+        self.icrystl = False	# dilithium crystals aboard
+        self.iseenit = False	# seen base attack report
+        self.thawed = False	# thawed game
+        self.condition = None	# "green", "yellow", "red", "docked", "dead"
+        self.iscraft = None	# "onship", "offship", "removed"
+        self.skill = None	# Player skill level
+        self.inkling = 0	# initial number of klingons
+        self.inbase = 0		# initial number of bases
+        self.incom = 0		# initial number of commanders
+        self.inscom = 0		# initial number of commanders
+        self.inrom = 0		# initial number of commanders
+        self.instar = 0		# initial stars
+        self.intorps = 0	# initial/max torpedoes
+        self.torps = 0		# number of torpedoes
+        self.ship = 0		# ship type -- 'E' is Enterprise
+        self.abandoned = 0	# count of crew abandoned in space
+        self.length = 0		# length of game
+        self.klhere = 0		# klingons here
+        self.casual = 0		# causalties
+        self.nhelp = 0		# calls for help
+        self.nkinks = 0		# count of energy-barrier crossings
+        self.iplnet = None	# planet # in quadrant
+        self.inplan = 0		# initial planets
+        self.irhere = 0		# Romulans in quadrant
+        self.isatb = 0		# =2 if super commander is attacking base
+        self.tourn = None	# tournament number
+        self.nprobes = 0	# number of probes available
+        self.inresor = 0.0	# initial resources
+        self.intime = 0.0	# initial time
+        self.inenrg = 0.0	# initial/max energy
+        self.inshld = 0.0	# initial/max shield
+        self.inlsr = 0.0	# initial life support resources
+        self.indate = 0.0	# initial date
+        self.energy = 0.0	# energy level
+        self.shield = 0.0	# shield level
+        self.warpfac = 0.0	# warp speed
+        self.lsupres = 0.0	# life support reserves
+        self.optime = 0.0	# time taken by current operation
+        self.damfac = 0.0	# damage factor
+        self.lastchart = 0.0	# time star chart was last updated
+        self.cryprob = 0.0	# probability that crystal will work
+        self.probe = None	# object holding probe course info
+        self.height = 0.0	# height of orbit around planet
+    def recompute(self):
+        # Stas thinks this should be (C expression): 
+        # game.state.remkl + len(game.state.kcmdr) > 0 ?
+	#	game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr)) : 99
+        # He says the existing expression is prone to divide-by-zero errors
+        # after killing the last klingon when score is shown -- perhaps also
+        # if the only remaining klingon is SCOM.
+        game.state.remtime = game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr))
+
+FWON = 0
+FDEPLETE = 1
+FLIFESUP = 2
+FNRG = 3
+FBATTLE = 4
+FNEG3 = 5
+FNOVA = 6
+FSNOVAED = 7
+FABANDN = 8
+FDILITHIUM = 9
+FMATERIALIZE = 10
+FPHASER = 11
+FLOST = 12
+FMINING = 13
+FDPLANET = 14
+FPNOVA = 15
+FSSC = 16
+FSTRACTOR = 17
+FDRAY = 18
+FTRIBBLE = 19
+FHOLE = 20
+FCREW = 21
+
+def withprob(p):
+    return random.random() < p
+
+def randrange(*args):
+    return random.randrange(*args)
+
+def randreal(*args):
+    v = random.random()
+    if len(args) == 1:
+        v *= args[0] 		# from [0, args[0])
+    elif len(args) == 2:
+        v = args[0] + v*(args[1]-args[0])	# from [args[0], args[1])
+    return v
+
+# Code from ai.c begins here
+
+def welcoming(iq):
+    "Would this quadrant welcome another Klingon?"
+    return iq.valid_quadrant() and \
+	not game.state.galaxy[iq.i][iq.j].supernova and \
+	game.state.galaxy[iq.i][iq.j].klingons < MAXKLQUAD
+
+def tryexit(enemy, look, irun):
+    "A bad guy attempts to bug out."
+    iq = coord()
+    iq.i = game.quadrant.i+(look.i+(QUADSIZE-1))/QUADSIZE - 1
+    iq.j = game.quadrant.j+(look.j+(QUADSIZE-1))/QUADSIZE - 1
+    if not welcoming(iq):
+	return False;
+    if enemy.type == 'R':
+	return False; # Romulans cannot escape! 
+    if not irun:
+	# avoid intruding on another commander's territory 
+	if enemy.type == 'C':
+            if iq in game.state.kcmdr:
+                return False
+	    # refuse to leave if currently attacking starbase 
+	    if game.battle == game.quadrant:
+		return False
+	# don't leave if over 1000 units of energy 
+	if enemy.power > 1000.0:
+	    return False
+    # emit escape message and move out of quadrant.
+    # we know this if either short or long range sensors are working
+    if not damaged(DSRSENS) or not damaged(DLRSENS) or \
+	game.condition == "docked":
+	prout(crmena(True, enemy.type, "sector", enemy.location) + \
+              (_(" escapes to Quadrant %s (and regains strength).") % q))
+    # handle local matters related to escape
+    enemy.move(None)
+    game.klhere -= 1
+    if game.condition != "docked":
+	newcnd()
+    # Handle global matters related to escape 
+    game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
+    game.state.galaxy[iq.i][iq.j].klingons += 1
+    if enemy.type=='S':
+	game.iscate = False
+	game.ientesc = False
+	game.isatb = 0
+	schedule(FSCMOVE, 0.2777)
+	unschedule(FSCDBAS)
+	game.state.kscmdr=iq
+    else:
+	for cmdr in game.state.kcmdr:
+	    if cmdr == game.quadrant:
+		game.state.kcmdr[n] = iq
+		break
+    return True; # success 
+
+# The bad-guy movement algorithm:
+# 
+# 1. Enterprise has "force" based on condition of phaser and photon torpedoes.
+# If both are operating full strength, force is 1000. If both are damaged,
+# force is -1000. Having shields down subtracts an additional 1000.
+# 
+# 2. Enemy has forces equal to the energy of the attacker plus
+# 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
+# 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
+# 
+# Attacker Initial energy levels (nominal):
+# Klingon   Romulan   Commander   Super-Commander
+# Novice    400        700        1200        
+# Fair      425        750        1250
+# Good      450        800        1300        1750
+# Expert    475        850        1350        1875
+# Emeritus  500        900        1400        2000
+# VARIANCE   75        200         200         200
+# 
+# Enemy vessels only move prior to their attack. In Novice - Good games
+# only commanders move. In Expert games, all enemy vessels move if there
+# is a commander present. In Emeritus games all enemy vessels move.
+# 
+# 3. If Enterprise is not docked, an aggressive action is taken if enemy
+# forces are 1000 greater than Enterprise.
+# 
+# Agressive action on average cuts the distance between the ship and
+# the enemy to 1/4 the original.
+# 
+# 4.  At lower energy advantage, movement units are proportional to the
+# advantage with a 650 advantage being to hold ground, 800 to move forward
+# 1, 950 for two, 150 for back 4, etc. Variance of 100.
+# 
+# If docked, is reduced by roughly 1.75*game.skill, generally forcing a
+# retreat, especially at high skill levels.
+# 
+# 5.  Motion is limited to skill level, except for SC hi-tailing it out.
+
+def movebaddy(enemy):
+    "Tactical movement for the bad guys."
+    next = coord(); look = coord()
+    irun = False
+    # This should probably be just (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant) 
+    if game.skill >= SKILL_EXPERT:
+	nbaddys = (((game.quadrant in game.state.kcmdr)*2 + (game.state.kscmdr==game.quadrant)*2+game.klhere*1.23+game.irhere*1.5)/2.0)
+    else:
+	nbaddys = (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant)
+    dist1 = enemy.kdist
+    mdist = int(dist1 + 0.5); # Nearest integer distance 
+    # If SC, check with spy to see if should hi-tail it 
+    if enemy.type=='S' and \
+	(enemy.power <= 500.0 or (game.condition=="docked" and not damaged(DPHOTON))):
+	irun = True
+	motion = -QUADSIZE
+    else:
+	# decide whether to advance, retreat, or hold position 
+	forces = enemy.power+100.0*len(game.enemies)+400*(nbaddys-1)
+	if not game.shldup:
+	    forces += 1000; # Good for enemy if shield is down! 
+	if not damaged(DPHASER) or not damaged(DPHOTON):
+            if damaged(DPHASER): # phasers damaged 
+		forces += 300.0
+	    else:
+		forces -= 0.2*(game.energy - 2500.0)
+	    if damaged(DPHOTON): # photon torpedoes damaged 
+		forces += 300.0
+	    else:
+		forces -= 50.0*game.torps
+	else:
+	    # phasers and photon tubes both out! 
+	    forces += 1000.0
+	motion = 0
+        if forces <= 1000.0 and game.condition != "docked": # Typical situation 
+	    motion = ((forces + randreal(200))/150.0) - 5.0
+	else:
+            if forces > 1000.0: # Very strong -- move in for kill 
+		motion = (1.0 - randreal())**2 * dist1 + 1.0
+	    if game.condition=="docked" and (game.options & OPTION_BASE): # protected by base -- back off ! 
+		motion -= game.skill*(2.0-randreal()**2)
+	if idebug:
+	    proutn("=== MOTION = %d, FORCES = %1.2f, " % (motion, forces))
+	# don't move if no motion 
+	if motion==0:
+	    return
+	# Limit motion according to skill 
+	if abs(motion) > game.skill:
+            if motion < 0:
+                motion = -game.skill
+            else:
+                motion = game.skill
+    # calculate preferred number of steps 
+    nsteps = abs(int(motion))
+    if motion > 0 and nsteps > mdist:
+	nsteps = mdist; # don't overshoot 
+    if nsteps > QUADSIZE:
+	nsteps = QUADSIZE; # This shouldn't be necessary 
+    if nsteps < 1:
+	nsteps = 1; # This shouldn't be necessary 
+    if idebug:
+	proutn("NSTEPS = %d:" % nsteps)
+    # Compute preferred values of delta X and Y 
+    m = game.sector - enemy.location
+    if 2.0 * abs(m.i) < abs(m.j):
+	m.i = 0
+    if 2.0 * abs(m.j) < abs(game.sector.i-enemy.location.i):
+	m.j = 0
+    m = (motion * m).sgn()
+    next = enemy.location
+    # main move loop 
+    for ll in range(nsteps):
+	if idebug:
+	    proutn(" %d" % (ll+1))
+	# Check if preferred position available 
+	look = next + m
+        if m.i < 0:
+            krawli = 1
+        else:
+            krawli = -1
+        if m.j < 0:
+            krawlj = 1
+        else:
+            krawlj = -1
+	success = False
+	attempts = 0; # Settle mysterious hang problem 
+	while attempts < 20 and not success:
+            attempts += 1
+	    if look.i < 0 or look.i >= QUADSIZE:
+		if motion < 0 and tryexit(enemy, look, irun):
+		    return
+		if krawli == m.i or m.j == 0:
+		    break
+		look.i = next.i + krawli
+		krawli = -krawli
+	    elif look.j < 0 or look.j >= QUADSIZE:
+		if motion < 0 and tryexit(enemy, look, irun):
+		    return
+		if krawlj == m.j or m.i == 0:
+		    break
+		look.j = next.j + krawlj
+		krawlj = -krawlj
+	    elif (game.options & OPTION_RAMMING) and game.quad[look.i][look.j] != '.':
+		# See if enemy should ram ship 
+		if game.quad[look.i][look.j] == game.ship and \
+		    (enemy.type == 'C' or enemy.type == 'S'):
+		    collision(rammed=True, enemy=enemy)
+		    return
+		if krawli != m.i and m.j != 0:
+		    look.i = next.i + krawli
+		    krawli = -krawli
+		elif krawlj != m.j and m.i != 0:
+		    look.j = next.j + krawlj
+		    krawlj = -krawlj
+		else:
+		    break; # we have failed 
+	    else:
+		success = True
+	if success:
+	    next = look
+	    if idebug:
+		proutn(`next`)
+	else:
+	    break; # done early 
+    if idebug:
+	skip(1)
+    if enemy.move(next):
+	if not damaged(DSRSENS) or game.condition == "docked":
+	    proutn(_("*** %s from Sector %s") % (cramen(enemy.type), enemy.location))
+	    if enemy.kdist < dist1:
+		proutn(_(" advances to "))
+	    else:
+		proutn(_(" retreats to "))
+	    prout("Sector %s." % next)
+
+def moveklings():
+    "Sequence Klingon tactical movement."
+    if idebug:
+	prout("== MOVCOM")
+    # Figure out which Klingon is the commander (or Supercommander)
+    # and do move
+    if game.quadrant in game.state.kcmdr:
+        for enemy in game.enemies:
+	    if enemy.type == 'C':
+		movebaddy(enemy)
+    if game.state.kscmdr==game.quadrant:
+        for enemy in game.enemies:
+	    if enemy.type == 'S':
+		movebaddy(enemy)
+		break
+    # If skill level is high, move other Klingons and Romulans too!
+    # Move these last so they can base their actions on what the
+    # commander(s) do.
+    if game.skill >= SKILL_EXPERT and (game.options & OPTION_MVBADDY):
+        for enemy in game.enemies:
+            if enemy.type in ('K', 'R'):
+		movebaddy(enemy)
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+
+def movescom(iq, avoid):
+    "Commander movement helper." 
+    # Avoid quadrants with bases if we want to avoid Enterprise 
+    if not welcoming(iq) or (avoid and iq in game.state.baseq):
+	return False
+    if game.justin and not game.iscate:
+	return False
+    # do the move 
+    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons -= 1
+    game.state.kscmdr = iq
+    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons += 1
+    if game.state.kscmdr==game.quadrant:
+	# SC has scooted, remove him from current quadrant 
+	game.iscate=False
+	game.isatb=0
+	game.ientesc = False
+	unschedule(FSCDBAS)
+	for enemy in game.enemies:
+	    if enemy.type == 'S':
+		break
+	enemy.move(None)
+	game.klhere -= 1
+	if game.condition != "docked":
+	    newcnd()
+        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    # check for a helpful planet 
+    for i in range(game.inplan):
+	if game.state.planets[i].quadrant == game.state.kscmdr and \
+	    game.state.planets[i].crystals == "present":
+	    # destroy the planet 
+	    game.state.planets[i].pclass = "destroyed"
+	    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].planet = None
+	    if communicating():
+		announce()
+		prout(_("Lt. Uhura-  \"Captain, Starfleet Intelligence reports"))
+		proutn(_("   a planet in Quadrant %s has been destroyed") % game.state.kscmdr)
+		prout(_("   by the Super-commander.\""))
+	    break
+    return True; # looks good! 
+			
+def supercommander():
+    "Move the Super Commander." 
+    iq = coord(); sc = coord(); ibq = coord(); idelta = coord()
+    basetbl = []
+    if idebug:
+	prout("== SUPERCOMMANDER")
+    # Decide on being active or passive 
+    avoid = ((game.incom - len(game.state.kcmdr) + game.inkling - game.state.remkl)/(game.state.date+0.01-game.indate) < 0.1*game.skill*(game.skill+1.0) or \
+	    (game.state.date-game.indate) < 3.0)
+    if not game.iscate and avoid:
+	# compute move away from Enterprise 
+	idelta = game.state.kscmdr-game.quadrant
+	if idelta.distance() > 2.0:
+	    # circulate in space 
+	    idelta.i = game.state.kscmdr.j-game.quadrant.j
+	    idelta.j = game.quadrant.i-game.state.kscmdr.i
+    else:
+	# compute distances to starbases 
+	if not game.state.baseq:
+	    # nothing left to do 
+	    unschedule(FSCMOVE)
+	    return
+	sc = game.state.kscmdr
+        for base in game.state.baseq:
+	    basetbl.append((i, (base - sc).distance()))
+	if game.state.baseq > 1:
+            basetbl.sort(lambda x, y: cmp(x[1]. y[1]))
+	# look for nearest base without a commander, no Enterprise, and
+        # without too many Klingons, and not already under attack. 
+	ifindit = iwhichb = 0
+	for (i2, base) in enumerate(game.state.baseq):
+	    i = basetbl[i2][0];	# bug in original had it not finding nearest
+	    if base==game.quadrant or base==game.battle or not welcoming(base):
+		continue
+	    # if there is a commander, and no other base is appropriate,
+	    # we will take the one with the commander
+            for cmdr in game.state.kcmdr:
+		if base == cmdr and ifindit != 2:
+		    ifindit = 2
+		    iwhichb = i
+		    break
+	    else:	# no commander -- use this one 
+		ifindit = 1
+		iwhichb = i
+		break
+	if ifindit==0:
+	    return # Nothing suitable -- wait until next time
+	ibq = game.state.baseq[iwhichb]
+	# decide how to move toward base 
+	idelta = ibq - game.state.kscmdr
+    # Maximum movement is 1 quadrant in either or both axes 
+    idelta = idelta.sgn()
+    # try moving in both x and y directions
+    # there was what looked like a bug in the Almy C code here,
+    # but it might be this translation is just wrong.
+    iq = game.state.kscmdr + idelta
+    if not movescom(iq, avoid):
+	# failed -- try some other maneuvers 
+	if idelta.i==0 or idelta.j==0:
+	    # attempt angle move 
+	    if idelta.i != 0:
+		iq.j = game.state.kscmdr.j + 1
+		if not movescom(iq, avoid):
+		    iq.j = game.state.kscmdr.j - 1
+		    movescom(iq, avoid)
+	    elif idelta.j != 0:
+		iq.i = game.state.kscmdr.i + 1
+		if not movescom(iq, avoid):
+		    iq.i = game.state.kscmdr.i - 1
+		    movescom(iq, avoid)
+	else:
+	    # try moving just in x or y 
+	    iq.j = game.state.kscmdr.j
+	    if not movescom(iq, avoid):
+		iq.j = game.state.kscmdr.j + idelta.j
+		iq.i = game.state.kscmdr.i
+		movescom(iq, avoid)
+    # check for a base 
+    if len(game.state.baseq) == 0:
+	unschedule(FSCMOVE)
+    else:
+        for ibq in game.state.baseq:
+	    if ibq == game.state.kscmdr and game.state.kscmdr == game.battle:
+		# attack the base 
+		if avoid:
+		    return # no, don't attack base! 
+		game.iseenit = False
+		game.isatb = 1
+		schedule(FSCDBAS, randreal(1.0, 3.0))
+		if is_scheduled(FCDBAS):
+		    postpone(FSCDBAS, scheduled(FCDBAS)-game.state.date)
+		if not communicating():
+		    return # no warning 
+		game.iseenit = True
+		announce()
+		prout(_("Lt. Uhura-  \"Captain, the starbase in Quadrant %s") \
+                      % game.state.kscmdr)
+		prout(_("   reports that it is under attack from the Klingon Super-commander."))
+		proutn(_("   It can survive until stardate %d.\"") \
+                       % int(scheduled(FSCDBAS)))
+		if not game.resting:
+		    return
+		prout(_("Mr. Spock-  \"Captain, shall we cancel the rest period?\""))
+		if ja() == False:
+		    return
+		game.resting = False
+		game.optime = 0.0; # actually finished 
+		return
+    # Check for intelligence report 
+    if not idebug and \
+	(withprob(0.8) or \
+	 (not communicating()) or \
+	 not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].charted):
+	return
+    announce()
+    prout(_("Lt. Uhura-  \"Captain, Starfleet Intelligence reports"))
+    proutn(_("   the Super-commander is in Quadrant %s,") % game.state.kscmdr)
+    return
+
+def movetholian():
+    "Move the Tholian."
+    if not game.tholian or game.justin:
+	return
+    id = coord()
+    if game.tholian.location.i == 0 and game.tholian.location.j == 0:
+	id.i = 0; id.j = QUADSIZE-1
+    elif game.tholian.location.i == 0 and game.tholian.location.j == QUADSIZE-1:
+	id.i = QUADSIZE-1; id.j = QUADSIZE-1
+    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == QUADSIZE-1:
+	id.i = QUADSIZE-1; id.j = 0
+    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == 0:
+	id.i = 0; id.j = 0
+    else:
+	# something is wrong! 
+	game.tholian.move(None)
+        prout("***Internal error: Tholian in a bad spot.")
+	return
+    # do nothing if we are blocked 
+    if game.quad[id.i][id.j] not in ('.', '#'):
+	return
+    here = copy.copy(game.tholian.location)
+    delta = (id - game.tholian.location).sgn()
+    # move in x axis 
+    while here.i != id.i:
+        here.i += delta.i
+        if game.quad[here.i][here.j]=='.':
+            game.tholian.move(here)
+    # move in y axis 
+    while here.j != id.j:
+        here.j += delta.j
+        if game.quad[here.i][here.j]=='.':
+            game.tholian.move(here)
+    # check to see if all holes plugged 
+    for i in range(QUADSIZE):
+	if game.quad[0][i]!='#' and game.quad[0][i]!='T':
+	    return
+	if game.quad[QUADSIZE-1][i]!='#' and game.quad[QUADSIZE-1][i]!='T':
+	    return
+	if game.quad[i][0]!='#' and game.quad[i][0]!='T':
+	    return
+	if game.quad[i][QUADSIZE-1]!='#' and game.quad[i][QUADSIZE-1]!='T':
+	    return
+    # All plugged up -- Tholian splits 
+    game.quad[game.tholian.location.i][game.tholian.location.j]='#'
+    dropin(' ')
+    prout(crmena(True, 'T', "sector", game.tholian) + _(" completes web."))
+    game.tholian.move(None)
+    return
+
+# Code from battle.c begins here
+
+def doshield(shraise):
+    "Change shield status."
+    action = "NONE"
+    game.ididit = False
+    if shraise:
+	action = "SHUP"
+    else:
+	key = scanner.next()
+	if key == "IHALPHA":
+	    if scanner.sees("transfer"):
+		action = "NRG"
+	    else:
+		if damaged(DSHIELD):
+		    prout(_("Shields damaged and down."))
+		    return
+		if scanner.sees("up"):
+		    action = "SHUP"
+		elif scanner.sees("down"):
+		    action = "SHDN"
+	if action=="NONE":
+	    proutn(_("Do you wish to change shield energy? "))
+	    if ja() == True:
+		action = "NRG"
+	    elif damaged(DSHIELD):
+		prout(_("Shields damaged and down."))
+		return
+	    elif game.shldup:
+		proutn(_("Shields are up. Do you want them down? "))
+		if ja() == True:
+		    action = "SHDN"
+		else:
+		    scanner.chew()
+		    return
+	    else:
+		proutn(_("Shields are down. Do you want them up? "))
+		if ja() == True:
+		    action = "SHUP"
+		else:
+		    scanner.chew()
+		    return    
+    if action == "SHUP": # raise shields 
+	if game.shldup:
+	    prout(_("Shields already up."))
+	    return
+	game.shldup = True
+	game.shldchg = True
+	if game.condition != "docked":
+	    game.energy -= 50.0
+	prout(_("Shields raised."))
+	if game.energy <= 0:
+	    skip(1)
+	    prout(_("Shields raising uses up last of energy."))
+	    finish(FNRG)
+	    return
+	game.ididit=True
+	return
+    elif action == "SHDN":
+	if not game.shldup:
+	    prout(_("Shields already down."))
+	    return
+	game.shldup=False
+	game.shldchg=True
+	prout(_("Shields lowered."))
+	game.ididit = True
+	return
+    elif action == "NRG":
+	while scanner.next() != "IHREAL":
+	    scanner.chew()
+	    proutn(_("Energy to transfer to shields- "))
+        nrg = scanner.real
+	scanner.chew()
+	if nrg == 0:
+	    return
+	if nrg > game.energy:
+	    prout(_("Insufficient ship energy."))
+	    return
+	game.ididit = True
+	if game.shield+nrg >= game.inshld:
+	    prout(_("Shield energy maximized."))
+	    if game.shield+nrg > game.inshld:
+		prout(_("Excess energy requested returned to ship energy"))
+	    game.energy -= game.inshld-game.shield
+	    game.shield = game.inshld
+	    return
+	if nrg < 0.0 and game.energy-nrg > game.inenrg:
+	    # Prevent shield drain loophole 
+	    skip(1)
+	    prout(_("Engineering to bridge--"))
+	    prout(_("  Scott here. Power circuit problem, Captain."))
+	    prout(_("  I can't drain the shields."))
+	    game.ididit = False
+	    return
+	if game.shield+nrg < 0:
+	    prout(_("All shield energy transferred to ship."))
+	    game.energy += game.shield
+	    game.shield = 0.0
+	    return
+	proutn(_("Scotty- \""))
+	if nrg > 0:
+	    prout(_("Transferring energy to shields.\""))
+	else:
+	    prout(_("Draining energy from shields.\""))
+	game.shield += nrg
+	game.energy -= nrg
+	return
+
+def randdevice():
+    "Choose a device to damage, at random."
+    weights = (
+	105,	# DSRSENS: short range scanners	10.5% 
+	105,	# DLRSENS: long range scanners		10.5% 
+	120,	# DPHASER: phasers			12.0% 
+	120,	# DPHOTON: photon torpedoes		12.0% 
+	25,	# DLIFSUP: life support			 2.5% 
+	65,	# DWARPEN: warp drive			 6.5% 
+	70,	# DIMPULS: impulse engines		 6.5% 
+	145,	# DSHIELD: deflector shields		14.5% 
+	30,	# DRADIO:  subspace radio		 3.0% 
+	45,	# DSHUTTL: shuttle			 4.5% 
+	15,	# DCOMPTR: computer			 1.5% 
+	20,	# NAVCOMP: navigation system		 2.0% 
+	75,	# DTRANSP: transporter			 7.5% 
+	20,	# DSHCTRL: high-speed shield controller  2.0% 
+	10,	# DDRAY: death ray			 1.0% 
+	30,	# DDSP: deep-space probes		 3.0% 
+    )
+    assert(sum(weights) == 1000)
+    idx = randrange(1000)
+    sum = 0
+    for (i, w) in enumerate(weights):
+	sum += w
+	if idx < sum:
+	    return i
+    return None;	# we should never get here
+
+def collision(rammed, enemy):
+    "Collision handling fot rammong events."
+    prouts(_("***RED ALERT!  RED ALERT!"))
+    skip(1)
+    prout(_("***COLLISION IMMINENT."))
+    skip(2)
+    proutn("***")
+    proutn(crmshp())
+    hardness = {'R':1.5, 'C':2.0, 'S':2.5, 'T':0.5, '?':4.0}.get(enemy.type, 1.0)
+    if rammed:
+        proutn(_(" rammed by "))
+    else:
+        proutn(_(" rams "))
+    proutn(crmena(False, enemy.type, "sector", enemy.location))
+    if rammed:
+	proutn(_(" (original position)"))
+    skip(1)
+    deadkl(enemy.location, enemy.type, game.sector)
+    proutn("***" + crmship() + " heavily damaged.")
+    icas = randrange(10, 30)
+    prout(_("***Sickbay reports %d casualties"), icas)
+    game.casual += icas
+    game.state.crew -= icas
+    # In the pre-SST2K version, all devices got equiprobably damaged,
+    # which was silly.  Instead, pick up to half the devices at
+    # random according to our weighting table,
+    ncrits = randrange(NDEVICES/2)
+    for m in range(ncrits):
+	dev = randdevice()
+	if game.damage[dev] < 0:
+	    continue
+	extradm = (10.0*hardness*randreal()+1.0)*game.damfac
+	# Damage for at least time of travel! 
+	game.damage[dev] += game.optime + extradm
+    game.shldup = False
+    prout(_("***Shields are down."))
+    if game.state.remkl + len(game.state.kcmdr) + game.state.nscrem:
+	announce()
+	damagereport()
+    else:
+	finish(FWON)
+    return
+
+def torpedo(origin, bearing, dispersion, number, nburst):
+    "Let a photon torpedo fly" 
+    if not damaged(DSRSENS) or game.condition=="docked":
+	setwnd(srscan_window)
+    else: 
+	setwnd(message_window)
+    ac = bearing + 0.25*dispersion	# dispersion is a random variable
+    bullseye = (15.0 - bearing)*0.5235988
+    track = course(bearing=ac, distance=QUADSIZE, origin=cartesian(origin)) 
+    bumpto = coord(0, 0)
+    # Loop to move a single torpedo 
+    setwnd(message_window)
+    for step in range(1, QUADSIZE*2):
+        if not track.next(): break
+        w = track.sector()
+	if not w.valid_sector():
+	    break
+	iquad=game.quad[w.i][w.j]
+	tracktorpedo(origin, w, step, number, nburst, iquad)
+	if iquad=='.':
+	    continue
+	# hit something 
+	if not damaged(DSRSENS) or game.condition == "docked":
+	    skip(1);	# start new line after text track 
+	if iquad in ('E', 'F'): # Hit our ship 
+	    skip(1)
+	    prout(_("Torpedo hits %s.") % crmshp())
+	    hit = 700.0 + randreal(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
+	    newcnd(); # we're blown out of dock 
+	    if game.landed or game.condition=="docked":
+		return hit # Cheat if on a planet 
+            # In the C/FORTRAN version, dispersion was 2.5 radians, which
+            # is 143 degrees, which is almost exactly 4.8 clockface units
+            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
+            displacement.next()
+            bumpto = displacement.sector()
+	    if not bumpto.valid_sector():
+		return hit
+	    if game.quad[bumpto.i][bumpto.j]==' ':
+		finish(FHOLE)
+		return hit
+	    if game.quad[bumpto.i][bumpto.j]!='.':
+		# can't move into object 
+		return hit
+	    game.sector = bumpto
+	    proutn(crmshp())
+            game.quad[w.i][w.j]='.'
+            game.quad[bumpto.i][bumpto.j]=iquad
+            prout(_(" displaced by blast to Sector %s ") % bumpto)
+            for enemy in game.enemies:
+                enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
+            game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+            return None
+	elif iquad in ('C', 'S', 'R', 'K'): # Hit a regular enemy 
+	    # find the enemy 
+	    if iquad in ('C', 'S') and withprob(0.05):
+		prout(crmena(True, iquad, "sector", w) + _(" uses anti-photon device;"))
+		prout(_("   torpedo neutralized."))
+		return None
+            for enemy in game.enemies:
+		if w == enemy.location:
+		    break
+	    kp = math.fabs(enemy.power)
+	    h1 = 700.0 + randrange(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
+	    h1 = math.fabs(h1)
+	    if kp < h1:
+		h1 = kp
+            if enemy.power < 0:
+                enemy.power -= -h1
+            else:
+                enemy.power -= h1
+	    if enemy.power == 0:
+		deadkl(w, iquad, w)
+		return None
+	    proutn(crmena(True, iquad, "sector", w))
+            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
+            displacement.next()
+            bumpto = displacement.sector()
+            if not bumpto.valid_sector():
+		prout(_(" damaged but not destroyed."))
+		return
+	    if game.quad[bumpto.i][bumpto.j] == ' ':
+		prout(_(" buffeted into black hole."))
+		deadkl(w, iquad, bumpto)
+	    if game.quad[bumpto.i][bumpto.j] != '.':
+		prout(_(" damaged but not destroyed."))
+            else:
+                prout(_(" damaged-- displaced by blast to Sector %s ")%bumpto)
+                enemy.location = bumpto
+                game.quad[w.i][w.j]='.'
+                game.quad[bumpto.i][bumpto.j]=iquad
+                for enemy in game.enemies:
+                    enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
+                game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+            return None
+	elif iquad == 'B': # Hit a base 
+	    skip(1)
+	    prout(_("***STARBASE DESTROYED.."))
+            game.state.baseq = filter(lambda x: x != game.quadrant, game.state.baseq)
+	    game.quad[w.i][w.j]='.'
+	    game.base.invalidate()
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase -= 1
+	    game.state.chart[game.quadrant.i][game.quadrant.j].starbase -= 1
+	    game.state.basekl += 1
+	    newcnd()
+	    return None
+	elif iquad == 'P': # Hit a planet 
+	    prout(crmena(True, iquad, "sector", w) + _(" destroyed."))
+	    game.state.nplankl += 1
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+	    game.iplnet.pclass = "destroyed"
+	    game.iplnet = None
+	    game.plnet.invalidate()
+	    game.quad[w.i][w.j] = '.'
+	    if game.landed:
+		# captain perishes on planet 
+		finish(FDPLANET)
+	    return None
+	elif iquad == '@': # Hit an inhabited world -- very bad! 
+	    prout(crmena(True, iquad, "sector", w) + _(" destroyed."))
+	    game.state.nworldkl += 1
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+	    game.iplnet.pclass = "destroyed"
+	    game.iplnet = None
+	    game.plnet.invalidate()
+	    game.quad[w.i][w.j] = '.'
+	    if game.landed:
+		# captain perishes on planet 
+		finish(FDPLANET)
+	    prout(_("The torpedo destroyed an inhabited planet."))
+	    return None
+	elif iquad == '*': # Hit a star 
+	    if withprob(0.9):
+		nova(w)
+            else:
+                prout(crmena(True, '*', "sector", w) + _(" unaffected by photon blast."))
+	    return None
+	elif iquad == '?': # Hit a thingy 
+	    if not (game.options & OPTION_THINGY) or withprob(0.3):
+		skip(1)
+		prouts(_("AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!"))
+		skip(1)
+		prouts(_("    HACK!     HACK!    HACK!        *CHOKE!*  "))
+		skip(1)
+		proutn(_("Mr. Spock-"))
+		prouts(_("  \"Fascinating!\""))
+		skip(1)
+		deadkl(w, iquad, w)
+	    else:
+		# Stas Sergeev added the possibility that
+		# you can shove the Thingy and piss it off.
+		# It then becomes an enemy and may fire at you.
+		thing.angry = True
+		shoved = True
+	    return None
+	elif iquad == ' ': # Black hole 
+	    skip(1)
+	    prout(crmena(True, ' ', "sector", w) + _(" swallows torpedo."))
+	    return None
+	elif iquad == '#': # hit the web 
+	    skip(1)
+	    prout(_("***Torpedo absorbed by Tholian web."))
+	    return None
+	elif iquad == 'T':  # Hit a Tholian 
+	    h1 = 700.0 + randrange(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-angle))
+	    h1 = math.fabs(h1)
+	    if h1 >= 600:
+		game.quad[w.i][w.j] = '.'
+		deadkl(w, iquad, w)
+		game.tholian = None
+		return None
+	    skip(1)
+	    proutn(crmena(True, 'T', "sector", w))
+	    if withprob(0.05):
+		prout(_(" survives photon blast."))
+		return None
+	    prout(_(" disappears."))
+	    game.tholian.move(None)
+	    game.quad[w.i][w.j] = '#'
+	    dropin(' ')
+	    return None
+        else: # Problem!
+	    skip(1)
+	    proutn("Don't know how to handle torpedo collision with ")
+	    proutn(crmena(True, iquad, "sector", w))
+	    skip(1)
+	    return None
+	break
+    skip(1)
+    prout(_("Torpedo missed."))
+    return None;
+
+def fry(hit):
+    "Critical-hit resolution." 
+    if hit < (275.0-25.0*game.skill)*randreal(1.0, 1.5):
+	return
+    ncrit = int(1.0 + hit/(500.0+randreal(100)))
+    proutn(_("***CRITICAL HIT--"))
+    # Select devices and cause damage
+    cdam = []
+    for loop1 in range(ncrit):
+        while True:
+	    j = randdevice()
+	    # Cheat to prevent shuttle damage unless on ship 
+            if not (game.damage[j]<0.0 or (j==DSHUTTL and game.iscraft != "onship")):
+                break
+	cdam.append(j)
+	extradm = (hit*game.damfac)/(ncrit*randreal(75, 100))
+	game.damage[j] += extradm
+    skipcount = 0
+    for (i, j) in enumerate(cdam):
+	proutn(device[j])
+        if skipcount % 3 == 2 and i < len(cdam)-1:
+            skip(1)
+        skipcount += 1
+        if i < len(cdam)-1:
+            proutn(_(" and "))
+    prout(_(" damaged."))
+    if damaged(DSHIELD) and game.shldup:
+	prout(_("***Shields knocked down."))
+	game.shldup=False
+
+def attack(torps_ok):
+    # bad guy attacks us 
+    # torps_ok == False forces use of phasers in an attack 
+    # game could be over at this point, check
+    if game.alldone:
+	return
+    attempt = False; ihurt = False;
+    hitmax=0.0; hittot=0.0; chgfac=1.0
+    where = "neither"
+    if idebug:
+	prout("=== ATTACK!")
+    # Tholian gets to move before attacking 
+    if game.tholian:
+	movetholian()
+    # if you have just entered the RNZ, you'll get a warning 
+    if game.neutz: # The one chance not to be attacked 
+	game.neutz = False
+	return
+    # commanders get a chance to tac-move towards you 
+    if (((game.quadrant in game.state.kcmdr or game.state.kscmdr==game.quadrant) and not game.justin) or game.skill == SKILL_EMERITUS) and torps_ok:
+	moveklings()
+    # if no enemies remain after movement, we're done 
+    if len(game.enemies)==0 or (len(game.enemies)==1 and thing == game.quadrant and not thing.angry):
+	return
+    # set up partial hits if attack happens during shield status change 
+    pfac = 1.0/game.inshld
+    if game.shldchg:
+	chgfac = 0.25 + randreal(0.5)
+    skip(1)
+    # message verbosity control 
+    if game.skill <= SKILL_FAIR:
+	where = "sector"
+    for enemy in game.enemies:
+	if enemy.power < 0:
+	    continue;	# too weak to attack 
+	# compute hit strength and diminish shield power 
+	r = randreal()
+	# Increase chance of photon torpedos if docked or enemy energy is low 
+	if game.condition == "docked":
+	    r *= 0.25
+	if enemy.power < 500:
+	    r *= 0.25; 
+	if enemy.type=='T' or (enemy.type=='?' and not thing.angry):
+	    continue
+	# different enemies have different probabilities of throwing a torp 
+	usephasers = not torps_ok or \
+	    (enemy.type == 'K' and r > 0.0005) or \
+	    (enemy.type=='C' and r > 0.015) or \
+	    (enemy.type=='R' and r > 0.3) or \
+	    (enemy.type=='S' and r > 0.07) or \
+	    (enemy.type=='?' and r > 0.05)
+	if usephasers:	    # Enemy uses phasers 
+	    if game.condition == "docked":
+		continue; # Don't waste the effort! 
+	    attempt = True; # Attempt to attack 
+	    dustfac = randreal(0.8, 0.85)
+	    hit = enemy.power*math.pow(dustfac,enemy.kavgd)
+	    enemy.power *= 0.75
+	else: # Enemy uses photon torpedo 
+	    # We should be able to make the bearing() method work here
+	    course = 1.90985*math.atan2(game.sector.j-enemy.location.j, enemy.location.i-game.sector.i)
+	    hit = 0
+	    proutn(_("***TORPEDO INCOMING"))
+	    if not damaged(DSRSENS):
+		proutn(_(" From ") + crmena(False, enemy.type, where, enemy.location))
+	    attempt = True
+	    prout("  ")
+	    dispersion = (randreal()+randreal())*0.5 - 0.5
+	    dispersion += 0.002*enemy.power*dispersion
+	    hit = torpedo(enemy.location, course, dispersion, number=1, nburst=1)
+	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+		finish(FWON); # Klingons did themselves in! 
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.alldone:
+		return # Supernova or finished 
+	    if hit == None:
+		continue
+	# incoming phaser or torpedo, shields may dissipate it 
+	if game.shldup or game.shldchg or game.condition=="docked":
+	    # shields will take hits 
+	    propor = pfac * game.shield
+            if game.condition =="docked":
+                propr *= 2.1
+	    if propor < 0.1:
+		propor = 0.1
+	    hitsh = propor*chgfac*hit+1.0
+	    absorb = 0.8*hitsh
+	    if absorb > game.shield:
+		absorb = game.shield
+	    game.shield -= absorb
+	    hit -= hitsh
+	    # taking a hit blasts us out of a starbase dock 
+	    if game.condition == "docked":
+		dock(False)
+	    # but the shields may take care of it 
+	    if propor > 0.1 and hit < 0.005*game.energy:
+		continue
+	# hit from this opponent got through shields, so take damage 
+	ihurt = True
+	proutn(_("%d unit hit") % int(hit))
+	if (damaged(DSRSENS) and usephasers) or game.skill<=SKILL_FAIR:
+	    proutn(_(" on the ") + crmshp())
+	if not damaged(DSRSENS) and usephasers:
+	    prout(_(" from ") + crmena(False, enemy.type, where, enemy.location))
+	skip(1)
+	# Decide if hit is critical 
+	if hit > hitmax:
+	    hitmax = hit
+	hittot += hit
+	fry(hit)
+	game.energy -= hit
+    if game.energy <= 0:
+	# Returning home upon your shield, not with it... 
+	finish(FBATTLE)
+	return
+    if not attempt and game.condition == "docked":
+	prout(_("***Enemies decide against attacking your ship."))
+    percent = 100.0*pfac*game.shield+0.5
+    if not ihurt:
+	# Shields fully protect ship 
+	proutn(_("Enemy attack reduces shield strength to "))
+    else:
+	# Emit message if starship suffered hit(s) 
+	skip(1)
+	proutn(_("Energy left %2d    shields ") % int(game.energy))
+	if game.shldup:
+	    proutn(_("up "))
+	elif not damaged(DSHIELD):
+	    proutn(_("down "))
+	else:
+	    proutn(_("damaged, "))
+    prout(_("%d%%,   torpedoes left %d") % (percent, game.torps))
+    # Check if anyone was hurt 
+    if hitmax >= 200 or hittot >= 500:
+	icas = randrange(int(hittot * 0.015))
+	if icas >= 2:
+	    skip(1)
+	    prout(_("Mc Coy-  \"Sickbay to bridge.  We suffered %d casualties") % icas)
+	    prout(_("   in that last attack.\""))
+	    game.casual += icas
+	    game.state.crew -= icas
+    # After attack, reset average distance to enemies 
+    for enemy in game.enemies:
+	enemy.kavgd = enemy.kdist
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    return
+		
+def deadkl(w, type, mv):
+    "Kill a Klingon, Tholian, Romulan, or Thingy." 
+    # Added mv to allow enemy to "move" before dying 
+    proutn(crmena(True, type, "sector", mv))
+    # Decide what kind of enemy it is and update appropriately 
+    if type == 'R':
+        # Chalk up a Romulan 
+        game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans -= 1
+        game.irhere -= 1
+        game.state.nromrem -= 1
+    elif type == 'T':
+        # Killed a Tholian 
+        game.tholian = None
+    elif type == '?':
+        # Killed a Thingy
+        global thing
+        thing = None
+    else:
+        # Killed some type of Klingon 
+        game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
+        game.klhere -= 1
+        if type == 'C':
+            game.state.kcmdr.remove(game.quadrant)
+            unschedule(FTBEAM)
+            if game.state.kcmdr:
+                schedule(FTBEAM, expran(1.0*game.incom/len(game.state.kcmdr)))
+            if is_scheduled(FCDBAS) and game.battle == game.quadrant:
+                unschedule(FCDBAS)    
+        elif type ==  'K':
+            game.state.remkl -= 1
+        elif type ==  'S':
+            game.state.nscrem -= 1
+            game.state.kscmdr.invalidate()
+            game.isatb = 0
+            game.iscate = False
+            unschedule(FSCMOVE)
+            unschedule(FSCDBAS)
+    # For each kind of enemy, finish message to player 
+    prout(_(" destroyed."))
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+	return
+    game.recompute()
+    # Remove enemy ship from arrays describing local conditions
+    for e in game.enemies:
+	if e.location == w:
+            e.move(None)
+	    break
+    return
+
+def targetcheck(w):
+    "Return None if target is invalid, otherwise return a course angle."
+    if not w.valid_sector():
+	huh()
+	return None
+    delta = coord()
+    # FIXME: C code this was translated from is wacky -- why the sign reversal?
+    delta.j = (w.j - game.sector.j);
+    delta.i = (game.sector.i - w.i);
+    if delta == coord(0, 0):
+	skip(1)
+	prout(_("Spock-  \"Bridge to sickbay.  Dr. McCoy,"))
+	prout(_("  I recommend an immediate review of"))
+	prout(_("  the Captain's psychological profile.\""))
+	scanner.chew()
+	return None
+    return delta.bearing()
+
+def torps():
+    "Launch photon torpedo salvo."
+    course = []
+    game.ididit = False
+    if damaged(DPHOTON):
+	prout(_("Photon tubes damaged."))
+	scanner.chew()
+	return
+    if game.torps == 0:
+	prout(_("No torpedoes left."))
+	scanner.chew()
+	return
+    # First, get torpedo count
+    while True:
+        scanner.next()
+	if scanner.token == "IHALPHA":
+	    huh()
+	    return
+	elif scanner.token == "IHEOL" or not scanner.waiting():
+	    prout(_("%d torpedoes left.") % game.torps)
+            scanner.chew()
+	    proutn(_("Number of torpedoes to fire- "))
+            continue	# Go back around to get a number
+	else: # key == "IHREAL"
+	    n = scanner.int()
+	    if n <= 0: # abort command 
+		scanner.chew()
+		return
+	    if n > MAXBURST:
+		scanner.chew()
+		prout(_("Maximum of %d torpedoes per burst.") % MAXBURST)
+		return
+            if n > game.torps:
+                scanner.chew()	# User requested more torps than available
+                continue	# Go back around
+            break	# All is good, go to next stage
+    # Next, get targets
+    target = []
+    for i in range(n):
+	key = scanner.next()
+	if i==0 and key == "IHEOL":
+	    break;	# no coordinate waiting, we will try prompting 
+	if i==1 and key == "IHEOL":
+	    # direct all torpedoes at one target 
+	    while i < n:
+		target.append(target[0])
+		course.append(course[0])
+		i += 1
+	    break
+        scanner.push(scanner.token)
+        target.append(scanner.getcoord())
+        if target[-1] == None:
+            return
+        course.append(targetcheck(target[-1]))
+        if course[-1] == None:
+	    return
+    scanner.chew()
+    if len(target) == 0:
+	# prompt for each one 
+	for i in range(n):
+	    proutn(_("Target sector for torpedo number %d- ") % (i+1))
+	    scanner.chew()
+            target.append(scanner.getcoord())
+            if target[-1] == None:
+                return
+            course.append(targetcheck(target[-1]))
+            if course[-1] == None:
+                return
+    game.ididit = True
+    # Loop for moving <n> torpedoes 
+    for i in range(n):
+	if game.condition != "docked":
+	    game.torps -= 1
+	dispersion = (randreal()+randreal())*0.5 -0.5
+	if math.fabs(dispersion) >= 0.47:
+	    # misfire! 
+	    dispersion *= randreal(1.2, 2.2)
+	    if n > 0:
+		prouts(_("***TORPEDO NUMBER %d MISFIRES") % (i+1))
+	    else:
+		prouts(_("***TORPEDO MISFIRES."))
+	    skip(1)
+	    if i < n:
+		prout(_("  Remainder of burst aborted."))
+	    if withprob(0.2):
+		prout(_("***Photon tubes damaged by misfire."))
+		game.damage[DPHOTON] = game.damfac * randreal(1.0, 3.0)
+	    break
+	if game.shldup or game.condition == "docked":
+	    dispersion *= 1.0 + 0.0001*game.shield
+	torpedo(game.sector, course[i], dispersion, number=i, nburst=n)
+	if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+	    return
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+	finish(FWON);
+
+def overheat(rpow):
+    "Check for phasers overheating."
+    if rpow > 1500:
+        checkburn = (rpow-1500.0)*0.00038
+        if withprob(checkburn):
+	    prout(_("Weapons officer Sulu-  \"Phasers overheated, sir.\""))
+	    game.damage[DPHASER] = game.damfac* randreal(1.0, 2.0) * (1.0+checkburn)
+
+def checkshctrl(rpow):
+    "Check shield control."
+    skip(1)
+    if withprob(0.998):
+	prout(_("Shields lowered."))
+	return False
+    # Something bad has happened 
+    prouts(_("***RED ALERT!  RED ALERT!"))
+    skip(2)
+    hit = rpow*game.shield/game.inshld
+    game.energy -= rpow+hit*0.8
+    game.shield -= hit*0.2
+    if game.energy <= 0.0:
+	prouts(_("Sulu-  \"Captain! Shield malf***********************\""))
+	skip(1)
+	stars()
+	finish(FPHASER)
+	return True
+    prouts(_("Sulu-  \"Captain! Shield malfunction! Phaser fire contained!\""))
+    skip(2)
+    prout(_("Lt. Uhura-  \"Sir, all decks reporting damage.\""))
+    icas = randrange(int(hit*0.012))
+    skip(1)
+    fry(0.8*hit)
+    if icas:
+	skip(1)
+	prout(_("McCoy to bridge- \"Severe radiation burns, Jim."))
+	prout(_("  %d casualties so far.\"") % icas)
+	game.casual += icas
+	game.state.crew -= icas
+    skip(1)
+    prout(_("Phaser energy dispersed by shields."))
+    prout(_("Enemy unaffected."))
+    overheat(rpow)
+    return True;
+
+def hittem(hits):
+    "Register a phaser hit on Klingons and Romulans."
+    nenhr2 = len(game.enemies); kk=0
+    w = coord()
+    skip(1)
+    for (k, wham) in enumerate(hits):
+	if wham==0:
+	    continue
+	dustfac = randreal(0.9, 1.0)
+	hit = wham*math.pow(dustfac,game.enemies[kk].kdist)
+	kpini = game.enemies[kk].power
+	kp = math.fabs(kpini)
+	if PHASEFAC*hit < kp:
+	    kp = PHASEFAC*hit
+        if game.enemies[kk].power < 0:
+            game.enemies[kk].power -= -kp
+        else:
+            game.enemies[kk].power -= kp
+	kpow = game.enemies[kk].power
+	w = game.enemies[kk].location
+	if hit > 0.005:
+	    if not damaged(DSRSENS):
+		boom(w)
+	    proutn(_("%d unit hit on ") % int(hit))
+	else:
+	    proutn(_("Very small hit on "))
+	ienm = game.quad[w.i][w.j]
+	if ienm=='?':
+	    thing.angry = True
+	proutn(crmena(False, ienm, "sector", w))
+	skip(1)
+	if kpow == 0:
+	    deadkl(w, ienm, w)
+	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+		finish(FWON);		
+	    if game.alldone:
+		return
+	    kk -= 1	# don't do the increment
+            continue
+	else: # decide whether or not to emasculate klingon 
+	    if kpow>0 and withprob(0.9) and kpow <= randreal(0.4, 0.8)*kpini:
+		prout(_("***Mr. Spock-  \"Captain, the vessel at Sector %s")%w)
+		prout(_("   has just lost its firepower.\""))
+		game.enemies[kk].power = -kpow
+        kk += 1
+    return
+
+def phasers():
+    "Fire phasers at bad guys."
+    hits = []
+    kz = 0; k = 1; irec=0 # Cheating inhibitor 
+    ifast = False; no = False; itarg = True; msgflag = True; rpow=0
+    automode = "NOTSET"
+    key=0
+    skip(1)
+    # SR sensors and Computer are needed for automode 
+    if damaged(DSRSENS) or damaged(DCOMPTR):
+	itarg = False
+    if game.condition == "docked":
+	prout(_("Phasers can't be fired through base shields."))
+	scanner.chew()
+	return
+    if damaged(DPHASER):
+	prout(_("Phaser control damaged."))
+	scanner.chew()
+	return
+    if game.shldup:
+	if damaged(DSHCTRL):
+	    prout(_("High speed shield control damaged."))
+	    scanner.chew()
+	    return
+	if game.energy <= 200.0:
+	    prout(_("Insufficient energy to activate high-speed shield control."))
+	    scanner.chew()
+	    return
+	prout(_("Weapons Officer Sulu-  \"High-speed shield control enabled, sir.\""))
+	ifast = True
+    # Original code so convoluted, I re-did it all
+    # (That was Tom Almy talking about the C code, I think -- ESR)
+    while automode=="NOTSET":
+	key=scanner.next()
+	if key == "IHALPHA":
+	    if scanner.sees("manual"):
+		if len(game.enemies)==0:
+		    prout(_("There is no enemy present to select."))
+		    scanner.chew()
+		    key = "IHEOL"
+		    automode="AUTOMATIC"
+		else:
+		    automode = "MANUAL"
+		    key = scanner.next()
+	    elif scanner.sees("automatic"):
+		if (not itarg) and len(game.enemies) != 0:
+		    automode = "FORCEMAN"
+		else:
+		    if len(game.enemies)==0:
+			prout(_("Energy will be expended into space."))
+		    automode = "AUTOMATIC"
+		    key = scanner.next()
+	    elif scanner.sees("no"):
+		no = True
+	    else:
+		huh()
+		return
+	elif key == "IHREAL":
+	    if len(game.enemies)==0:
+		prout(_("Energy will be expended into space."))
+		automode = "AUTOMATIC"
+	    elif not itarg:
+		automode = "FORCEMAN"
+	    else:
+		automode = "AUTOMATIC"
+	else:
+	    # "IHEOL" 
+	    if len(game.enemies)==0:
+		prout(_("Energy will be expended into space."))
+		automode = "AUTOMATIC"
+	    elif not itarg:
+		automode = "FORCEMAN"
+	    else: 
+		proutn(_("Manual or automatic? "))
+                scanner.chew()
+    avail = game.energy
+    if ifast:
+        avail -= 200.0
+    if automode == "AUTOMATIC":
+	if key == "IHALPHA" and scanner.sees("no"):
+	    no = True
+	    key = scanner.next()
+	if key != "IHREAL" and len(game.enemies) != 0:
+	    prout(_("Phasers locked on target. Energy available: %.2f")%avail)
+	irec=0
+        while True:
+	    scanner.chew()
+	    if not kz:
+		for i in range(len(game.enemies)):
+		    irec += math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))*randreal(1.01, 1.06) + 1.0
+	    kz=1
+	    proutn(_("%d units required. ") % irec)
+	    scanner.chew()
+	    proutn(_("Units to fire= "))
+	    key = scanner.next()
+	    if key!="IHREAL":
+		return
+	    rpow = scanner.real
+	    if rpow > avail:
+		proutn(_("Energy available= %.2f") % avail)
+		skip(1)
+		key = "IHEOL"
+            if not rpow > avail:
+                break
+	if rpow<=0:
+	    # chicken out 
+	    scanner.chew()
+	    return
+        key=scanner.next()
+	if key == "IHALPHA" and scanner.sees("no"):
+	    no = True
+	if ifast:
+	    game.energy -= 200; # Go and do it! 
+	    if checkshctrl(rpow):
+		return
+	scanner.chew()
+	game.energy -= rpow
+	extra = rpow
+	if len(game.enemies):
+	    extra = 0.0
+	    powrem = rpow
+	    for i in range(len(game.enemies)):
+		hits.append(0.0)
+		if powrem <= 0:
+		    continue
+		hits[i] = math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))
+		over = randreal(1.01, 1.06) * hits[i]
+		temp = powrem
+		powrem -= hits[i] + over
+		if powrem <= 0 and temp < hits[i]:
+		    hits[i] = temp
+		if powrem <= 0:
+		    over = 0.0
+		extra += over
+	    if powrem > 0.0:
+		extra += powrem
+	    hittem(hits)
+	    game.ididit = True
+	if extra > 0 and not game.alldone:
+	    if game.tholian:
+		proutn(_("*** Tholian web absorbs "))
+		if len(game.enemies)>0:
+		    proutn(_("excess "))
+		prout(_("phaser energy."))
+	    else:
+		prout(_("%d expended on empty space.") % int(extra))
+    elif automode == "FORCEMAN":
+	scanner.chew()
+	key = "IHEOL"
+	if damaged(DCOMPTR):
+	    prout(_("Battle computer damaged, manual fire only."))
+	else:
+	    skip(1)
+	    prouts(_("---WORKING---"))
+	    skip(1)
+	    prout(_("Short-range-sensors-damaged"))
+	    prout(_("Insufficient-data-for-automatic-phaser-fire"))
+	    prout(_("Manual-fire-must-be-used"))
+	    skip(1)
+    elif automode == "MANUAL":
+	rpow = 0.0
+        for k in range(len(game.enemies)):
+	    aim = game.enemies[k].location
+	    ienm = game.quad[aim.i][aim.j]
+	    if msgflag:
+		proutn(_("Energy available= %.2f") % (avail-0.006))
+		skip(1)
+		msgflag = False
+		rpow = 0.0
+	    if damaged(DSRSENS) and \
+               not game.sector.distance(aim)<2**0.5 and ienm in ('C', 'S'):
+		prout(cramen(ienm) + _(" can't be located without short range scan."))
+		scanner.chew()
+		key = "IHEOL"
+		hits[k] = 0; # prevent overflow -- thanks to Alexei Voitenko 
+		k += 1
+		continue
+	    if key == "IHEOL":
+		scanner.chew()
+		if itarg and k > kz:
+		    irec=(abs(game.enemies[k].power)/(PHASEFAC*math.pow(0.9,game.enemies[k].kdist))) *	randreal(1.01, 1.06) + 1.0
+		kz = k
+		proutn("(")
+		if not damaged(DCOMPTR):
+		    proutn("%d" % irec)
+		else:
+		    proutn("??")
+		proutn(")  ")
+		proutn(_("units to fire at %s-  ") % crmena(False, ienm, "sector", aim))		
+		key = scanner.next()
+	    if key == "IHALPHA" and scanner.sees("no"):
+		no = True
+		key = scanner.next()
+		continue
+	    if key == "IHALPHA":
+		huh()
+		return
+	    if key == "IHEOL":
+		if k==1: # Let me say I'm baffled by this 
+		    msgflag = True
+		continue
+	    if scanner.real < 0:
+		# abort out 
+		scanner.chew()
+		return
+	    hits[k] = scanner.real
+	    rpow += scanner.real
+	    # If total requested is too much, inform and start over 
+            if rpow > avail:
+		prout(_("Available energy exceeded -- try again."))
+		scanner.chew()
+		return
+	    key = scanner.next(); # scan for next value 
+	    k += 1
+	if rpow == 0.0:
+	    # zero energy -- abort 
+	    scanner.chew()
+	    return
+	if key == "IHALPHA" and scanner.sees("no"):
+	    no = True
+	game.energy -= rpow
+	scanner.chew()
+	if ifast:
+	    game.energy -= 200.0
+	    if checkshctrl(rpow):
+		return
+	hittem(hits)
+	game.ididit = True
+     # Say shield raised or malfunction, if necessary 
+    if game.alldone:
+	return
+    if ifast:
+	skip(1)
+	if no == 0:
+	    if withprob(0.01):
+		prout(_("Sulu-  \"Sir, the high-speed shield control has malfunctioned . . ."))
+		prouts(_("         CLICK   CLICK   POP  . . ."))
+		prout(_(" No response, sir!"))
+		game.shldup = False
+	    else:
+		prout(_("Shields raised."))
+	else:
+	    game.shldup = False
+    overheat(rpow);
+
+# Code from events,c begins here.
+
+# This isn't a real event queue a la BSD Trek yet -- you can only have one 
+# event of each type active at any given time.  Mostly these means we can 
+# only have one FDISTR/FENSLV/FREPRO sequence going at any given time
+# BSD Trek, from which we swiped the idea, can have up to 5.
+
+def unschedule(evtype):
+    "Remove an event from the schedule."
+    game.future[evtype].date = FOREVER
+    return game.future[evtype]
+
+def is_scheduled(evtype):
+    "Is an event of specified type scheduled."
+    return game.future[evtype].date != FOREVER
+
+def scheduled(evtype):
+    "When will this event happen?"
+    return game.future[evtype].date
+
+def schedule(evtype, offset):
+    "Schedule an event of specified type."
+    game.future[evtype].date = game.state.date + offset
+    return game.future[evtype]
+
+def postpone(evtype, offset):
+    "Postpone a scheduled event."
+    game.future[evtype].date += offset
+
+def cancelrest():
+    "Rest period is interrupted by event."
+    if game.resting:
+	skip(1)
+	proutn(_("Mr. Spock-  \"Captain, shall we cancel the rest period?\""))
+	if ja() == True:
+	    game.resting = False
+	    game.optime = 0.0
+	    return True
+    return False
+
+def events():
+    "Run through the event queue looking for things to do."
+    i=0
+    fintim = game.state.date + game.optime; yank=0
+    ictbeam = False; istract = False
+    w = coord(); hold = coord()
+    ev = event(); ev2 = event()
+
+    def tractorbeam(yank):
+        "Tractor-beaming cases merge here." 
+        announce()
+        game.optime = (10.0/(7.5*7.5))*yank # 7.5 is yank rate (warp 7.5) 
+        skip(1)
+        prout("***" + crmshp() + _(" caught in long range tractor beam--"))
+        # If Kirk & Co. screwing around on planet, handle 
+        atover(True) # atover(true) is Grab 
+        if game.alldone:
+            return
+        if game.icraft: # Caught in Galileo? 
+            finish(FSTRACTOR)
+            return
+        # Check to see if shuttle is aboard 
+        if game.iscraft == "offship":
+            skip(1)
+            if withprob(0.5):
+                prout(_("Galileo, left on the planet surface, is captured"))
+                prout(_("by aliens and made into a flying McDonald's."))
+                game.damage[DSHUTTL] = -10
+                game.iscraft = "removed"
+            else:
+                prout(_("Galileo, left on the planet surface, is well hidden."))
+        if evcode == FSPY:
+            game.quadrant = game.state.kscmdr
+        else:
+            game.quadrant = game.state.kcmdr[i]
+        game.sector = randplace(QUADSIZE)
+        prout(crmshp() + _(" is pulled to Quadrant %s, Sector %s") \
+               % (game.quadrant, game.sector))
+        if game.resting:
+            prout(_("(Remainder of rest/repair period cancelled.)"))
+            game.resting = False
+        if not game.shldup:
+            if not damaged(DSHIELD) and game.shield > 0:
+                doshield(shraise=True) # raise shields 
+                game.shldchg = False
+            else:
+                prout(_("(Shields not currently useable.)"))
+        newqad()
+        # Adjust finish time to time of tractor beaming 
+        fintim = game.state.date+game.optime
+        attack(torps_ok=False)
+        if not game.state.kcmdr:
+            unschedule(FTBEAM)
+        else: 
+            schedule(FTBEAM, game.optime+expran(1.5*game.intime/len(game.state.kcmdr)))
+
+    def destroybase():
+        "Code merges here for any commander destroying a starbase." 
+        # Not perfect, but will have to do 
+        # Handle case where base is in same quadrant as starship 
+        if game.battle == game.quadrant:
+            game.state.chart[game.battle.i][game.battle.j].starbase = False
+            game.quad[game.base.i][game.base.j] = '.'
+            game.base.invalidate()
+            newcnd()
+            skip(1)
+            prout(_("Spock-  \"Captain, I believe the starbase has been destroyed.\""))
+        elif game.state.baseq and communicating():
+            # Get word via subspace radio 
+            announce()
+            skip(1)
+            prout(_("Lt. Uhura-  \"Captain, Starfleet Command reports that"))
+            proutn(_("   the starbase in Quadrant %s has been destroyed by") % game.battle)
+            if game.isatb == 2: 
+                prout(_("the Klingon Super-Commander"))
+            else:
+                prout(_("a Klingon Commander"))
+            game.state.chart[game.battle.i][game.battle.j].starbase = False
+        # Remove Starbase from galaxy 
+        game.state.galaxy[game.battle.i][game.battle.j].starbase = False
+        game.state.baseq = filter(lambda x: x != game.battle, game.state.baseq)
+        if game.isatb == 2:
+            # reinstate a commander's base attack 
+            game.battle = hold
+            game.isatb = 0
+        else:
+            game.battle.invalidate()
+    if idebug:
+	prout("=== EVENTS from %.2f to %.2f:" % (game.state.date, fintim))
+	for i in range(1, NEVENTS):
+	    if   i == FSNOVA:  proutn("=== Supernova       ")
+	    elif i == FTBEAM:  proutn("=== T Beam          ")
+	    elif i == FSNAP:   proutn("=== Snapshot        ")
+	    elif i == FBATTAK: proutn("=== Base Attack     ")
+	    elif i == FCDBAS:  proutn("=== Base Destroy    ")
+	    elif i == FSCMOVE: proutn("=== SC Move         ")
+	    elif i == FSCDBAS: proutn("=== SC Base Destroy ")
+	    elif i == FDSPROB: proutn("=== Probe Move      ")
+	    elif i == FDISTR:  proutn("=== Distress Call   ")
+	    elif i == FENSLV:  proutn("=== Enslavement     ")
+	    elif i == FREPRO:  proutn("=== Klingon Build   ")
+	    if is_scheduled(i):
+		prout("%.2f" % (scheduled(i)))
+	    else:
+		prout("never")
+    radio_was_broken = damaged(DRADIO)
+    hold.i = hold.j = 0
+    while True:
+	# Select earliest extraneous event, evcode==0 if no events 
+	evcode = FSPY
+	if game.alldone:
+	    return
+	datemin = fintim
+	for l in range(1, NEVENTS):
+	    if game.future[l].date < datemin:
+		evcode = l
+		if idebug:
+		    prout("== Event %d fires" % evcode)
+		datemin = game.future[l].date
+	xtime = datemin-game.state.date
+	game.state.date = datemin
+	# Decrement Federation resources and recompute remaining time 
+	game.state.remres -= (game.state.remkl+4*len(game.state.kcmdr))*xtime
+        game.recompute()
+	if game.state.remtime <=0:
+	    finish(FDEPLETE)
+	    return
+	# Any crew left alive? 
+	if game.state.crew <=0:
+	    finish(FCREW)
+	    return
+	# Is life support adequate? 
+	if damaged(DLIFSUP) and game.condition != "docked":
+	    if game.lsupres < xtime and game.damage[DLIFSUP] > game.lsupres:
+		finish(FLIFESUP)
+		return
+	    game.lsupres -= xtime
+	    if game.damage[DLIFSUP] <= xtime:
+		game.lsupres = game.inlsr
+	# Fix devices 
+	repair = xtime
+	if game.condition == "docked":
+	    repair /= DOCKFAC
+	# Don't fix Deathray here 
+	for l in range(NDEVICES):
+	    if game.damage[l] > 0.0 and l != DDRAY:
+                if game.damage[l]-repair > 0.0:
+                    game.damage[l] -= repair
+                else:
+                    game.damage[l] = 0.0
+	# If radio repaired, update star chart and attack reports 
+	if radio_was_broken and not damaged(DRADIO):
+	    prout(_("Lt. Uhura- \"Captain, the sub-space radio is working and"))
+	    prout(_("   surveillance reports are coming in."))
+	    skip(1)
+	    if not game.iseenit:
+		attackreport(False)
+		game.iseenit = True
+	    rechart()
+	    prout(_("   The star chart is now up to date.\""))
+	    skip(1)
+	# Cause extraneous event EVCODE to occur 
+	game.optime -= xtime
+	if evcode == FSNOVA: # Supernova 
+	    announce()
+	    supernova(None)
+	    schedule(FSNOVA, expran(0.5*game.intime))
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		return
+	elif evcode == FSPY: # Check with spy to see if SC should tractor beam 
+	    if game.state.nscrem == 0 or \
+		ictbeam or istract or \
+                game.condition=="docked" or game.isatb==1 or game.iscate:
+		return
+	    if game.ientesc or \
+		(game.energy<2000 and game.torps<4 and game.shield < 1250) or \
+		(damaged(DPHASER) and (damaged(DPHOTON) or game.torps<4)) or \
+		(damaged(DSHIELD) and \
+		 (game.energy < 2500 or damaged(DPHASER)) and \
+                 (game.torps < 5 or damaged(DPHOTON))):
+		# Tractor-beam her! 
+		istract = ictbeam = True
+                tractorbeam((game.state.kscmdr-game.quadrant).distance())
+	    else:
+		return
+	elif evcode == FTBEAM: # Tractor beam 
+            if not game.state.kcmdr:
+                unschedule(FTBEAM)
+                continue
+            i = randrange(len(game.state.kcmdr))
+            yank = (game.state.kcmdr[i]-game.quadrant).distance()
+            if istract or game.condition == "docked" or yank == 0:
+                # Drats! Have to reschedule 
+                schedule(FTBEAM, 
+                         game.optime + expran(1.5*game.intime/len(game.state.kcmdr)))
+                continue
+            ictbeam = True
+            tractorbeam(yank)
+	elif evcode == FSNAP: # Snapshot of the universe (for time warp) 
+	    game.snapsht = copy.deepcopy(game.state)
+	    game.state.snap = True
+	    schedule(FSNAP, expran(0.5 * game.intime))
+	elif evcode == FBATTAK: # Commander attacks starbase 
+	    if not game.state.kcmdr or not game.state.baseq:
+		# no can do 
+		unschedule(FBATTAK)
+		unschedule(FCDBAS)
+                continue
+            try:
+                for ibq in game.state.baseq:
+                   for cmdr in game.state.kcmdr: 
+                       if ibq == cmdr and ibq != game.quadrant and ibq != game.state.kscmdr:
+                           raise ibq
+                else:
+                    # no match found -- try later 
+                    schedule(FBATTAK, expran(0.3*game.intime))
+                    unschedule(FCDBAS)
+                    continue
+            except coord:
+                pass
+	    # commander + starbase combination found -- launch attack 
+	    game.battle = ibq
+	    schedule(FCDBAS, randreal(1.0, 4.0))
+	    if game.isatb: # extra time if SC already attacking 
+		postpone(FCDBAS, scheduled(FSCDBAS)-game.state.date)
+	    game.future[FBATTAK].date = game.future[FCDBAS].date + expran(0.3*game.intime)
+	    game.iseenit = False
+            if not communicating():
+		continue # No warning :-( 
+	    game.iseenit = True
+	    announce()
+	    skip(1)
+	    prout(_("Lt. Uhura-  \"Captain, the starbase in Quadrant %s") % game.battle)
+	    prout(_("   reports that it is under attack and that it can"))
+	    prout(_("   hold out only until stardate %d.\"") % (int(scheduled(FCDBAS))))
+	    if cancelrest():
+                return
+	elif evcode == FSCDBAS: # Supercommander destroys base 
+	    unschedule(FSCDBAS)
+	    game.isatb = 2
+	    if not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].starbase: 
+		continue # WAS RETURN! 
+	    hold = game.battle
+	    game.battle = game.state.kscmdr
+	    destroybase()
+	elif evcode == FCDBAS: # Commander succeeds in destroying base 
+	    if evcode==FCDBAS:
+		unschedule(FCDBAS)
+                if not game.state.baseq() \
+                       or not game.state.galaxy[game.battle.i][game.battle.j].starbase:
+		    game.battle.invalidate()
+                    continue
+		# find the lucky pair 
+		for cmdr in game.state.kcmdr:
+		    if cmdr == game.battle: 
+			break
+                else:
+		    # No action to take after all 
+		    continue
+            destroybase()
+	elif evcode == FSCMOVE: # Supercommander moves 
+	    schedule(FSCMOVE, 0.2777)
+	    if not game.ientesc and not istract and game.isatb != 1 and \
+                   (not game.iscate or not game.justin): 
+		supercommander()
+	elif evcode == FDSPROB: # Move deep space probe 
+	    schedule(FDSPROB, 0.01)
+            if not game.probe.next():
+		if not game.probe.quadrant().valid_quadrant() or \
+		    game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j].supernova:
+		    # Left galaxy or ran into supernova
+                    if communicating():
+			announce()
+			skip(1)
+			proutn(_("Lt. Uhura-  \"The deep space probe "))
+			if not game.probe.quadrant().valid_quadrant():
+			    prout(_("has left the galaxy.\""))
+			else:
+			    prout(_("is no longer transmitting.\""))
+		    unschedule(FDSPROB)
+		    continue
+                if communicating():
+		    #announce()
+		    skip(1)
+		    prout(_("Lt. Uhura-  \"The deep space probe is now in Quadrant %s.\"") % game.probe.quadrant())
+	    pdest = game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j]
+	    if communicating():
+		chp = game.state.chart[game.probe.quadrant().i][game.probe.quadrant().j]
+		chp.klingons = pdest.klingons
+		chp.starbase = pdest.starbase
+		chp.stars = pdest.stars
+		pdest.charted = True
+	    game.probe.moves -= 1 # One less to travel
+	    if game.probe.arrived() and game.isarmed and pdest.stars:
+		supernova(game.probe)		# fire in the hole!
+		unschedule(FDSPROB)
+		if game.state.galaxy[game.quadrant().i][game.quadrant().j].supernova: 
+		    return
+	elif evcode == FDISTR: # inhabited system issues distress call 
+	    unschedule(FDISTR)
+	    # try a whole bunch of times to find something suitable 
+            for i in range(100):
+		# need a quadrant which is not the current one,
+		# which has some stars which are inhabited and
+		# not already under attack, which is not
+		# supernova'ed, and which has some Klingons in it
+		w = randplace(GALSIZE)
+		q = game.state.galaxy[w.i][w.j]
+                if not (game.quadrant == w or q.planet == None or \
+		      not q.planet.inhabited or \
+		      q.supernova or q.status!="secure" or q.klingons<=0):
+                    break
+            else:
+		# can't seem to find one; ignore this call 
+		if idebug:
+		    prout("=== Couldn't find location for distress event.")
+		continue
+	    # got one!!  Schedule its enslavement 
+	    ev = schedule(FENSLV, expran(game.intime))
+	    ev.quadrant = w
+	    q.status = "distressed"
+	    # tell the captain about it if we can 
+	    if communicating():
+		prout(_("Uhura- Captain, %s in Quadrant %s reports it is under attack") \
+                        % (q.planet, `w`))
+		prout(_("by a Klingon invasion fleet."))
+		if cancelrest():
+		    return
+	elif evcode == FENSLV:		# starsystem is enslaved 
+	    ev = unschedule(FENSLV)
+	    # see if current distress call still active 
+	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
+	    if q.klingons <= 0:
+		q.status = "secure"
+		continue
+	    q.status = "enslaved"
+
+	    # play stork and schedule the first baby 
+	    ev2 = schedule(FREPRO, expran(2.0 * game.intime))
+	    ev2.quadrant = ev.quadrant
+
+	    # report the disaster if we can 
+	    if communicating():
+		prout(_("Uhura- We've lost contact with starsystem %s") % \
+                        q.planet)
+		prout(_("in Quadrant %s.\n") % ev.quadrant)
+	elif evcode == FREPRO:		# Klingon reproduces 
+	    # If we ever switch to a real event queue, we'll need to
+	    # explicitly retrieve and restore the x and y.
+	    ev = schedule(FREPRO, expran(1.0 * game.intime))
+	    # see if current distress call still active 
+	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
+	    if q.klingons <= 0:
+		q.status = "secure"
+		continue
+	    if game.state.remkl >=MAXKLGAME:
+		continue		# full right now 
+	    # reproduce one Klingon 
+	    w = ev.quadrant
+            m = coord()
+	    if game.klhere >= MAXKLQUAD:
+                try:
+                    # this quadrant not ok, pick an adjacent one 
+                    for m.i in range(w.i - 1, w.i + 2):
+                        for m.j in range(w.j - 1, w.j + 2):
+                            if not m.valid_quadrant():
+                                continue
+                            q = game.state.galaxy[m.i][m.j]
+                            # check for this quad ok (not full & no snova) 
+                            if q.klingons >= MAXKLQUAD or q.supernova:
+                                continue
+                            raise "FOUNDIT"
+                    else:
+                        continue	# search for eligible quadrant failed
+                except "FOUNDIT":
+                    w = m
+	    # deliver the child 
+	    game.state.remkl += 1
+	    q.klingons += 1
+	    if game.quadrant == w:
+                game.klhere += 1
+		game.enemies.append(newkling())
+	    # recompute time left
+            game.recompute()
+	    if communicating():
+		if game.quadrant == w:
+		    prout(_("Spock- sensors indicate the Klingons have"))
+		    prout(_("launched a warship from %s.") % q.planet)
+		else:
+		    prout(_("Uhura- Starfleet reports increased Klingon activity"))
+		    if q.planet != None:
+			proutn(_("near %s ") % q.planet)
+		    prout(_("in Quadrant %s.") % w)
+				
+def wait():
+    "Wait on events."
+    game.ididit = False
+    while True:
+	key = scanner.next()
+	if key  != "IHEOL":
+	    break
+	proutn(_("How long? "))
+    scanner.chew()
+    if key != "IHREAL":
+	huh()
+	return
+    origTime = delay = scanner.real
+    if delay <= 0.0:
+	return
+    if delay >= game.state.remtime or len(game.enemies) != 0:
+	proutn(_("Are you sure? "))
+	if ja() == False:
+	    return
+    # Alternate resting periods (events) with attacks 
+    game.resting = True
+    while True:
+	if delay <= 0:
+	    game.resting = False
+	if not game.resting:
+	    prout(_("%d stardates left.") % int(game.state.remtime))
+	    return
+	temp = game.optime = delay
+	if len(game.enemies):
+	    rtime = randreal(1.0, 2.0)
+	    if rtime < temp:
+		temp = rtime
+	    game.optime = temp
+	if game.optime < delay:
+	    attack(torps_ok=False)
+	if game.alldone:
+	    return
+	events()
+	game.ididit = True
+	if game.alldone:
+	    return
+	delay -= temp
+	# Repair Deathray if long rest at starbase 
+	if origTime-delay >= 9.99 and game.condition == "docked":
+	    game.damage[DDRAY] = 0.0
+	# leave if quadrant supernovas
+        if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            break
+    game.resting = False
+    game.optime = 0
+
+def nova(nov):
+    "Star goes nova." 
+    course = (0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5)
+    newc = coord(); neighbor = coord(); bump = coord(0, 0)
+    if withprob(0.05):
+	# Wow! We've supernova'ed 
+	supernova(game.quadrant)
+	return
+    # handle initial nova 
+    game.quad[nov.i][nov.j] = '.'
+    prout(crmena(False, '*', "sector", nov) + _(" novas."))
+    game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
+    game.state.starkl += 1
+    # Set up queue to recursively trigger adjacent stars 
+    hits = [nov]
+    kount = 0
+    while hits:
+        offset = coord()
+        start = hits.pop()
+        for offset.i in range(-1, 1+1):
+            for offset.j in range(-1, 1+1):
+                if offset.j==0 and offset.i==0:
+                    continue
+                neighbor = start + offset
+                if not neighbor.valid_sector():
+                    continue
+                iquad = game.quad[neighbor.i][neighbor.j]
+                # Empty space ends reaction
+                if iquad in ('.', '?', ' ', 'T', '#'):
+                    pass
+                elif iquad == '*': # Affect another star 
+                    if withprob(0.05):
+                        # This star supernovas 
+                        supernova(game.quadrant)
+                        return
+                    else:
+                        hits.append(neighbor)
+			game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
+			game.state.starkl += 1
+			proutn(crmena(True, '*', "sector", neighbor))
+			prout(_(" novas."))
+                        game.quad[neighbor.i][neighbor.j] = '.'
+                        kount += 1
+                elif iquad in ('P', '@'): # Destroy planet 
+                    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+                    if iquad == 'P':
+                        game.state.nplankl += 1
+                    else:
+                        game.state.worldkl += 1
+                    prout(crmena(True, 'B', "sector", neighbor) + _(" destroyed."))
+                    game.iplnet.pclass = "destroyed"
+                    game.iplnet = None
+                    game.plnet.invalidate()
+                    if game.landed:
+                        finish(FPNOVA)
+                        return
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                elif iquad == 'B': # Destroy base 
+                    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase = False
+                    game.state.baseq = filter(lambda x: x!= game.quadrant, game.state.baseq)
+                    game.base.invalidate()
+                    game.state.basekl += 1
+                    newcnd()
+                    prout(crmena(True, 'B', "sector", neighbor) + _(" destroyed."))
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                elif iquad in ('E', 'F'): # Buffet ship 
+                    prout(_("***Starship buffeted by nova."))
+                    if game.shldup:
+                        if game.shield >= 2000.0:
+                            game.shield -= 2000.0
+                        else:
+                            diff = 2000.0 - game.shield
+                            game.energy -= diff
+                            game.shield = 0.0
+                            game.shldup = False
+                            prout(_("***Shields knocked out."))
+                            game.damage[DSHIELD] += 0.005*game.damfac*randreal()*diff
+                    else:
+                        game.energy -= 2000.0
+                    if game.energy <= 0:
+                        finish(FNOVA)
+                        return
+                    # add in course nova contributes to kicking starship
+                    bump += (game.sector-hits[mm]).sgn()
+                elif iquad == 'K': # kill klingon 
+                    deadkl(neighbor, iquad, neighbor)
+                elif iquad in ('C','S','R'): # Damage/destroy big enemies 
+                    for ll in range(len(game.enemies)):
+                        if game.enemies[ll].location == neighbor:
+                            break
+                    game.enemies[ll].power -= 800.0 # If firepower is lost, die 
+                    if game.enemies[ll].power <= 0.0:
+                        deadkl(neighbor, iquad, neighbor)
+                        break
+                    newc = neighbor + neighbor - hits[mm]
+                    proutn(crmena(True, iquad, "sector", neighbor) + _(" damaged"))
+                    if not newc.valid_sector():
+                        # can't leave quadrant 
+                        skip(1)
+                        break
+                    iquad1 = game.quad[newc.i][newc.j]
+                    if iquad1 == ' ':
+                        proutn(_(", blasted into ") + crmena(False, ' ', "sector", newc))
+                        skip(1)
+                        deadkl(neighbor, iquad, newc)
+                        break
+                    if iquad1 != '.':
+                        # can't move into something else 
+                        skip(1)
+                        break
+                    proutn(_(", buffeted to Sector %s") % newc)
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                    game.quad[newc.i][newc.j] = iquad
+                    game.enemies[ll].move(newc)
+    # Starship affected by nova -- kick it away. 
+    dist = kount*0.1
+    direc = course[3*(bump.i+1)+bump.j+2]
+    if direc == 0.0:
+	dist = 0.0
+    if dist == 0.0:
+	return
+    course = course(bearing=direc, distance=dist)
+    game.optime = course.time(warp=4)
+    skip(1)
+    prout(_("Force of nova displaces starship."))
+    imove(course, noattack=True)
+    game.optime = course.time(warp=4)
+    return
+	
+def supernova(w):
+    "Star goes supernova."
+    num = 0; npdead = 0
+    if w != None: 
+	nq = copy.copy(w)
+    else:
+	# Scheduled supernova -- select star at random. 
+	stars = 0
+        nq = coord()
+	for nq.i in range(GALSIZE):
+	    for nq.j in range(GALSIZE):
+		stars += game.state.galaxy[nq.i][nq.j].stars
+	if stars == 0:
+	    return # nothing to supernova exists 
+	num = randrange(stars) + 1
+	for nq.i in range(GALSIZE):
+	    for nq.j in range(GALSIZE):
+		num -= game.state.galaxy[nq.i][nq.j].stars
+		if num <= 0:
+		    break
+	    if num <=0:
+		break
+	if idebug:
+	    proutn("=== Super nova here?")
+	    if ja() == True:
+		nq = game.quadrant
+    if not nq == game.quadrant or game.justin:
+	# it isn't here, or we just entered (treat as enroute) 
+	if communicating():
+	    skip(1)
+	    prout(_("Message from Starfleet Command       Stardate %.2f") % game.state.date)
+	    prout(_("     Supernova in Quadrant %s; caution advised.") % nq)
+    else:
+	ns = coord()
+	# we are in the quadrant! 
+	num = randrange(game.state.galaxy[nq.i][nq.j].stars) + 1
+	for ns.i in range(QUADSIZE):
+	    for ns.j in range(QUADSIZE):
+		if game.quad[ns.i][ns.j]=='*':
+		    num -= 1
+		    if num==0:
+			break
+	    if num==0:
+		break
+	skip(1)
+	prouts(_("***RED ALERT!  RED ALERT!"))
+	skip(1)
+	prout(_("***Incipient supernova detected at Sector %s") % ns)
+	if (ns.i-game.sector.i)**2 + (ns.j-game.sector.j)**2 <= 2.1:
+	    proutn(_("Emergency override attempts t"))
+	    prouts("***************")
+	    skip(1)
+	    stars()
+	    game.alldone = True
+    # destroy any Klingons in supernovaed quadrant
+    kldead = game.state.galaxy[nq.i][nq.j].klingons
+    game.state.galaxy[nq.i][nq.j].klingons = 0
+    if nq == game.state.kscmdr:
+	# did in the Supercommander! 
+	game.state.nscrem = game.state.kscmdr.i = game.state.kscmdr.j = game.isatb =  0
+	game.iscate = False
+	unschedule(FSCMOVE)
+	unschedule(FSCDBAS)
+    survivors = filter(lambda w: w != nq, game.state.kcmdr)
+    comkills = len(game.state.kcmdr) - len(survivors)
+    game.state.kcmdr = survivors
+    kldead -= comkills
+    if not game.state.kcmdr:
+        unschedule(FTBEAM)
+    game.state.remkl -= kldead
+    # destroy Romulans and planets in supernovaed quadrant 
+    nrmdead = game.state.galaxy[nq.i][nq.j].romulans
+    game.state.galaxy[nq.i][nq.j].romulans = 0
+    game.state.nromrem -= nrmdead
+    # Destroy planets 
+    for loop in range(game.inplan):
+	if game.state.planets[loop].quadrant == nq:
+	    game.state.planets[loop].pclass = "destroyed"
+	    npdead += 1
+    # Destroy any base in supernovaed quadrant
+    game.state.baseq = filter(lambda x: x != nq, game.state.baseq)
+    # If starship caused supernova, tally up destruction 
+    if w != None:
+	game.state.starkl += game.state.galaxy[nq.i][nq.j].stars
+	game.state.basekl += game.state.galaxy[nq.i][nq.j].starbase
+	game.state.nplankl += npdead
+    # mark supernova in galaxy and in star chart 
+    if game.quadrant == nq or communicating():
+	game.state.galaxy[nq.i][nq.j].supernova = True
+    # If supernova destroys last Klingons give special message 
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0 and not nq == game.quadrant:
+	skip(2)
+	if w == None:
+	    prout(_("Lucky you!"))
+	proutn(_("A supernova in %s has just destroyed the last Klingons.") % nq)
+	finish(FWON)
+	return
+    # if some Klingons remain, continue or die in supernova 
+    if game.alldone:
+	finish(FSNOVAED)
+    return
+
+# Code from finish.c ends here.
+
+def selfdestruct():
+    "Self-destruct maneuver. Finish with a BANG!" 
+    scanner.chew()
+    if damaged(DCOMPTR):
+	prout(_("Computer damaged; cannot execute destruct sequence."))
+	return
+    prouts(_("---WORKING---")); skip(1)
+    prouts(_("SELF-DESTRUCT-SEQUENCE-ACTIVATED")); skip(1)
+    prouts("   10"); skip(1)
+    prouts("       9"); skip(1)
+    prouts("          8"); skip(1)
+    prouts("             7"); skip(1)
+    prouts("                6"); skip(1)
+    skip(1)
+    prout(_("ENTER-CORRECT-PASSWORD-TO-CONTINUE-"))
+    skip(1)
+    prout(_("SELF-DESTRUCT-SEQUENCE-OTHERWISE-"))
+    skip(1)
+    prout(_("SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED"))
+    skip(1)
+    scanner.next()
+    scanner.chew()
+    if game.passwd != scanner.token:
+	prouts(_("PASSWORD-REJECTED;"))
+	skip(1)
+	prouts(_("CONTINUITY-EFFECTED"))
+	skip(2)
+	return
+    prouts(_("PASSWORD-ACCEPTED")); skip(1)
+    prouts("                   5"); skip(1)
+    prouts("                      4"); skip(1)
+    prouts("                         3"); skip(1)
+    prouts("                            2"); skip(1)
+    prouts("                              1"); skip(1)
+    if withprob(0.15):
+	prouts(_("GOODBYE-CRUEL-WORLD"))
+	skip(1)
+    kaboom()
+
+def kaboom():
+    stars()
+    if game.ship=='E':
+	prouts("***")
+    prouts(_("********* Entropy of %s maximized *********") % crmshp())
+    skip(1)
+    stars()
+    skip(1)
+    if len(game.enemies) != 0:
+	whammo = 25.0 * game.energy
+	l=1
+	while l <= len(game.enemies):
+	    if game.enemies[l].power*game.enemies[l].kdist <= whammo: 
+		deadkl(game.enemies[l].location, game.quad[game.enemies[l].location.i][game.enemies[l].location.j], game.enemies[l].location)
+	    l += 1
+    finish(FDILITHIUM)
+				
+def killrate():
+    "Compute our rate of kils over time."
+    elapsed = game.state.date - game.indate
+    if elapsed == 0:	# Avoid divide-by-zero error if calculated on turn 0
+        return 0
+    else:
+        starting = (game.inkling + game.incom + game.inscom)
+        remaining = (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)
+        return (starting - remaining)/elapsed
+
+def badpoints():
+    "Compute demerits."
+    badpt = 5.0*game.state.starkl + \
+            game.casual + \
+            10.0*game.state.nplankl + \
+            300*game.state.nworldkl + \
+            45.0*game.nhelp +\
+            100.0*game.state.basekl +\
+            3.0*game.abandoned
+    if game.ship == 'F':
+        badpt += 100.0
+    elif game.ship == None:
+        badpt += 200.0
+    return badpt
+
+def finish(ifin):
+    # end the game, with appropriate notfications 
+    igotit = False
+    game.alldone = True
+    skip(3)
+    prout(_("It is stardate %.1f.") % game.state.date)
+    skip(1)
+    if ifin == FWON: # Game has been won
+	if game.state.nromrem != 0:
+	    prout(_("The remaining %d Romulans surrender to Starfleet Command.") %
+		  game.state.nromrem)
+
+	prout(_("You have smashed the Klingon invasion fleet and saved"))
+	prout(_("the Federation."))
+	game.gamewon = True
+	if game.alive:
+            badpt = badpoints()
+            if badpt < 100.0:
+                badpt = 0.0	# Close enough!
+            # killsPerDate >= RateMax
+	    if game.state.date-game.indate < 5.0 or \
+                killrate() >= 0.1*game.skill*(game.skill+1.0) + 0.1 + 0.008*badpt:
+		skip(1)
+		prout(_("In fact, you have done so well that Starfleet Command"))
+		if game.skill == SKILL_NOVICE:
+		    prout(_("promotes you one step in rank from \"Novice\" to \"Fair\"."))
+		elif game.skill == SKILL_FAIR:
+		    prout(_("promotes you one step in rank from \"Fair\" to \"Good\"."))
+		elif game.skill == SKILL_GOOD:
+		    prout(_("promotes you one step in rank from \"Good\" to \"Expert\"."))
+		elif game.skill == SKILL_EXPERT:
+		    prout(_("promotes you to Commodore Emeritus."))
+		    skip(1)
+		    prout(_("Now that you think you're really good, try playing"))
+		    prout(_("the \"Emeritus\" game. It will splatter your ego."))
+		elif game.skill == SKILL_EMERITUS:
+		    skip(1)
+		    proutn(_("Computer-  "))
+		    prouts(_("ERROR-ERROR-ERROR-ERROR"))
+		    skip(2)
+		    prouts(_("  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM"))
+		    skip(1)
+		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
+		    skip(1)
+		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
+		    skip(1)
+		    prouts(_("  THIS-PROGRAM-MUST-SURVIVE"))
+		    skip(1)
+		    prouts(_("  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI"))
+		    skip(2)
+		    prout(_("Now you can retire and write your own Star Trek game!"))
+		    skip(1)
+		elif game.skill >= SKILL_EXPERT:
+		    if game.thawed and not idebug:
+			prout(_("You cannot get a citation, so..."))
+		    else:
+			proutn(_("Do you want your Commodore Emeritus Citation printed? "))
+			scanner.chew()
+			if ja() == True:
+			    igotit = True
+	    # Only grant long life if alive (original didn't!)
+	    skip(1)
+	    prout(_("LIVE LONG AND PROSPER."))
+	score()
+	if igotit:
+	    plaque()	    
+	return
+    elif ifin == FDEPLETE: # Federation Resources Depleted
+	prout(_("Your time has run out and the Federation has been"))
+	prout(_("conquered.  Your starship is now Klingon property,"))
+	prout(_("and you are put on trial as a war criminal.  On the"))
+	proutn(_("basis of your record, you are "))
+	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)*3.0 > (game.inkling + game.incom + game.inscom):
+	    prout(_("acquitted."))
+	    skip(1)
+	    prout(_("LIVE LONG AND PROSPER."))
+	else:
+	    prout(_("found guilty and"))
+	    prout(_("sentenced to death by slow torture."))
+	    game.alive = False
+	score()
+	return
+    elif ifin == FLIFESUP:
+	prout(_("Your life support reserves have run out, and"))
+	prout(_("you die of thirst, starvation, and asphyxiation."))
+	prout(_("Your starship is a derelict in space."))
+    elif ifin == FNRG:
+	prout(_("Your energy supply is exhausted."))
+	skip(1)
+	prout(_("Your starship is a derelict in space."))
+    elif ifin == FBATTLE:
+	prout(_("The %s has been destroyed in battle.") % crmshp())
+	skip(1)
+	prout(_("Dulce et decorum est pro patria mori."))
+    elif ifin == FNEG3:
+	prout(_("You have made three attempts to cross the negative energy"))
+	prout(_("barrier which surrounds the galaxy."))
+	skip(1)
+	prout(_("Your navigation is abominable."))
+	score()
+    elif ifin == FNOVA:
+	prout(_("Your starship has been destroyed by a nova."))
+	prout(_("That was a great shot."))
+	skip(1)
+    elif ifin == FSNOVAED:
+	prout(_("The %s has been fried by a supernova.") % crmshp())
+	prout(_("...Not even cinders remain..."))
+    elif ifin == FABANDN:
+	prout(_("You have been captured by the Klingons. If you still"))
+	prout(_("had a starbase to be returned to, you would have been"))
+	prout(_("repatriated and given another chance. Since you have"))
+	prout(_("no starbases, you will be mercilessly tortured to death."))
+    elif ifin == FDILITHIUM:
+	prout(_("Your starship is now an expanding cloud of subatomic particles"))
+    elif ifin == FMATERIALIZE:
+	prout(_("Starbase was unable to re-materialize your starship."))
+	prout(_("Sic transit gloria mundi"))
+    elif ifin == FPHASER:
+	prout(_("The %s has been cremated by its own phasers.") % crmshp())
+    elif ifin == FLOST:
+	prout(_("You and your landing party have been"))
+	prout(_("converted to energy, disipating through space."))
+    elif ifin == FMINING:
+	prout(_("You are left with your landing party on"))
+	prout(_("a wild jungle planet inhabited by primitive cannibals."))
+	skip(1)
+	prout(_("They are very fond of \"Captain Kirk\" soup."))
+	skip(1)
+	prout(_("Without your leadership, the %s is destroyed.") % crmshp())
+    elif ifin == FDPLANET:
+	prout(_("You and your mining party perish."))
+	skip(1)
+	prout(_("That was a great shot."))
+	skip(1)
+    elif ifin == FSSC:
+	prout(_("The Galileo is instantly annihilated by the supernova."))
+	prout(_("You and your mining party are atomized."))
+	skip(1)
+	prout(_("Mr. Spock takes command of the %s and") % crmshp())
+	prout(_("joins the Romulans, wreaking terror on the Federation."))
+    elif ifin == FPNOVA:
+	prout(_("You and your mining party are atomized."))
+	skip(1)
+	prout(_("Mr. Spock takes command of the %s and") % crmshp())
+	prout(_("joins the Romulans, wreaking terror on the Federation."))
+    elif ifin == FSTRACTOR:
+	prout(_("The shuttle craft Galileo is also caught,"))
+	prout(_("and breaks up under the strain."))
+	skip(1)
+	prout(_("Your debris is scattered for millions of miles."))
+	prout(_("Without your leadership, the %s is destroyed.") % crmshp())
+    elif ifin == FDRAY:
+	prout(_("The mutants attack and kill Spock."))
+	prout(_("Your ship is captured by Klingons, and"))
+	prout(_("your crew is put on display in a Klingon zoo."))
+    elif ifin == FTRIBBLE:
+	prout(_("Tribbles consume all remaining water,"))
+	prout(_("food, and oxygen on your ship."))
+	skip(1)
+	prout(_("You die of thirst, starvation, and asphyxiation."))
+	prout(_("Your starship is a derelict in space."))
+    elif ifin == FHOLE:
+	prout(_("Your ship is drawn to the center of the black hole."))
+	prout(_("You are crushed into extremely dense matter."))
+    elif ifin == FCREW:
+	prout(_("Your last crew member has died."))
+    if game.ship == 'F':
+	game.ship = None
+    elif game.ship == 'E':
+	game.ship = 'F'
+    game.alive = False
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0:
+	goodies = game.state.remres/game.inresor
+	baddies = (game.state.remkl + 2.0*len(game.state.kcmdr))/(game.inkling+2.0*game.incom)
+	if goodies/baddies >= randreal(1.0, 1.5):
+	    prout(_("As a result of your actions, a treaty with the Klingon"))
+	    prout(_("Empire has been signed. The terms of the treaty are"))
+	    if goodies/baddies >= randreal(3.0):
+		prout(_("favorable to the Federation."))
+		skip(1)
+		prout(_("Congratulations!"))
+	    else:
+		prout(_("highly unfavorable to the Federation."))
+	else:
+	    prout(_("The Federation will be destroyed."))
+    else:
+	prout(_("Since you took the last Klingon with you, you are a"))
+	prout(_("martyr and a hero. Someday maybe they'll erect a"))
+	prout(_("statue in your memory. Rest in peace, and try not"))
+	prout(_("to think about pigeons."))
+	game.gamewon = True
+    score()
+
+def score():
+    "Compute player's score."
+    timused = game.state.date - game.indate
+    iskill = game.skill
+    if (timused == 0 or (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0) and timused < 5.0:
+	timused = 5.0
+    perdate = killrate()
+    ithperd = 500*perdate + 0.5
+    iwon = 0
+    if game.gamewon:
+	iwon = 100*game.skill
+    if game.ship == 'E': 
+	klship = 0
+    elif game.ship == 'F': 
+	klship = 1
+    else:
+	klship = 2
+    iscore = 10*(game.inkling - game.state.remkl) \
+             + 50*(game.incom - len(game.state.kcmdr)) \
+             + ithperd + iwon \
+             + 20*(game.inrom - game.state.nromrem) \
+             + 200*(game.inscom - game.state.nscrem) \
+    	     - game.state.nromrem \
+             - badpoints()
+    if not game.alive:
+	iscore -= 200
+    skip(2)
+    prout(_("Your score --"))
+    if game.inrom - game.state.nromrem:
+	prout(_("%6d Romulans destroyed                 %5d") %
+	      (game.inrom - game.state.nromrem, 20*(game.inrom - game.state.nromrem)))
+    if game.state.nromrem and game.gamewon:
+	prout(_("%6d Romulans captured                  %5d") %
+	      (game.state.nromrem, game.state.nromrem))
+    if game.inkling - game.state.remkl:
+	prout(_("%6d ordinary Klingons destroyed        %5d") %
+	      (game.inkling - game.state.remkl, 10*(game.inkling - game.state.remkl)))
+    if game.incom - len(game.state.kcmdr):
+	prout(_("%6d Klingon commanders destroyed       %5d") %
+	      (game.incom - len(game.state.kcmdr), 50*(game.incom - len(game.state.kcmdr))))
+    if game.inscom - game.state.nscrem:
+	prout(_("%6d Super-Commander destroyed          %5d") %
+	      (game.inscom - game.state.nscrem, 200*(game.inscom - game.state.nscrem)))
+    if ithperd:
+	prout(_("%6.2f Klingons per stardate              %5d") %
+	      (perdate, ithperd))
+    if game.state.starkl:
+	prout(_("%6d stars destroyed by your action     %5d") %
+	      (game.state.starkl, -5*game.state.starkl))
+    if game.state.nplankl:
+	prout(_("%6d planets destroyed by your action   %5d") %
+	      (game.state.nplankl, -10*game.state.nplankl))
+    if (game.options & OPTION_WORLDS) and game.state.nworldkl:
+	prout(_("%6d inhabited planets destroyed by your action   %5d") %
+	      (game.state.nworldkl, -300*game.state.nworldkl))
+    if game.state.basekl:
+	prout(_("%6d bases destroyed by your action     %5d") %
+	      (game.state.basekl, -100*game.state.basekl))
+    if game.nhelp:
+	prout(_("%6d calls for help from starbase       %5d") %
+	      (game.nhelp, -45*game.nhelp))
+    if game.casual:
+	prout(_("%6d casualties incurred                %5d") %
+	      (game.casual, -game.casual))
+    if game.abandoned:
+	prout(_("%6d crew abandoned in space            %5d") %
+	      (game.abandoned, -3*game.abandoned))
+    if klship:
+	prout(_("%6d ship(s) lost or destroyed          %5d") %
+	      (klship, -100*klship))
+    if not game.alive:
+	prout(_("Penalty for getting yourself killed        -200"))
+    if game.gamewon:
+	proutn(_("Bonus for winning "))
+	if game.skill   == SKILL_NOVICE:	proutn(_("Novice game  "))
+	elif game.skill == SKILL_FAIR:  	proutn(_("Fair game    "))
+	elif game.skill ==  SKILL_GOOD: 	proutn(_("Good game    "))
+	elif game.skill ==  SKILL_EXPERT:	proutn(_("Expert game  "))
+	elif game.skill ==  SKILL_EMERITUS:	proutn(_("Emeritus game"))
+	prout("           %5d" % iwon)
+    skip(1)
+    prout(_("TOTAL SCORE                               %5d") % iscore)
+
+def plaque():
+    "Emit winner's commemmorative plaque." 
+    skip(2)
+    while True:
+        proutn(_("File or device name for your plaque: "))
+        winner = cgetline()
+        try:
+            fp = open(winner, "w")
+            break
+        except IOError:
+            prout(_("Invalid name."))
+
+    proutn(_("Enter name to go on plaque (up to 30 characters): "))
+    winner = cgetline()
+    # The 38 below must be 64 for 132-column paper 
+    nskip = 38 - len(winner)/2
+    fp.write("\n\n\n\n")
+    # --------DRAW ENTERPRISE PICTURE. 
+    fp.write("                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n" )
+    fp.write("                                      EEE                      E  : :                                         :  E\n" )
+    fp.write("                                    EE   EEE                   E  : :                   NCC-1701              :  E\n")
+    fp.write("EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n")
+    fp.write(" E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n")
+    fp.write("                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n")
+    fp.write("                               EEEEEEE   EEEEE    E          E              E  E\n")
+    fp.write("                                      EEE           E          E            E  E\n")
+    fp.write("                                                       E         E          E  E\n")
+    fp.write("                                                         EEEEEEEEEEEEE      E  E\n")
+    fp.write("                                                      EEE :           EEEEEEE  EEEEEEEE\n")
+    fp.write("                                                    :E    :                 EEEE       E\n")
+    fp.write("                                                   .-E   -:-----                       E\n")
+    fp.write("                                                    :E    :                            E\n")
+    fp.write("                                                      EE  :                    EEEEEEEE\n")
+    fp.write("                                                       EEEEEEEEEEEEEEEEEEEEEEE\n")
+    fp.write("\n\n\n")
+    fp.write(_("                                                       U. S. S. ENTERPRISE\n"))
+    fp.write("\n\n\n\n")
+    fp.write(_("                                  For demonstrating outstanding ability as a starship captain\n"))
+    fp.write("\n")
+    fp.write(_("                                                Starfleet Command bestows to you\n"))
+    fp.write("\n")
+    fp.write("%*s%s\n\n" % (nskip, "", winner))
+    fp.write(_("                                                           the rank of\n\n"))
+    fp.write(_("                                                       \"Commodore Emeritus\"\n\n"))
+    fp.write("                                                          ")
+    if game.skill ==  SKILL_EXPERT:
+        fp.write(_(" Expert level\n\n"))
+    elif game.skill == SKILL_EMERITUS:
+        fp.write(_("Emeritus level\n\n"))
+    else:
+        fp.write(_(" Cheat level\n\n"))
+    timestring = time.ctime()
+    fp.write(_("                                                 This day of %.6s %.4s, %.8s\n\n") %
+                    (timestring+4, timestring+20, timestring+11))
+    fp.write(_("                                                        Your score:  %d\n\n") % iscore)
+    fp.write(_("                                                    Klingons per stardate:  %.2f\n") % perdate)
+    fp.close()
+
+# Code from io.c begins here
+
+rows = linecount = 0	# for paging 
+stdscr = None
+replayfp = None
+fullscreen_window = None
+srscan_window     = None
+report_window     = None
+status_window     = None
+lrscan_window     = None
+message_window    = None
+prompt_window     = None
+curwnd = None
+
+def iostart():
+    global stdscr, rows
+    "for some recent versions of python2, the following enables UTF8"
+    "for the older ones we probably need to set C locale, and the python3"
+    "has no problems at all"
+    if sys.version_info.major < 3:
+	import locale
+	locale.setlocale(locale.LC_ALL, "")
+    gettext.bindtextdomain("sst", "/usr/local/share/locale")
+    gettext.textdomain("sst")
+    if not (game.options & OPTION_CURSES):
+	ln_env = os.getenv("LINES")
+        if ln_env:
+            rows = ln_env
+        else:
+            rows = 25
+    else:
+	stdscr = curses.initscr()
+	stdscr.keypad(True)
+	curses.nonl()
+	curses.cbreak()
+        if game.options & OPTION_COLOR:
+            curses.start_color();
+            curses.use_default_colors()
+            curses.init_pair(curses.COLOR_BLACK,   curses.COLOR_BLACK, -1);
+            curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN, -1);
+            curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED, -1);
+            curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN, -1);
+            curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE, -1);
+            curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1);
+            curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE, -1);
+            curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW, -1);
+        global fullscreen_window, srscan_window, report_window, status_window
+        global lrscan_window, message_window, prompt_window
+        (rows, columns)   = stdscr.getmaxyx()
+	fullscreen_window = stdscr
+	srscan_window     = curses.newwin(12, 25, 0,       0)
+	report_window     = curses.newwin(11, 0,  1,       25)
+	status_window     = curses.newwin(10, 0,  1,       39)
+	lrscan_window     = curses.newwin(5,  0,  0,       64) 
+	message_window    = curses.newwin(0,  0,  12,      0)
+	prompt_window     = curses.newwin(1,  0,  rows-2,  0) 
+	message_window.scrollok(True)
+	setwnd(fullscreen_window)
+
+def ioend():
+    "Wrap up I/O."
+    if game.options & OPTION_CURSES:
+        stdscr.keypad(False)
+        curses.echo()
+        curses.nocbreak()
+        curses.endwin()
+
+def waitfor():
+    "Wait for user action -- OK to do nothing if on a TTY"
+    if game.options & OPTION_CURSES:
+	stdscr.getch()
+
+def announce():
+    skip(1)
+    prouts(_("[ANNOUNCEMENT ARRIVING...]"))
+    skip(1)
+
+def pause_game():
+    if game.skill > SKILL_FAIR:
+        prompt = _("[CONTINUE?]")
+    else:
+        prompt = _("[PRESS ENTER TO CONTINUE]")
+
+    if game.options & OPTION_CURSES:
+        drawmaps(0)
+        setwnd(prompt_window)
+        prompt_window.clear()
+        prompt_window.addstr(prompt)
+        prompt_window.getstr()
+        prompt_window.clear()
+        prompt_window.refresh()
+        setwnd(message_window)
+    else:
+        global linecount
+        sys.stdout.write('\n')
+        proutn(prompt)
+        raw_input()
+        for j in range(rows):
+            sys.stdout.write('\n')
+        linecount = 0
+
+def skip(i):
+    "Skip i lines.  Pause game if this would cause a scrolling event."
+    for dummy in range(i):
+	if game.options & OPTION_CURSES:
+            (y, x) = curwnd.getyx()
+            (my, mx) = curwnd.getmaxyx()
+	    if curwnd == message_window and y >= my - 2:
+		pause_game()
+		clrscr()
+	    else:
+                try:
+                    curwnd.move(y+1, 0)
+                except curses.error:
+                    pass
+	else:
+            global linecount
+	    linecount += 1
+	    if rows and linecount >= rows:
+		pause_game()
+	    else:
+		sys.stdout.write('\n')
+
+def proutn(line):
+    "Utter a line with no following line feed."
+    if game.options & OPTION_CURSES:
+	curwnd.addstr(line)
+	curwnd.refresh()
+    else:
+	sys.stdout.write(line)
+        sys.stdout.flush()
+
+def prout(line):
+    proutn(line)
+    skip(1)
+
+def prouts(line):
+    "Emit slowly!" 
+    for c in line:
+        if not replayfp or replayfp.closed:	# Don't slow down replays
+            time.sleep(0.03)
+	proutn(c)
+	if game.options & OPTION_CURSES:
+	    curwnd.refresh()
+	else:
+	    sys.stdout.flush()
+    if not replayfp or replayfp.closed:
+        time.sleep(0.03)
+
+def cgetline():
+    "Get a line of input."
+    if game.options & OPTION_CURSES:
+	line = curwnd.getstr() + "\n"
+	curwnd.refresh()
+    else:
+	if replayfp and not replayfp.closed:
+            while True:
+                line = replayfp.readline()
+                proutn(line)
+                if line == '':
+                    prout("*** Replay finished")
+                    replayfp.close()
+                    break
+                elif line[0] != "#":
+                    break
+	else:
+	    line = raw_input() + "\n"
+    if logfp:
+	logfp.write(line)
+    return line
+
+def setwnd(wnd):
+    "Change windows -- OK for this to be a no-op in tty mode."
+    global curwnd
+    if game.options & OPTION_CURSES:
+        curwnd = wnd
+        curses.curs_set(wnd == fullscreen_window or wnd == message_window or wnd == prompt_window)
+
+def clreol():
+    "Clear to end of line -- can be a no-op in tty mode" 
+    if game.options & OPTION_CURSES:
+        curwnd.clrtoeol()
+        curwnd.refresh()
+
+def clrscr():
+    "Clear screen -- can be a no-op in tty mode."
+    global linecount
+    if game.options & OPTION_CURSES:
+       curwnd.clear()
+       curwnd.move(0, 0)
+       curwnd.refresh()
+    linecount = 0
+
+def textcolor(color=DEFAULT):
+    if game.options & OPTION_COLOR:
+	if color == DEFAULT: 
+	    curwnd.attrset(0);
+	elif color ==  BLACK: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK));
+	elif color ==  BLUE: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE));
+	elif color ==  GREEN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN));
+	elif color ==  CYAN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN));
+	elif color ==  RED: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_RED));
+	elif color ==  MAGENTA: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA));
+	elif color ==  BROWN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW));
+	elif color ==  LIGHTGRAY: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE));
+	elif color ==  DARKGRAY: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK) | curses.A_BOLD);
+	elif color ==  LIGHTBLUE: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE) | curses.A_BOLD);
+	elif color ==  LIGHTGREEN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN) | curses.A_BOLD);
+	elif color ==  LIGHTCYAN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN) | curses.A_BOLD);
+	elif color ==  LIGHTRED: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_RED) | curses.A_BOLD);
+	elif color ==  LIGHTMAGENTA: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA) | curses.A_BOLD);
+	elif color ==  YELLOW: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW) | curses.A_BOLD);
+	elif color ==  WHITE:
+	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE) | curses.A_BOLD);
+
+def highvideo():
+    if game.options & OPTION_COLOR:
+        curwnd.attron(curses.A_REVERSE)
+
+#
+# Things past this point have policy implications.
+# 
+
+def drawmaps(mode):
+    "Hook to be called after moving to redraw maps."
+    if game.options & OPTION_CURSES:
+	if mode == 1:
+	    sensor()
+        setwnd(srscan_window)
+        curwnd.move(0, 0)
+        srscan()
+	if mode != 2:
+	    setwnd(status_window)
+	    status_window.clear()
+	    status_window.move(0, 0)
+	    setwnd(report_window)
+	    report_window.clear()
+	    report_window.move(0, 0)
+	    status()
+	    setwnd(lrscan_window)
+	    lrscan_window.clear()
+	    lrscan_window.move(0, 0)
+	    lrscan(silent=False)
+
+def put_srscan_sym(w, sym):
+    "Emit symbol for short-range scan."
+    srscan_window.move(w.i+1, w.j*2+2)
+    srscan_window.addch(sym)
+    srscan_window.refresh()
+
+def boom(w):
+    "Enemy fall down, go boom."  
+    if game.options & OPTION_CURSES:
+	drawmaps(2)
+	setwnd(srscan_window)
+	srscan_window.attron(curses.A_REVERSE)
+	put_srscan_sym(w, game.quad[w.i][w.j])
+	#sound(500)
+	#time.sleep(1.0)
+	#nosound()
+	srscan_window.attroff(curses.A_REVERSE)
+	put_srscan_sym(w, game.quad[w.i][w.j])
+	curses.delay_output(500)
+	setwnd(message_window) 
+
+def warble():
+    "Sound and visual effects for teleportation."
+    if game.options & OPTION_CURSES:
+	drawmaps(2)
+	setwnd(message_window)
+	#sound(50)
+    prouts("     . . . . .     ")
+    if game.options & OPTION_CURSES:
+	#curses.delay_output(1000)
+	#nosound()
+        pass
+
+def tracktorpedo(origin, w, step, i, n, iquad):
+    "Torpedo-track animation." 
+    if not game.options & OPTION_CURSES:
+	if step == 1:
+	    if n != 1:
+		skip(1)
+		proutn(_("Track for torpedo number %d-  ") % (i+1))
+	    else:
+		skip(1)
+		proutn(_("Torpedo track- "))
+	elif step==4 or step==9: 
+	    skip(1)
+	proutn("%s   " % w)
+    else:
+	if not damaged(DSRSENS) or game.condition=="docked":
+	    if i != 0 and step == 1:
+		drawmaps(2)
+		time.sleep(0.4)
+	    if (iquad=='.') or (iquad==' '):
+		put_srscan_sym(w, '+')
+		#sound(step*10)
+		#time.sleep(0.1)
+		#nosound()
+		put_srscan_sym(w, iquad)
+	    else:
+		curwnd.attron(curses.A_REVERSE)
+		put_srscan_sym(w, iquad)
+		#sound(500)
+		#time.sleep(1.0)
+		#nosound()
+		curwnd.attroff(curses.A_REVERSE)
+		put_srscan_sym(w, iquad)
+	else:
+	    proutn("%s   " % w)
+
+def makechart():
+    "Display the current galaxy chart."
+    if game.options & OPTION_CURSES:
+	setwnd(message_window)
+	message_window.clear()
+    chart()
+    if game.options & OPTION_TTY:
+	skip(1)
+
+NSYM	= 14
+
+def prstat(txt, data):
+    proutn(txt)
+    if game.options & OPTION_CURSES:
+	skip(1)
+	setwnd(status_window)
+    else:
+        proutn(" " * (NSYM - len(txt)))
+    proutn(data)
+    skip(1)
+    if game.options & OPTION_CURSES:
+	setwnd(report_window)
+
+# Code from moving.c begins here
+
+def imove(course=None, noattack=False):
+    "Movement execution for warp, impulse, supernova, and tractor-beam events."
+    w = coord()
+
+    def newquadrant(noattack):
+        # Leaving quadrant -- allow final enemy attack 
+        # Don't do it if being pushed by Nova 
+        if len(game.enemies) != 0 and not noattack:
+            newcnd()
+            for enemy in game.enemies:
+                finald = (w - enemy.location).distance()
+                enemy.kavgd = 0.5 * (finald + enemy.kdist)
+            # Stas Sergeev added the condition
+            # that attacks only happen if Klingons
+            # are present and your skill is good.
+            if game.skill > SKILL_GOOD and game.klhere > 0 and not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+                attack(torps_ok=False)
+            if game.alldone:
+                return
+        # check for edge of galaxy 
+        kinks = 0
+        while True:
+            kink = False
+            if course.final.i < 0:
+                course.final.i = -course.final.i
+                kink = True
+            if course.final.j < 0:
+                course.final.j = -course.final.j
+                kink = True
+            if course.final.i >= GALSIZE*QUADSIZE:
+                course.final.i = (GALSIZE*QUADSIZE*2) - course.final.i
+                kink = True
+            if course.final.j >= GALSIZE*QUADSIZE:
+                course.final.j = (GALSIZE*QUADSIZE*2) - course.final.j
+                kink = True
+            if kink:
+                kinks += 1
+            else:
+                break
+        if kinks:
+            game.nkinks += 1
+            if game.nkinks == 3:
+                # Three strikes -- you're out! 
+                finish(FNEG3)
+                return
+            skip(1)
+            prout(_("YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER"))
+            prout(_("AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,"))
+            prout(_("YOU WILL BE DESTROYED."))
+        # Compute final position in new quadrant 
+        if trbeam: # Don't bother if we are to be beamed 
+            return
+        game.quadrant = course.final.quadrant()
+        game.sector = course.final.sector()
+        skip(1)
+        prout(_("Entering Quadrant %s.") % game.quadrant)
+        game.quad[game.sector.i][game.sector.j] = game.ship
+        newqad()
+        if game.skill>SKILL_NOVICE:
+            attack(torps_ok=False)  
+
+    def check_collision(h):
+        iquad = game.quad[h.i][h.j]
+        if iquad != '.':
+            # object encountered in flight path 
+            stopegy = 50.0*course.distance/game.optime
+            if iquad in ('T', 'K', 'C', 'S', 'R', '?'):
+                for enemy in game.enemies:
+                    if enemy.location == game.sector:
+                        break
+                collision(rammed=False, enemy=enemy)
+                return True
+            elif iquad == ' ':
+                skip(1)
+                prouts(_("***RED ALERT!  RED ALERT!"))
+                skip(1)
+                proutn("***" + crmshp())
+                proutn(_(" pulled into black hole at Sector %s") % h)
+                # Getting pulled into a black hole was certain
+                # death in Almy's original.  Stas Sergeev added a
+                # possibility that you'll get timewarped instead.
+                n=0
+                for m in range(NDEVICES):
+                    if game.damage[m]>0: 
+                        n += 1
+                probf=math.pow(1.4,(game.energy+game.shield)/5000.0-1.0)*math.pow(1.3,1.0/(n+1)-1.0)
+                if (game.options & OPTION_BLKHOLE) and withprob(1-probf): 
+                    timwrp()
+                else: 
+                    finish(FHOLE)
+                return True
+            else:
+                # something else 
+                skip(1)
+                proutn(crmshp())
+                if iquad == '#':
+                    prout(_(" encounters Tholian web at %s;") % h)
+                else:
+                    prout(_(" blocked by object at %s;") % h)
+                proutn(_("Emergency stop required "))
+                prout(_("%2d units of energy.") % int(stopegy))
+                game.energy -= stopegy
+                if game.energy <= 0:
+                    finish(FNRG)
+                return True
+        return False
+
+    trbeam = False
+    if game.inorbit:
+	prout(_("Helmsman Sulu- \"Leaving standard orbit.\""))
+	game.inorbit = False
+    # If tractor beam is to occur, don't move full distance 
+    if game.state.date+game.optime >= scheduled(FTBEAM):
+	trbeam = True
+	game.condition = "red"
+	course.distance = course.distance*(scheduled(FTBEAM)-game.state.date)/game.optime + 0.1
+	game.optime = scheduled(FTBEAM) - game.state.date + 1e-5
+    # Move out
+    game.quad[game.sector.i][game.sector.j] = '.'
+    for m in range(course.moves):
+        course.next()
+        w = course.sector()
+        if course.origin.quadrant() != course.location.quadrant():
+            newquadrant(noattack)
+            break
+        elif check_collision(w):
+            print "Collision detected"
+            break
+        else:
+            game.sector = w
+    # We're in destination quadrant -- compute new average enemy distances
+    game.quad[game.sector.i][game.sector.j] = game.ship
+    if game.enemies:
+        for enemy in game.enemies:
+            finald = (w-enemy.location).distance()
+            enemy.kavgd = 0.5 * (finald + enemy.kdist)
+            enemy.kdist = finald
+        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            attack(torps_ok=False)
+        for enemy in game.enemies:
+            enemy.kavgd = enemy.kdist
+    newcnd()
+    drawmaps(0)
+    setwnd(message_window)
+    return
+
+def dock(verbose):
+    "Dock our ship at a starbase."
+    scanner.chew()
+    if game.condition == "docked" and verbose:
+	prout(_("Already docked."))
+	return
+    if game.inorbit:
+	prout(_("You must first leave standard orbit."))
+	return
+    if not game.base.is_valid() or abs(game.sector.i-game.base.i) > 1 or abs(game.sector.j-game.base.j) > 1:
+	prout(crmshp() + _(" not adjacent to base."))
+	return
+    game.condition = "docked"
+    if "verbose":
+	prout(_("Docked."))
+    game.ididit = True
+    if game.energy < game.inenrg:
+	game.energy = game.inenrg
+    game.shield = game.inshld
+    game.torps = game.intorps
+    game.lsupres = game.inlsr
+    game.state.crew = FULLCREW
+    if not damaged(DRADIO) and \
+	((is_scheduled(FCDBAS) or game.isatb == 1) and not game.iseenit):
+	# get attack report from base 
+	prout(_("Lt. Uhura- \"Captain, an important message from the starbase:\""))
+	attackreport(False)
+	game.iseenit = True
+
+def cartesian(loc1=None, loc2=None):
+    if loc1 is None:
+        return game.quadrant * QUADSIZE + game.sector
+    elif loc2 is None:
+        return game.quadrant * QUADSIZE + loc1
+    else:
+        return loc1 * QUADSIZE + loc2
+
+def getcourse(isprobe):
+    "Get a course and distance from the user."
+    key = 0
+    dquad = copy.copy(game.quadrant)
+    navmode = "unspecified"
+    itemp = "curt"
+    dsect = coord()
+    iprompt = False
+    if game.landed and not isprobe:
+	prout(_("Dummy! You can't leave standard orbit until you"))
+	proutn(_("are back aboard the ship."))
+	scanner.chew()
+	raise TrekError
+    while navmode == "unspecified":
+	if damaged(DNAVSYS):
+	    if isprobe:
+		prout(_("Computer damaged; manual navigation only"))
+	    else:
+		prout(_("Computer damaged; manual movement only"))
+	    scanner.chew()
+	    navmode = "manual"
+	    key = "IHEOL"
+	    break
+        key = scanner.next()
+	if key == "IHEOL":
+	    proutn(_("Manual or automatic- "))
+	    iprompt = True
+	    scanner.chew()
+	elif key == "IHALPHA":
+            if scanner.sees("manual"):
+		navmode = "manual"
+		key = scanner.next()
+		break
+            elif scanner.sees("automatic"):
+		navmode = "automatic"
+		key = scanner.next()
+		break
+	    else:
+		huh()
+		scanner.chew()
+		raise TrekError
+	else: # numeric 
+	    if isprobe:
+		prout(_("(Manual navigation assumed.)"))
+	    else:
+		prout(_("(Manual movement assumed.)"))
+	    navmode = "manual"
+	    break
+    delta = coord()
+    if navmode == "automatic":
+	while key == "IHEOL":
+	    if isprobe:
+		proutn(_("Target quadrant or quadrant&sector- "))
+	    else:
+		proutn(_("Destination sector or quadrant&sector- "))
+	    scanner.chew()
+	    iprompt = True
+	    key = scanner.next()
+	if key != "IHREAL":
+	    huh()
+	    raise TrekError
+	xi = int(round(scanner.real))-1
+	key = scanner.next()
+	if key != "IHREAL":
+	    huh()
+	    raise TrekError
+	xj = int(round(scanner.real))-1
+	key = scanner.next()
+	if key == "IHREAL":
+	    # both quadrant and sector specified 
+	    xk = int(round(scanner.real))-1
+	    key = scanner.next()
+	    if key != "IHREAL":
+		huh()
+		raise TrekError
+	    xl = int(round(scanner.real))-1
+	    dquad.i = xi
+	    dquad.j = xj
+	    dsect.i = xk
+	    dsect.j = xl
+	else:
+            # only one pair of numbers was specified
+	    if isprobe:
+		# only quadrant specified -- go to center of dest quad 
+		dquad.i = xi
+		dquad.j = xj
+		dsect.j = dsect.i = 4	# preserves 1-origin behavior
+	    else:
+                # only sector specified
+		dsect.i = xi
+		dsect.j = xj
+	    itemp = "normal"
+	if not dquad.valid_quadrant() or not dsect.valid_sector():
+	    huh()
+	    raise TrekError
+	skip(1)
+	if not isprobe:
+	    if itemp > "curt":
+		if iprompt:
+		    prout(_("Helmsman Sulu- \"Course locked in for Sector %s.\"") % dsect)
+	    else:
+		prout(_("Ensign Chekov- \"Course laid in, Captain.\""))
+        # the actual deltas get computed here
+	delta.j = dquad.j-game.quadrant.j + (dsect.j-game.sector.j)/(QUADSIZE*1.0)
+	delta.i = game.quadrant.i-dquad.i + (game.sector.i-dsect.i)/(QUADSIZE*1.0)
+    else: # manual 
+	while key == "IHEOL":
+	    proutn(_("X and Y displacements- "))
+	    scanner.chew()
+	    iprompt = True
+	    key = scanner.next()
+	itemp = "verbose"
+	if key != "IHREAL":
+	    huh()
+	    raise TrekError
+	delta.j = scanner.real
+	key = scanner.next()
+	if key != "IHREAL":
+	    huh()
+	    raise TrekError
+	delta.i = scanner.real
+    # Check for zero movement 
+    if delta.i == 0 and delta.j == 0:
+	scanner.chew()
+	raise TrekError
+    if itemp == "verbose" and not isprobe:
+	skip(1)
+	prout(_("Helmsman Sulu- \"Aye, Sir.\""))
+    scanner.chew()
+    return course(bearing=delta.bearing(), distance=delta.distance())
+
+class course:
+    def __init__(self, bearing, distance, origin=None): 
+        self.distance = distance
+        self.bearing = bearing
+        if origin is None:
+            self.origin = cartesian(game.quadrant, game.sector)
+        else:
+            self.origin = origin
+        # The bearing() code we inherited from FORTRAN is actually computing
+        # clockface directions!
+        if self.bearing < 0.0:
+            self.bearing += 12.0
+        self.angle = ((15.0 - self.bearing) * 0.5235988)
+        if origin is None:
+            self.origin = cartesian(game.quadrant, game.sector)
+        else:
+            self.origin = cartesian(game.quadrant, origin)
+        self.increment = coord(-math.sin(self.angle), math.cos(self.angle))
+        bigger = max(abs(self.increment.i), abs(self.increment.j))
+        self.increment /= bigger
+        self.moves = int(round(10*self.distance*bigger))
+        self.reset()
+        self.final = (self.location + self.moves*self.increment).roundtogrid()
+    def reset(self):
+        self.location = self.origin
+        self.step = 0
+    def arrived(self):
+        return self.location.roundtogrid() == self.final
+    def next(self):
+        "Next step on course."
+        self.step += 1
+        self.nextlocation = self.location + self.increment
+        samequad = (self.location.quadrant() == self.nextlocation.quadrant())
+        self.location = self.nextlocation
+        return samequad
+    def quadrant(self):
+        return self.location.quadrant()
+    def sector(self):
+        return self.location.sector()
+    def power(self, warp):
+	return self.distance*(warp**3)*(game.shldup+1)
+    def time(self, warp):
+        return 10.0*self.distance/warp**2
+
+def impulse():
+    "Move under impulse power."
+    game.ididit = False
+    if damaged(DIMPULS):
+	scanner.chew()
+	skip(1)
+	prout(_("Engineer Scott- \"The impulse engines are damaged, Sir.\""))
+	return
+    if game.energy > 30.0:
+        try:
+            course = getcourse(isprobe=False)
+        except TrekError:
+	    return
+	power = 20.0 + 100.0*course.distance
+    else:
+	power = 30.0
+    if power >= game.energy:
+	# Insufficient power for trip 
+	skip(1)
+	prout(_("First Officer Spock- \"Captain, the impulse engines"))
+	prout(_("require 20.0 units to engage, plus 100.0 units per"))
+	if game.energy > 30:
+	    proutn(_("quadrant.  We can go, therefore, a maximum of %d") %
+                     int(0.01 * (game.energy-20.0)-0.05))
+	    prout(_(" quadrants.\""))
+	else:
+	    prout(_("quadrant.  They are, therefore, useless.\""))
+	scanner.chew()
+	return
+    # Make sure enough time is left for the trip 
+    game.optime = course.dist/0.095
+    if game.optime >= game.state.remtime:
+	prout(_("First Officer Spock- \"Captain, our speed under impulse"))
+	prout(_("power is only 0.95 sectors per stardate. Are you sure"))
+	proutn(_("we dare spend the time?\" "))
+	if ja() == False:
+	    return
+    # Activate impulse engines and pay the cost 
+    imove(course, noattack=False)
+    game.ididit = True
+    if game.alldone:
+	return
+    power = 20.0 + 100.0*course.dist
+    game.energy -= power
+    game.optime = course.dist/0.095
+    if game.energy <= 0:
+	finish(FNRG)
+    return
+
+def warp(course, involuntary):
+    "ove under warp drive."
+    blooey = False; twarp = False
+    if not involuntary: # Not WARPX entry 
+	game.ididit = False
+	if game.damage[DWARPEN] > 10.0:
+	    scanner.chew()
+	    skip(1)
+	    prout(_("Engineer Scott- \"The warp engines are damaged, Sir.\""))
+	    return
+	if damaged(DWARPEN) and game.warpfac > 4.0:
+	    scanner.chew()
+	    skip(1)
+	    prout(_("Engineer Scott- \"Sorry, Captain. Until this damage"))
+	    prout(_("  is repaired, I can only give you warp 4.\""))
+	    return
+       	# Read in course and distance
+        if course==None:
+            try:
+                course = getcourse(isprobe=False)
+            except TrekError:
+                return
+	# Make sure starship has enough energy for the trip
+        # Note: this formula is slightly different from the C version,
+        # and lets you skate a bit closer to the edge.
+	if course.power(game.warpfac) >= game.energy:
+	    # Insufficient power for trip 
+	    game.ididit = False
+	    skip(1)
+	    prout(_("Engineering to bridge--"))
+	    if not game.shldup or 0.5*power > game.energy:
+		iwarp = (game.energy/(course.dist+0.05)) ** 0.333333333
+		if iwarp <= 0:
+		    prout(_("We can't do it, Captain. We don't have enough energy."))
+		else:
+		    proutn(_("We don't have enough energy, but we could do it at warp %d") % iwarp)
+		    if game.shldup:
+			prout(",")
+			prout(_("if you'll lower the shields."))
+		    else:
+			prout(".")
+	    else:
+		prout(_("We haven't the energy to go that far with the shields up."))
+	    return				
+	# Make sure enough time is left for the trip 
+	game.optime = course.time(game.warpfac)
+	if game.optime >= 0.8*game.state.remtime:
+	    skip(1)
+	    prout(_("First Officer Spock- \"Captain, I compute that such"))
+	    proutn(_("  a trip would require approximately %2.0f") %
+		   (100.0*game.optime/game.state.remtime))
+	    prout(_(" percent of our"))
+	    proutn(_("  remaining time.  Are you sure this is wise?\" "))
+	    if ja() == False:
+		game.ididit = False
+		game.optime=0 
+		return
+    # Entry WARPX 
+    if game.warpfac > 6.0:
+	# Decide if engine damage will occur
+        # ESR: Seems wrong. Probability of damage goes *down* with distance? 
+	prob = course.distance*(6.0-game.warpfac)**2/66.666666666
+	if prob > randreal():
+	    blooey = True
+	    course.distance = randreal(course.distance)
+	# Decide if time warp will occur 
+	if 0.5*course.distance*math.pow(7.0,game.warpfac-10.0) > randreal():
+	    twarp = True
+	if idebug and game.warpfac==10 and not twarp:
+	    blooey = False
+	    proutn("=== Force time warp? ")
+	    if ja() == True:
+		twarp = True
+	if blooey or twarp:
+	    # If time warp or engine damage, check path 
+	    # If it is obstructed, don't do warp or damage 
+            for m in range(course.moves):
+                course.next()
+                w = course.sector()
+                if not w.valid_sector():
+                    break
+		if game.quad[w.i][w.j] != '.':
+		    blooey = False
+		    twarp = False
+            course.reset()
+    # Activate Warp Engines and pay the cost 
+    imove(course, noattack=False)
+    if game.alldone:
+	return
+    game.energy -= course.power(game.warpfac)
+    if game.energy <= 0:
+	finish(FNRG)
+    game.optime = course.time(game.warpfac)
+    if twarp:
+	timwrp()
+    if blooey:
+	game.damage[DWARPEN] = game.damfac * randreal(1.0, 4.0)
+	skip(1)
+	prout(_("Engineering to bridge--"))
+	prout(_("  Scott here.  The warp engines are damaged."))
+	prout(_("  We'll have to reduce speed to warp 4."))
+    game.ididit = True
+    return
+
+def setwarp():
+    "Change the warp factor."
+    while True:
+        key=scanner.next()
+        if key != "IHEOL":
+            break
+	scanner.chew()
+	proutn(_("Warp factor- "))
+    if key != "IHREAL":
+	huh()
+	return
+    if game.damage[DWARPEN] > 10.0:
+	prout(_("Warp engines inoperative."))
+	return
+    if damaged(DWARPEN) and scanner.real > 4.0:
+	prout(_("Engineer Scott- \"I'm doing my best, Captain,"))
+	prout(_("  but right now we can only go warp 4.\""))
+	return
+    if scanner.real > 10.0:
+	prout(_("Helmsman Sulu- \"Our top speed is warp 10, Captain.\""))
+	return
+    if scanner.real < 1.0:
+	prout(_("Helmsman Sulu- \"We can't go below warp 1, Captain.\""))
+	return
+    oldfac = game.warpfac
+    game.warpfac = scanner.real
+    if game.warpfac <= oldfac or game.warpfac <= 6.0:
+	prout(_("Helmsman Sulu- \"Warp factor %d, Captain.\"") %
+	       int(game.warpfac))
+	return
+    if game.warpfac < 8.00:
+	prout(_("Engineer Scott- \"Aye, but our maximum safe speed is warp 6.\""))
+	return
+    if game.warpfac == 10.0:
+	prout(_("Engineer Scott- \"Aye, Captain, we'll try it.\""))
+	return
+    prout(_("Engineer Scott- \"Aye, Captain, but our engines may not take it.\""))
+    return
+
+def atover(igrab):
+    "Cope with being tossed out of quadrant by supernova or yanked by beam."
+    scanner.chew()
+    # is captain on planet? 
+    if game.landed:
+	if damaged(DTRANSP):
+	    finish(FPNOVA)
+	    return
+	prout(_("Scotty rushes to the transporter controls."))
+	if game.shldup:
+	    prout(_("But with the shields up it's hopeless."))
+	    finish(FPNOVA)
+	prouts(_("His desperate attempt to rescue you . . ."))
+	if withprob(0.5):
+	    prout(_("fails."))
+	    finish(FPNOVA)
+	    return
+	prout(_("SUCCEEDS!"))
+	if game.imine:
+	    game.imine = False
+	    proutn(_("The crystals mined were "))
+	    if withprob(0.25):
+		prout(_("lost."))
+	    else:
+		prout(_("saved."))
+		game.icrystl = True
+    if igrab:
+	return
+    # Check to see if captain in shuttle craft 
+    if game.icraft:
+	finish(FSTRACTOR)
+    if game.alldone:
+	return
+    # Inform captain of attempt to reach safety 
+    skip(1)
+    while True:
+	if game.justin:
+	    prouts(_("***RED ALERT!  RED ALERT!"))
+	    skip(1)
+	    proutn(_("The %s has stopped in a quadrant containing") % crmshp())
+	    prouts(_("   a supernova."))
+	    skip(2)
+	prout(_("***Emergency automatic override attempts to hurl ")+crmshp())
+	prout(_("safely out of quadrant."))
+	if not damaged(DRADIO):
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
+	# Try to use warp engines 
+	if damaged(DWARPEN):
+	    skip(1)
+	    prout(_("Warp engines damaged."))
+	    finish(FSNOVAED)
+	    return
+	game.warpfac = randreal(6.0, 8.0)
+	prout(_("Warp factor set to %d") % int(game.warpfac))
+	power = 0.75*game.energy
+	dist = power/(game.warpfac*game.warpfac*game.warpfac*(game.shldup+1))
+	dist = max(dist, randreal(math.sqrt(2)))
+        bugout = course(bearing=randreal(12), distance=dist)	# How dumb!
+	game.optime = bugout.time(game.warpfac)
+	game.justin = False
+	game.inorbit = False
+	warp(bugout, involuntary=True)
+	if not game.justin:
+	    # This is bad news, we didn't leave quadrant. 
+	    if game.alldone:
+		return
+	    skip(1)
+	    prout(_("Insufficient energy to leave quadrant."))
+	    finish(FSNOVAED)
+	    return
+	# Repeat if another snova
+        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            break
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0: 
+	finish(FWON) # Snova killed remaining enemy. 
+
+def timwrp():
+    "Let's do the time warp again."
+    prout(_("***TIME WARP ENTERED."))
+    if game.state.snap and withprob(0.5):
+	# Go back in time 
+	prout(_("You are traveling backwards in time %d stardates.") %
+	      int(game.state.date-game.snapsht.date))
+	game.state = game.snapsht
+	game.state.snap = False
+	if len(game.state.kcmdr):
+	    schedule(FTBEAM, expran(game.intime/len(game.state.kcmdr)))
+	    schedule(FBATTAK, expran(0.3*game.intime))
+	schedule(FSNOVA, expran(0.5*game.intime))
+	# next snapshot will be sooner 
+	schedule(FSNAP, expran(0.25*game.state.remtime))
+				
+	if game.state.nscrem:
+	    schedule(FSCMOVE, 0.2777)	    
+	game.isatb = 0
+	unschedule(FCDBAS)
+	unschedule(FSCDBAS)
+	game.battle.invalidate()
+	# Make sure Galileo is consistant -- Snapshot may have been taken
+        # when on planet, which would give us two Galileos! 
+	gotit = False
+	for l in range(game.inplan):
+	    if game.state.planets[l].known == "shuttle_down":
+		gotit = True
+		if game.iscraft == "onship" and game.ship=='E':
+		    prout(_("Chekov-  \"Security reports the Galileo has disappeared, Sir!"))
+		    game.iscraft = "offship"
+	# Likewise, if in the original time the Galileo was abandoned, but
+	# was on ship earlier, it would have vanished -- let's restore it.
+	if game.iscraft == "offship" and not gotit and game.damage[DSHUTTL] >= 0.0:
+	    prout(_("Chekov-  \"Security reports the Galileo has reappeared in the dock!\""))
+	    game.iscraft = "onship"
+        # There used to be code to do the actual reconstrction here,
+        # but the starchart is now part of the snapshotted galaxy state.
+	prout(_("Spock has reconstructed a correct star chart from memory"))
+    else:
+	# Go forward in time 
+	game.optime = expran(0.5*game.intime)
+	prout(_("You are traveling forward in time %d stardates.") % int(game.optime))
+	# cheat to make sure no tractor beams occur during time warp 
+	postpone(FTBEAM, game.optime)
+	game.damage[DRADIO] += game.optime
+    newqad()
+    events()	# Stas Sergeev added this -- do pending events 
+
+def probe():
+    "Launch deep-space probe." 
+    # New code to launch a deep space probe 
+    if game.nprobes == 0:
+	scanner.chew()
+	skip(1)
+	if game.ship == 'E': 
+	    prout(_("Engineer Scott- \"We have no more deep space probes, Sir.\""))
+	else:
+	    prout(_("Ye Faerie Queene has no deep space probes."))
+	return
+    if damaged(DDSP):
+	scanner.chew()
+	skip(1)
+	prout(_("Engineer Scott- \"The probe launcher is damaged, Sir.\""))
+	return
+    if is_scheduled(FDSPROB):
+	scanner.chew()
+	skip(1)
+	if damaged(DRADIO) and game.condition != "docked":
+	    prout(_("Spock-  \"Records show the previous probe has not yet"))
+	    prout(_("   reached its destination.\""))
+	else:
+	    prout(_("Uhura- \"The previous probe is still reporting data, Sir.\""))
+	return
+    key = scanner.next()
+    if key == "IHEOL":
+        if game.nprobes == 1:
+            prout(_("1 probe left."))
+        else:
+            prout(_("%d probes left") % game.nprobes)
+	proutn(_("Are you sure you want to fire a probe? "))
+	if ja() == False:
+	    return
+    game.isarmed = False
+    if key == "IHALPHA" and scanner.token == "armed":
+	game.isarmed = True
+	key = scanner.next()
+    elif key == "IHEOL":
+	proutn(_("Arm NOVAMAX warhead? "))
+	game.isarmed = ja()
+    elif key == "IHREAL":		# first element of course
+        scanner.push(scanner.token)
+    try:
+        game.probe = getcourse(isprobe=True)
+    except TrekError:
+        return
+    game.nprobes -= 1
+    schedule(FDSPROB, 0.01) # Time to move one sector
+    prout(_("Ensign Chekov-  \"The deep space probe is launched, Captain.\""))
+    game.ididit = True
+    return
+
+def mayday():
+    "Yell for help from nearest starbase."
+    # There's more than one way to move in this game! 
+    scanner.chew()
+    # Test for conditions which prevent calling for help 
+    if game.condition == "docked":
+	prout(_("Lt. Uhura-  \"But Captain, we're already docked.\""))
+	return
+    if damaged(DRADIO):
+	prout(_("Subspace radio damaged."))
+	return
+    if not game.state.baseq:
+	prout(_("Lt. Uhura-  \"Captain, I'm not getting any response from Starbase.\""))
+	return
+    if game.landed:
+	prout(_("You must be aboard the %s.") % crmshp())
+	return
+    # OK -- call for help from nearest starbase 
+    game.nhelp += 1
+    if game.base.i!=0:
+	# There's one in this quadrant 
+	ddist = (game.base - game.sector).distance()
+    else:
+	ddist = FOREVER
+        for ibq in game.state.baseq:
+	    xdist = QUADSIZE * (ibq - game.quadrant).distance()
+	    if xdist < ddist:
+		ddist = xdist
+	# Since starbase not in quadrant, set up new quadrant 
+	game.quadrant = ibq
+	newqad()
+    # dematerialize starship 
+    game.quad[game.sector.i][game.sector.j]='.'
+    proutn(_("Starbase in Quadrant %s responds--%s dematerializes") \
+           % (game.quadrant, crmshp()))
+    game.sector.invalidate()
+    for m in range(1, 5+1):
+        w = game.base.scatter() 
+	if w.valid_sector() and game.quad[w.i][w.j]=='.':
+	    # found one -- finish up 
+            game.sector = w
+	    break
+    if not game.sector.is_valid():
+	prout(_("You have been lost in space..."))
+	finish(FMATERIALIZE)
+	return
+    # Give starbase three chances to rematerialize starship 
+    probf = math.pow((1.0 - math.pow(0.98,ddist)), 0.33333333)
+    for m in range(1, 3+1):
+	if m == 1: proutn(_("1st"))
+	elif m == 2: proutn(_("2nd"))
+	elif m == 3: proutn(_("3rd"))
+	proutn(_(" attempt to re-materialize ") + crmshp())
+	game.quad[ix][iy]=('-','o','O')[m-1]
+        textcolor(RED)
+	warble()
+	if randreal() > probf:
+	    break
+	prout(_("fails."))
+        textcolor(DEFAULT)
+	curses.delay_output(500)
+    if m > 3:
+	game.quad[ix][iy]='?'
+	game.alive = False
+	drawmaps(1)
+	setwnd(message_window)
+	finish(FMATERIALIZE)
+	return
+    game.quad[ix][iy]=game.ship
+    textcolor(GREEN);
+    prout(_("succeeds."))
+    textcolor(DEFAULT);
+    dock(False)
+    skip(1)
+    prout(_("Lt. Uhura-  \"Captain, we made it!\""))
+
+def abandon():
+    "Abandon ship."
+    scanner.chew()
+    if game.condition=="docked":
+	if game.ship!='E':
+	    prout(_("You cannot abandon Ye Faerie Queene."))
+	    return
+    else:
+	# Must take shuttle craft to exit 
+	if game.damage[DSHUTTL]==-1:
+	    prout(_("Ye Faerie Queene has no shuttle craft."))
+	    return
+	if game.damage[DSHUTTL]<0:
+	    prout(_("Shuttle craft now serving Big Macs."))
+	    return
+	if game.damage[DSHUTTL]>0:
+	    prout(_("Shuttle craft damaged."))
+	    return
+	if game.landed:
+	    prout(_("You must be aboard the ship."))
+	    return
+	if game.iscraft != "onship":
+	    prout(_("Shuttle craft not currently available."))
+	    return
+	# Emit abandon ship messages 
+	skip(1)
+	prouts(_("***ABANDON SHIP!  ABANDON SHIP!"))
+	skip(1)
+	prouts(_("***ALL HANDS ABANDON SHIP!"))
+	skip(2)
+	prout(_("Captain and crew escape in shuttle craft."))
+	if not game.state.baseq:
+	    # Oops! no place to go... 
+	    finish(FABANDN)
+	    return
+	q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
+	# Dispose of crew 
+	if not (game.options & OPTION_WORLDS) and not damaged(DTRANSP):
+	    prout(_("Remainder of ship's complement beam down"))
+	    prout(_("to nearest habitable planet."))
+	elif q.planet != None and not damaged(DTRANSP):
+	    prout(_("Remainder of ship's complement beam down to %s.") %
+		    q.planet)
+	else:
+	    prout(_("Entire crew of %d left to die in outer space.") %
+		    game.state.crew)
+	    game.casual += game.state.crew
+	    game.abandoned += game.state.crew
+	# If at least one base left, give 'em the Faerie Queene 
+	skip(1)
+	game.icrystl = False # crystals are lost 
+	game.nprobes = 0 # No probes 
+	prout(_("You are captured by Klingons and released to"))
+	prout(_("the Federation in a prisoner-of-war exchange."))
+	nb = randrange(len(game.state.baseq))
+	# Set up quadrant and position FQ adjacient to base 
+	if not game.quadrant == game.state.baseq[nb]:
+	    game.quadrant = game.state.baseq[nb]
+	    game.sector.i = game.sector.j = 5
+	    newqad()
+	while True:
+	    # position next to base by trial and error 
+	    game.quad[game.sector.i][game.sector.j] = '.'
+	    for l in range(QUADSIZE):
+		game.sector = game.base.scatter()
+		if game.sector.valid_sector() and \
+                       game.quad[game.sector.i][game.sector.j] == '.':
+                    break
+	    if l < QUADSIZE+1:
+		break # found a spot 
+	    game.sector.i=QUADSIZE/2
+	    game.sector.j=QUADSIZE/2
+	    newqad()
+    # Get new commission 
+    game.quad[game.sector.i][game.sector.j] = game.ship = 'F'
+    game.state.crew = FULLCREW
+    prout(_("Starfleet puts you in command of another ship,"))
+    prout(_("the Faerie Queene, which is antiquated but,"))
+    prout(_("still useable."))
+    if game.icrystl:
+	prout(_("The dilithium crystals have been moved."))
+    game.imine = False
+    game.iscraft = "offship" # Galileo disappears 
+    # Resupply ship 
+    game.condition="docked"
+    for l in range(NDEVICES): 
+	game.damage[l] = 0.0
+    game.damage[DSHUTTL] = -1
+    game.energy = game.inenrg = 3000.0
+    game.shield = game.inshld = 1250.0
+    game.torps = game.intorps = 6
+    game.lsupres=game.inlsr=3.0
+    game.shldup=False
+    game.warpfac=5.0
+    return
+
+# Code from planets.c begins here.
+
+def consumeTime():
+    "Abort a lengthy operation if an event interrupts it." 
+    game.ididit = True
+    events()
+    if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.justin: 
+	return True
+    return False
+
+def survey():
+    "Report on (uninhabited) planets in the galaxy."
+    iknow = False
+    skip(1)
+    scanner.chew()
+    prout(_("Spock-  \"Planet report follows, Captain.\""))
+    skip(1)
+    for i in range(game.inplan):
+	if game.state.planets[i].pclass == "destroyed":
+	    continue
+	if (game.state.planets[i].known != "unknown" \
+            and not game.state.planets[i].inhabited) \
+            or idebug:
+	    iknow = True
+	    if idebug and game.state.planets[i].known=="unknown":
+		proutn("(Unknown) ")
+	    proutn(_("Quadrant %s") % game.state.planets[i].quadrant)
+	    proutn(_("   class "))
+	    proutn(game.state.planets[i].pclass)
+	    proutn("   ")
+	    if game.state.planets[i].crystals != present:
+		proutn(_("no "))
+	    prout(_("dilithium crystals present."))
+	    if game.state.planets[i].known=="shuttle_down": 
+		prout(_("    Shuttle Craft Galileo on surface."))
+    if not iknow:
+	prout(_("No information available."))
+
+def orbit():
+    "Enter standard orbit." 
+    skip(1)
+    scanner.chew()
+    if game.inorbit:
+	prout(_("Already in standard orbit."))
+	return
+    if damaged(DWARPEN) and damaged(DIMPULS):
+	prout(_("Both warp and impulse engines damaged."))
+	return
+    if not game.plnet.is_valid():
+        prout("There is no planet in this sector.")
+        return
+    if abs(game.sector.i-game.plnet.i)>1 or abs(game.sector.j-game.plnet.j)>1:
+	prout(crmshp() + _(" not adjacent to planet."))
+	skip(1)
+	return
+    game.optime = randreal(0.02, 0.05)
+    prout(_("Helmsman Sulu-  \"Entering standard orbit, Sir.\""))
+    newcnd()
+    if consumeTime():
+	return
+    game.height = randreal(1400, 8600)
+    prout(_("Sulu-  \"Entered orbit at altitude %.2f kilometers.\"") % game.height)
+    game.inorbit = True
+    game.ididit = True
+
+def sensor():
+    "Examine planets in this quadrant."
+    if damaged(DSRSENS):
+	if game.options & OPTION_TTY:
+	    prout(_("Short range sensors damaged."))
+	return
+    if game.iplnet == None:
+	if game.options & OPTION_TTY:
+	    prout(_("Spock- \"No planet in this quadrant, Captain.\""))
+	return
+    if game.iplnet.known == "unknown":
+	prout(_("Spock-  \"Sensor scan for Quadrant %s-") % game.quadrant)
+	skip(1)
+	prout(_("         Planet at Sector %s is of class %s.") %
+	      (game.plnet, game.iplnet.pclass))
+	if game.iplnet.known=="shuttle_down": 
+	    prout(_("         Sensors show Galileo still on surface."))
+	proutn(_("         Readings indicate"))
+	if game.iplnet.crystals != "present":
+	    proutn(_(" no"))
+	prout(_(" dilithium crystals present.\""))
+	if game.iplnet.known == "unknown":
+	    game.iplnet.known = "known"
+    elif game.iplnet.inhabited:
+        prout(_("Spock-  \"The inhabited planet %s ") % game.iplnet.name)
+        prout(_("        is located at Sector %s, Captain.\"") % game.plnet)
+
+def beam():
+    "Use the transporter."
+    nrgneed = 0
+    scanner.chew()
+    skip(1)
+    if damaged(DTRANSP):
+	prout(_("Transporter damaged."))
+	if not damaged(DSHUTTL) and (game.iplnet.known=="shuttle_down" or game.iscraft == "onship"):
+	    skip(1)
+	    proutn(_("Spock-  \"May I suggest the shuttle craft, Sir?\" "))
+	    if ja() == True:
+		shuttle()
+	return
+    if not game.inorbit:
+	prout(crmshp() + _(" not in standard orbit."))
+	return
+    if game.shldup:
+	prout(_("Impossible to transport through shields."))
+	return
+    if game.iplnet.known=="unknown":
+	prout(_("Spock-  \"Captain, we have no information on this planet"))
+	prout(_("  and Starfleet Regulations clearly state that in this situation"))
+	prout(_("  you may not go down.\""))
+	return
+    if not game.landed and game.iplnet.crystals=="absent":
+	prout(_("Spock-  \"Captain, I fail to see the logic in"))
+	prout(_("  exploring a planet with no dilithium crystals."))
+	proutn(_("  Are you sure this is wise?\" "))
+	if ja() == False:
+	    scanner.chew()
+	    return
+    if not (game.options & OPTION_PLAIN):
+	nrgneed = 50 * game.skill + game.height / 100.0
+	if nrgneed > game.energy:
+    	    prout(_("Engineering to bridge--"))
+	    prout(_("  Captain, we don't have enough energy for transportation."))
+	    return
+	if not game.landed and nrgneed * 2 > game.energy:
+    	    prout(_("Engineering to bridge--"))
+	    prout(_("  Captain, we have enough energy only to transport you down to"))
+	    prout(_("  the planet, but there wouldn't be an energy for the trip back."))
+	    if game.iplnet.known == "shuttle_down":
+		prout(_("  Although the Galileo shuttle craft may still be on a surface."))
+	    proutn(_("  Are you sure this is wise?\" "))
+	    if ja() == False:
+		scanner.chew()
+		return
+    if game.landed:
+	# Coming from planet 
+	if game.iplnet.known=="shuttle_down":
+	    proutn(_("Spock-  \"Wouldn't you rather take the Galileo?\" "))
+	    if ja() == True:
+		scanner.chew()
+		return
+	    prout(_("Your crew hides the Galileo to prevent capture by aliens."))
+	prout(_("Landing party assembled, ready to beam up."))
+	skip(1)
+	prout(_("Kirk whips out communicator..."))
+	prouts(_("BEEP  BEEP  BEEP"))
+	skip(2)
+	prout(_("\"Kirk to enterprise-  Lock on coordinates...energize.\""))
+    else:
+	# Going to planet 
+	prout(_("Scotty-  \"Transporter room ready, Sir.\""))
+	skip(1)
+	prout(_("Kirk and landing party prepare to beam down to planet surface."))
+	skip(1)
+	prout(_("Kirk-  \"Energize.\""))
+    game.ididit = True
+    skip(1)
+    prouts("WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .")
+    skip(2)
+    if withprob(0.98):
+	prouts("BOOOIIIOOOIIOOOOIIIOIING . . .")
+	skip(2)
+	prout(_("Scotty-  \"Oh my God!  I've lost them.\""))
+	finish(FLOST)
+	return
+    prouts(".    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW")
+    game.landed = not game.landed
+    game.energy -= nrgneed
+    skip(2)
+    prout(_("Transport complete."))
+    if game.landed and game.iplnet.known=="shuttle_down":
+	prout(_("The shuttle craft Galileo is here!"))
+    if not game.landed and game.imine:
+	game.icrystl = True
+	game.cryprob = 0.05
+    game.imine = False
+    return
+
+def mine():
+    "Strip-mine a world for dilithium."
+    skip(1)
+    scanner.chew()
+    if not game.landed:
+	prout(_("Mining party not on planet."))
+	return
+    if game.iplnet.crystals == "mined":
+	prout(_("This planet has already been strip-mined for dilithium."))
+	return
+    elif game.iplnet.crystals == "absent":
+	prout(_("No dilithium crystals on this planet."))
+	return
+    if game.imine:
+	prout(_("You've already mined enough crystals for this trip."))
+	return
+    if game.icrystl and game.cryprob == 0.05:
+	prout(_("With all those fresh crystals aboard the ") + crmshp())
+	prout(_("there's no reason to mine more at this time."))
+	return
+    game.optime = randreal(0.1, 0.3)*(ord(game.iplnet.pclass)-ord("L"))
+    if consumeTime():
+	return
+    prout(_("Mining operation complete."))
+    game.iplnet.crystals = "mined"
+    game.imine = game.ididit = True
+
+def usecrystals():
+    "Use dilithium crystals."
+    game.ididit = False
+    skip(1)
+    scanner.chew()
+    if not game.icrystl:
+	prout(_("No dilithium crystals available."))
+	return
+    if game.energy >= 1000:
+	prout(_("Spock-  \"Captain, Starfleet Regulations prohibit such an operation"))
+	prout(_("  except when Condition Yellow exists."))
+	return
+    prout(_("Spock- \"Captain, I must warn you that loading"))
+    prout(_("  raw dilithium crystals into the ship's power"))
+    prout(_("  system may risk a severe explosion."))
+    proutn(_("  Are you sure this is wise?\" "))
+    if ja() == False:
+	scanner.chew()
+	return
+    skip(1)
+    prout(_("Engineering Officer Scott-  \"(GULP) Aye Sir."))
+    prout(_("  Mr. Spock and I will try it.\""))
+    skip(1)
+    prout(_("Spock-  \"Crystals in place, Sir."))
+    prout(_("  Ready to activate circuit.\""))
+    skip(1)
+    prouts(_("Scotty-  \"Keep your fingers crossed, Sir!\""))
+    skip(1)
+    if withprob(game.cryprob):
+	prouts(_("  \"Activating now! - - No good!  It's***"))
+	skip(2)
+	prouts(_("***RED ALERT!  RED A*L********************************"))
+	skip(1)
+	stars()
+	prouts(_("******************   KA-BOOM!!!!   *******************"))
+	skip(1)
+	kaboom()
+	return
+    game.energy += randreal(5000.0, 5500.0)
+    prouts(_("  \"Activating now! - - "))
+    prout(_("The instruments"))
+    prout(_("   are going crazy, but I think it's"))
+    prout(_("   going to work!!  Congratulations, Sir!\""))
+    game.cryprob *= 2.0
+    game.ididit = True
+
+def shuttle():
+    "Use shuttlecraft for planetary jaunt."
+    scanner.chew()
+    skip(1)
+    if damaged(DSHUTTL):
+	if game.damage[DSHUTTL] == -1.0:
+	    if game.inorbit and game.iplnet.known == "shuttle_down":
+		prout(_("Ye Faerie Queene has no shuttle craft bay to dock it at."))
+	    else:
+		prout(_("Ye Faerie Queene had no shuttle craft."))
+	elif game.damage[DSHUTTL] > 0:
+	    prout(_("The Galileo is damaged."))
+	else: # game.damage[DSHUTTL] < 0  
+	    prout(_("Shuttle craft is now serving Big Macs."))
+	return
+    if not game.inorbit:
+	prout(crmshp() + _(" not in standard orbit."))
+	return
+    if (game.iplnet.known != "shuttle_down") and game.iscraft != "onship":
+	prout(_("Shuttle craft not currently available."))
+	return
+    if not game.landed and game.iplnet.known=="shuttle_down":
+	prout(_("You will have to beam down to retrieve the shuttle craft."))
+	return
+    if game.shldup or game.condition == "docked":
+	prout(_("Shuttle craft cannot pass through shields."))
+	return
+    if game.iplnet.known=="unknown":
+	prout(_("Spock-  \"Captain, we have no information on this planet"))
+	prout(_("  and Starfleet Regulations clearly state that in this situation"))
+	prout(_("  you may not fly down.\""))
+	return
+    game.optime = 3.0e-5*game.height
+    if game.optime >= 0.8*game.state.remtime:
+	prout(_("First Officer Spock-  \"Captain, I compute that such"))
+	proutn(_("  a maneuver would require approximately %2d%% of our") % \
+	       int(100*game.optime/game.state.remtime))
+	prout(_("remaining time."))
+	proutn(_("Are you sure this is wise?\" "))
+	if ja() == False:
+	    game.optime = 0.0
+	    return
+    if game.landed:
+	# Kirk on planet 
+	if game.iscraft == "onship":
+	    # Galileo on ship! 
+	    if not damaged(DTRANSP):
+		proutn(_("Spock-  \"Would you rather use the transporter?\" "))
+		if ja() == True:
+		    beam()
+		    return
+		proutn(_("Shuttle crew"))
+	    else:
+		proutn(_("Rescue party"))
+	    prout(_(" boards Galileo and swoops toward planet surface."))
+	    game.iscraft = "offship"
+	    skip(1)
+	    if consumeTime():
+		return
+	    game.iplnet.known="shuttle_down"
+	    prout(_("Trip complete."))
+	    return
+	else:
+	    # Ready to go back to ship 
+	    prout(_("You and your mining party board the"))
+	    prout(_("shuttle craft for the trip back to the Enterprise."))
+	    skip(1)
+	    prouts(_("The short hop begins . . ."))
+	    skip(1)
+	    game.iplnet.known="known"
+	    game.icraft = True
+	    skip(1)
+	    game.landed = False
+	    if consumeTime():
+		return
+	    game.iscraft = "onship"
+	    game.icraft = False
+	    if game.imine:
+		game.icrystl = True
+		game.cryprob = 0.05
+	    game.imine = False
+	    prout(_("Trip complete."))
+	    return
+    else:
+	# Kirk on ship and so is Galileo 
+	prout(_("Mining party assembles in the hangar deck,"))
+	prout(_("ready to board the shuttle craft \"Galileo\"."))
+	skip(1)
+	prouts(_("The hangar doors open; the trip begins."))
+	skip(1)
+	game.icraft = True
+	game.iscraft = "offship"
+	if consumeTime():
+	    return
+	game.iplnet.known = "shuttle_down"
+	game.landed = True
+	game.icraft = False
+	prout(_("Trip complete."))
+	return
+
+def deathray():
+    "Use the big zapper."
+    game.ididit = False
+    skip(1)
+    scanner.chew()
+    if game.ship != 'E':
+	prout(_("Ye Faerie Queene has no death ray."))
+	return
+    if len(game.enemies)==0:
+	prout(_("Sulu-  \"But Sir, there are no enemies in this quadrant.\""))
+	return
+    if damaged(DDRAY):
+	prout(_("Death Ray is damaged."))
+	return
+    prout(_("Spock-  \"Captain, the 'Experimental Death Ray'"))
+    prout(_("  is highly unpredictible.  Considering the alternatives,"))
+    proutn(_("  are you sure this is wise?\" "))
+    if ja() == False:
+	return
+    prout(_("Spock-  \"Acknowledged.\""))
+    skip(1)
+    game.ididit = True
+    prouts(_("WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE"))
+    skip(1)
+    prout(_("Crew scrambles in emergency preparation."))
+    prout(_("Spock and Scotty ready the death ray and"))
+    prout(_("prepare to channel all ship's power to the device."))
+    skip(1)
+    prout(_("Spock-  \"Preparations complete, sir.\""))
+    prout(_("Kirk-  \"Engage!\""))
+    skip(1)
+    prouts(_("WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR"))
+    skip(1)
+    dprob = 0.30
+    if game.options & OPTION_PLAIN:
+	dprob = 0.5
+    r = randreal()
+    if r > dprob:
+	prouts(_("Sulu- \"Captain!  It's working!\""))
+	skip(2)
+	while len(game.enemies) > 0:
+	    deadkl(game.enemies[1].location, game.quad[game.enemies[1].location.i][game.enemies[1].location.j],game.enemies[1].location)
+	prout(_("Ensign Chekov-  \"Congratulations, Captain!\""))
+	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) == 0:
+	    finish(FWON)    
+	if (game.options & OPTION_PLAIN) == 0:
+	    prout(_("Spock-  \"Captain, I believe the `Experimental Death Ray'"))
+	    if withprob(0.05):
+		prout(_("   is still operational.\""))
+	    else:
+		prout(_("   has been rendered nonfunctional.\""))
+		game.damage[DDRAY] = 39.95
+	return
+    r = randreal()	# Pick failure method 
+    if r <= 0.30:
+	prouts(_("Sulu- \"Captain!  It's working!\""))
+	skip(1)
+	prouts(_("***RED ALERT!  RED ALERT!"))
+	skip(1)
+	prout(_("***MATTER-ANTIMATTER IMPLOSION IMMINENT!"))
+	skip(1)
+	prouts(_("***RED ALERT!  RED A*L********************************"))
+	skip(1)
+	stars()
+	prouts(_("******************   KA-BOOM!!!!   *******************"))
+	skip(1)
+	kaboom()
+	return
+    if r <= 0.55:
+	prouts(_("Sulu- \"Captain!  Yagabandaghangrapl, brachriigringlanbla!\""))
+	skip(1)
+	prout(_("Lt. Uhura-  \"Graaeek!  Graaeek!\""))
+	skip(1)
+	prout(_("Spock-  \"Fascinating!  . . . All humans aboard"))
+	prout(_("  have apparently been transformed into strange mutations."))
+	prout(_("  Vulcans do not seem to be affected."))
+	skip(1)
+	prout(_("Kirk-  \"Raauch!  Raauch!\""))
+	finish(FDRAY)
+	return
+    if r <= 0.75:
+	intj
+	prouts(_("Sulu- \"Captain!  It's   --WHAT?!?!\""))
+	skip(2)
+	proutn(_("Spock-  \"I believe the word is"))
+	prouts(_(" *ASTONISHING*"))
+	prout(_(" Mr. Sulu."))
+	for i in range(QUADSIZE):
+	    for j in range(QUADSIZE):
+		if game.quad[i][j] == '.':
+		    game.quad[i][j] = '?'
+	prout(_("  Captain, our quadrant is now infested with"))
+	prouts(_(" - - - - - -  *THINGS*."))
+	skip(1)
+	prout(_("  I have no logical explanation.\""))
+	return
+    prouts(_("Sulu- \"Captain!  The Death Ray is creating tribbles!\""))
+    skip(1)
+    prout(_("Scotty-  \"There are so many tribbles down here"))
+    prout(_("  in Engineering, we can't move for 'em, Captain.\""))
+    finish(FTRIBBLE)
+    return
+
+# Code from reports.c begins here
+
+def attackreport(curt):
+    "eport status of bases under attack."
+    if not curt:
+	if is_scheduled(FCDBAS):
+	    prout(_("Starbase in Quadrant %s is currently under Commander attack.") % game.battle)
+	    prout(_("It can hold out until Stardate %d.") % int(scheduled(FCDBAS)))
+	elif game.isatb == 1:
+	    prout(_("Starbase in Quadrant %s is under Super-commander attack.") % game.state.kscmdr)
+	    prout(_("It can hold out until Stardate %d.") % int(scheduled(FSCDBAS)))
+	else:
+	    prout(_("No Starbase is currently under attack."))
+    else:
+        if is_scheduled(FCDBAS):
+	    proutn(_("Base in %s attacked by C. Alive until %.1f") % (game.battle, scheduled(FCDBAS)))
+        if game.isatb:
+	    proutn(_("Base in %s attacked by S. Alive until %.1f") % (game.state.kscmdr, scheduled(FSCDBAS)))
+	clreol()
+
+def report():
+    # report on general game status 
+    scanner.chew()
+    s1 = "" and game.thawed and _("thawed ")
+    s2 = {1:"short", 2:"medium", 4:"long"}[game.length]
+    s3 = (None, _("novice"), _("fair"),
+          _("good"), _("expert"), _("emeritus"))[game.skill]
+    prout(_("You %s a %s%s %s game.") % ((_("were playing"), _("are playing"))[game.alldone], s1, s2, s3))
+    if game.skill>SKILL_GOOD and game.thawed and not game.alldone:
+	prout(_("No plaque is allowed."))
+    if game.tourn:
+	prout(_("This is tournament game %d.") % game.tourn)
+    prout(_("Your secret password is \"%s\"") % game.passwd)
+    proutn(_("%d of %d Klingons have been killed") % (((game.inkling + game.incom + game.inscom) - (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)), 
+	   (game.inkling + game.incom + game.inscom)))
+    if game.incom - len(game.state.kcmdr):
+	prout(_(", including %d Commander%s.") % (game.incom - len(game.state.kcmdr), (_("s"), "")[(game.incom - len(game.state.kcmdr))==1]))
+    elif game.inkling - game.state.remkl + (game.inscom - game.state.nscrem) > 0:
+	prout(_(", but no Commanders."))
+    else:
+	prout(".")
+    if game.skill > SKILL_FAIR:
+	prout(_("The Super Commander has %sbeen destroyed.") % ("", _("not "))[game.state.nscrem])
+    if len(game.state.baseq) != game.inbase:
+	proutn(_("There "))
+	if game.inbase-len(game.state.baseq)==1:
+	    proutn(_("has been 1 base"))
+	else:
+	    proutn(_("have been %d bases") % (game.inbase-len(game.state.baseq)))
+	prout(_(" destroyed, %d remaining.") % len(game.state.baseq))
+    else:
+	prout(_("There are %d bases.") % game.inbase)
+    if communicating() or game.iseenit:
+	# Don't report this if not seen and
+	# either the radio is dead or not at base!
+	attackreport(False)
+	game.iseenit = True
+    if game.casual: 
+	prout(_("%d casualt%s suffered so far.") % (game.casual, ("y", "ies")[game.casual!=1]))
+    if game.nhelp:
+	prout(_("There were %d call%s for help.") % (game.nhelp,  ("" , _("s"))[game.nhelp!=1]))
+    if game.ship == 'E':
+	proutn(_("You have "))
+	if game.nprobes:
+	    proutn("%d" % (game.nprobes))
+	else:
+	    proutn(_("no"))
+	proutn(_(" deep space probe"))
+	if game.nprobes!=1:
+	    proutn(_("s"))
+	prout(".")
+    if communicating() and is_scheduled(FDSPROB):
+	if game.isarmed: 
+	    proutn(_("An armed deep space probe is in "))
+	else:
+	    proutn(_("A deep space probe is in "))
+	prout("Quadrant %s." % game.probec)
+    if game.icrystl:
+	if game.cryprob <= .05:
+	    prout(_("Dilithium crystals aboard ship... not yet used."))
+	else:
+	    i=0
+	    ai = 0.05
+	    while game.cryprob > ai:
+		ai *= 2.0
+		i += 1
+	    prout(_("Dilithium crystals have been used %d time%s.") % \
+                  (i, (_("s"), "")[i==1]))
+    skip(1)
+	
+def lrscan(silent):
+    "Long-range sensor scan."
+    if damaged(DLRSENS):
+	# Now allow base's sensors if docked 
+	if game.condition != "docked":
+            if not silent:
+                prout(_("LONG-RANGE SENSORS DAMAGED."))
+	    return
+        if not silent:
+            prout(_("Starbase's long-range scan"))
+    elif not silent:
+	prout(_("Long-range scan"))
+    for x in range(game.quadrant.i-1, game.quadrant.i+2):
+        if not silent:
+            proutn(" ")
+        for y in range(game.quadrant.j-1, game.quadrant.j+2):
+	    if not coord(x, y).valid_quadrant():
+                if not silent:
+                    proutn("  -1")
+	    else:
+		if not damaged(DRADIO):
+		    game.state.galaxy[x][y].charted = True
+		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons
+		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase
+		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars
+		if not silent and game.state.galaxy[x][y].supernova: 
+		    proutn(" ***")
+		elif not silent:
+		    proutn(" %3d" % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
+	if not silent:
+	    prout(" ")
+
+def damagereport():
+    "Damage report."
+    jdam = False
+    scanner.chew()
+    for i in range(NDEVICES):
+	if damaged(i):
+	    if not jdam:
+		prout(_("\tDEVICE\t\t\t-REPAIR TIMES-"))
+		prout(_("\t\t\tIN FLIGHT\t\tDOCKED"))
+		jdam = True
+	    prout("  %-26s\t%8.2f\t\t%8.2f" % (device[i],
+                                               game.damage[i]+0.05,
+                                               DOCKFAC*game.damage[i]+0.005))
+    if not jdam:
+	prout(_("All devices functional."))
+
+def rechart():
+    "Update the chart in the Enterprise's computer from galaxy data."
+    game.lastchart = game.state.date
+    for i in range(GALSIZE):
+	for j in range(GALSIZE):
+	    if game.state.galaxy[i][j].charted:
+		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons
+		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase
+		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars
+
+def chart():
+    "Display the star chart."
+    scanner.chew()
+    if (game.options & OPTION_AUTOSCAN):
+        lrscan(silent=True)
+    if not damaged(DRADIO):
+	rechart()
+    if game.lastchart < game.state.date and game.condition == "docked":
+	prout(_("Spock-  \"I revised the Star Chart from the starbase's records.\""))
+	rechart()
+    prout(_("       STAR CHART FOR THE KNOWN GALAXY"))
+    if game.state.date > game.lastchart:
+	prout(_("(Last surveillance update %d stardates ago).") % ((int)(game.state.date-game.lastchart)))
+    prout("      1    2    3    4    5    6    7    8")
+    for i in range(GALSIZE):
+	proutn("%d |" % (i+1))
+	for j in range(GALSIZE):
+	    if (game.options & OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
+		proutn("<")
+	    else:
+		proutn(" ")
+	    if game.state.galaxy[i][j].supernova:
+		show = "***"
+	    elif not game.state.galaxy[i][j].charted and game.state.galaxy[i][j].starbase:
+		show = ".1."
+	    elif game.state.galaxy[i][j].charted:
+		show = "%3d" % (game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars)
+	    else:
+		show = "..."
+	    proutn(show)
+	    if (game.options & OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
+		proutn(">")
+	    else:
+		proutn(" ")
+	proutn("  |")
+	if i<GALSIZE:
+	    skip(1)
+
+def sectscan(goodScan, i, j):
+    "Light up an individual dot in a sector."
+    if goodScan or (abs(i-game.sector.i)<= 1 and abs(j-game.sector.j) <= 1):
+        textcolor({"green":GREEN,
+                   "yellow":YELLOW,
+                   "red":RED,
+                   "docked":CYAN,
+                   "dead":BROWN}[game.condition]) 
+        if game.quad[i][j] != game.ship: 
+            highvideo();
+	proutn("%c " % game.quad[i][j])
+        textcolor(DEFAULT)
+    else:
+	proutn("- ")
+
+def status(req=0):
+    "Emit status report lines"
+    if not req or req == 1:
+	prstat(_("Stardate"), _("%.1f, Time Left %.2f") \
+               % (game.state.date, game.state.remtime))
+    if not req or req == 2:
+	if game.condition != "docked":
+	    newcnd()
+	prstat(_("Condition"), _("%s, %i DAMAGES") % \
+               (game.condition.upper(), sum(map(lambda x: x > 0, game.damage))))
+    if not req or req == 3:
+	prstat(_("Position"), "%s , %s" % (game.quadrant, game.sector))
+    if not req or req == 4:
+	if damaged(DLIFSUP):
+	    if game.condition == "docked":
+		s = _("DAMAGED, Base provides")
+	    else:
+		s = _("DAMAGED, reserves=%4.2f") % game.lsupres
+	else:
+	    s = _("ACTIVE")
+	prstat(_("Life Support"), s)
+    if not req or req == 5:
+	prstat(_("Warp Factor"), "%.1f" % game.warpfac)
+    if not req or req == 6:
+        extra = ""
+        if game.icrystl and (game.options & OPTION_SHOWME):
+            extra = _(" (have crystals)")
+	prstat(_("Energy"), "%.2f%s" % (game.energy, extra))
+    if not req or req == 7:
+	prstat(_("Torpedoes"), "%d" % (game.torps))
+    if not req or req == 8:
+	if damaged(DSHIELD):
+	    s = _("DAMAGED,")
+	elif game.shldup:
+	    s = _("UP,")
+	else:
+	    s = _("DOWN,")
+	data = _(" %d%% %.1f units") \
+               % (int((100.0*game.shield)/game.inshld + 0.5), game.shield)
+	prstat(_("Shields"), s+data)
+    if not req or req == 9:
+        prstat(_("Klingons Left"), "%d" \
+               % (game.state.remkl+len(game.state.kcmdr)+game.state.nscrem))
+    if not req or req == 10:
+	if game.options & OPTION_WORLDS:
+	    plnet = game.state.galaxy[game.quadrant.i][game.quadrant.j].planet
+	    if plnet and plnet.inhabited:
+		prstat(_("Major system"), plnet.name)
+	    else:
+		prout(_("Sector is uninhabited"))
+    elif not req or req == 11:
+	attackreport(not req)
+
+def request():
+    "Request specified status data, a historical relic from slow TTYs."
+    requests = ("da","co","po","ls","wa","en","to","sh","kl","sy", "ti")
+    while scanner.next() == "IHEOL":
+	proutn(_("Information desired? "))
+    scanner.chew()
+    if scanner.token in requests:
+        status(requests.index(scanner.token))
+    else:
+	prout(_("UNRECOGNIZED REQUEST. Legal requests are:"))
+	prout(("  date, condition, position, lsupport, warpfactor,"))
+	prout(("  energy, torpedoes, shields, klingons, system, time."))
+		
+def srscan():
+    "Short-range scan." 
+    goodScan=True
+    if damaged(DSRSENS):
+	# Allow base's sensors if docked 
+	if game.condition != "docked":
+	    prout(_("   S.R. SENSORS DAMAGED!"))
+	    goodScan=False
+	else:
+	    prout(_("  [Using Base's sensors]"))
+    else:
+	prout(_("     Short-range scan"))
+    if goodScan and not damaged(DRADIO): 
+	game.state.chart[game.quadrant.i][game.quadrant.j].klingons = game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons
+	game.state.chart[game.quadrant.i][game.quadrant.j].starbase = game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase
+	game.state.chart[game.quadrant.i][game.quadrant.j].stars = game.state.galaxy[game.quadrant.i][game.quadrant.j].stars
+	game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
+    prout("    1 2 3 4 5 6 7 8 9 10")
+    if game.condition != "docked":
+	newcnd()
+    for i in range(QUADSIZE):
+	proutn("%2d  " % (i+1))
+	for j in range(QUADSIZE):
+	    sectscan(goodScan, i, j)
+	skip(1)
+		
+def eta():
+    "Use computer to get estimated time of arrival for a warp jump."
+    w1 = coord(); w2 = coord()
+    prompt = False
+    if damaged(DCOMPTR):
+	prout(_("COMPUTER DAMAGED, USE A POCKET CALCULATOR."))
+	skip(1)
+	return
+    if scanner.next() != "IHREAL":
+	prompt = True
+	scanner.chew()
+	proutn(_("Destination quadrant and/or sector? "))
+	if scanner.next()!="IHREAL":
+	    huh()
+	    return
+    w1.j = int(scanner.real-0.5)
+    if scanner.next() != "IHREAL":
+	huh()
+	return
+    w1.i = int(scanner.real-0.5)
+    if scanner.next() == "IHREAL":
+	w2.j = int(scanner.real-0.5)
+	if scanner.next() != "IHREAL":
+	    huh()
+	    return
+	w2.i = int(scanner.real-0.5)
+    else:
+	if game.quadrant.j>w1.i:
+	    w2.i = 0
+	else:
+	    w2.i=QUADSIZE-1
+	if game.quadrant.i>w1.j:
+	    w2.j = 0
+	else:
+	    w2.j=QUADSIZE-1
+    if not w1.valid_quadrant() or not w2.valid_sector():
+	huh()
+	return
+    dist = math.sqrt((w1.j-game.quadrant.j+(w2.j-game.sector.j)/(QUADSIZE*1.0))**2+
+		(w1.i-game.quadrant.i+(w2.i-game.sector.i)/(QUADSIZE*1.0))**2)
+    wfl = False
+    if prompt:
+	prout(_("Answer \"no\" if you don't know the value:"))
+    while True:
+	scanner.chew()
+	proutn(_("Time or arrival date? "))
+	if scanner.next()=="IHREAL":
+	    ttime = scanner.real
+	    if ttime > game.state.date:
+		ttime -= game.state.date # Actually a star date
+            twarp=(math.floor(math.sqrt((10.0*dist)/ttime)*10.0)+1.0)/10.0
+            if ttime <= 1e-10 or twarp > 10:
+		prout(_("We'll never make it, sir."))
+		scanner.chew()
+		return
+	    if twarp < 1.0:
+		twarp = 1.0
+	    break
+	scanner.chew()
+	proutn(_("Warp factor? "))
+	if scanner.next()== "IHREAL":
+	    wfl = True
+	    twarp = scanner.real
+	    if twarp<1.0 or twarp > 10.0:
+		huh()
+		return
+	    break
+	prout(_("Captain, certainly you can give me one of these."))
+    while True:
+	scanner.chew()
+	ttime = (10.0*dist)/twarp**2
+	tpower = dist*twarp*twarp*twarp*(game.shldup+1)
+	if tpower >= game.energy:
+	    prout(_("Insufficient energy, sir."))
+	    if not game.shldup or tpower > game.energy*2.0:
+		if not wfl:
+		    return
+		proutn(_("New warp factor to try? "))
+		if scanner.next() == "IHREAL":
+		    wfl = True
+		    twarp = scanner.real
+		    if twarp<1.0 or twarp > 10.0:
+			huh()
+			return
+		    continue
+		else:
+		    scanner.chew()
+		    skip(1)
+		    return
+	    prout(_("But if you lower your shields,"))
+	    proutn(_("remaining"))
+	    tpower /= 2
+	else:
+	    proutn(_("Remaining"))
+	prout(_(" energy will be %.2f.") % (game.energy-tpower))
+	if wfl:
+	    prout(_("And we will arrive at stardate %.2f.") % (game.state.date+ttime))
+	elif twarp==1.0:
+	    prout(_("Any warp speed is adequate."))
+	else:
+	    prout(_("Minimum warp needed is %.2f,") % (twarp))
+	    prout(_("and we will arrive at stardate %.2f.") % (game.state.date+ttime))
+	if game.state.remtime < ttime:
+	    prout(_("Unfortunately, the Federation will be destroyed by then."))
+	if twarp > 6.0:
+	    prout(_("You'll be taking risks at that speed, Captain"))
+	if (game.isatb==1 and game.state.kscmdr == w1 and \
+	     scheduled(FSCDBAS)< ttime+game.state.date) or \
+	    (scheduled(FCDBAS)<ttime+game.state.date and game.battle == w1):
+	    prout(_("The starbase there will be destroyed by then."))
+	proutn(_("New warp factor to try? "))
+	if scanner.next() == "IHREAL":
+	    wfl = True
+	    twarp = scanner.real
+	    if twarp<1.0 or twarp > 10.0:
+		huh()
+		return
+	else:
+	    scanner.chew()
+	    skip(1)
+	    return
+
+# Code from setup.c begins here
+
+def prelim():
+    "Issue a historically correct banner."
+    skip(2)
+    prout(_("-SUPER- STAR TREK"))
+    skip(1)
+# From the FORTRAN original
+#    prout(_("Latest update-21 Sept 78"))
+#    skip(1)
+
+def freeze(boss):
+    "Save game."
+    if boss:
+	scanner.push("emsave.trk")
+    key = scanner.next()
+    if key == "IHEOL":
+        proutn(_("File name: "))
+        key = scanner.next()
+    if key != "IHALPHA":
+        huh()
+        return
+    scanner.chew()
+    if '.' not in scanner.token:
+        scanner.token += ".trk"
+    try:
+        fp = open(scanner.token, "wb")
+    except IOError:
+	prout(_("Can't freeze game as file %s") % scanner.token)
+	return
+    cPickle.dump(game, fp)
+    fp.close()
+
+def thaw():
+    "Retrieve saved game." 
+    game.passwd[0] = '\0'
+    key = scanner.next()
+    if key == "IHEOL":
+	proutn(_("File name: "))
+	key = scanner.next()
+    if key != "IHALPHA":
+	huh()
+	return True
+    scanner.chew()
+    if '.' not in scanner.token:
+        scanner.token += ".trk"
+    try:
+        fp = open(scanner.token, "rb")
+    except IOError:
+	prout(_("Can't thaw game in %s") % scanner.token)
+	return
+    game = cPickle.load(fp)
+    fp.close()
+    return False
+
+# I used <http://www.memory-alpha.org> to find planets
+# with references in ST:TOS.  Eath and the Alpha Centauri
+# Colony have been omitted.
+# 
+# Some planets marked Class G and P here will be displayed as class M
+# because of the way planets are generated. This is a known bug.
+systnames = (
+    # Federation Worlds 
+    _("Andoria (Fesoan)"),	# several episodes 
+    _("Tellar Prime (Miracht)"),	# TOS: "Journey to Babel" 
+    _("Vulcan (T'Khasi)"),	# many episodes 
+    _("Medusa"),		# TOS: "Is There in Truth No Beauty?" 
+    _("Argelius II (Nelphia)"),	# TOS: "Wolf in the Fold" ("IV" in BSD) 
+    _("Ardana"),		# TOS: "The Cloud Minders" 
+    _("Catulla (Cendo-Prae)"),	# TOS: "The Way to Eden" 
+    _("Gideon"),		# TOS: "The Mark of Gideon" 
+    _("Aldebaran III"),		# TOS: "The Deadly Years" 
+    _("Alpha Majoris I"),	# TOS: "Wolf in the Fold" 
+    _("Altair IV"),		# TOS: "Amok Time 
+    _("Ariannus"),		# TOS: "Let That Be Your Last Battlefield" 
+    _("Benecia"),		# TOS: "The Conscience of the King" 
+    _("Beta Niobe I (Sarpeidon)"),	# TOS: "All Our Yesterdays" 
+    _("Alpha Carinae II"),	# TOS: "The Ultimate Computer" 
+    _("Capella IV (Kohath)"),	# TOS: "Friday's Child" (Class G) 
+    _("Daran V"),		# TOS: "For the World is Hollow and I Have Touched the Sky" 
+    _("Deneb II"),		# TOS: "Wolf in the Fold" ("IV" in BSD) 
+    _("Eminiar VII"),		# TOS: "A Taste of Armageddon" 
+    _("Gamma Canaris IV"),	# TOS: "Metamorphosis" 
+    _("Gamma Tranguli VI (Vaalel)"),	# TOS: "The Apple" 
+    _("Ingraham B"),		# TOS: "Operation: Annihilate" 
+    _("Janus IV"),		# TOS: "The Devil in the Dark" 
+    _("Makus III"),		# TOS: "The Galileo Seven" 
+    _("Marcos XII"),		# TOS: "And the Children Shall Lead", 
+    _("Omega IV"),		# TOS: "The Omega Glory" 
+    _("Regulus V"),		# TOS: "Amok Time 
+    _("Deneva"),		# TOS: "Operation -- Annihilate!" 
+    # Worlds from BSD Trek 
+    _("Rigel II"),		# TOS: "Shore Leave" ("III" in BSD) 
+    _("Beta III"),		# TOS: "The Return of the Archons" 
+    _("Triacus"),		# TOS: "And the Children Shall Lead", 
+    _("Exo III"),		# TOS: "What Are Little Girls Made Of?" (Class P) 
+#	# Others 
+#    _("Hansen's Planet"),	# TOS: "The Galileo Seven" 
+#    _("Taurus IV"),		# TOS: "The Galileo Seven" (class G) 
+#    _("Antos IV (Doraphane)"),	# TOS: "Whom Gods Destroy", "Who Mourns for Adonais?" 
+#    _("Izar"),			# TOS: "Whom Gods Destroy" 
+#    _("Tiburon"),		# TOS: "The Way to Eden" 
+#    _("Merak II"),		# TOS: "The Cloud Minders" 
+#    _("Coridan (Desotriana)"),	# TOS: "Journey to Babel" 
+#    _("Iotia"),		# TOS: "A Piece of the Action" 
+)
+
+device = (
+	_("S. R. Sensors"), \
+	_("L. R. Sensors"), \
+	_("Phasers"), \
+	_("Photon Tubes"), \
+	_("Life Support"), \
+	_("Warp Engines"), \
+	_("Impulse Engines"), \
+	_("Shields"), \
+	_("Subspace Radio"), \
+	_("Shuttle Craft"), \
+	_("Computer"), \
+	_("Navigation System"), \
+	_("Transporter"), \
+	_("Shield Control"), \
+	_("Death Ray"), \
+	_("D. S. Probe"), \
+)
+
+def setup():
+    "Prepare to play, set up cosmos."
+    w = coord()
+    #  Decide how many of everything
+    if choose():
+	return # frozen game
+    # Prepare the Enterprise
+    game.alldone = game.gamewon = game.shldchg = game.shldup = False
+    game.ship = 'E'
+    game.state.crew = FULLCREW
+    game.energy = game.inenrg = 5000.0
+    game.shield = game.inshld = 2500.0
+    game.inlsr = 4.0
+    game.lsupres = 4.0
+    game.quadrant = randplace(GALSIZE)
+    game.sector = randplace(QUADSIZE)
+    game.torps = game.intorps = 10
+    game.nprobes = randrange(2, 5)
+    game.warpfac = 5.0
+    for i in range(NDEVICES): 
+	game.damage[i] = 0.0
+    # Set up assorted game parameters
+    game.battle = coord()
+    game.state.date = game.indate = 100.0 * randreal(20, 51)
+    game.nkinks = game.nhelp = game.casual = game.abandoned = 0
+    game.iscate = game.resting = game.imine = game.icrystl = game.icraft = False
+    game.isatb = game.state.nplankl = 0
+    game.state.starkl = game.state.basekl = 0
+    game.iscraft = "onship"
+    game.landed = False
+    game.alive = True
+    # Starchart is functional but we've never seen it
+    game.lastchart = FOREVER
+    # Put stars in the galaxy
+    game.instar = 0
+    for i in range(GALSIZE):
+	for j in range(GALSIZE):
+	    k = randrange(1, QUADSIZE**2/10+1)
+	    game.instar += k
+	    game.state.galaxy[i][j].stars = k
+    # Locate star bases in galaxy
+    for i in range(game.inbase):
+        while True:
+            while True:
+                w = randplace(GALSIZE)
+                if not game.state.galaxy[w.i][w.j].starbase:
+                    break
+	    contflag = False
+            # C version: for (j = i-1; j > 0; j--)
+            # so it did them in the opposite order.
+            for j in range(1, i):
+		# Improved placement algorithm to spread out bases
+		distq = (w - game.state.baseq[j]).distance()
+		if distq < 6.0*(BASEMAX+1-game.inbase) and withprob(0.75):
+		    contflag = True
+		    if idebug:
+			prout("=== Abandoning base #%d at %s" % (i, w))
+		    break
+		elif distq < 6.0 * (BASEMAX+1-game.inbase):
+		    if idebug:
+			prout("=== Saving base #%d, close to #%d" % (i, j))
+            if not contflag:
+                break
+	game.state.baseq.append(w)
+	game.state.galaxy[w.i][w.j].starbase = game.state.chart[w.i][w.j].starbase = True
+    # Position ordinary Klingon Battle Cruisers
+    krem = game.inkling
+    klumper = 0.25*game.skill*(9.0-game.length)+1.0
+    if klumper > MAXKLQUAD: 
+	klumper = MAXKLQUAD
+    while True:
+	r = randreal()
+	klump = (1.0 - r*r)*klumper
+	if klump > krem:
+	    klump = krem
+	krem -= klump
+        while True:
+            w = randplace(GALSIZE)
+            if not game.state.galaxy[w.i][w.j].supernova and \
+               game.state.galaxy[w.i][w.j].klingons + klump <= MAXKLQUAD:
+                break
+	game.state.galaxy[w.i][w.j].klingons += int(klump)
+        if krem <= 0:
+            break
+    # Position Klingon Commander Ships
+    for i in range(game.incom):
+        while True:
+            w = randplace(GALSIZE)
+            if not welcoming(w) or w in game.state.kcmdr:
+                continue
+            if (game.state.galaxy[w.i][w.j].klingons or withprob(0.25)):
+                break
+	game.state.galaxy[w.i][w.j].klingons += 1
+	game.state.kcmdr.append(w)
+    # Locate planets in galaxy
+    for i in range(game.inplan):
+        while True:
+            w = randplace(GALSIZE) 
+            if game.state.galaxy[w.i][w.j].planet == None:
+                break
+        new = planet()
+	new.quadrant = w
+        new.crystals = "absent"
+	if (game.options & OPTION_WORLDS) and i < NINHAB:
+	    new.pclass = "M"	# All inhabited planets are class M
+	    new.crystals = "absent"
+	    new.known = "known"
+            new.name = systnames[i]
+	    new.inhabited = True
+	else:
+	    new.pclass = ("M", "N", "O")[randrange(0, 3)]
+            if withprob(0.33):
+                new.crystals = "present"
+	    new.known = "unknown"
+	    new.inhabited = False
+	game.state.galaxy[w.i][w.j].planet = new
+        game.state.planets.append(new)
+    # Locate Romulans
+    for i in range(game.state.nromrem):
+	w = randplace(GALSIZE)
+	game.state.galaxy[w.i][w.j].romulans += 1
+    # Place the Super-Commander if needed
+    if game.state.nscrem > 0:
+        while True:
+            w = randplace(GALSIZE)
+            if welcoming(w):
+                break
+	game.state.kscmdr = w
+	game.state.galaxy[w.i][w.j].klingons += 1
+    # Initialize times for extraneous events
+    schedule(FSNOVA, expran(0.5 * game.intime))
+    schedule(FTBEAM, expran(1.5 * (game.intime / len(game.state.kcmdr))))
+    schedule(FSNAP, randreal(1.0, 2.0)) # Force an early snapshot
+    schedule(FBATTAK, expran(0.3*game.intime))
+    unschedule(FCDBAS)
+    if game.state.nscrem:
+	schedule(FSCMOVE, 0.2777)
+    else:
+	unschedule(FSCMOVE)
+    unschedule(FSCDBAS)
+    unschedule(FDSPROB)
+    if (game.options & OPTION_WORLDS) and game.skill >= SKILL_GOOD:
+	schedule(FDISTR, expran(1.0 + game.intime))
+    else:
+	unschedule(FDISTR)
+    unschedule(FENSLV)
+    unschedule(FREPRO)
+    # Place thing (in tournament game, we don't want one!)
+    # New in SST2K: never place the Thing near a starbase.
+    # This makes sense and avoids a special case in the old code.
+    global thing
+    if game.tourn is None:
+        while True:
+            thing = randplace(GALSIZE)
+            if thing not in game.state.baseq:
+                break
+    skip(2)
+    game.state.snap = False
+    if game.skill == SKILL_NOVICE:
+	prout(_("It is stardate %d. The Federation is being attacked by") % int(game.state.date))
+	prout(_("a deadly Klingon invasion force. As captain of the United"))
+	prout(_("Starship U.S.S. Enterprise, it is your mission to seek out"))
+	prout(_("and destroy this invasion force of %d battle cruisers.") % ((game.inkling + game.incom + game.inscom)))
+	prout(_("You have an initial allotment of %d stardates to complete") % int(game.intime))
+	prout(_("your mission.  As you proceed you may be given more time."))
+	skip(1)
+	prout(_("You will have %d supporting starbases.") % (game.inbase))
+	proutn(_("Starbase locations-  "))
+    else:
+	prout(_("Stardate %d.") % int(game.state.date))
+	skip(1)
+	prout(_("%d Klingons.") % (game.inkling + game.incom + game.inscom))
+	prout(_("An unknown number of Romulans."))
+	if game.state.nscrem:
+	    prout(_("And one (GULP) Super-Commander."))
+	prout(_("%d stardates.") % int(game.intime))
+	proutn(_("%d starbases in ") % game.inbase)
+    for i in range(game.inbase):
+	proutn(`game.state.baseq[i]`)
+	proutn("  ")
+    skip(2)
+    proutn(_("The Enterprise is currently in Quadrant %s") % game.quadrant)
+    proutn(_(" Sector %s") % game.sector)
+    skip(2)
+    prout(_("Good Luck!"))
+    if game.state.nscrem:
+	prout(_("  YOU'LL NEED IT."))
+    waitfor()
+    newqad()
+    if len(game.enemies) - (thing == game.quadrant) - (game.tholian != None):
+	game.shldup = True
+    if game.neutz:	# bad luck to start in a Romulan Neutral Zone
+	attack(torps_ok=False)
+
+def choose():
+    "Choose your game type."
+    while True:
+	game.tourn = game.length = 0
+	game.thawed = False
+	game.skill = SKILL_NONE
+	if not scanner.inqueue: # Can start with command line options 
+	    proutn(_("Would you like a regular, tournament, or saved game? "))
+        scanner.next()
+        if scanner.sees("tournament"):
+	    while scanner.next() == "IHEOL":
+		proutn(_("Type in tournament number-"))
+	    if scanner.real == 0:
+		scanner.chew()
+		continue # We don't want a blank entry
+	    game.tourn = int(round(scanner.real))
+	    random.seed(scanner.real)
+            if logfp:
+                logfp.write("# random.seed(%d)\n" % scanner.real)
+	    break
+        if scanner.sees("saved") or scanner.sees("frozen"):
+	    if thaw():
+		continue
+	    scanner.chew()
+	    if game.passwd == None:
+		continue
+	    if not game.alldone:
+		game.thawed = True # No plaque if not finished
+	    report()
+	    waitfor()
+	    return True
+        if scanner.sees("regular"):
+	    break
+	proutn(_("What is \"%s\"?") % scanner.token)
+	scanner.chew()
+    while game.length==0 or game.skill==SKILL_NONE:
+	if scanner.next() == "IHALPHA":
+            if scanner.sees("short"):
+		game.length = 1
+	    elif scanner.sees("medium"):
+		game.length = 2
+	    elif scanner.sees("long"):
+		game.length = 4
+	    elif scanner.sees("novice"):
+		game.skill = SKILL_NOVICE
+	    elif scanner.sees("fair"):
+		game.skill = SKILL_FAIR
+	    elif scanner.sees("good"):
+		game.skill = SKILL_GOOD
+	    elif scanner.sees("expert"):
+		game.skill = SKILL_EXPERT
+	    elif scanner.sees("emeritus"):
+		game.skill = SKILL_EMERITUS
+	    else:
+		proutn(_("What is \""))
+		proutn(scanner.token)
+		prout("\"?")
+	else:
+	    scanner.chew()
+	    if game.length==0:
+		proutn(_("Would you like a Short, Medium, or Long game? "))
+	    elif game.skill == SKILL_NONE:
+		proutn(_("Are you a Novice, Fair, Good, Expert, or Emeritus player? "))
+    # Choose game options -- added by ESR for SST2K
+    if scanner.next() != "IHALPHA":
+	scanner.chew()
+	proutn(_("Choose your game style (plain, almy, fancy or just press enter): "))
+	scanner.next()
+    if scanner.sees("plain"):
+	# Approximates the UT FORTRAN version.
+	game.options &=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
+	game.options |= OPTION_PLAIN
+    elif scanner.sees("almy"):
+	# Approximates Tom Almy's version.
+	game.options &=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
+	game.options |= OPTION_ALMY
+    elif scanner.sees("fancy") or scanner.sees("\n"):
+	pass
+    elif len(scanner.token):
+        proutn(_("What is \"%s\"?") % scanner.token)
+    game.options &=~ OPTION_COLOR
+    setpassword()
+    if game.passwd == "debug":
+	idebug = True
+	prout("=== Debug mode enabled.")
+    # Use parameters to generate initial values of things
+    game.damfac = 0.5 * game.skill
+    game.inbase = randrange(BASEMIN, BASEMAX+1)
+    game.inplan = 0
+    if game.options & OPTION_PLANETS:
+	game.inplan += randrange(MAXUNINHAB/2, MAXUNINHAB+1)
+    if game.options & OPTION_WORLDS:
+	game.inplan += int(NINHAB)
+    game.state.nromrem = game.inrom = randrange(2 *game.skill)
+    game.state.nscrem = game.inscom = (game.skill > SKILL_FAIR)
+    game.state.remtime = 7.0 * game.length
+    game.intime = game.state.remtime
+    game.state.remkl = game.inkling = 2.0*game.intime*((game.skill+1 - 2*randreal())*game.skill*0.1+.15)
+    game.incom = min(MINCMDR, int(game.skill + 0.0625*game.inkling*randreal()))
+    game.state.remres = (game.inkling+4*game.incom)*game.intime
+    game.inresor = game.state.remres
+    if game.inkling > 50:
+        game.state.inbase += 1
+    return False
+
+def dropin(iquad=None):
+    "Drop a feature on a random dot in the current quadrant."
+    while True:
+        w = randplace(QUADSIZE)
+        if game.quad[w.i][w.j] == '.':
+            break
+    if iquad is not None:
+        game.quad[w.i][w.j] = iquad
+    return w
+
+def newcnd():
+    "Update our alert status."
+    game.condition = "green"
+    if game.energy < 1000.0:
+	game.condition = "yellow"
+    if game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons or game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans:
+	game.condition = "red"
+    if not game.alive:
+	game.condition="dead"
+
+def newkling():
+    "Drop new Klingon into current quadrant."
+    return enemy('K', loc=dropin(), power=randreal(300,450)+25.0*game.skill)
+
+def newqad():
+    "Set up a new state of quadrant, for when we enter or re-enter it."
+    game.justin = True
+    game.iplnet = None
+    game.neutz = game.inorbit = game.landed = False
+    game.ientesc = game.iseenit = False
+    # Create a blank quadrant
+    game.quad = fill2d(QUADSIZE, lambda i, j: '.')
+    if game.iscate:
+	# Attempt to escape Super-commander, so tbeam back!
+	game.iscate = False
+	game.ientesc = True
+    q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
+    # cope with supernova
+    if q.supernova:
+	return
+    game.klhere = q.klingons
+    game.irhere = q.romulans
+    # Position Starship
+    game.quad[game.sector.i][game.sector.j] = game.ship
+    game.enemies = []
+    if q.klingons:
+	# Position ordinary Klingons
+	for i in range(game.klhere):
+            newkling()
+	# If we need a commander, promote a Klingon
+        for cmdr in game.state.kcmdr:
+	    if cmdr == game.quadrant:
+                e = game.enemies[game.klhere-1]
+                game.quad[e.location.i][e.location.j] = 'C'
+                e.power = randreal(950,1350) + 50.0*game.skill
+		break	
+	# If we need a super-commander, promote a Klingon
+	if game.quadrant == game.state.kscmdr:
+            e = game.enemies[0]
+	    game.quad[e.location.i][e.location.j] = 'S'
+	    e.power = randreal(1175.0,  1575.0) + 125.0*game.skill
+	    game.iscate = (game.state.remkl > 1)
+    # Put in Romulans if needed
+    for i in range(q.romulans):
+        enemy('R', loc=dropin(), power=randreal(400.0,850.0)+50.0*game.skill)
+    # If quadrant needs a starbase, put it in
+    if q.starbase:
+	game.base = dropin('B')
+    # If quadrant needs a planet, put it in
+    if q.planet:
+	game.iplnet = q.planet
+	if not q.planet.inhabited:
+	    game.plnet = dropin('P')
+	else:
+	    game.plnet = dropin('@')
+    # Check for condition
+    newcnd()
+    # Check for RNZ
+    if game.irhere > 0 and game.klhere == 0:
+	game.neutz = True
+	if not damaged(DRADIO):
+	    skip(1)
+	    prout(_("LT. Uhura- \"Captain, an urgent message."))
+	    prout(_("  I'll put it on audio.\"  CLICK"))
+	    skip(1)
+	    prout(_("INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE."))
+	    prout(_("LEAVE AT ONCE, OR YOU WILL BE DESTROYED!"))
+    # Put in THING if needed
+    if thing == game.quadrant:
+        enemy(type='?', loc=dropin(),
+                  power=randreal(6000,6500.0)+250.0*game.skill)
+        if not damaged(DSRSENS):
+            skip(1)
+            prout(_("Mr. Spock- \"Captain, this is most unusual."))
+            prout(_("    Please examine your short-range scan.\""))
+    # Decide if quadrant needs a Tholian; lighten up if skill is low 
+    if game.options & OPTION_THOLIAN:
+	if (game.skill < SKILL_GOOD and withprob(0.02)) or \
+	    (game.skill == SKILL_GOOD and withprob(0.05)) or \
+            (game.skill > SKILL_GOOD and withprob(0.08)):
+            w = coord()
+            while True:
+		w.i = withprob(0.5) * (QUADSIZE-1)
+		w.j = withprob(0.5) * (QUADSIZE-1)
+                if game.quad[w.i][w.j] == '.':
+                    break
+            game.tholian = enemy(type='T', loc=w,
+                                 power=randrange(100, 500) + 25.0*game.skill)
+	    # Reserve unoccupied corners 
+	    if game.quad[0][0]=='.':
+		game.quad[0][0] = 'X'
+	    if game.quad[0][QUADSIZE-1]=='.':
+		game.quad[0][QUADSIZE-1] = 'X'
+	    if game.quad[QUADSIZE-1][0]=='.':
+		game.quad[QUADSIZE-1][0] = 'X'
+	    if game.quad[QUADSIZE-1][QUADSIZE-1]=='.':
+		game.quad[QUADSIZE-1][QUADSIZE-1] = 'X'
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    # And finally the stars
+    for i in range(q.stars):
+	dropin('*')
+    # Put in a few black holes
+    for i in range(1, 3+1):
+	if withprob(0.5): 
+	    dropin(' ')
+    # Take out X's in corners if Tholian present
+    if game.tholian:
+	if game.quad[0][0]=='X':
+	    game.quad[0][0] = '.'
+	if game.quad[0][QUADSIZE-1]=='X':
+	    game.quad[0][QUADSIZE-1] = '.'
+	if game.quad[QUADSIZE-1][0]=='X':
+	    game.quad[QUADSIZE-1][0] = '.'
+	if game.quad[QUADSIZE-1][QUADSIZE-1]=='X':
+	    game.quad[QUADSIZE-1][QUADSIZE-1] = '.'
+
+def setpassword():
+    "Set the self-destruct password."
+    if game.options & OPTION_PLAIN:
+	while True:
+	    scanner.chew()
+	    proutn(_("Please type in a secret password- "))
+	    scanner.next()
+	    game.passwd = scanner.token
+	    if game.passwd != None:
+		break
+    else:
+        game.passwd = ""
+        for i in range(3):
+	    game.passwd += chr(ord('a')+randrange(26))
+
+# Code from sst.c begins here
+
+commands = {
+    "SRSCAN":   	OPTION_TTY,
+    "STATUS":   	OPTION_TTY,
+    "REQUEST":  	OPTION_TTY,
+    "LRSCAN":   	OPTION_TTY,
+    "PHASERS":  	0,
+    "TORPEDO":  	0,
+    "PHOTONS":  	0,
+    "MOVE":     	0,
+    "SHIELDS":   	0,
+    "DOCK":     	0,
+    "DAMAGES":   	0,
+    "CHART":    	0,
+    "IMPULSE":  	0,
+    "REST":     	0,
+    "WARP":     	0,
+    "SCORE":    	0,
+    "SENSORS":  	OPTION_PLANETS,
+    "ORBIT":		OPTION_PLANETS,
+    "TRANSPORT":	OPTION_PLANETS,
+    "MINE":		OPTION_PLANETS,
+    "CRYSTALS":  	OPTION_PLANETS,
+    "SHUTTLE":  	OPTION_PLANETS,
+    "PLANETS":  	OPTION_PLANETS,
+    "REPORT":   	0,
+    "COMPUTER": 	0,
+    "COMMANDS": 	0,
+    "EMEXIT":		0,
+    "PROBE":		OPTION_PROBE,
+    "SAVE":		0,
+    "FREEZE":		0,	# Synonym for SAVE
+    "ABANDON":  	0,
+    "DESTRUCT": 	0,
+    "DEATHRAY": 	0,
+    "DEBUG":    	0,
+    "MAYDAY":		0,
+    "SOS":		0,	# Synonym for MAYDAY
+    "CALL":		0,	# Synonym for MAYDAY
+    "QUIT":		0,
+    "HELP":		0,
+}
+
+def listCommands():
+    "Generate a list of legal commands."
+    prout(_("LEGAL COMMANDS ARE:"))
+    emitted = 0
+    for key in commands:
+	if not commands[key] or (commands[key] & game.options):
+            proutn("%-12s " % key)
+            emitted += 1
+            if emitted % 5 == 4:
+                skip(1)
+    skip(1)
+
+def helpme():
+    "Browse on-line help."
+    key = scanner.next()
+    while True:
+	if key == "IHEOL":
+	    setwnd(prompt_window)
+	    proutn(_("Help on what command? "))
+	    key = scanner.next()
+	setwnd(message_window)
+	if key == "IHEOL":
+	    return
+        if scanner.token.upper() in commands or scanner.token == "ABBREV":
+	    break
+	skip(1)
+	listCommands()
+	key = "IHEOL"
+	scanner.chew()
+	skip(1)
+    cmd = scanner.token.upper()
+    for directory in docpath:
+        try:
+            fp = open(os.path.join(directory, "sst.doc"), "r")
+            break
+        except IOError:
+            pass
+    else:
+        prout(_("Spock-  \"Captain, that information is missing from the"))
+        prout(_("   computer. You need to find sst.doc and put it somewhere"))
+        proutn(_("   in these directories: %s") % ":".join(docpath))
+        prout(".\"")
+        # This used to continue: "You need to find SST.DOC and put 
+        # it in the current directory."
+        return
+    while True:
+        linebuf = fp.readline()
+	if linebuf == '':
+	    prout(_("Spock- \"Captain, there is no information on that command.\""))
+	    fp.close()
+	    return
+	if linebuf[0] == '%' and linebuf[1] == '%' and linebuf[2] == ' ':
+            linebuf = linebuf[3:].strip()
+            if cmd.upper() == linebuf:
+		break
+    skip(1)
+    prout(_("Spock- \"Captain, I've found the following information:\""))
+    skip(1)
+    while True:
+        linebuf = fp.readline()
+        if "******" in linebuf:
+	    break
+	proutn(linebuf)
+    fp.close()
+
+def makemoves():
+    "Command-interpretation loop."
+    clrscr()
+    setwnd(message_window)
+    while True: 	# command loop 
+	drawmaps(1)
+        while True:	# get a command 
+	    hitme = False
+	    game.optime = game.justin = False
+	    scanner.chew()
+	    setwnd(prompt_window)
+	    clrscr()
+	    proutn("COMMAND> ")
+	    if scanner.next() == "IHEOL":
+		if game.options & OPTION_CURSES:
+		    makechart()
+		continue
+            elif scanner.token == "":
+                continue
+	    game.ididit = False
+	    clrscr()
+	    setwnd(message_window)
+	    clrscr()
+            candidates = filter(lambda x: x.startswith(scanner.token.upper()),
+                                commands)
+            if len(candidates) == 1:
+                cmd = candidates[0]
+                break
+            elif candidates and not (game.options & OPTION_PLAIN):
+                prout("Commands with prefix '%s': %s" % (scanner.token, " ".join(candidates)))
+            else:
+                listCommands()
+                continue
+	if cmd == "SRSCAN":		# srscan
+	    srscan()
+	elif cmd == "STATUS":		# status
+	    status()
+	elif cmd == "REQUEST":		# status request 
+	    request()
+	elif cmd == "LRSCAN":		# long range scan
+	    lrscan(silent=False)
+	elif cmd == "PHASERS":		# phasers
+	    phasers()
+	    if game.ididit:
+		hitme = True
+	elif cmd in ("TORPEDO", "PHOTONS"):	# photon torpedos
+	    torps()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "MOVE":		# move under warp
+	    warp(course=None, involuntary=False)
+	elif cmd == "SHIELDS":		# shields
+	    doshield(shraise=False)
+	    if game.ididit:
+		hitme = True
+		game.shldchg = False
+	elif cmd == "DOCK":		# dock at starbase
+	    dock(True)
+	    if game.ididit:
+		attack(torps_ok=False)		
+	elif cmd == "DAMAGES":		# damage reports
+	    damagereport()
+	elif cmd == "CHART":		# chart
+	    makechart()
+	elif cmd == "IMPULSE":		# impulse
+	    impulse()
+	elif cmd == "REST":		# rest
+	    wait()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "WARP":		# warp
+	    setwarp()
+	elif cmd == "SCORE":		# score
+	    score()
+	elif cmd == "SENSORS":		# sensors
+	    sensor()
+	elif cmd == "ORBIT":		# orbit
+	    orbit()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "TRANSPORT":		# transport "beam"
+	    beam()
+	elif cmd == "MINE":		# mine
+	    mine()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "CRYSTALS":		# crystals
+	    usecrystals()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "SHUTTLE":		# shuttle
+	    shuttle()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "PLANETS":		# Planet list
+	    survey()
+	elif cmd == "REPORT":		# Game Report 
+	    report()
+	elif cmd == "COMPUTER":		# use COMPUTER!
+	    eta()
+	elif cmd == "COMMANDS":
+	    listCommands()
+	elif cmd == "EMEXIT":		# Emergency exit
+	    clrscr()			# Hide screen
+	    freeze(True)		# forced save
+	    raise SysExit,1			# And quick exit
+	elif cmd == "PROBE":
+	    probe()			# Launch probe
+	    if game.ididit:
+		hitme = True
+	elif cmd == "ABANDON":		# Abandon Ship
+	    abandon()
+	elif cmd == "DESTRUCT":		# Self Destruct
+	    selfdestruct()
+	elif cmd == "SAVE":		# Save Game
+	    freeze(False)
+	    clrscr()
+	    if game.skill > SKILL_GOOD:
+		prout(_("WARNING--Saved games produce no plaques!"))
+	elif cmd == "DEATHRAY":		# Try a desparation measure
+	    deathray()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "DEBUGCMD":		# What do we want for debug???
+	    debugme()
+	elif cmd == "MAYDAY":		# Call for help
+	    mayday()
+	    if game.ididit:
+		hitme = True
+	elif cmd == "QUIT":
+	    game.alldone = True		# quit the game
+	elif cmd == "HELP":
+	    helpme()			# get help
+	while True:
+	    if game.alldone:
+		break		# Game has ended
+	    if game.optime != 0.0:
+		events()
+		if game.alldone:
+		    break	# Events did us in
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		atover(False)
+		continue
+	    if hitme and not game.justin:
+		attack(torps_ok=True)
+		if game.alldone:
+		    break
+		if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		    atover(False)
+		    hitme = True
+		    continue
+	    break
+	if game.alldone:
+	    break
+    if idebug:
+	prout("=== Ending")
+
+def cramen(type):
+    "Emit the name of an enemy or feature." 
+    if   type == 'R': s = _("Romulan")
+    elif type == 'K': s = _("Klingon")
+    elif type == 'C': s = _("Commander")
+    elif type == 'S': s = _("Super-commander")
+    elif type == '*': s = _("Star")
+    elif type == 'P': s = _("Planet")
+    elif type == 'B': s = _("Starbase")
+    elif type == ' ': s = _("Black hole")
+    elif type == 'T': s = _("Tholian")
+    elif type == '#': s = _("Tholian web")
+    elif type == '?': s = _("Stranger")
+    elif type == '@': s = _("Inhabited World")
+    else: s = "Unknown??"
+    return s
+
+def crmena(stars, enemy, loctype, w):
+    "Emit the name of an enemy and his location."
+    buf = ""
+    if stars:
+	buf += "***"
+    buf += cramen(enemy) + _(" at ")
+    if loctype == "quadrant":
+	buf += _("Quadrant ")
+    elif loctype == "sector":
+	buf += _("Sector ")
+    return buf + `w`
+
+def crmshp():
+    "Emit our ship name." 
+    return{'E':_("Enterprise"),'F':_("Faerie Queene")}.get(game.ship,"Ship???")
+
+def stars():
+    "Emit a line of stars" 
+    prouts("******************************************************")
+    skip(1)
+
+def expran(avrage):
+    return -avrage*math.log(1e-7 + randreal())
+
+def randplace(size):
+    "Choose a random location."
+    w = coord()
+    w.i = randrange(size) 
+    w.j = randrange(size)
+    return w
+
+class sstscanner:
+    def __init__(self):
+        self.type = None
+        self.token = None
+        self.real = 0.0
+        self.inqueue = []
+    def next(self):
+        # Get a token from the user
+        self.real = 0.0
+        self.token = ''
+        # Fill the token quue if nothing here
+        while not self.inqueue:
+            line = cgetline()
+            if curwnd==prompt_window:
+                clrscr()
+                setwnd(message_window)
+                clrscr()
+            if line == '':
+                return None
+            if not line:
+                continue
+            else:
+                self.inqueue = line.lstrip().split() + ["\n"]
+        # From here on in it's all looking at the queue
+        self.token = self.inqueue.pop(0)
+        if self.token == "\n":
+            self.type = "IHEOL"
+            return "IHEOL"
+        try:
+            self.real = float(self.token)
+            self.type = "IHREAL"
+            return "IHREAL"
+        except ValueError:
+            pass
+        # Treat as alpha
+        self.token = self.token.lower()
+        self.type = "IHALPHA"
+        self.real = None
+        return "IHALPHA"
+    def append(self, tok):
+        self.inqueue.append(tok)
+    def push(self, tok):
+        self.inqueue.insert(0, tok)
+    def waiting(self):
+        return self.inqueue
+    def chew(self):
+        # Demand input for next scan
+        self.inqueue = []
+        self.real = self.token = None
+    def sees(self, s):
+        # compares s to item and returns true if it matches to the length of s
+        return s.startswith(self.token)
+    def int(self):
+        # Round token value to nearest integer
+        return int(round(scanner.real))
+    def getcoord(self):
+        s = coord()
+        scanner.next()
+    	if scanner.type != "IHREAL":
+	    huh()
+	    return None
+	s.i = scanner.int()-1
+        scanner.next()
+	if scanner.type != "IHREAL":
+	    huh()
+	    return None
+	s.j = scanner.int()-1
+        return s
+    def __repr__(str):
+        return "<sstcanner: token=%s, type=%s, queue=%s>" % (scanner.token, scanner.type, scanner.inqueue)
+
+def ja():
+    "Yes-or-no confirmation."
+    scanner.chew()
+    while True:
+	scanner.next()
+	if scanner.token == 'y':
+	    return True
+	if scanner.token == 'n':
+	    return False
+	scanner.chew()
+	proutn(_("Please answer with \"y\" or \"n\": "))
+
+def huh():
+    "Complain about unparseable input."
+    scanner.chew()
+    skip(1)
+    prout(_("Beg your pardon, Captain?"))
+
+def debugme():
+    "Access to the internals for debugging."
+    proutn("Reset levels? ")
+    if ja() == True:
+	if game.energy < game.inenrg:
+	    game.energy = game.inenrg
+	game.shield = game.inshld
+	game.torps = game.intorps
+	game.lsupres = game.inlsr
+    proutn("Reset damage? ")
+    if ja() == True:
+	for i in range(NDEVICES): 
+	    if game.damage[i] > 0.0: 
+		game.damage[i] = 0.0
+    proutn("Toggle debug flag? ")
+    if ja() == True:
+	idebug = not idebug
+	if idebug:
+	    prout("Debug output ON")	    
+	else:
+	    prout("Debug output OFF")
+    proutn("Cause selective damage? ")
+    if ja() == True:
+	for i in range(NDEVICES):
+	    proutn("Kill %s?" % device[i])
+	    scanner.chew()
+	    key = scanner.next()
+            if key == "IHALPHA" and scanner.sees("y"):
+		game.damage[i] = 10.0
+    proutn("Examine/change events? ")
+    if ja() == True:
+	ev = event()
+	w = coord()
+        legends = {
+            FSNOVA:  "Supernova       ",
+            FTBEAM:  "T Beam          ",
+            FSNAP:   "Snapshot        ",
+            FBATTAK: "Base Attack     ",
+            FCDBAS:  "Base Destroy    ",
+            FSCMOVE: "SC Move         ",
+            FSCDBAS: "SC Base Destroy ",
+            FDSPROB: "Probe Move      ",
+            FDISTR:  "Distress Call   ",
+            FENSLV:  "Enslavement     ",
+            FREPRO:  "Klingon Build   ",
+        }
+	for i in range(1, NEVENTS):
+            proutn(legends[i])
+	    if is_scheduled(i):
+		proutn("%.2f" % (scheduled(i)-game.state.date))
+		if i == FENSLV or i == FREPRO:
+		    ev = findevent(i)
+		    proutn(" in %s" % ev.quadrant)
+	    else:
+		proutn("never")
+	    proutn("? ")
+	    scanner.chew()
+	    key = scanner.next()
+	    if key == 'n':
+		unschedule(i)
+		scanner.chew()
+	    elif key == "IHREAL":
+		ev = schedule(i, scanner.real)
+		if i == FENSLV or i == FREPRO:
+		    scanner.chew()
+		    proutn("In quadrant- ")
+		    key = scanner.next()
+		    # "IHEOL" says to leave coordinates as they are 
+		    if key != "IHEOL":
+			if key != "IHREAL":
+			    prout("Event %d canceled, no x coordinate." % (i))
+			    unschedule(i)
+			    continue
+			w.i = int(round(scanner.real))
+			key = scanner.next()
+			if key != "IHREAL":
+			    prout("Event %d canceled, no y coordinate." % (i))
+			    unschedule(i)
+			    continue
+			w.j = int(round(scanner.real))
+			ev.quadrant = w
+	scanner.chew()
+    proutn("Induce supernova here? ")
+    if ja() == True:
+	game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova = True
+	atover(True)
+
+if __name__ == '__main__':
+    import getopt, socket
+    try:
+        global line, thing, game, idebug
+        game = None
+        thing = coord()
+        thing.angry = False
+        game = gamestate()
+        idebug = 0
+        game.options = OPTION_ALL &~ (OPTION_IOMODES | OPTION_PLAIN | OPTION_ALMY)
+        if os.getenv("TERM"):
+            game.options |= OPTION_CURSES
+        else:
+            game.options |= OPTION_TTY
+        seed = int(time.time())
+        (options, arguments) = getopt.getopt(sys.argv[1:], "r:s:tx")
+        for (switch, val) in options:
+            if switch == '-r':
+                try:
+                    replayfp = open(val, "r")
+                except IOError:
+                    sys.stderr.write("sst: can't open replay file %s\n" % val)
+                    raise SystemExit, 1
+                try:
+                    line = replayfp.readline().strip()
+                    (leader, key, seed) = line.split()
+                    seed = eval(seed)
+                    sys.stderr.write("sst2k: seed set to %s\n" % seed)
+                    line = replayfp.readline().strip()
+                    arguments += line.split()[2:]
+                except ValueError:
+                    sys.stderr.write("sst: replay file %s is ill-formed\n"% val)
+                    raise SystemExit(1)
+                game.options |= OPTION_TTY
+                game.options &=~ OPTION_CURSES
+            elif switch == '-s':
+                seed = int(val)
+            elif switch == '-t':
+                game.options |= OPTION_TTY
+                game.options &=~ OPTION_CURSES
+            elif switch == '-x':
+                idebug = True
+            else:
+                sys.stderr.write("usage: sst [-t] [-x] [startcommand...].\n")
+                raise SystemExit, 1
+        # where to save the input in case of bugs
+        if "TMPDIR" in os.environ:
+            tmpdir = os.environ['TMPDIR']
+        else:
+            tmpdir = "/tmp"
+        try:
+            logfp = open(os.path.join(tmpdir, "sst-input.log"), "w")
+        except IOError:
+            sys.stderr.write("sst: warning, can't open logfile\n")
+            sys.exit(1)
+        if logfp:
+            logfp.write("# seed %s\n" % seed)
+            logfp.write("# options %s\n" % " ".join(arguments))
+            logfp.write("# recorded by %s@%s on %s\n" % \
+                    (getpass.getuser(),socket.gethostname(),time.ctime()))
+        random.seed(seed)
+        scanner = sstscanner()
+        map(scanner.append, arguments)
+        try:
+            iostart()
+            while True: # Play a game 
+                setwnd(fullscreen_window)
+                clrscr()
+                prelim()
+                setup()
+                if game.alldone:
+                    score()
+                    game.alldone = False
+                else:
+                    makemoves()
+                skip(1)
+                stars()
+                skip(1)
+                if game.tourn and game.alldone:
+                    proutn(_("Do you want your score recorded?"))
+                    if ja() == True:
+                        scanner.chew()
+                        scanner.push("\n")
+                        freeze(False)
+                scanner.chew()
+                proutn(_("Do you want to play again? "))
+                if not ja():
+                    break
+            skip(1)
+            prout(_("May the Great Bird of the Galaxy roost upon your home planet."))
+        finally:
+            ioend()
+        raise SystemExit, 0
+    except KeyboardInterrupt:
+        if logfp:
+            logfp.close()
+        print ""

Deleted: trunk/sst.spec
===================================================================
--- trunk/sst.spec	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/sst.spec	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,49 +0,0 @@
-Name: sst
-Version: 2.0
-Release: 1
-URL: http://sst.berlios.de
-Source0: %{name}-%{version}.tar.gz
-License: GPL
-Group: Games
-Summary: the classic game of Super Star Trek
-BuildRoot: %{_tmppath}/%{name}-root
-#Freshmeat-Name: strek
-
-%description
-Save the Federation from the invading Klingons!  Visit exotic planets and
-strip-mine them for dilithium!  Encounter mysterious space thingies!
-The classic Super Star Trek game from the days of slow teletypes, reloaded.
-
-%prep
-%setup -q
-
-%build
-make %{?_smp_mflags} all sst-doc.html
-
-%install
-[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
-mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
-mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
-cp sst "$RPM_BUILD_ROOT"%{_bindir}
-cp sst.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/
-mkdir -p "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/
-cp sst.doc "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/
-cp sst-doc.html "$RPM_BUILD_ROOT"%{_defaultdocdir}/sst/index.html
-
-%clean
-[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
-
-%files
-%doc README COPYING
-%defattr(-,root,root,-)
-%{_mandir}/man6/sst.6*
-%{_bindir}/sst
-%{_defaultdocdir}/sst/sst.doc
-%{_defaultdocdir}/sst/index.html
-
-%changelog
-
-* Thu Apr 14 2005 Eric S. Raymond <esr at snark.thyrsus.com> - 2.0-1
-- First release under new management.
-
-



From esr at mail.berlios.de  Tue Nov 30 09:31:22 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 09:31:22 +0100
Subject: [Sst-commit-watch] r811 - in trunk: . c-version
Message-ID: <20101130083123.3929B480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 09:31:22 +0100 (Tue, 30 Nov 2010)
New Revision: 811

Added:
   trunk/c-version/AUTHORS
   trunk/c-version/COPYING
   trunk/c-version/ChangeLog
   trunk/c-version/INSTALL
   trunk/c-version/NEWS
   trunk/c-version/README
Removed:
   trunk/AUTHORS
   trunk/INSTALL
   trunk/NEWS
Modified:
   trunk/c-version/Makefile.am
   trunk/c-version/configure.ac
Log:
These changes allow the obsolete C sources to build again. 


Deleted: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2010-11-30 08:15:36 UTC (rev 810)
+++ trunk/AUTHORS	2010-11-30 08:31:22 UTC (rev 811)
@@ -1,6 +0,0 @@
-David Matuszek <matuszek at cis.upenn.edu>
-Paul Reynolds
-Don Smith
-Tom Almy <tom at almy.us>
-Stas Sergeev <stsp at aknet.ru>
-Eric S. Raymond <esr at thyrsus.com>

Deleted: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2010-11-30 08:15:36 UTC (rev 810)
+++ trunk/INSTALL	2010-11-30 08:31:22 UTC (rev 811)
@@ -1,229 +0,0 @@
-Copyright 1994, 1995, 1996, 1999, 2000, 2001, 2002 Free Software
-Foundation, Inc.
-
-   This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
-
-Basic Installation
-==================
-
-   These are generic installation instructions.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, and a
-file `config.log' containing compiler output (useful mainly for
-debugging `configure').
-
-   It can also use an optional file (typically called `config.cache'
-and enabled with `--cache-file=config.cache' or simply `-C') that saves
-the results of its tests to speed up reconfiguring.  (Caching is
-disabled by default to prevent problems with accidental use of stale
-cache files.)
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If you are using the cache, and at
-some point `config.cache' contains results you don't want to keep, you
-may remove or edit it.
-
-   The file `configure.ac' (or `configure.in') is used to create
-`configure' by a program called `autoconf'.  You only need
-`configure.ac' if you want to change it or regenerate `configure' using
-a newer version of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.  If you're
-     using `csh' on an old version of System V, you might need to type
-     `sh ./configure' instead to prevent `csh' from trying to execute
-     `configure' itself.
-
-     Running `configure' takes awhile.  While running, it prints some
-     messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-Compilers and Options
-=====================
-
-   Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  Run `./configure --help'
-for details on some of the pertinent environment variables.
-
-   You can give `configure' initial values for configuration parameters
-by setting variables in the command line or in the environment.  Here
-is an example:
-
-     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
-
-   *Note Defining Variables::, for more details.
-
-Compiling For Multiple Architectures
-====================================
-
-   You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you must use a version of `make' that
-supports the `VPATH' variable, such as GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   If you have to use a `make' that does not support the `VPATH'
-variable, you have to compile the package for one architecture at a
-time in the source code directory.  After you have installed the
-package for one architecture, use `make distclean' before reconfiguring
-for another architecture.
-
-Installation Names
-==================
-
-   By default, `make install' will install the package's files in
-`/usr/local/bin', `/usr/local/man', etc.  You can specify an
-installation prefix other than `/usr/local' by giving `configure' the
-option `--prefix=PATH'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-give `configure' the option `--exec-prefix=PATH', the package will use
-PATH as the prefix for installing programs and libraries.
-Documentation and other data files will still use the regular prefix.
-
-   In addition, if you use an unusual directory layout you can give
-options like `--bindir=PATH' to specify different values for particular
-kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-   Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-   There may be some features `configure' cannot figure out
-automatically, but needs to determine by the type of machine the package
-will run on.  Usually, assuming the package is built to be run on the
-_same_ architectures, `configure' can figure that out, but if it prints
-a message saying it cannot guess the machine type, give it the
-`--build=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name which has the form:
-
-     CPU-COMPANY-SYSTEM
-
-where SYSTEM can have one of these forms:
-
-     OS KERNEL-OS
-
-   See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the machine type.
-
-   If you are _building_ compiler tools for cross-compiling, you should
-use the `--target=TYPE' option to select the type of system they will
-produce code for.
-
-   If you want to _use_ a cross compiler, that generates code for a
-platform different from the build platform, you should specify the
-"host" platform (i.e., that on which the generated programs will
-eventually be run) with `--host=TYPE'.
-
-Sharing Defaults
-================
-
-   If you want to set default values for `configure' scripts to share,
-you can create a site shell script called `config.site' that gives
-default values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Defining Variables
-==================
-
-   Variables not defined in a site shell script can be set in the
-environment passed to `configure'.  However, some packages may run
-configure again during the build, and the customized values of these
-variables may be lost.  In order to avoid this problem, you should set
-them in the `configure' command line, using `VAR=value'.  For example:
-
-     ./configure CC=/usr/local2/bin/gcc
-
-will cause the specified gcc to be used as the C compiler (unless it is
-overridden in the site shell script).
-
-`configure' Invocation
-======================
-
-   `configure' recognizes the following options to control how it
-operates.
-
-`--help'
-`-h'
-     Print a summary of the options to `configure', and exit.
-
-`--version'
-`-V'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`--cache-file=FILE'
-     Enable the cache: use and save the results of the tests in FILE,
-     traditionally `config.cache'.  FILE defaults to `/dev/null' to
-     disable caching.
-
-`--config-cache'
-`-C'
-     Alias for `--cache-file=config.cache'.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.  To
-     suppress all normal output, redirect it to `/dev/null' (any error
-     messages will still be shown).
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`configure' also accepts some other, not widely useful, options.  Run
-`configure --help' for more details.
-

Deleted: trunk/NEWS
===================================================================
Copied: trunk/c-version/AUTHORS (from rev 809, trunk/AUTHORS)
===================================================================
--- trunk/c-version/AUTHORS	                        (rev 0)
+++ trunk/c-version/AUTHORS	2010-11-30 08:31:22 UTC (rev 811)
@@ -0,0 +1,6 @@
+David Matuszek <matuszek at cis.upenn.edu>
+Paul Reynolds
+Don Smith
+Tom Almy <tom at almy.us>
+Stas Sergeev <stsp at aknet.ru>
+Eric S. Raymond <esr at thyrsus.com>

Added: trunk/c-version/COPYING
===================================================================
--- trunk/c-version/COPYING	                        (rev 0)
+++ trunk/c-version/COPYING	2010-11-30 08:31:22 UTC (rev 811)
@@ -0,0 +1,4 @@
+The NEWS, ChangeLog, and COPYING files in this directory are stubs to appease
+the cruel gods of autoconf.  See the top-level directory of the distributoon for
+the real ones.
+

Added: trunk/c-version/ChangeLog
===================================================================
--- trunk/c-version/ChangeLog	                        (rev 0)
+++ trunk/c-version/ChangeLog	2010-11-30 08:31:22 UTC (rev 811)
@@ -0,0 +1,4 @@
+The NEWS, ChangeLog, and COPYING files in this directory are stubs to appease
+the cruel gods of autoconf.  See the top-level directory of the distributoon for
+the real ones.
+

Copied: trunk/c-version/INSTALL (from rev 809, trunk/INSTALL)
===================================================================
--- trunk/c-version/INSTALL	                        (rev 0)
+++ trunk/c-version/INSTALL	2010-11-30 08:31:22 UTC (rev 811)
@@ -0,0 +1,229 @@
+Copyright 1994, 1995, 1996, 1999, 2000, 2001, 2002 Free Software
+Foundation, Inc.
+
+   This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+   These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+   Some systems require unusual options for compilation or linking that
+the `configure' script does not know about.  Run `./configure --help'
+for details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+   You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+   By default, `make install' will install the package's files in
+`/usr/local/bin', `/usr/local/man', etc.  You can specify an
+installation prefix other than `/usr/local' by giving `configure' the
+option `--prefix=PATH'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+give `configure' the option `--exec-prefix=PATH', the package will use
+PATH as the prefix for installing programs and libraries.
+Documentation and other data files will still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=PATH' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+   Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+   There may be some features `configure' cannot figure out
+automatically, but needs to determine by the type of machine the package
+will run on.  Usually, assuming the package is built to be run on the
+_same_ architectures, `configure' can figure that out, but if it prints
+a message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the `--target=TYPE' option to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+   If you want to set default values for `configure' scripts to share,
+you can create a site shell script called `config.site' that gives
+default values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+   Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+will cause the specified gcc to be used as the C compiler (unless it is
+overridden in the site shell script).
+
+`configure' Invocation
+======================
+
+   `configure' recognizes the following options to control how it
+operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+

Modified: trunk/c-version/Makefile.am
===================================================================
--- trunk/c-version/Makefile.am	2010-11-30 08:15:36 UTC (rev 810)
+++ trunk/c-version/Makefile.am	2010-11-30 08:31:22 UTC (rev 811)
@@ -1,6 +1,6 @@
 ## Process this file with automake to produce Makefile.in
 
-SUBDIRS = po src doc
+SUBDIRS = src
 
 EXTRA_DIST = config.rpath po m4 \
 	autogen.sh sst.spec ChangeLog.old

Copied: trunk/c-version/NEWS (from rev 809, trunk/NEWS)
===================================================================
Added: trunk/c-version/README
===================================================================
--- trunk/c-version/README	                        (rev 0)
+++ trunk/c-version/README	2010-11-30 08:31:22 UTC (rev 811)
@@ -0,0 +1,5 @@
+This is an archive of the last C version of SST.  The game was moved to
+Python in 2006.
+
+The NEWS, ChangeLog, and COPYING files in this directory are stubs to appease
+the cruel gods of autoconf.

Modified: trunk/c-version/configure.ac
===================================================================
--- trunk/c-version/configure.ac	2010-11-30 08:15:36 UTC (rev 810)
+++ trunk/c-version/configure.ac	2010-11-30 08:31:22 UTC (rev 811)
@@ -46,7 +46,11 @@
 AC_CONFIG_FILES([
     Makefile
     src/Makefile
-    po/Makefile.in
-    doc/Makefile
 ])
+
+# These used to be in AC_CONFIG_FILES before the C version became obsolete.
+# Now the build machinery in them is separate/
+#    po/Makefile.in
+#    doc/Makefile
+
 AC_OUTPUT



From esr at mail.berlios.de  Tue Nov 30 09:48:53 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 09:48:53 +0100
Subject: [Sst-commit-watch] r812 - trunk/doc
Message-ID: <20101130084853.51B88480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 09:48:52 +0100 (Tue, 30 Nov 2010)
New Revision: 812

Added:
   trunk/doc/Makefile
Log:
Pull this loose from the autoconf goo.


Copied: trunk/doc/Makefile (from rev 809, trunk/doc/Makefile.am)
===================================================================
--- trunk/doc/Makefile	                        (rev 0)
+++ trunk/doc/Makefile	2010-11-30 08:48:52 UTC (rev 812)
@@ -0,0 +1,16 @@
+# From this directory, distribute rge following files:
+# HACKING makehelp.py sst-doc.xml sst-layer.xsl sst.xml
+
+sst.6: sst.xml
+	xmlto man sst.xml
+
+sst-doc.txt: sst-doc.xml
+	xmlto -m sst-layer.xsl txt sst-doc.xml
+sst.doc: sst-doc.txt
+	./makehelp.py >sst.doc
+
+sst-doc.html: sst-doc.xml
+	xmlto xhtml-nochunks sst-doc.xml
+
+clean:
+	rm -f sst.6 sst-doc.txt sst.doc



From esr at mail.berlios.de  Tue Nov 30 09:53:28 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 09:53:28 +0100
Subject: [Sst-commit-watch] r813 - trunk/doc
Message-ID: <20101130085328.3C4FB480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 09:53:27 +0100 (Tue, 30 Nov 2010)
New Revision: 813

Modified:
   trunk/doc/HACKING
Log:
Typo fix.


Modified: trunk/doc/HACKING
===================================================================
--- trunk/doc/HACKING	2010-11-30 08:48:52 UTC (rev 812)
+++ trunk/doc/HACKING	2010-11-30 08:53:27 UTC (rev 813)
@@ -1,7 +1,7 @@
 This is the hackers' guide to SST2K.  Read it before messing with the code.
 
 It consists of an introduction, a history, suggestions for regression testing,
-some notes on the Python translation.  For a to-do list, see TODO in the
+and some notes on the Python translation.  For a to-do list, see TODO in the
 top-level directory.
 
 INTRODUCTION:



From esr at mail.berlios.de  Tue Nov 30 09:57:12 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 09:57:12 +0100
Subject: [Sst-commit-watch] r814 - in trunk: . c-version/src doc
Message-ID: <20101130085712.8CB1D480149@sheep.berlios.de>

Author: esr
Date: 2010-11-30 09:57:12 +0100 (Tue, 30 Nov 2010)
New Revision: 814

Added:
   trunk/replay
Removed:
   trunk/c-version/src/replay
   trunk/doc/Makefile.am
Log:
Move the replay debugging script iup from the C sources directory.


Deleted: trunk/c-version/src/replay
===================================================================
--- trunk/c-version/src/replay	2010-11-30 08:53:27 UTC (rev 813)
+++ trunk/c-version/src/replay	2010-11-30 08:57:12 UTC (rev 814)
@@ -1,14 +0,0 @@
-#!/bin/sh
-# Replay the last SST game. With arg, use only that many lines of the log
-#
-# Because the replay log captures the random-number seed,
-# repeating this any number of times should produce identical games,
-# unless the code changes.
-#
-if [ $1 ]
-then
-    head -n `expr $1 + 2` </usr/tmp/sst-input.log >replay.log
-else
-    mv /usr/tmp/sst-input.log replay.log
-fi
-python sst.py -t -r replay.log

Deleted: trunk/doc/Makefile.am
===================================================================
--- trunk/doc/Makefile.am	2010-11-30 08:53:27 UTC (rev 813)
+++ trunk/doc/Makefile.am	2010-11-30 08:57:12 UTC (rev 814)
@@ -1,15 +0,0 @@
-man_MANS = sst.6
-pkgdata_DATA = sst-doc.txt sst.doc
-CLEANFILES = $(pkgdata_DATA) $(man_MANS)
-EXTRA_DIST = makehelp.py sst-doc.xml sst-layer.xsl sst.xml
-
-sst.6: sst.xml
-	xmlto man sst.xml
-
-sst-doc.txt: sst-doc.xml
-	xmlto -m sst-layer.xsl txt sst-doc.xml
-sst.doc: sst-doc.txt
-	./makehelp.py >sst.doc
-
-sst-doc.html: sst-doc.xml
-	xmlto xhtml-nochunks sst-doc.xml

Copied: trunk/replay (from rev 810, trunk/c-version/src/replay)
===================================================================
--- trunk/replay	                        (rev 0)
+++ trunk/replay	2010-11-30 08:57:12 UTC (rev 814)
@@ -0,0 +1,14 @@
+#!/bin/sh
+# Replay the last SST game. With arg, use only that many lines of the log
+#
+# Because the replay log captures the random-number seed,
+# repeating this any number of times should produce identical games,
+# unless the code changes.
+#
+if [ $1 ]
+then
+    head -n `expr $1 + 2` </usr/tmp/sst-input.log >replay.log
+else
+    mv /usr/tmp/sst-input.log replay.log
+fi
+python sst.py -t -r replay.log



From esr at mail.berlios.de  Tue Nov 30 10:44:56 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 10:44:56 +0100
Subject: [Sst-commit-watch] r815 - in trunk: . doc
Message-ID: <20101130094456.8C31048018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 10:44:56 +0100 (Tue, 30 Nov 2010)
New Revision: 815

Added:
   trunk/NEWS
Removed:
   trunk/ChangeLog
Modified:
   trunk/doc/sst-doc.xml
Log:
Documentation update.


Deleted: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2010-11-30 08:57:12 UTC (rev 814)
+++ trunk/ChangeLog	2010-11-30 09:44:56 UTC (rev 815)
@@ -1,30 +0,0 @@
-2006-09-15  Eric S. Raymond  <esr at snark.thyrsus.com>
-
-	* TODO: Fixed these bug items from the TO-DO list:
-	
-	* Bring the online help in sync with our commands changes
-	
-	* Find out why the online help contains the escape sequences like
-	~@~T (Eric?)
-	
-	The first was due to bugs in some macro definitions in sst.c, now
-	fixed.  The second was from escape sequences generated into
-	sst.doc by xmlto for left-and right-quotes, dashes, and no-break
-	spaces; that is fixed by an additional translation step in
-	makehelp.py.
-	
-	xmlto still generates line-drawing characters for the tables in
-	the LRSCAN and REPORT help items, but those look OK on an xterm in
-	text mode and their help items are suppressed (along with their
-	commands) in curses mode.
-	
-	This is not a completely satisfactory solution, but it will do
-	until a design change makes those help items visible again.
-
-2006-09-12  gettextize  <bug-gnu-gettext at gnu.org>
-
-	* Makefile.am (SUBDIRS): Add po.
-	(ACLOCAL_AMFLAGS): New variable.
-	(EXTRA_DIST): Add config.rpath, m4/ChangeLog.
-	* configure.ac (AC_CONFIG_FILES): Add po/Makefile.in.
-

Copied: trunk/NEWS (from rev 809, trunk/ChangeLog)
===================================================================
--- trunk/NEWS	                        (rev 0)
+++ trunk/NEWS	2010-11-30 09:44:56 UTC (rev 815)
@@ -0,0 +1,11 @@
+			SST2K project news.
+
+2.0 @ 2010-11-30
+
+    Game code moved to Python. Many bug fixes.
+
+1.0 @ 2004-06-06
+
+    Initial release.
+
+

Modified: trunk/doc/sst-doc.xml
===================================================================
--- trunk/doc/sst-doc.xml	2010-11-30 08:57:12 UTC (rev 814)
+++ trunk/doc/sst-doc.xml	2010-11-30 09:44:56 UTC (rev 815)
@@ -1826,8 +1826,8 @@
 <para>Planets are auto-scanned when you enter the quadrant.</para>
 </listitem>
 <listitem>
-<para>Mining or using crystals in presense of enemy now yields an attack.
-There are other minor adjustments to what yields an attack
+<para>Mining or using crystals in the presence of the enemy now yields
+an attack.  There are other minor adjustments to what yields an attack
 and what does not.</para>
 </listitem>
 <listitem>



From esr at mail.berlios.de  Tue Nov 30 10:47:59 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 10:47:59 +0100
Subject: [Sst-commit-watch] r816 - in trunk: . doc
Message-ID: <20101130094800.1025048018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 10:47:59 +0100 (Tue, 30 Nov 2010)
New Revision: 816

Added:
   trunk/doc/ChangeLog.old
Removed:
   trunk/ChangeLog.old
Log:
Keep around Stas's narrative for archival purposes. 


Deleted: trunk/ChangeLog.old
===================================================================
--- trunk/ChangeLog.old	2010-11-30 09:44:56 UTC (rev 815)
+++ trunk/ChangeLog.old	2010-11-30 09:47:59 UTC (rev 816)
@@ -1,106 +0,0 @@
-Tom Almy story:
-
-Back in (about) 1977 I got a copy of this Super Star Trek game for
-the CDC 6600 mainframe computer. Someone had converted it to PDP-11
-Fortran but couldn't get it to run because of its size. I modified
-the program to use overlays and managed to shoehorn it in on the 56k
-byte machine.
-
-I liked the game so much I put some time into fixing bugs, mainly
-what could be called continuity errors and loopholes in the game's
-logic. We even played a couple tournaments.
-
-In 1979, I lost access to that PDP-11. I did save the source code
-listing. In 1995, missing that old friend, I started converting the
-program into portable ANSI C. It's been slow, tedious work that took
-over a year to accomplish.
-
-In early 1997, I got the bright idea to look for references to "Super
-Star Trek" on the World Wide Web. There weren't many hits, but there
-was one that came up with 1979 Fortran sources! This version had a
-few additional features that mine didn't have, however mine had some
-feature it didn't have. So I merged its features that I liked. I also
-took a peek at the DECUS version (a port, less sources, to the
-PDP-10), and some other variations.
-
-Modifications I made:
-
-  Compared to original version, I've changed the "help" command to
-  "call" and the "terminate" command to "quit" to better match user
-  expectations. The DECUS version apparently made those changes as well
-  as changing "freeze" to "save". However I like "freeze".
-
-  I added EMEXIT from the 1979 version.
-
-  That later version also mentions srscan and lrscan working when
-  docked (using the starbase's scanners), so I made some changes here
-  to do this (and indicating that fact to the player), and then
-  realized the base would have a subspace radio as well -- doing a
-  Chart when docked updates the star chart, and all radio reports will
-  be heard. The Dock command will also give a report if a base is under
-  attack.
-
-  It also had some added logic to spread the initial positioning of
-  bases. That made sense to add because most people abort games with
-  bad base placement.
-
-  The experimental deathray originally had only a 5% chance of success,
-  but could be used repeatedly. I guess after a couple years of use, it
-  was less "experimental" because the 1979 version had a 70% success
-  rate. However it was prone to breaking after use. I upgraded the
-  deathray, but kept the original set of failure modes (great humor!).
-
-  I put in the Tholian Web code from the 1979 version.
-
-  I added code so that Romulans and regular Klingons could move in
-  advanced games. I re-enabled the code which allows enemy ships to
-  ram the Enterprise; it had never worked right. The 1979 version
-  seems to have it all fixed up, but I'm still not overly happy with
-  the algorithm.
-
-  The DECUS version had a Deep Space Probe. Looked like a good idea
-  so I implimented it based on its description.
-
-
-Stas Sergeev story:
-
-Found Tom Almy's C sources - yeah! Hmm, not too playable - I've got
-used to that nice text-based GUI I've seen on an IBM S/370 port, and the
-command-line control gets me quite annoyed. But that's a good starting
-point for some improvements - the sources are finally here! I was about
-to start writing an S/370 emulator to get it a go, and now here are
-the sources - what a great finding.
-
-[a bit later]
-
-Added a text-based interface which makes the game much more playable.
-Initially I made it for DOS using conio.h. Later I decided to make a
-linux port, and I ported it using a linux-conio package. I had to patch
-linux-conio a lot, so you have to use my version. The colors are still
-wrong though.
-I also fixed an uncountable amount of bugs and added some features, I
-can't remember now which ones.
-
-[3 years later]
-
-I dusted off the game and finally got around to move it to autoconf.
-For building with Borland C under DOS, use the build_bc.bat file.
-
-It turned out Tom Almy also did a linux port and made some bug-fixing
-work, although to the much smaller extent than I did. I contacted him
-and notified about my port, but he expressed no interest. :(
-
-[a year later]
-
-I've found out that Eric S Raymond (ESR) took over the development
-of the Tom Almy's sources. He could use mine instead as they are
-much more advanced, but oh well... Now I have to find out the way
-to incorporate my mods into his version and hope that he can do
-the better work on that game than I could (which is most likely
-the case).
-.....
-OK, the changes were incorporated, however Eric removed the conio
-port and therefore the game can no longer be compiled with bcc/DOS.
-The DJGPP port might still be possible in the future.
-
-  -- Stas Sergeev <stsp at users.sourceforge.net>

Copied: trunk/doc/ChangeLog.old (from rev 809, trunk/ChangeLog.old)
===================================================================
--- trunk/doc/ChangeLog.old	                        (rev 0)
+++ trunk/doc/ChangeLog.old	2010-11-30 09:47:59 UTC (rev 816)
@@ -0,0 +1,42 @@
+Stas Sergeev story:
+
+Found Tom Almy's C sources - yeah! Hmm, not too playable - I've got
+used to that nice text-based GUI I've seen on an IBM S/370 port, and the
+command-line control gets me quite annoyed. But that's a good starting
+point for some improvements - the sources are finally here! I was about
+to start writing an S/370 emulator to get it a go, and now here are
+the sources - what a great finding.
+
+[a bit later]
+
+Added a text-based interface which makes the game much more playable.
+Initially I made it for DOS using conio.h. Later I decided to make a
+linux port, and I ported it using a linux-conio package. I had to patch
+linux-conio a lot, so you have to use my version. The colors are still
+wrong though.
+I also fixed an uncountable amount of bugs and added some features, I
+can't remember now which ones.
+
+[3 years later]
+
+I dusted off the game and finally got around to move it to autoconf.
+For building with Borland C under DOS, use the build_bc.bat file.
+
+It turned out Tom Almy also did a linux port and made some bug-fixing
+work, although to the much smaller extent than I did. I contacted him
+and notified about my port, but he expressed no interest. :(
+
+[a year later]
+
+I've found out that Eric S Raymond (ESR) took over the development
+of the Tom Almy's sources. He could use mine instead as they are
+much more advanced, but oh well... Now I have to find out the way
+to incorporate my mods into his version and hope that he can do
+the better work on that game than I could (which is most likely
+the case).
+.....
+OK, the changes were incorporated, however Eric removed the conio
+port and therefore the game can no longer be compiled with bcc/DOS.
+The DJGPP port might still be possible in the future.
+
+  -- Stas Sergeev <stsp at users.sourceforge.net>



From esr at mail.berlios.de  Tue Nov 30 10:51:35 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 10:51:35 +0100
Subject: [Sst-commit-watch] r817 - trunk
Message-ID: <20101130095135.CB68048018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 10:51:35 +0100 (Tue, 30 Nov 2010)
New Revision: 817

Modified:
   trunk/sst.py
Log:
Typo fix.


Modified: trunk/sst.py
===================================================================
--- trunk/sst.py	2010-11-30 09:47:59 UTC (rev 816)
+++ trunk/sst.py	2010-11-30 09:51:35 UTC (rev 817)
@@ -5230,7 +5230,7 @@
     return False
 
 # I used <http://www.memory-alpha.org> to find planets
-# with references in ST:TOS.  Eath and the Alpha Centauri
+# with references in ST:TOS.  Earth and the Alpha Centauri
 # Colony have been omitted.
 # 
 # Some planets marked Class G and P here will be displayed as class M



From esr at mail.berlios.de  Tue Nov 30 11:09:53 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 11:09:53 +0100
Subject: [Sst-commit-watch] r818 - trunk
Message-ID: <20101130100953.A196348018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 11:09:53 +0100 (Tue, 30 Nov 2010)
New Revision: 818

Modified:
   trunk/sst.py
Log:
Fix a reference to sys.version_info.major that broke Python 2.6.


Modified: trunk/sst.py
===================================================================
--- trunk/sst.py	2010-11-30 09:51:35 UTC (rev 817)
+++ trunk/sst.py	2010-11-30 10:09:53 UTC (rev 818)
@@ -3066,7 +3066,7 @@
     "for some recent versions of python2, the following enables UTF8"
     "for the older ones we probably need to set C locale, and the python3"
     "has no problems at all"
-    if sys.version_info.major < 3:
+    if sys.version_info[0] < 3:
 	import locale
 	locale.setlocale(locale.LC_ALL, "")
     gettext.bindtextdomain("sst", "/usr/local/share/locale")



From esr at mail.berlios.de  Tue Nov 30 11:19:08 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 11:19:08 +0100
Subject: [Sst-commit-watch] r819 - in trunk: . doc
Message-ID: <20101130101908.BE7A048018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 11:19:08 +0100 (Tue, 30 Nov 2010)
New Revision: 819

Modified:
   trunk/doc/sst.xml
   trunk/sst.py
Log:
Add a -V option.


Modified: trunk/doc/sst.xml
===================================================================
--- trunk/doc/sst.xml	2010-11-30 10:09:53 UTC (rev 818)
+++ trunk/doc/sst.xml	2010-11-30 10:19:08 UTC (rev 819)
@@ -18,6 +18,7 @@
       <arg choice='opt'>-r <replaceable>filename</replaceable></arg> 
       <arg choice='opt'>-t </arg> 
       <arg choice='opt'>-x </arg> 
+      <arg choice='opt'>-V </arg> 
       <arg rep='repeat' ><replaceable>command</replaceable></arg>  
 </cmdsynopsis>
 
@@ -51,6 +52,8 @@
 <para>The option -x enables some debugging features of interest
 probably only to sst2k developers.</para>
 
+<para>With -V, the program emits its version and exits.</para>
+
 <para>Input tokens for the setup prompts will be read from the
 remainder of the command line before standard input.  Thus, for
 example, you can invoke the program as</para>

Modified: trunk/sst.py
===================================================================
--- trunk/sst.py	2010-11-30 10:09:53 UTC (rev 818)
+++ trunk/sst.py	2010-11-30 10:19:08 UTC (rev 819)
@@ -13,6 +13,8 @@
 """
 import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
 
+version="2.0"
+
 docpath  	= (".", "../doc", "/usr/share/doc/sst")
 
 def _(str): return gettext.gettext(str)
@@ -6255,7 +6257,7 @@
         else:
             game.options |= OPTION_TTY
         seed = int(time.time())
-        (options, arguments) = getopt.getopt(sys.argv[1:], "r:s:tx")
+        (options, arguments) = getopt.getopt(sys.argv[1:], "r:s:txV")
         for (switch, val) in options:
             if switch == '-r':
                 try:
@@ -6282,6 +6284,9 @@
                 game.options &=~ OPTION_CURSES
             elif switch == '-x':
                 idebug = True
+            elif switch == '-V':
+                print "SST2K", version
+                raise SystemExit, 0 
             else:
                 sys.stderr.write("usage: sst [-t] [-x] [startcommand...].\n")
                 raise SystemExit, 1



From esr at mail.berlios.de  Tue Nov 30 11:29:51 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 11:29:51 +0100
Subject: [Sst-commit-watch] r820 - trunk
Message-ID: <20101130102951.6336848018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 11:29:51 +0100 (Tue, 30 Nov 2010)
New Revision: 820

Added:
   trunk/Makefile
Log:
A much simpler makefile.


Added: trunk/Makefile
===================================================================
--- trunk/Makefile	                        (rev 0)
+++ trunk/Makefile	2010-11-30 10:29:51 UTC (rev 820)
@@ -0,0 +1,37 @@
+# Makefile for the SST2K project
+
+VERS=$(shell sed <sst.py -n -e '/version=\(.*\)/s//\1/p')
+
+MANDIR=/usr/share/man/man1
+BINDIR=/usr/bin
+
+DOCS    = README COPYING NEWS doc/HACKING doc/sst-doc.xml doc/sst-layer.xsl doc/sst.xml
+SOURCES = sst.py Makefile replay doc/makehelp.py $(DOCS)
+
+all: sst-$(VERS).tar.gz
+
+install: sst.6
+	cp sst.py $(BINDIR)
+	gzip <sst.6 >$(MANDIR)/sst.6.gz
+
+sst.6: doc/sst.xml
+	cd doc; xmlto man sst.xml; mv sst.6 ..
+
+sst.html: doc/sst.xml
+	cd doc; xmlto html-nochunks sst.xml; mv sst.html ..
+
+sst-$(VERS).tar.gz: $(SOURCES) sst.6
+	mkdir sst-$(VERS)
+	cp $(SOURCES) sst-$(VERS)
+	tar -czf sst-$(VERS).tar.gz sst-$(VERS)
+	rm -fr sst-$(VERS)
+	ls -l sst-$(VERS).tar.gz
+
+dist: sst-$(VERS).tar.gz
+
+clean:
+	rm -f sst.6 sst.html
+	rm -f *.1 MANIFEST index.html SHIPPER.*
+
+release: sst-$(VERS).tar.gz sst.html
+	shipper -u -m -t; make clean



From esr at mail.berlios.de  Tue Nov 30 11:31:51 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 11:31:51 +0100
Subject: [Sst-commit-watch] r821 - trunk/doc
Message-ID: <20101130103152.061D548018C@sheep.berlios.de>

Author: esr
Date: 2010-11-30 11:31:51 +0100 (Tue, 30 Nov 2010)
New Revision: 821

Modified:
   trunk/doc/sst.xml
Log:
Silence some DocBook warnings.


Modified: trunk/doc/sst.xml
===================================================================
--- trunk/doc/sst.xml	2010-11-30 10:29:51 UTC (rev 820)
+++ trunk/doc/sst.xml	2010-11-30 10:31:51 UTC (rev 821)
@@ -6,6 +6,9 @@
 <refentrytitle>sst</refentrytitle>
 <manvolnum>6</manvolnum>
 <refmiscinfo class='date'>Nov 1 2004</refmiscinfo>
+<refmiscinfo class='productname'>SST2K</refmiscinfo>
+<refmiscinfo class='source'>SST2K</refmiscinfo>
+<refmiscinfo class='manual'>Games</refmiscinfo>
 </refmeta>
 <refnamediv id='name'>
 <refname>sst</refname>



From esr at mail.berlios.de  Tue Nov 30 18:57:50 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 18:57:50 +0100
Subject: [Sst-commit-watch] r822 - trunk/po
Message-ID: <20101130175750.EC8CF480196@sheep.berlios.de>

Author: esr
Date: 2010-11-30 18:57:50 +0100 (Tue, 30 Nov 2010)
New Revision: 822

Added:
   trunk/po/Makefile
   trunk/po/msgfmt.py
Removed:
   trunk/po/ChangeLog
   trunk/po/Makefile.in.in
   trunk/po/Makevars
   trunk/po/Makevars.template
   trunk/po/POTFILES.in
   trunk/po/Rules-quot
   trunk/po/boldquot.sed
   trunk/po/en at boldquot.header
   trunk/po/en at quot.header
   trunk/po/insert-header.sin
   trunk/po/quot.sed
   trunk/po/remove-potcdate.sin
Log:
Replace autotools cruft for .handling po->.mo generation with Pyton. 


Deleted: trunk/po/ChangeLog
===================================================================
--- trunk/po/ChangeLog	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/ChangeLog	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,12 +0,0 @@
-2006-09-12  gettextize  <bug-gnu-gettext at gnu.org>
-
-	* Makefile.in.in: New file, from gettext-0.14.5.
-	* boldquot.sed: New file, from gettext-0.14.5.
-	* en at boldquot.header: New file, from gettext-0.14.5.
-	* en at quot.header: New file, from gettext-0.14.5.
-	* insert-header.sin: New file, from gettext-0.14.5.
-	* quot.sed: New file, from gettext-0.14.5.
-	* remove-potcdate.sin: New file, from gettext-0.14.5.
-	* Rules-quot: New file, from gettext-0.14.5.
-	* POTFILES.in: New file.
-

Added: trunk/po/Makefile
===================================================================
--- trunk/po/Makefile	                        (rev 0)
+++ trunk/po/Makefile	2010-11-30 17:57:50 UTC (rev 822)
@@ -0,0 +1,11 @@
+# Note: msgfmt.py is copiere from the Python source distribution
+
+.SUFFIXES: .po .mo
+
+.po.mo:
+	python msgfmt.py $<
+
+all: ru.mo
+
+clean:
+	rm *.mo

Deleted: trunk/po/Makefile.in.in
===================================================================
--- trunk/po/Makefile.in.in	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/Makefile.in.in	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,384 +0,0 @@
-# Makefile for PO directory in any package using GNU gettext.
-# Copyright (C) 1995-1997, 2000-2005 by Ulrich Drepper <drepper at gnu.ai.mit.edu>
-#
-# This file can be copied and used freely without restrictions.  It can
-# be used in projects which are not available under the GNU General Public
-# License but which still want to provide support for the GNU gettext
-# functionality.
-# Please note that the actual code of GNU gettext is covered by the GNU
-# General Public License and is *not* in the public domain.
-#
-# Origin: gettext-0.14.4
-
-PACKAGE = @PACKAGE@
-VERSION = @VERSION@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-
-SHELL = /bin/sh
- at SET_MAKE@
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-datadir = @datadir@
-localedir = $(datadir)/locale
-gettextsrcdir = $(datadir)/gettext/po
-
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-mkinstalldirs = $(SHELL) $(MKINSTALLDIRS)
-
-GMSGFMT = @GMSGFMT@
-MSGFMT = @MSGFMT@
-XGETTEXT = @XGETTEXT@
-MSGMERGE = msgmerge
-MSGMERGE_UPDATE = @MSGMERGE@ --update
-MSGINIT = msginit
-MSGCONV = msgconv
-MSGFILTER = msgfilter
-
-POFILES = @POFILES@
-GMOFILES = @GMOFILES@
-UPDATEPOFILES = @UPDATEPOFILES@
-DUMMYPOFILES = @DUMMYPOFILES@
-DISTFILES.common = Makefile.in.in remove-potcdate.sin \
-$(DISTFILES.common.extra1) $(DISTFILES.common.extra2) $(DISTFILES.common.extra3)
-DISTFILES = $(DISTFILES.common) Makevars POTFILES.in \
-$(POFILES) $(GMOFILES) \
-$(DISTFILES.extra1) $(DISTFILES.extra2) $(DISTFILES.extra3)
-
-POTFILES = \
-
-CATALOGS = @CATALOGS@
-
-# Makevars gets inserted here. (Don't remove this line!)
-
-.SUFFIXES:
-.SUFFIXES: .po .gmo .mo .sed .sin .nop .po-create .po-update
-
-.po.mo:
-	@echo "$(MSGFMT) -c -o $@ $<"; \
-	$(MSGFMT) -c -o t-$@ $< && mv t-$@ $@
-
-.po.gmo:
-	@lang=`echo $* | sed -e 's,.*/,,'`; \
-	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
-	echo "$${cdcmd}rm -f $${lang}.gmo && $(GMSGFMT) -c --statistics -o $${lang}.gmo $${lang}.po"; \
-	cd $(srcdir) && rm -f $${lang}.gmo && $(GMSGFMT) -c --statistics -o t-$${lang}.gmo $${lang}.po && mv t-$${lang}.gmo $${lang}.gmo
-
-.sin.sed:
-	sed -e '/^#/d' $< > t-$@
-	mv t-$@ $@
-
-
-all: all- at USE_NLS@
-
-all-yes: stamp-po
-all-no:
-
-# $(srcdir)/$(DOMAIN).pot is only created when needed. When xgettext finds no
-# internationalized messages, no $(srcdir)/$(DOMAIN).pot is created (because
-# we don't want to bother translators with empty POT files). We assume that
-# LINGUAS is empty in this case, i.e. $(POFILES) and $(GMOFILES) are empty.
-# In this case, stamp-po is a nop (i.e. a phony target).
-
-# stamp-po is a timestamp denoting the last time at which the CATALOGS have
-# been loosely updated. Its purpose is that when a developer or translator
-# checks out the package via CVS, and the $(DOMAIN).pot file is not in CVS,
-# "make" will update the $(DOMAIN).pot and the $(CATALOGS), but subsequent
-# invocations of "make" will do nothing. This timestamp would not be necessary
-# if updating the $(CATALOGS) would always touch them; however, the rule for
-# $(POFILES) has been designed to not touch files that don't need to be
-# changed.
-stamp-po: $(srcdir)/$(DOMAIN).pot
-	test ! -f $(srcdir)/$(DOMAIN).pot || \
-	  test -z "$(GMOFILES)" || $(MAKE) $(GMOFILES)
-	@test ! -f $(srcdir)/$(DOMAIN).pot || { \
-	  echo "touch stamp-po" && \
-	  echo timestamp > stamp-poT && \
-	  mv stamp-poT stamp-po; \
-	}
-
-# Note: Target 'all' must not depend on target '$(DOMAIN).pot-update',
-# otherwise packages like GCC can not be built if only parts of the source
-# have been downloaded.
-
-# This target rebuilds $(DOMAIN).pot; it is an expensive operation.
-# Note that $(DOMAIN).pot is not touched if it doesn't need to be changed.
-$(DOMAIN).pot-update: $(POTFILES) $(srcdir)/POTFILES.in remove-potcdate.sed
-	if test -n '$(MSGID_BUGS_ADDRESS)' || test '$(PACKAGE_BUGREPORT)' = '@'PACKAGE_BUGREPORT'@'; then \
-	  msgid_bugs_address='$(MSGID_BUGS_ADDRESS)'; \
-	else \
-	  msgid_bugs_address='$(PACKAGE_BUGREPORT)'; \
-	fi; \
-	$(XGETTEXT) --default-domain=$(DOMAIN) --directory=$(top_srcdir) \
-	  --add-comments=TRANSLATORS: $(XGETTEXT_OPTIONS) \
-	  --files-from=$(srcdir)/POTFILES.in \
-	  --copyright-holder='$(COPYRIGHT_HOLDER)' \
-	  --msgid-bugs-address="$$msgid_bugs_address"
-	test ! -f $(DOMAIN).po || { \
-	  if test -f $(srcdir)/$(DOMAIN).pot; then \
-	    sed -f remove-potcdate.sed < $(srcdir)/$(DOMAIN).pot > $(DOMAIN).1po && \
-	    sed -f remove-potcdate.sed < $(DOMAIN).po > $(DOMAIN).2po && \
-	    if cmp $(DOMAIN).1po $(DOMAIN).2po >/dev/null 2>&1; then \
-	      rm -f $(DOMAIN).1po $(DOMAIN).2po $(DOMAIN).po; \
-	    else \
-	      rm -f $(DOMAIN).1po $(DOMAIN).2po $(srcdir)/$(DOMAIN).pot && \
-	      mv $(DOMAIN).po $(srcdir)/$(DOMAIN).pot; \
-	    fi; \
-	  else \
-	    mv $(DOMAIN).po $(srcdir)/$(DOMAIN).pot; \
-	  fi; \
-	}
-
-# This rule has no dependencies: we don't need to update $(DOMAIN).pot at
-# every "make" invocation, only create it when it is missing.
-# Only "make $(DOMAIN).pot-update" or "make dist" will force an update.
-$(srcdir)/$(DOMAIN).pot:
-	$(MAKE) $(DOMAIN).pot-update
-
-# This target rebuilds a PO file if $(DOMAIN).pot has changed.
-# Note that a PO file is not touched if it doesn't need to be changed.
-$(POFILES): $(srcdir)/$(DOMAIN).pot
-	@lang=`echo $@ | sed -e 's,.*/,,' -e 's/\.po$$//'`; \
-	if test -f "$(srcdir)/$${lang}.po"; then \
-	  test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
-	  echo "$${cdcmd}$(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot"; \
-	  cd $(srcdir) && $(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot; \
-	else \
-	  $(MAKE) $${lang}.po-create; \
-	fi
-
-
-install: install-exec install-data
-install-exec:
-install-data: install-data- at USE_NLS@
-	if test "$(PACKAGE)" = "gettext-tools"; then \
-	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
-	  for file in $(DISTFILES.common) Makevars.template; do \
-	    $(INSTALL_DATA) $(srcdir)/$$file \
-			    $(DESTDIR)$(gettextsrcdir)/$$file; \
-	  done; \
-	  for file in Makevars; do \
-	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
-	  done; \
-	else \
-	  : ; \
-	fi
-install-data-no: all
-install-data-yes: all
-	$(mkinstalldirs) $(DESTDIR)$(datadir)
-	@catalogs='$(CATALOGS)'; \
-	for cat in $$catalogs; do \
-	  cat=`basename $$cat`; \
-	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
-	  dir=$(localedir)/$$lang/LC_MESSAGES; \
-	  $(mkinstalldirs) $(DESTDIR)$$dir; \
-	  if test -r $$cat; then realcat=$$cat; else realcat=$(srcdir)/$$cat; fi; \
-	  $(INSTALL_DATA) $$realcat $(DESTDIR)$$dir/$(DOMAIN).mo; \
-	  echo "installing $$realcat as $(DESTDIR)$$dir/$(DOMAIN).mo"; \
-	  for lc in '' $(EXTRA_LOCALE_CATEGORIES); do \
-	    if test -n "$$lc"; then \
-	      if (cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc 2>/dev/null) | grep ' -> ' >/dev/null; then \
-	        link=`cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc | sed -e 's/^.* -> //'`; \
-	        mv $(DESTDIR)$(localedir)/$$lang/$$lc $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
-	        mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	        (cd $(DESTDIR)$(localedir)/$$lang/$$lc.old && \
-	         for file in *; do \
-	           if test -f $$file; then \
-	             ln -s ../$$link/$$file $(DESTDIR)$(localedir)/$$lang/$$lc/$$file; \
-	           fi; \
-	         done); \
-	        rm -f $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
-	      else \
-	        if test -d $(DESTDIR)$(localedir)/$$lang/$$lc; then \
-	          :; \
-	        else \
-	          rm -f $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	          mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	        fi; \
-	      fi; \
-	      rm -f $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
-	      ln -s ../LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo 2>/dev/null || \
-	      ln $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo 2>/dev/null || \
-	      cp -p $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
-	      echo "installing $$realcat link as $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo"; \
-	    fi; \
-	  done; \
-	done
-
-install-strip: install
-
-installdirs: installdirs-exec installdirs-data
-installdirs-exec:
-installdirs-data: installdirs-data- at USE_NLS@
-	if test "$(PACKAGE)" = "gettext-tools"; then \
-	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
-	else \
-	  : ; \
-	fi
-installdirs-data-no:
-installdirs-data-yes:
-	$(mkinstalldirs) $(DESTDIR)$(datadir)
-	@catalogs='$(CATALOGS)'; \
-	for cat in $$catalogs; do \
-	  cat=`basename $$cat`; \
-	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
-	  dir=$(localedir)/$$lang/LC_MESSAGES; \
-	  $(mkinstalldirs) $(DESTDIR)$$dir; \
-	  for lc in '' $(EXTRA_LOCALE_CATEGORIES); do \
-	    if test -n "$$lc"; then \
-	      if (cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc 2>/dev/null) | grep ' -> ' >/dev/null; then \
-	        link=`cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc | sed -e 's/^.* -> //'`; \
-	        mv $(DESTDIR)$(localedir)/$$lang/$$lc $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
-	        mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	        (cd $(DESTDIR)$(localedir)/$$lang/$$lc.old && \
-	         for file in *; do \
-	           if test -f $$file; then \
-	             ln -s ../$$link/$$file $(DESTDIR)$(localedir)/$$lang/$$lc/$$file; \
-	           fi; \
-	         done); \
-	        rm -f $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
-	      else \
-	        if test -d $(DESTDIR)$(localedir)/$$lang/$$lc; then \
-	          :; \
-	        else \
-	          rm -f $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	          mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
-	        fi; \
-	      fi; \
-	    fi; \
-	  done; \
-	done
-
-# Define this as empty until I found a useful application.
-installcheck:
-
-uninstall: uninstall-exec uninstall-data
-uninstall-exec:
-uninstall-data: uninstall-data- at USE_NLS@
-	if test "$(PACKAGE)" = "gettext-tools"; then \
-	  for file in $(DISTFILES.common) Makevars.template; do \
-	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
-	  done; \
-	else \
-	  : ; \
-	fi
-uninstall-data-no:
-uninstall-data-yes:
-	catalogs='$(CATALOGS)'; \
-	for cat in $$catalogs; do \
-	  cat=`basename $$cat`; \
-	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
-	  for lc in LC_MESSAGES $(EXTRA_LOCALE_CATEGORIES); do \
-	    rm -f $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
-	  done; \
-	done
-
-check: all
-
-info dvi ps pdf html tags TAGS ctags CTAGS ID:
-
-mostlyclean:
-	rm -f remove-potcdate.sed
-	rm -f stamp-poT
-	rm -f core core.* $(DOMAIN).po $(DOMAIN).1po $(DOMAIN).2po *.new.po
-	rm -fr *.o
-
-clean: mostlyclean
-
-distclean: clean
-	rm -f Makefile Makefile.in POTFILES *.mo
-
-maintainer-clean: distclean
-	@echo "This command is intended for maintainers to use;"
-	@echo "it deletes files that may require special tools to rebuild."
-	rm -f stamp-po $(GMOFILES)
-
-distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
-dist distdir:
-	$(MAKE) update-po
-	@$(MAKE) dist2
-# This is a separate target because 'update-po' must be executed before.
-dist2: stamp-po $(DISTFILES)
-	dists="$(DISTFILES)"; \
-	if test "$(PACKAGE)" = "gettext-tools"; then \
-	  dists="$$dists Makevars.template"; \
-	fi; \
-	if test -f $(srcdir)/$(DOMAIN).pot; then \
-	  dists="$$dists $(DOMAIN).pot stamp-po"; \
-	fi; \
-	if test -f $(srcdir)/ChangeLog; then \
-	  dists="$$dists ChangeLog"; \
-	fi; \
-	for i in 0 1 2 3 4 5 6 7 8 9; do \
-	  if test -f $(srcdir)/ChangeLog.$$i; then \
-	    dists="$$dists ChangeLog.$$i"; \
-	  fi; \
-	done; \
-	if test -f $(srcdir)/LINGUAS; then dists="$$dists LINGUAS"; fi; \
-	for file in $$dists; do \
-	  if test -f $$file; then \
-	    cp -p $$file $(distdir) || exit 1; \
-	  else \
-	    cp -p $(srcdir)/$$file $(distdir) || exit 1; \
-	  fi; \
-	done
-
-update-po: Makefile
-	$(MAKE) $(DOMAIN).pot-update
-	test -z "$(UPDATEPOFILES)" || $(MAKE) $(UPDATEPOFILES)
-	$(MAKE) update-gmo
-
-# General rule for creating PO files.
-
-.nop.po-create:
-	@lang=`echo $@ | sed -e 's/\.po-create$$//'`; \
-	echo "File $$lang.po does not exist. If you are a translator, you can create it through 'msginit'." 1>&2; \
-	exit 1
-
-# General rule for updating PO files.
-
-.nop.po-update:
-	@lang=`echo $@ | sed -e 's/\.po-update$$//'`; \
-	if test "$(PACKAGE)" = "gettext-tools"; then PATH=`pwd`/../src:$$PATH; fi; \
-	tmpdir=`pwd`; \
-	echo "$$lang:"; \
-	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
-	echo "$${cdcmd}$(MSGMERGE) $$lang.po $(DOMAIN).pot -o $$lang.new.po"; \
-	cd $(srcdir); \
-	if $(MSGMERGE) $$lang.po $(DOMAIN).pot -o $$tmpdir/$$lang.new.po; then \
-	  if cmp $$lang.po $$tmpdir/$$lang.new.po >/dev/null 2>&1; then \
-	    rm -f $$tmpdir/$$lang.new.po; \
-	  else \
-	    if mv -f $$tmpdir/$$lang.new.po $$lang.po; then \
-	      :; \
-	    else \
-	      echo "msgmerge for $$lang.po failed: cannot move $$tmpdir/$$lang.new.po to $$lang.po" 1>&2; \
-	      exit 1; \
-	    fi; \
-	  fi; \
-	else \
-	  echo "msgmerge for $$lang.po failed!" 1>&2; \
-	  rm -f $$tmpdir/$$lang.new.po; \
-	fi
-
-$(DUMMYPOFILES):
-
-update-gmo: Makefile $(GMOFILES)
-	@:
-
-Makefile: Makefile.in.in Makevars $(top_builddir)/config.status @POMAKEFILEDEPS@
-	cd $(top_builddir) \
-	  && CONFIG_FILES=$(subdir)/$@.in CONFIG_HEADERS= \
-	       $(SHELL) ./config.status
-
-force:
-
-# Tell versions [3.59,3.63) of GNU make not to export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: trunk/po/Makevars
===================================================================
--- trunk/po/Makevars	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/Makevars	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,41 +0,0 @@
-# Makefile variables for PO directory in any package using GNU gettext.
-
-# Usually the message domain is the same as the package name.
-DOMAIN = $(PACKAGE)
-
-# These two variables depend on the location of this directory.
-subdir = po
-top_builddir = ..
-
-# These options get passed to xgettext.
-XGETTEXT_OPTIONS = --keyword=_ --keyword=N_
-
-# This is the copyright holder that gets inserted into the header of the
-# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
-# package.  (Note that the msgstr strings, extracted from the package's
-# sources, belong to the copyright holder of the package.)  Translators are
-# expected to transfer the copyright for their translations to this person
-# or entity, or to disclaim their copyright.  The empty string stands for
-# the public domain; in this case the translators are expected to disclaim
-# their copyright.
-COPYRIGHT_HOLDER = Free Software Foundation, Inc.
-
-# This is the email address or URL to which the translators shall report
-# bugs in the untranslated strings:
-# - Strings which are not entire sentences, see the maintainer guidelines
-#   in the GNU gettext documentation, section 'Preparing Strings'.
-# - Strings which use unclear terms or require additional context to be
-#   understood.
-# - Strings which make invalid assumptions about notation of date, time or
-#   money.
-# - Pluralisation problems.
-# - Incorrect English spelling.
-# - Incorrect formatting.
-# It can be your email address, or a mailing list address where translators
-# can write to without being subscribed, or the URL of a web page through
-# which the translators can contact you.
-MSGID_BUGS_ADDRESS =
-
-# This is the list of locale categories, beyond LC_MESSAGES, for which the
-# message catalogs shall be used.  It is usually empty.
-EXTRA_LOCALE_CATEGORIES =

Deleted: trunk/po/Makevars.template
===================================================================
--- trunk/po/Makevars.template	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/Makevars.template	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,41 +0,0 @@
-# Makefile variables for PO directory in any package using GNU gettext.
-
-# Usually the message domain is the same as the package name.
-DOMAIN = $(PACKAGE)
-
-# These two variables depend on the location of this directory.
-subdir = po
-top_builddir = ..
-
-# These options get passed to xgettext.
-XGETTEXT_OPTIONS = --keyword=_ --keyword=N_
-
-# This is the copyright holder that gets inserted into the header of the
-# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
-# package.  (Note that the msgstr strings, extracted from the package's
-# sources, belong to the copyright holder of the package.)  Translators are
-# expected to transfer the copyright for their translations to this person
-# or entity, or to disclaim their copyright.  The empty string stands for
-# the public domain; in this case the translators are expected to disclaim
-# their copyright.
-COPYRIGHT_HOLDER = Free Software Foundation, Inc.
-
-# This is the email address or URL to which the translators shall report
-# bugs in the untranslated strings:
-# - Strings which are not entire sentences, see the maintainer guidelines
-#   in the GNU gettext documentation, section 'Preparing Strings'.
-# - Strings which use unclear terms or require additional context to be
-#   understood.
-# - Strings which make invalid assumptions about notation of date, time or
-#   money.
-# - Pluralisation problems.
-# - Incorrect English spelling.
-# - Incorrect formatting.
-# It can be your email address, or a mailing list address where translators
-# can write to without being subscribed, or the URL of a web page through
-# which the translators can contact you.
-MSGID_BUGS_ADDRESS =
-
-# This is the list of locale categories, beyond LC_MESSAGES, for which the
-# message catalogs shall be used.  It is usually empty.
-EXTRA_LOCALE_CATEGORIES =

Deleted: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/POTFILES.in	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,2 +0,0 @@
-# List of source files which contain translatable strings.
-src/sst.py

Deleted: trunk/po/Rules-quot
===================================================================
--- trunk/po/Rules-quot	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/Rules-quot	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,47 +0,0 @@
-# Special Makefile rules for English message catalogs with quotation marks.
-
-DISTFILES.common.extra1 = quot.sed boldquot.sed en at quot.header en at boldquot.header insert-header.sin Rules-quot
-
-.SUFFIXES: .insert-header .po-update-en
-
-en at quot.po-create:
-	$(MAKE) en at quot.po-update
-en at boldquot.po-create:
-	$(MAKE) en at boldquot.po-update
-
-en at quot.po-update: en at quot.po-update-en
-en at boldquot.po-update: en at boldquot.po-update-en
-
-.insert-header.po-update-en:
-	@lang=`echo $@ | sed -e 's/\.po-update-en$$//'`; \
-	if test "$(PACKAGE)" = "gettext"; then PATH=`pwd`/../src:$$PATH; GETTEXTLIBDIR=`cd $(top_srcdir)/src && pwd`; export GETTEXTLIBDIR; fi; \
-	tmpdir=`pwd`; \
-	echo "$$lang:"; \
-	ll=`echo $$lang | sed -e 's/@.*//'`; \
-	LC_ALL=C; export LC_ALL; \
-	cd $(srcdir); \
-	if $(MSGINIT) -i $(DOMAIN).pot --no-translator -l $$ll -o - 2>/dev/null | sed -f $$tmpdir/$$lang.insert-header | $(MSGCONV) -t UTF-8 | $(MSGFILTER) sed -f `echo $$lang | sed -e 's/.*@//'`.sed 2>/dev/null > $$tmpdir/$$lang.new.po; then \
-	  if cmp $$lang.po $$tmpdir/$$lang.new.po >/dev/null 2>&1; then \
-	    rm -f $$tmpdir/$$lang.new.po; \
-	  else \
-	    if mv -f $$tmpdir/$$lang.new.po $$lang.po; then \
-	      :; \
-	    else \
-	      echo "creation of $$lang.po failed: cannot move $$tmpdir/$$lang.new.po to $$lang.po" 1>&2; \
-	      exit 1; \
-	    fi; \
-	  fi; \
-	else \
-	  echo "creation of $$lang.po failed!" 1>&2; \
-	  rm -f $$tmpdir/$$lang.new.po; \
-	fi
-
-en at quot.insert-header: insert-header.sin
-	sed -e '/^#/d' -e 's/HEADER/en at quot.header/g' $(srcdir)/insert-header.sin > en at quot.insert-header
-
-en at boldquot.insert-header: insert-header.sin
-	sed -e '/^#/d' -e 's/HEADER/en at boldquot.header/g' $(srcdir)/insert-header.sin > en at boldquot.insert-header
-
-mostlyclean: mostlyclean-quot
-mostlyclean-quot:
-	rm -f *.insert-header

Deleted: trunk/po/boldquot.sed
===================================================================
--- trunk/po/boldquot.sed	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/boldquot.sed	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,10 +0,0 @@
-s/"\([^"]*\)"/???\1???/g
-s/`\([^`']*\)'/???\1???/g
-s/ '\([^`']*\)' / ???\1??? /g
-s/ '\([^`']*\)'$/ ???\1???/g
-s/^'\([^`']*\)' /???\1??? /g
-s/??????/""/g
-s/???/???[1m/g
-s/???/[0m???/g
-s/???/???[1m/g
-s/???/[0m???/g

Deleted: trunk/po/en at boldquot.header
===================================================================
--- trunk/po/en at boldquot.header	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/en at boldquot.header	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,25 +0,0 @@
-# All this catalog "translates" are quotation characters.
-# The msgids must be ASCII and therefore cannot contain real quotation
-# characters, only substitutes like grave accent (0x60), apostrophe (0x27)
-# and double quote (0x22). These substitutes look strange; see
-# http://www.cl.cam.ac.uk/~mgk25/ucs/quotes.html
-#
-# This catalog translates grave accent (0x60) and apostrophe (0x27) to
-# left single quotation mark (U+2018) and right single quotation mark (U+2019).
-# It also translates pairs of apostrophe (0x27) to
-# left single quotation mark (U+2018) and right single quotation mark (U+2019)
-# and pairs of quotation mark (0x22) to
-# left double quotation mark (U+201C) and right double quotation mark (U+201D).
-#
-# When output to an UTF-8 terminal, the quotation characters appear perfectly.
-# When output to an ISO-8859-1 terminal, the single quotation marks are
-# transliterated to apostrophes (by iconv in glibc 2.2 or newer) or to
-# grave/acute accent (by libiconv), and the double quotation marks are
-# transliterated to 0x22.
-# When output to an ASCII terminal, the single quotation marks are
-# transliterated to apostrophes, and the double quotation marks are
-# transliterated to 0x22.
-#
-# This catalog furthermore displays the text between the quotation marks in
-# bold face, assuming the VT100/XTerm escape sequences.
-#

Deleted: trunk/po/en at quot.header
===================================================================
--- trunk/po/en at quot.header	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/en at quot.header	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,22 +0,0 @@
-# All this catalog "translates" are quotation characters.
-# The msgids must be ASCII and therefore cannot contain real quotation
-# characters, only substitutes like grave accent (0x60), apostrophe (0x27)
-# and double quote (0x22). These substitutes look strange; see
-# http://www.cl.cam.ac.uk/~mgk25/ucs/quotes.html
-#
-# This catalog translates grave accent (0x60) and apostrophe (0x27) to
-# left single quotation mark (U+2018) and right single quotation mark (U+2019).
-# It also translates pairs of apostrophe (0x27) to
-# left single quotation mark (U+2018) and right single quotation mark (U+2019)
-# and pairs of quotation mark (0x22) to
-# left double quotation mark (U+201C) and right double quotation mark (U+201D).
-#
-# When output to an UTF-8 terminal, the quotation characters appear perfectly.
-# When output to an ISO-8859-1 terminal, the single quotation marks are
-# transliterated to apostrophes (by iconv in glibc 2.2 or newer) or to
-# grave/acute accent (by libiconv), and the double quotation marks are
-# transliterated to 0x22.
-# When output to an ASCII terminal, the single quotation marks are
-# transliterated to apostrophes, and the double quotation marks are
-# transliterated to 0x22.
-#

Deleted: trunk/po/insert-header.sin
===================================================================
--- trunk/po/insert-header.sin	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/insert-header.sin	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,23 +0,0 @@
-# Sed script that inserts the file called HEADER before the header entry.
-#
-# At each occurrence of a line starting with "msgid ", we execute the following
-# commands. At the first occurrence, insert the file. At the following
-# occurrences, do nothing. The distinction between the first and the following
-# occurrences is achieved by looking at the hold space.
-/^msgid /{
-x
-# Test if the hold space is empty.
-s/m/m/
-ta
-# Yes it was empty. First occurrence. Read the file.
-r HEADER
-# Output the file's contents by reading the next line. But don't lose the
-# current line while doing this.
-g
-N
-bb
-:a
-# The hold space was nonempty. Following occurrences. Do nothing.
-x
-:b
-}

Added: trunk/po/msgfmt.py
===================================================================
--- trunk/po/msgfmt.py	                        (rev 0)
+++ trunk/po/msgfmt.py	2010-11-30 17:57:50 UTC (rev 822)
@@ -0,0 +1,203 @@
+#! /usr/bin/env python
+# -*- coding: iso-8859-1 -*-
+# Written by Martin v. L?wis <loewis at informatik.hu-berlin.de>
+
+"""Generate binary message catalog from textual translation description.
+
+This program converts a textual Uniforum-style message catalog (.po file) into
+a binary GNU catalog (.mo file).  This is essentially the same function as the
+GNU msgfmt program, however, it is a simpler implementation.
+
+Usage: msgfmt.py [OPTIONS] filename.po
+
+Options:
+    -o file
+    --output-file=file
+        Specify the output file to write to.  If omitted, output will go to a
+        file named filename.mo (based off the input file name).
+
+    -h
+    --help
+        Print this message and exit.
+
+    -V
+    --version
+        Display version information and exit.
+"""
+
+import sys
+import os
+import getopt
+import struct
+import array
+
+__version__ = "1.1"
+
+MESSAGES = {}
+
+
+
+def usage(code, msg=''):
+    print >> sys.stderr, __doc__
+    if msg:
+        print >> sys.stderr, msg
+    sys.exit(code)
+
+
+
+def add(id, str, fuzzy):
+    "Add a non-fuzzy translation to the dictionary."
+    global MESSAGES
+    if not fuzzy and str:
+        MESSAGES[id] = str
+
+
+
+def generate():
+    "Return the generated output."
+    global MESSAGES
+    keys = MESSAGES.keys()
+    # the keys are sorted in the .mo file
+    keys.sort()
+    offsets = []
+    ids = strs = ''
+    for id in keys:
+        # For each string, we need size and file offset.  Each string is NUL
+        # terminated; the NUL does not count into the size.
+        offsets.append((len(ids), len(id), len(strs), len(MESSAGES[id])))
+        ids += id + '\0'
+        strs += MESSAGES[id] + '\0'
+    output = ''
+    # The header is 7 32-bit unsigned integers.  We don't use hash tables, so
+    # the keys start right after the index tables.
+    # translated string.
+    keystart = 7*4+16*len(keys)
+    # and the values start after the keys
+    valuestart = keystart + len(ids)
+    koffsets = []
+    voffsets = []
+    # The string table first has the list of keys, then the list of values.
+    # Each entry has first the size of the string, then the file offset.
+    for o1, l1, o2, l2 in offsets:
+        koffsets += [l1, o1+keystart]
+        voffsets += [l2, o2+valuestart]
+    offsets = koffsets + voffsets
+    output = struct.pack("Iiiiiii",
+                         0x950412deL,       # Magic
+                         0,                 # Version
+                         len(keys),         # # of entries
+                         7*4,               # start of key index
+                         7*4+len(keys)*8,   # start of value index
+                         0, 0)              # size and offset of hash table
+    output += array.array("i", offsets).tostring()
+    output += ids
+    output += strs
+    return output
+
+
+
+def make(filename, outfile):
+    ID = 1
+    STR = 2
+
+    # Compute .mo name from .po name and arguments
+    if filename.endswith('.po'):
+        infile = filename
+    else:
+        infile = filename + '.po'
+    if outfile is None:
+        outfile = os.path.splitext(infile)[0] + '.mo'
+
+    try:
+        lines = open(infile).readlines()
+    except IOError, msg:
+        print >> sys.stderr, msg
+        sys.exit(1)
+
+    section = None
+    fuzzy = 0
+
+    # Parse the catalog
+    lno = 0
+    for l in lines:
+        lno += 1
+        # If we get a comment line after a msgstr, this is a new entry
+        if l[0] == '#' and section == STR:
+            add(msgid, msgstr, fuzzy)
+            section = None
+            fuzzy = 0
+        # Record a fuzzy mark
+        if l[:2] == '#,' and 'fuzzy' in l:
+            fuzzy = 1
+        # Skip comments
+        if l[0] == '#':
+            continue
+        # Now we are in a msgid section, output previous section
+        if l.startswith('msgid'):
+            if section == STR:
+                add(msgid, msgstr, fuzzy)
+            section = ID
+            l = l[5:]
+            msgid = msgstr = ''
+        # Now we are in a msgstr section
+        elif l.startswith('msgstr'):
+            section = STR
+            l = l[6:]
+        # Skip empty lines
+        l = l.strip()
+        if not l:
+            continue
+        # XXX: Does this always follow Python escape semantics?
+        l = eval(l)
+        if section == ID:
+            msgid += l
+        elif section == STR:
+            msgstr += l
+        else:
+            print >> sys.stderr, 'Syntax error on %s:%d' % (infile, lno), \
+                  'before:'
+            print >> sys.stderr, l
+            sys.exit(1)
+    # Add last entry
+    if section == STR:
+        add(msgid, msgstr, fuzzy)
+
+    # Compute output
+    output = generate()
+
+    try:
+        open(outfile,"wb").write(output)
+    except IOError,msg:
+        print >> sys.stderr, msg
+
+
+
+def main():
+    try:
+        opts, args = getopt.getopt(sys.argv[1:], 'hVo:',
+                                   ['help', 'version', 'output-file='])
+    except getopt.error, msg:
+        usage(1, msg)
+
+    outfile = None
+    # parse options
+    for opt, arg in opts:
+        if opt in ('-h', '--help'):
+            usage(0)
+        elif opt in ('-V', '--version'):
+            print >> sys.stderr, "msgfmt.py", __version__
+            sys.exit(0)
+        elif opt in ('-o', '--output-file'):
+            outfile = arg
+    # do it
+    if not args:
+        print >> sys.stderr, 'No input file given'
+        print >> sys.stderr, "Try `msgfmt --help' for more information."
+        return
+
+    for filename in args:
+        make(filename, outfile)
+
+
+if __name__ == '__main__':
+    main()


Property changes on: trunk/po/msgfmt.py
___________________________________________________________________
Added: svn:executable
   + *

Deleted: trunk/po/quot.sed
===================================================================
--- trunk/po/quot.sed	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/quot.sed	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,6 +0,0 @@
-s/"\([^"]*\)"/???\1???/g
-s/`\([^`']*\)'/???\1???/g
-s/ '\([^`']*\)' / ???\1??? /g
-s/ '\([^`']*\)'$/ ???\1???/g
-s/^'\([^`']*\)' /???\1??? /g
-s/??????/""/g

Deleted: trunk/po/remove-potcdate.sin
===================================================================
--- trunk/po/remove-potcdate.sin	2010-11-30 10:31:51 UTC (rev 821)
+++ trunk/po/remove-potcdate.sin	2010-11-30 17:57:50 UTC (rev 822)
@@ -1,19 +0,0 @@
-# Sed script that remove the POT-Creation-Date line in the header entry
-# from a POT file.
-#
-# The distinction between the first and the following occurrences of the
-# pattern is achieved by looking at the hold space.
-/^"POT-Creation-Date: .*"$/{
-x
-# Test if the hold space is empty.
-s/P/P/
-ta
-# Yes it was empty. First occurrence. Remove the line.
-g
-d
-bb
-:a
-# The hold space was nonempty. Following occurrences. Do nothing.
-x
-:b
-}



From esr at mail.berlios.de  Tue Nov 30 19:00:33 2010
From: esr at mail.berlios.de (esr at mail.berlios.de)
Date: Tue, 30 Nov 2010 19:00:33 +0100
Subject: [Sst-commit-watch] r823 - trunk/po
Message-ID: <20101130180033.9A058480196@sheep.berlios.de>

Author: esr
Date: 2010-11-30 19:00:33 +0100 (Tue, 30 Nov 2010)
New Revision: 823

Modified:
   trunk/po/Makefile
Log:
Typo fix.


Modified: trunk/po/Makefile
===================================================================
--- trunk/po/Makefile	2010-11-30 17:57:50 UTC (rev 822)
+++ trunk/po/Makefile	2010-11-30 18:00:33 UTC (rev 823)
@@ -1,4 +1,4 @@
-# Note: msgfmt.py is copiere from the Python source distribution
+# Note: msgfmt.py is copied from the Python source distributionls
 
 .SUFFIXES: .po .mo
 



