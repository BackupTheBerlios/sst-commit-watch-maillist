<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Sst-commit-watch] r541 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/sst-commit-watch/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r541%20-%20trunk&In-Reply-To=%3C200609131720.k8DHKXsx011929%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000007.html">
   <LINK REL="Next"  HREF="000008.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Sst-commit-watch] r541 - trunk</H1>
    <B>stsp at BerliOS</B> 
    <A HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r541%20-%20trunk&In-Reply-To=%3C200609131720.k8DHKXsx011929%40sheep.berlios.de%3E"
       TITLE="[Sst-commit-watch] r541 - trunk">stsp at mail.berlios.de
       </A><BR>
    <I>Wed Sep 13 19:20:33 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000007.html">[Sst-commit-watch] r540 - trunk
</A></li>
        <LI>Next message: <A HREF="000008.html">[Sst-commit-watch] r542 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stsp
Date: 2006-09-13 19:20:32 +0200 (Wed, 13 Sep 2006)
New Revision: 541

Added:
   trunk/ABOUT-NLS
   trunk/AUTHORS
   trunk/COPYING
   trunk/ChangeLog
   trunk/ChangeLog.old
   trunk/INSTALL
   trunk/Makefile.am
   trunk/Makefile.in
   trunk/NEWS
   trunk/aclocal.m4
   trunk/autogen.sh
   trunk/compile
   trunk/config.guess
   trunk/config.rpath
   trunk/config.sub
   trunk/configure
   trunk/configure.ac
   trunk/depcomp
   trunk/doc/
   trunk/install-sh
   trunk/m4/
   trunk/missing
   trunk/mkinstalldirs
   trunk/po/
   trunk/src/
Removed:
   trunk/Makefile
   trunk/ai.c
   trunk/battle.c
   trunk/events.c
   trunk/finish.c
   trunk/io.c
   trunk/makehelp.py
   trunk/moving.c
   trunk/planets.c
   trunk/reports.c
   trunk/setup.c
   trunk/sst-doc.xml
   trunk/sst-layer.xsl
   trunk/sst.c
   trunk/sst.h
   trunk/sst.xml
   trunk/sstlinux.c
   trunk/sstlinux.h
Modified:
   trunk/README
   trunk/TODO
Log:
merge the autotools branch

Copied: trunk/ABOUT-NLS (from rev 538, branches/at-work/ABOUT-NLS)

Copied: trunk/AUTHORS (from rev 538, branches/at-work/AUTHORS)

Copied: trunk/COPYING (from rev 538, branches/at-work/COPYING)

Copied: trunk/ChangeLog (from rev 538, branches/at-work/ChangeLog)

Copied: trunk/ChangeLog.old (from rev 538, branches/at-work/ChangeLog.old)

Copied: trunk/INSTALL (from rev 538, branches/at-work/INSTALL)

Deleted: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/Makefile	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,81 +0,0 @@
-#	Makefile for the Super Star Trek game
-
-VERSION=$(shell sed &lt;sst.spec -n -e '/Version: \(.*\)/s//\1/p')
-
-CFLAGS= -O1 -g -Wall -DSSTDOC='&quot;/usr/share/doc/sst/sst.doc&quot;'
-
-.c.o:
-	$(CC) $(CFLAGS) -c $&lt;
-
-CFILES= sst.c finish.c reports.c setup.c moving.c battle.c events.c ai.c planets.c io.c sstlinux.c
-OFILES= $(CFILES:.c=.o)
-HFILES=sst.h
-DOCS = README sst-doc.xml sst.xml sst-layer.xsl TODO
-
-# sst.doc and sst.6 are included so target system won't need xmlto
-SOURCES= $(CFILES) $(HFILES) $(DOCS) sst.doc sst.6 makehelp.py makefile sst.spec
-
-all: sst sst.doc
-
-ai.o: ai.c sst.h
-battle.o: battle.c sst.h
-events.o: events.c sst.h
-finish.o: finish.c sst.h
-io.o: io.c sst.h
-moving.o: moving.c sstlinux.h sst.h
-planets.o: planets.c sst.h
-reports.o: reports.c sst.h
-setup.o: setup.c sst.h
-sst.o: sst.c sstlinux.h sst.h
-sstlinux.o: sstlinux.c sstlinux.h
-
-sst:  $(OFILES)
-	gcc  -o sst $(OFILES) -lm -lcurses
-
-$(OFILES):  $(HFILES)
-
-sst.6: sst.xml
-	xmlto man sst.xml
-
-sst-doc.txt: sst-doc.xml
-	xmlto -m sst-layer.xsl txt sst-doc.xml
-sst.doc: sst-doc.txt
-	makehelp.py &gt;sst.doc
-
-sst-doc.html: sst-doc.xml
-	xmlto xhtml-nochunks sst-doc.xml
-
-install: uninstall sst.6 sst.doc sst-doc.html 
-	install -m 755 -o 0 -g 0 -d $(ROOT)/usr/bin/
-	install -m 755 -o 0 -g 0 sst $(ROOT)/usr/bin/sst
-	install -m 755 -o 0 -g 0 -d $(ROOT)/usr/share/man/man6/
-	install -m 755 -o 0 -g 0 sst.6 $(ROOT)/usr/share/man/man6/sst.6
-	mkdir -p /usr/share/doc/sst/
-	install -m 644 -o 0 -g 0 sst.doc $(ROOT)/usr/share/doc/sst/
-	install -m 644 -o 0 -g 0 sst-doc.html $(ROOT)/usr/share/doc/sst/index.html
-
-uninstall:
-	rm -f ${ROOT}/usr/bin/sst ${ROOT}/usr/share/man/man6/sst.6
-	rm -fr ${ROOT}/usr/share/doc/sst/
-
-clean:
-	rm -f *.o sst sst-doc.html sst-doc.txt sst.doc
-
-# The &quot;trunk&quot; below assumes this is a Subversion working copy
-sst-$(VERSION).tar.gz: $(SOURCES) sst.6
-	ls $(SOURCES) sst.6 | sed s:^:sst-$(VERSION)/: &gt;MANIFEST
-	(cd ..; ln -s trunk sst-$(VERSION))
-	(cd ..; tar -czvf trunk/sst-$(VERSION).tar.gz `cat trunk/MANIFEST`)
-	(cd ..; rm sst-$(VERSION))
-
-dist: sst-$(VERSION).tar.gz
-
-release: sst-$(VERSION).tar.gz sst.html
-	shipper; rm -f CHANGES ANNOUNCE* *.6 *.html *.rpm *.lsm MANIFEST
-
-version:
-	@echo $(VERSION)
-
-# Experimental XaW code, not yet integrated with the game
-xio: xio.c
-	cc xio.c -lXaw3d -o xio

Copied: trunk/Makefile.am (from rev 538, branches/at-work/Makefile.am)

Copied: trunk/Makefile.in (from rev 538, branches/at-work/Makefile.in)

Copied: trunk/NEWS (from rev 538, branches/at-work/NEWS)

Modified: trunk/README
===================================================================
--- trunk/README	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/README	2006-09-13 17:20:32 UTC (rev 541)
@@ -5,9 +5,6 @@
 This is the classic Super Star Trek game from the days of slow teletypes, 
 reloaded.
 
-There is one binary, sst.  
-On-line documentation goes to /usr/share/doc/sst.doc.
-
 If you enjoy this, check out other ancient games in the Retrocomputing Museum 
 at &lt;<A HREF="http://www.catb.org/retro/">http://www.catb.org/retro/</A>&gt;.
 

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/TODO	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,4 +1,21 @@
 		Super Star Trek TO-DO list
 
+
+Short-term items:
+
+* Bring the online help in sync with our commands changes
+
+* Find out why the online help contains the escape sequences like ~@~T (Eric?)
+
+* Adjust the sst.spec wrt the build system changes
+
+* Maybe make a release
+
+
+Long-term items:
+
+* gettextize
+
+* Russian translation
+
 * Wrap a GUI around it.
-

Copied: trunk/aclocal.m4 (from rev 538, branches/at-work/aclocal.m4)

Deleted: trunk/ai.c
===================================================================
--- trunk/ai.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/ai.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,615 +0,0 @@
-#include &quot;sst.h&quot;
-
-static int tryexit(int lookx, int looky, int ienm, int loccom, int irun) 
-{
-    int iqx, iqy, l;
-
-    iqx = quadx+(lookx+(QUADSIZE-1))/QUADSIZE - 1;
-    iqy = quady+(looky+(QUADSIZE-1))/QUADSIZE - 1;
-    if (!VALID_QUADRANT(iqx,iqy) ||
-	game.state.galaxy[iqx][iqy].supernova ||
-	game.state.galaxy[iqx][iqy].klingons &gt; 8)
-	return 0; /* no can do -- neg energy, supernovae, or &gt;8 Klingons */
-    if (ienm == IHR) return 0; /* Romulans cannot escape! */
-    if (irun == 0) {
-	/* avoid intruding on another commander's territory */
-	if (ienm == IHC) {
-	    for_commanders(l)
-		if (game.state.cx[l]==iqx &amp;&amp; game.state.cy[l]==iqy) return 0;
-	    /* refuse to leave if currently attacking starbase */
-	    if (batx==quadx &amp;&amp; baty==quady) return 0;
-	}
-	/* don't leave if over 1000 units of energy */
-	if (game.kpower[loccom] &gt; 1000.) return 0;
-    }
-    /* print escape message and move out of quadrant.
-       We know this if either short or long range sensors are working */
-    if (game.damage[DSRSENS] == 0.0 || game.damage[DLRSENS] == 0.0 ||
-	condit == IHDOCKED) {
-	crmena(1, ienm, 2, game.kx[loccom], game.ky[loccom]);
-	prout(&quot; escapes to %s (and regains strength).&quot;,
-	      cramlc(quadrant, iqx, iqy));
-    }
-    /* handle local matters related to escape */
-    game.quad[game.kx[loccom]][game.ky[loccom]] = IHDOT;
-    game.kx[loccom] = game.kx[nenhere];
-    game.ky[loccom] = game.ky[nenhere];
-    game.kavgd[loccom] = game.kavgd[nenhere];
-    game.kpower[loccom] = game.kpower[nenhere];
-    game.kdist[loccom] = game.kdist[nenhere];
-    klhere--;
-    nenhere--;
-    if (condit != IHDOCKED) newcnd();
-    /* Handle global matters related to escape */
-    game.state.galaxy[quadx][quady].klingons--;
-    game.state.galaxy[iqx][iqy].klingons++;
-    if (ienm==IHS) {
-	ishere=0;
-	iscate=0;
-	ientesc=0;
-	isatb=0;
-	game.future[FSCMOVE]=0.2777+game.state.date;
-	game.future[FSCDBAS]=FOREVER;
-	game.state.isx=iqx;
-	game.state.isy=iqy;
-    }
-    else {
-	for_commanders(l) {
-	    if (game.state.cx[l]==quadx &amp;&amp; game.state.cy[l]==quady) {
-		game.state.cx[l]=iqx;
-		game.state.cy[l]=iqy;
-		break;
-	    }
-	}
-	comhere = 0;
-    }
-    return 1; /* success */
-}
-
-
-static void movebaddy(int comx, int comy, int loccom, int ienm) 
-{
-    int motion, mdist, nsteps, mx, my, nextx, nexty, lookx, looky, ll;
-    int irun = 0;
-    int krawlx, krawly;
-    int success;
-    int attempts;
-    /* This should probably be just comhere + ishere */
-    int nbaddys = skill &gt;= SKILL_EXPERT ?
-	(int)((comhere*2 + ishere*2+klhere*1.23+irhere*1.5)/2.0):
-	(comhere + ishere);
-    double dist1, forces;
-
-    dist1 = game.kdist[loccom];
-    mdist = dist1 + 0.5; /* Nearest integer distance */
-
-    /* If SC, check with spy to see if should hi-tail it */
-    if (ienm==IHS &amp;&amp;
-	(game.kpower[loccom] &lt;= 500.0 || (condit==IHDOCKED &amp;&amp; game.damage[DPHOTON]==0))) {
-	irun = 1;
-	motion = -QUADSIZE;
-    }
-    else {
-	/* decide whether to advance, retreat, or hold position */
-/* Algorithm:
- * Enterprise has &quot;force&quot; based on condition of phaser and photon torpedoes.
- If both are operating full strength, force is 1000. If both are damaged,
- force is -1000. Having shields down subtracts an additional 1000.
-
- * Enemy has forces equal to the energy of the attacker plus
- 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
- 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
-
- Attacker Initial energy levels (nominal):
- Klingon   Romulan   Commander   Super-Commander
- Novice    400        700        1200        
- Fair      425        750        1250
- Good      450        800        1300        1750
- Expert    475        850        1350        1875
- Emeritus  500        900        1400        2000
- VARIANCE   75        200         200         200
-
- Enemy vessels only move prior to their attack. In Novice - Good games
- only commanders move. In Expert games, all enemy vessels move if there
- is a commander present. In Emeritus games all enemy vessels move.
-
- *  If Enterprise is not docked, an agressive action is taken if enemy
- forces are 1000 greater than Enterprise.
-
- Agressive action on average cuts the distance between the ship and
- the enemy to 1/4 the original.
-
- *  At lower energy advantage, movement units are proportional to the
- advantage with a 650 advantage being to hold ground, 800 to move forward
- 1, 950 for two, 150 for back 4, etc. Variance of 100.
-
- If docked, is reduced by roughly 1.75*skill, generally forcing a
- retreat, especially at high skill levels.
-
- *  Motion is limited to skill level, except for SC hi-tailing it out.
- */
-
-	forces = game.kpower[loccom]+100.0*nenhere+400*(nbaddys-1);
-	if (shldup==0) forces += 1000; /* Good for enemy if shield is down! */
-	if (game.damage[DPHASER] == 0.0 || game.damage[DPHOTON] == 0.0) {
-	    if (game.damage[DPHASER] != 0) /* phasers damaged */
-		forces += 300.0;
-	    else
-		forces -= 0.2*(energy - 2500.0);
-	    if (game.damage[DPHOTON] != 0) /* photon torpedoes damaged */
-		forces += 300.0;
-	    else
-		forces -= 50.0*torps;
-	}
-	else {
-	    /* phasers and photon tubes both out! */
-	    forces += 1000.0;
-	}
-	motion = 0;
-	if (forces &lt;= 1000.0 &amp;&amp; condit != IHDOCKED) /* Typical situation */
-	    motion = ((forces+200.0*Rand())/150.0) - 5.0;
-	else {
-	    if (forces &gt; 1000.0) /* Very strong -- move in for kill */
-		motion = (1.0-square(Rand()))*dist1 + 1.0;
-	    if (condit==IHDOCKED &amp;&amp; (game.options &amp; OPTION_BASE)) /* protected by base -- back off ! */
-		motion -= skill*(2.0-square(Rand()));
-	}
-#ifdef DEBUG
-	if (idebug) {
-	    proutn(&quot;MOTION = %1.2f&quot;, motion);
-	    proutn(&quot;  FORCES = %1,2f&quot;, forces);
-	}
-#endif
-	/* don't move if no motion */
-	if (motion==0) return;
-	/* Limit motion according to skill */
-	if (abs(motion) &gt; skill) motion = (motion &lt; 0) ? -skill : skill;
-    }
-    /* calculate preferred number of steps */
-    nsteps = motion &lt; 0 ? -motion : motion;
-    if (motion &gt; 0 &amp;&amp; nsteps &gt; mdist) nsteps = mdist; /* don't overshoot */
-    if (nsteps &gt; QUADSIZE) nsteps = QUADSIZE; /* This shouldn't be necessary */
-    if (nsteps &lt; 1) nsteps = 1; /* This shouldn't be necessary */
-#ifdef DEBUG
-    if (idebug) {
-	prout(&quot;NSTEPS = %d&quot;, nsteps);
-    }
-#endif
-    /* Compute preferred values of delta X and Y */
-    mx = sectx - comx;
-    my = secty - comy;
-    if (2.0 * abs(mx) &lt; abs(my)) mx = 0;
-    if (2.0 * abs(my) &lt; abs(sectx-comx)) my = 0;
-    if (mx != 0) mx = mx*motion &lt; 0 ? -1 : 1;
-    if (my != 0) my = my*motion &lt; 0 ? -1 : 1;
-    nextx = comx;
-    nexty = comy;
-    /* main move loop */
-    for (ll = 0; ll &lt; nsteps; ll++) {
-#ifdef DEBUG
-	if (idebug) {
-	    prout(&quot;%d&quot;, ll+1);
-	}
-#endif
-	/* Check if preferred position available */
-	lookx = nextx + mx;
-	looky = nexty + my;
-	krawlx = mx &lt; 0 ? 1 : -1;
-	krawly = my &lt; 0 ? 1 : -1;
-	success = 0;
-	attempts = 0; /* Settle mysterious hang problem */
-	while (attempts++ &lt; 20 &amp;&amp; !success) {
-	    if (lookx &lt; 1 || lookx &gt; QUADSIZE) {
-		if (motion &lt; 0 &amp;&amp; tryexit(lookx, looky, ienm, loccom, irun))
-		    return;
-		if (krawlx == mx || my == 0) break;
-		lookx = nextx + krawlx;
-		krawlx = -krawlx;
-	    }
-	    else if (looky &lt; 1 || looky &gt; QUADSIZE) {
-		if (motion &lt; 0 &amp;&amp; tryexit(lookx, looky, ienm, loccom, irun))
-		    return;
-		if (krawly == my || mx == 0) break;
-		looky = nexty + krawly;
-		krawly = -krawly;
-	    }
-	    else if ((game.options &amp; OPTION_RAMMING) &amp;&amp; game.quad[lookx][looky] != IHDOT) {
-		/* See if we should ram ship */
-		if (game.quad[lookx][looky] == ship &amp;&amp;
-		    (ienm == IHC || ienm == IHS)) {
-		    ram(1, ienm, comx, comy);
-		    return;
-		}
-		if (krawlx != mx &amp;&amp; my != 0) {
-		    lookx = nextx + krawlx;
-		    krawlx = -krawlx;
-		}
-		else if (krawly != my &amp;&amp; mx != 0) {
-		    looky = nexty + krawly;
-		    krawly = -krawly;
-		}
-		else break; /* we have failed */
-	    }
-	    else success = 1;
-	}
-	if (success) {
-	    nextx = lookx;
-	    nexty = looky;
-#ifdef DEBUG
-	    if (idebug) {
-		prout(cramlc(neither, nextx, nexty));
-	    }
-#endif
-	}
-	else break; /* done early */
-    }
-    /* Put commander in place within same quadrant */
-    game.quad[comx][comy] = IHDOT;
-    game.quad[nextx][nexty] = ienm;
-    if (nextx != comx || nexty != comy) {
-	/* it moved */
-	game.kx[loccom] = nextx;
-	game.ky[loccom] = nexty;
-	game.kdist[loccom] = game.kavgd[loccom] =
-	    sqrt(square(sectx-nextx)+square(secty-nexty));
-	if (game.damage[DSRSENS] == 0 || condit == IHDOCKED) {
-	    proutn(&quot;***&quot;);
-	    cramen(ienm);
-	    proutn(&quot; from %s&quot;, cramlc(2, comx, comy));
-	    if (game.kdist[loccom] &lt; dist1) proutn(&quot; advances to &quot;);
-	    else proutn(&quot; retreats to &quot;);
-	    prout(cramlc(sector, nextx, nexty));
-	}
-    }
-}
-
-void movcom(void) 
-{
-    int ix, iy, i;
-
-#ifdef DEBUG
-    if (idebug) prout(&quot;MOVCOM&quot;);
-#endif
-
-    /* Figure out which Klingon is the commander (or Supercommander)
-       and do move */
-    if (comhere) 
-	for_local_enemies(i) {
-	    ix = game.kx[i];
-	    iy = game.ky[i];
-	    if (game.quad[ix][iy] == IHC) {
-		movebaddy(ix, iy, i, IHC);
-		break;
-	    }
-	}
-    if (ishere) 
-	for_local_enemies(i) {
-	    ix = game.kx[i];
-	    iy = game.ky[i];
-	    if (game.quad[ix][iy] == IHS) {
-		movebaddy(ix, iy, i, IHS);
-		break;
-	    }
-	}
-    /* if skill level is high, move other Klingons and Romulans too!
-       Move these last so they can base their actions on what the
-       commander(s) do. */
-    if (skill &gt;= SKILL_EXPERT &amp;&amp; (game.options &amp; OPTION_MVBADDY)) 
-	for_local_enemies(i) {
-	    ix = game.kx[i];
-	    iy = game.ky[i];
-	    if (game.quad[ix][iy] == IHK || game.quad[ix][iy] == IHR)
-		movebaddy(ix, iy, i, game.quad[ix][iy]);
-	}
-
-    sortkl();
-}
-
-static int movescom(int iqx, int iqy, int flag, int *ipage) 
-{
-    int i;
-
-    if ((iqx==quadx &amp;&amp; iqy==quady) ||
-	!VALID_QUADRANT(iqx, iqy) ||
-	game.state.galaxy[iqx][iqy].supernova ||
-	game.state.galaxy[iqx][iqy].klingons &gt; 8) 
-	return 1;
-    if (flag) {
-	/* Avoid quadrants with bases if we want to avoid Enterprise */
-	for_starbases(i)
-	    if (game.state.baseqx[i]==iqx &amp;&amp; game.state.baseqy[i]==iqy) return 1;
-    }
-    if (justin &amp;&amp; !iscate) return 1;
-    /* do the move */
-    game.state.galaxy[game.state.isx][game.state.isy].klingons--;
-    game.state.isx = iqx;
-    game.state.isy = iqy;
-    game.state.galaxy[game.state.isx][game.state.isy].klingons++;
-    if (ishere) {
-	/* SC has scooted, Remove him from current quadrant */
-	iscate=0;
-	isatb=0;
-	ishere=0;
-	ientesc=0;
-	game.future[FSCDBAS]=FOREVER;
-	for_local_enemies(i) 
-	    if (game.quad[game.kx[i]][game.ky[i]] == IHS) break;
-	game.quad[game.kx[i]][game.ky[i]] = IHDOT;
-	game.kx[i] = game.kx[nenhere];
-	game.ky[i] = game.ky[nenhere];
-	game.kdist[i] = game.kdist[nenhere];
-	game.kavgd[i] = game.kavgd[nenhere];
-	game.kpower[i] = game.kpower[nenhere];
-	klhere--;
-	nenhere--;
-	if (condit!=IHDOCKED) newcnd();
-	sortkl();
-    }
-    /* check for a helpful planet */
-    for (i = 0; i &lt; inplan; i++) {
-	if (game.state.plnets[i].x==game.state.isx &amp;&amp; game.state.plnets[i].y==game.state.isy &amp;&amp;
-	    game.state.plnets[i].crystals == 1) {
-	    /* destroy the planet */
-	    DESTROY(&amp;game.state.plnets[i]);
-	    game.state.galaxy[game.state.isx][game.state.isy].planets -= 1;
-	    if (game.damage[DRADIO] == 0.0 || condit == IHDOCKED) {
-		if (*ipage==0) pause_game(1);
-		*ipage = 1;
-		prout(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;);
-		proutn(&quot;   a planet in &quot;);
-		proutn(cramlc(quadrant, game.state.isx, game.state.isy));
-		prout(&quot; has been destroyed&quot;);
-		prout(&quot;   by the Super-commander.\&quot;&quot;);
-	    }
-	    break;
-	}
-    }
-    return 0; /* looks good! */
-}
-			
-void scom(int *ipage)
-{
-    int i, i2, j, ideltax, ideltay, ibqx, ibqy, sx, sy, ifindit, iwhichb;
-    int iqx, iqy;
-    int basetbl[BASEMAX+1];
-    double bdist[BASEMAX+1];
-    int flag;
-#ifdef DEBUG
-    if (idebug) prout(&quot;SCOM&quot;);
-#endif
-
-    /* Decide on being active or passive */
-    flag = ((NKILLC+NKILLK)/(game.state.date+0.01-indate) &lt; 0.1*skill*(skill+1.0) ||
-	    (game.state.date-indate) &lt; 3.0);
-    if (iscate==0 &amp;&amp; flag) {
-	/* compute move away from Enterprise */
-	ideltax = game.state.isx-quadx;
-	ideltay = game.state.isy-quady;
-	if (sqrt(ideltax*(double)ideltax+ideltay*(double)ideltay) &gt; 2.0) {
-	    /* circulate in space */
-	    ideltax = game.state.isy-quady;
-	    ideltay = quadx-game.state.isx;
-	}
-    }
-    else {
-	/* compute distances to starbases */
-	if (game.state.rembase &lt;= 0) {
-	    /* nothing left to do */
-	    game.future[FSCMOVE] = FOREVER;
-	    return;
-	}
-	sx = game.state.isx;
-	sy = game.state.isy;
-	for_starbases(i) {
-	    basetbl[i] = i;
-	    ibqx = game.state.baseqx[i];
-	    ibqy = game.state.baseqy[i];
-	    bdist[i] = sqrt(square(ibqx-sx) + square(ibqy-sy));
-	}
-	if (game.state.rembase &gt; 1) {
-	    /* sort into nearest first order */
-	    int iswitch;
-	    do {
-		iswitch = 0;
-		for (i=1; i &lt; game.state.rembase-1; i++) {
-		    if (bdist[i] &gt; bdist[i+1]) {
-			int ti = basetbl[i];
-			double t = bdist[i];
-			bdist[i] = bdist[i+1];
-			bdist[i+1] = t;
-			basetbl[i] = basetbl[i+1];
-			basetbl[i+1] =ti;
-			iswitch = 1;
-		    }
-		}
-	    } while (iswitch);
-	}
-	/* look for nearest base without a commander, no Enterprise, and
-	   without too many Klingons, and not already under attack. */
-	ifindit = iwhichb = 0;
-
-	for_starbases(i2) {
-	    i = basetbl[i2];	/* bug in original had it not finding nearest*/
-	    ibqx = game.state.baseqx[i];
-	    ibqy = game.state.baseqy[i];
-	    if ((ibqx == quadx &amp;&amp; ibqy == quady) ||
-		(ibqx == batx &amp;&amp; ibqy == baty) ||
-		game.state.galaxy[ibqx][ibqy].supernova ||
-		game.state.galaxy[ibqx][ibqy].klingons &gt; 8) 
-		continue;
-	    /* if there is a commander, an no other base is appropriate,
-	       we will take the one with the commander */
-	    for_commanders (j) {
-		if (ibqx==game.state.cx[j] &amp;&amp; ibqy==game.state.cy[j] &amp;&amp; ifindit!= 2) {
-		    ifindit = 2;
-		    iwhichb = i;
-		    break;
-		}
-	    }
-	    if (j &gt; game.state.remcom) { /* no commander -- use this one */
-		ifindit = 1;
-		iwhichb = i;
-		break;
-	    }
-	}
-	if (ifindit==0) return; /* Nothing suitable -- wait until next time*/
-	ibqx = game.state.baseqx[iwhichb];
-	ibqy = game.state.baseqy[iwhichb];
-	/* decide how to move toward base */
-	ideltax = ibqx - game.state.isx;
-	ideltay = ibqy - game.state.isy;
-    }
-    /* Maximum movement is 1 quadrant in either or both axis */
-    if (ideltax &gt; 1) ideltax = 1;
-    if (ideltax &lt; -1) ideltax = -1;
-    if (ideltay &gt; 1) ideltay = 1;
-    if (ideltay &lt; -1) ideltay = -1;
-
-    /* try moving in both x and y directions */
-    iqx = game.state.isx + ideltax;
-    iqy = game.state.isy + ideltax;
-    if (movescom(iqx, iqy, flag, ipage)) {
-	/* failed -- try some other maneuvers */
-	if (ideltax==0 || ideltay==0) {
-	    /* attempt angle move */
-	    if (ideltax != 0) {
-		iqy = game.state.isy + 1;
-		if (movescom(iqx, iqy, flag, ipage)) {
-		    iqy = game.state.isy - 1;
-		    movescom(iqx, iqy, flag, ipage);
-		}
-	    }
-	    else {
-		iqx = game.state.isx + 1;
-		if (movescom(iqx, iqy, flag, ipage)) {
-		    iqx = game.state.isx - 1;
-		    movescom(iqx, iqy, flag, ipage);
-		}
-	    }
-	}
-	else {
-	    /* try moving just in x or y */
-	    iqy = game.state.isy;
-	    if (movescom(iqx, iqy, flag, ipage)) {
-		iqy = game.state.isy + ideltay;
-		iqx = game.state.isx;
-		movescom(iqx, iqy, flag, ipage);
-	    }
-	}
-    }
-    /* check for a base */
-    if (game.state.rembase == 0) {
-	game.future[FSCMOVE] = FOREVER;
-    }
-    else for_starbases(i) {
-	ibqx = game.state.baseqx[i];
-	ibqy = game.state.baseqy[i];
-	if (ibqx==game.state.isx &amp;&amp; ibqy == game.state.isy &amp;&amp; game.state.isx != batx &amp;&amp; game.state.isy != baty) {
-	    /* attack the base */
-	    if (flag) return; /* no, don't attack base! */
-	    iseenit = 0;
-	    isatb=1;
-	    game.future[FSCDBAS] = game.state.date + 1.0 +2.0*Rand();
-	    if (game.future[FCDBAS] &lt; FOREVER) game.future[FSCDBAS] +=
-		game.future[FCDBAS]-game.state.date;
-	    if (game.damage[DRADIO] &gt; 0 &amp;&amp; condit != IHDOCKED)
-		return; /* no warning */
-	    iseenit = 1;
-	    if (*ipage == 0)  pause_game(1);
-	    *ipage=1;
-	    proutn(&quot;Lt. Uhura-  \&quot;Captain, the starbase in &quot;);
-	    proutn(cramlc(quadrant, game.state.isx, game.state.isy));
-	    skip(1);
-	    prout(&quot;   reports that it is under attack from the Klingon Super-commander.&quot;);
-	    proutn(&quot;   It can survive until stardate %d.\&quot;&quot;,
-		   (int)game.future[FSCDBAS]);
-	    if (resting==0) return;
-	    prout(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;);
-	    if (ja()==0) return;
-	    resting = 0;
-	    Time = 0.0; /* actually finished */
-	    return;
-	}
-    }
-    /* Check for intelligence report */
-    if (
-#ifdef DEBUG
-	idebug==0 &amp;&amp;
-#endif
-	(Rand() &gt; 0.2 ||
-	 (game.damage[DRADIO] &gt; 0.0 &amp;&amp; condit != IHDOCKED) ||
-	 !game.state.galaxy[game.state.isx][game.state.isy].charted))
-	return;
-    if (*ipage==0) pause_game(1);
-    *ipage = 1;
-    prout(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;);
-    proutn(&quot;   the Super-commander is in &quot;);
-    proutn(cramlc(quadrant, game.state.isx, game.state. isy));
-    prout(&quot;.\&quot;&quot;);
-    return;
-}
-
-void movetho(void)
-{
-    int idx, idy, im, i, dum, my;
-    /* Move the Tholian */
-    if (ithere==0 || justin == 1) return;
-
-    if (ithx == 1 &amp;&amp; ithy == 1) {
-	idx = 1; idy = QUADSIZE;
-    }
-    else if (ithx == 1 &amp;&amp; ithy == QUADSIZE) {
-	idx = QUADSIZE; idy = QUADSIZE;
-    }
-    else if (ithx == QUADSIZE &amp;&amp; ithy == QUADSIZE) {
-	idx = QUADSIZE; idy = 1;
-    }
-    else if (ithx == QUADSIZE &amp;&amp; ithy == 1) {
-	idx = 1; idy = 1;
-    }
-    else {
-	/* something is wrong! */
-	ithere = 0;
-	return;
-    }
-
-    /* Do nothing if we are blocked */
-    if (game.quad[idx][idy]!= IHDOT &amp;&amp; game.quad[idx][idy]!= IHWEB) return;
-    game.quad[ithx][ithy] = IHWEB;
-
-    if (ithx != idx) {
-	/* move in x axis */
-	im = fabs((double)idx - ithx)/((double)idx - ithx);
-	while (ithx != idx) {
-	    ithx += im;
-	    if (game.quad[ithx][ithy]==IHDOT) game.quad[ithx][ithy] = IHWEB;
-	}
-    }
-    else if (ithy != idy) {
-	/* move in y axis */
-	im = fabs((double)idy - ithy)/((double)idy - ithy);
-	while (ithy != idy) {
-	    ithy += im;
-	    if (game.quad[ithx][ithy]==IHDOT) game.quad[ithx][ithy] = IHWEB;
-	}
-    }
-    game.quad[ithx][ithy] = IHT;
-    game.kx[nenhere]=ithx;
-    game.ky[nenhere]=ithy;
-
-    /* check to see if all holes plugged */
-    for_sectors(i) {
-	if (game.quad[1][i]!=IHWEB &amp;&amp; game.quad[1][i]!=IHT) return;
-	if (game.quad[QUADSIZE][i]!=IHWEB &amp;&amp; game.quad[QUADSIZE][i]!=IHT) return;
-	if (game.quad[i][1]!=IHWEB &amp;&amp; game.quad[i][1]!=IHT) return;
-	if (game.quad[i][QUADSIZE]!=IHWEB &amp;&amp; game.quad[i][QUADSIZE]!=IHT) return;
-    }
-    /* All plugged up -- Tholian splits */
-    game.quad[ithx][ithy]=IHWEB;
-    dropin(IHBLANK, &amp;dum, &amp;my);
-    crmena(1,IHT, 2, ithx, ithy);
-    prout(&quot; completes web.&quot;);
-    ithere = ithx = ithy = 0;
-    nenhere--;
-    return;
-}

Copied: trunk/autogen.sh (from rev 538, branches/at-work/autogen.sh)

Deleted: trunk/battle.c
===================================================================
--- trunk/battle.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/battle.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,1226 +0,0 @@
-#include &lt;unistd.h&gt;
-#include &quot;sst.h&quot;
-
-void doshield(int i) 
-{
-    int key;
-    enum {NONE, SHUP, SHDN, NRG} action = NONE;
-
-    ididit = 0;
-
-    if (i == 2) action = SHUP;
-    else {
-	key = scan();
-	if (key == IHALPHA) {
-	    if (isit(&quot;transfer&quot;))
-		action = NRG;
-	    else {
-		chew();
-		if (game.damage[DSHIELD]) {
-		    prout(&quot;Shields damaged and down.&quot;);
-		    return;
-		}
-		if (isit(&quot;up&quot;))
-		    action = SHUP;
-		else if (isit(&quot;down&quot;))
-		    action = SHDN;
-	    }
-	}
-	if (action==NONE) {
-	    proutn(&quot;Do you wish to change shield energy? &quot;);
-	    if (ja()) {
-		proutn(&quot;Energy to transfer to shields- &quot;);
-		action = NRG;
-	    }
-	    else if (game.damage[DSHIELD]) {
-		prout(&quot;Shields damaged and down.&quot;);
-		return;
-	    }
-	    else if (shldup) {
-		proutn(&quot;Shields are up. Do you want them down? &quot;);
-		if (ja()) action = SHDN;
-		else {
-		    chew();
-		    return;
-		}
-	    }
-	    else {
-		proutn(&quot;Shields are down. Do you want them up? &quot;);
-		if (ja()) action = SHUP;
-		else {
-		    chew();
-		    return;
-		}
-	    }
-	}
-    }
-    switch (action) {
-    case SHUP: /* raise shields */
-	if (shldup) {
-	    prout(&quot;Shields already up.&quot;);
-	    return;
-	}
-	shldup = 1;
-	shldchg = 1;
-	if (condit != IHDOCKED) energy -= 50.0;
-	prout(&quot;Shields raised.&quot;);
-	if (energy &lt;= 0) {
-	    skip(1);
-	    prout(&quot;Shields raising uses up last of energy.&quot;);
-	    finish(FNRG);
-	    return;
-	}
-	ididit=1;
-	return;
-    case SHDN:
-	if (shldup==0) {
-	    prout(&quot;Shields already down.&quot;);
-	    return;
-	}
-	shldup=0;
-	shldchg=1;
-	prout(&quot;Shields lowered.&quot;);
-	ididit=1;
-	return;
-    case NRG:
-	while (scan() != IHREAL) {
-	    chew();
-	    proutn(&quot;Energy to transfer to shields- &quot;);
-	}
-	chew();
-	if (aaitem==0) return;
-	if (aaitem &gt; energy) {
-	    prout(&quot;Insufficient ship energy.&quot;);
-	    return;
-	}
-	ididit = 1;
-	if (shield+aaitem &gt;= inshld) {
-	    prout(&quot;Shield energy maximized.&quot;);
-	    if (shield+aaitem &gt; inshld) {
-		prout(&quot;Excess energy requested returned to ship energy&quot;);
-	    }
-	    energy -= inshld-shield;
-	    shield = inshld;
-	    return;
-	}
-	if (aaitem &lt; 0.0 &amp;&amp; energy-aaitem &gt; inenrg) {
-	    /* Prevent shield drain loophole */
-	    skip(1);
-	    prout(&quot;Engineering to bridge--&quot;);
-	    prout(&quot;  Scott here. Power circuit problem, Captain.&quot;);
-	    prout(&quot;  I can't drain the shields.&quot;);
-	    ididit = 0;
-	    return;
-	}
-	if (shield+aaitem &lt; 0) {
-	    prout(&quot;All shield energy transferred to ship.&quot;);
-	    energy += shield;
-	    shield = 0.0;
-	    return;
-	}
-	proutn(&quot;Scotty- \&quot;&quot;);
-	if (aaitem &gt; 0)
-	    prout(&quot;Transferring energy to shields.\&quot;&quot;);
-	else
-	    prout(&quot;Draining energy from shields.\&quot;&quot;);
-	shield += aaitem;
-	energy -= aaitem;
-	return;
-    case NONE:;	/* avoid gcc warning */
-    }
-}
-
-void ram(int ibumpd, int ienm, int ix, int iy)
-{
-    double type = 1.0, extradm;
-    int icas, l;
-	
-    prouts(&quot;***RED ALERT!  RED ALERT!&quot;);
-    skip(1);
-    prout(&quot;***COLLISION IMMINENT.&quot;);
-    skip(2);
-    proutn(&quot;***&quot;);
-    crmshp();
-    switch (ienm) {
-    case IHR: type = 1.5; break;
-    case IHC: type = 2.0; break;
-    case IHS: type = 2.5; break;
-    case IHT: type = 0.5; break;
-    case IHQUEST: type = 4.0; break;
-    }
-    proutn(ibumpd ? &quot; rammed by &quot; : &quot; rams &quot;);
-    crmena(0, ienm, 2, ix, iy);
-    if (ibumpd) proutn(&quot; (original position)&quot;);
-    skip(1);
-    deadkl(ix, iy, ienm, sectx, secty);
-    proutn(&quot;***&quot;);
-    crmshp();
-    prout(&quot; heavily damaged.&quot;);
-    icas = 10.0+20.0*Rand();
-    prout(&quot;***Sickbay reports %d casualties&quot;, icas);
-    casual += icas;
-    for (l=0; l &lt; NDEVICES; l++) {
-	if (l == DDRAY) 
-	    continue; // Don't damage deathray 
-	if (game.damage[l] &lt; 0) 
-	    continue;
-	extradm = (10.0*type*Rand()+1.0)*damfac;
-	game.damage[l] += Time + extradm; /* Damage for at least time of travel! */
-    }
-    shldup = 0;
-    if (KLINGREM) {
-	pause_game(2);
-	dreprt();
-    }
-    else finish(FWON);
-    return;
-}
-
-void torpedo(double course, double r, int inx, int iny, double *hit, int i, int n)
-{
-    int l, iquad=0, ix=0, iy=0, jx=0, jy=0, shoved=0, ll;
-	
-    double ac=course + 0.25*r;
-    double angle = (15.0-ac)*0.5235988;
-    double bullseye = (15.0 - course)*0.5235988;
-    double deltax=-sin(angle), deltay=cos(angle), x=inx, y=iny, bigger;
-    double ang, temp, xx, yy, kp, h1;
-
-    bigger = fabs(deltax);
-    if (fabs(deltay) &gt; bigger) bigger = fabs(deltay);
-    deltax /= bigger;
-    deltay /= bigger;
-    if (game.damage[DSRSENS]==0 || condit==IHDOCKED) 
-	setwnd(srscan_window);
-    else 
-	setwnd(message_window);
-    /* Loop to move a single torpedo */
-    for (l=1; l &lt;= 15; l++) {
-	x += deltax;
-	ix = x + 0.5;
-	y += deltay;
-	iy = y + 0.5;
-	if (!VALID_SECTOR(ix, iy)) break;
-	iquad=game.quad[ix][iy];
-	tracktorpedo(ix, iy, l, i, n, iquad);
-	if (iquad==IHDOT) continue;
-	/* hit something */
-	setwnd(message_window);
-	skip(1);	/* start new line after text track */
-	switch(iquad) {
-	case IHE: /* Hit our ship */
-	case IHF:
-	    skip(1);
-	    proutn(&quot;Torpedo hits &quot;);
-	    crmshp();
-	    prout(&quot;.&quot;);
-	    *hit = 700.0 + 100.0*Rand() -
-		1000.0*sqrt(square(ix-inx)+square(iy-iny))*
-		fabs(sin(bullseye-angle));
-	    *hit = fabs(*hit);
-	    newcnd(); /* we're blown out of dock */
-	    /* We may be displaced. */
-	    if (landed==1 || condit==IHDOCKED) return; /* Cheat if on a planet */
-	    ang = angle + 2.5*(Rand()-0.5);
-	    temp = fabs(sin(ang));
-	    if (fabs(cos(ang)) &gt; temp) temp = fabs(cos(ang));
-	    xx = -sin(ang)/temp;
-	    yy = cos(ang)/temp;
-	    jx=ix+xx+0.5;
-	    jy=iy+yy+0.5;
-	    if (!VALID_SECTOR(jx, jy)) return;
-	    if (game.quad[jx][jy]==IHBLANK) {
-		finish(FHOLE);
-		return;
-	    }
-	    if (game.quad[jx][jy]!=IHDOT) {
-		/* can't move into object */
-		return;
-	    }
-	    sectx = jx;
-	    secty = jy;
-	    crmshp();
-	    shoved = 1;
-	    break;
-					  
-	case IHC: /* Hit a commander */
-	case IHS:
-	    if (Rand() &lt;= 0.05) {
-		crmena(1, iquad, 2, ix, iy);
-		prout(&quot; uses anti-photon device;&quot;);
-		prout(&quot;   torpedo neutralized.&quot;);
-		return;
-	    }
-	case IHR: /* Hit a regular enemy */
-	case IHK:
-	    /* find the enemy */
-	    for_local_enemies(ll)
-		if (ix==game.kx[ll] &amp;&amp; iy==game.ky[ll]) break;
-	    kp = fabs(game.kpower[ll]);
-	    h1 = 700.0 + 100.0*Rand() -
-		1000.0*sqrt(square(ix-inx)+square(iy-iny))*
-		fabs(sin(bullseye-angle));
-	    h1 = fabs(h1);
-	    if (kp &lt; h1) h1 = kp;
-	    game.kpower[ll] -= (game.kpower[ll]&lt;0 ? -h1 : h1);
-	    if (game.kpower[ll] == 0) {
-		deadkl(ix, iy, iquad, ix, iy);
-		return;
-	    }
-	    crmena(1, iquad, 2, ix, iy);
-	    /* If enemy damaged but not destroyed, try to displace */
-	    ang = angle + 2.5*(Rand()-0.5);
-	    temp = fabs(sin(ang));
-	    if (fabs(cos(ang)) &gt; temp) temp = fabs(cos(ang));
-	    xx = -sin(ang)/temp;
-	    yy = cos(ang)/temp;
-	    jx=ix+xx+0.5;
-	    jy=iy+yy+0.5;
-	    if (!VALID_SECTOR(jx, jy)) {
-		prout(&quot; damaged but not destroyed.&quot;);
-		return;
-	    }
-	    if (game.quad[jx][jy]==IHBLANK) {
-		prout(&quot; buffeted into black hole.&quot;);
-		deadkl(ix, iy, iquad, jx, jy);
-		return;
-	    }
-	    if (game.quad[jx][jy]!=IHDOT) {
-		/* can't move into object */
-		prout(&quot; damaged but not destroyed.&quot;);
-		return;
-	    }
-	    proutn(&quot; damaged--&quot;);
-	    game.kx[ll] = jx;
-	    game.ky[ll] = jy;
-	    shoved = 1;
-	    break;
-	case IHB: /* Hit a base */
-	    skip(1);
-	    prout(&quot;***STARBASE DESTROYED..&quot;);
-	    for_starbases(ll) {
-		if (game.state.baseqx[ll]==quadx &amp;&amp; game.state.baseqy[ll]==quady) {
-		    game.state.baseqx[ll]=game.state.baseqx[game.state.rembase];
-		    game.state.baseqy[ll]=game.state.baseqy[game.state.rembase];
-		    break;
-		}
-	    }
-	    game.quad[ix][iy]=IHDOT;
-	    game.state.rembase--;
-	    basex=basey=0;
-	    game.state.galaxy[quadx][quady].starbase--;
-	    game.state.chart[quadx][quady].starbase--;
-	    game.state.basekl++;
-	    newcnd();
-	    return;
-	case IHP: /* Hit a planet */
-	    crmena(1, iquad, 2, ix, iy);
-	    prout(&quot; destroyed.&quot;);
-	    game.state.nplankl++;
-	    game.state.galaxy[quadx][quady].planets--;
-	    DESTROY(&amp;game.state.plnets[iplnet]);
-	    iplnet = 0;
-	    plnetx = plnety = 0;
-	    game.quad[ix][iy] = IHDOT;
-	    if (landed==1) {
-		/* captain perishes on planet */
-		finish(FDPLANET);
-	    }
-	    return;
-	case IHSTAR: /* Hit a star */
-	    if (Rand() &gt; 0.10) {
-		nova(ix, iy);
-		return;
-	    }
-	    crmena(1, IHSTAR, 2, ix, iy);
-	    prout(&quot; unaffected by photon blast.&quot;);
-	    return;
-	case IHQUEST: /* Hit a thingy */
-	    if (!(game.options &amp; OPTION_THINGY) || Rand()&gt;0.7) {
-		skip(1);
-		prouts(&quot;AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!&quot;);
-		skip(1);
-		prouts(&quot;    HACK!     HACK!    HACK!        *CHOKE!*  &quot;);
-		skip(1);
-		proutn(&quot;Mr. Spock-&quot;);
-		prouts(&quot;  \&quot;Fascinating!\&quot;&quot;);
-		skip(1);
-		deadkl(ix, iy, iquad, ix, iy);
-	    } else {
-		/*
-		 * Stas Sergeev added the possibility that
-		 * you can shove the Thingy and piss it off.
-		 * It then becomes an enemy and may fire at you.
-		 */
-		iqengry=1;
-		shoved=1;
-	    }
-	    return;
-	case IHBLANK: /* Black hole */
-	    skip(1);
-	    crmena(1, IHBLANK, 2, ix, iy);
-	    prout(&quot; swallows torpedo.&quot;);
-	    return;
-	case IHWEB: /* hit the web */
-	    skip(1);
-	    prout(&quot;***Torpedo absorbed by Tholian web.&quot;);
-	    return;
-	case IHT:  /* Hit a Tholian */
-	    h1 = 700.0 + 100.0*Rand() -
-		1000.0*sqrt(square(ix-inx)+square(iy-iny))*
-		fabs(sin(bullseye-angle));
-	    h1 = fabs(h1);
-	    if (h1 &gt;= 600) {
-		game.quad[ix][iy] = IHDOT;
-		ithere = 0;
-		ithx = ithy = 0;
-		deadkl(ix, iy, iquad, ix, iy);
-		return;
-	    }
-	    skip(1);
-	    crmena(1, IHT, 2, ix, iy);
-	    if (Rand() &gt; 0.05) {
-		prout(&quot; survives photon blast.&quot;);
-		return;
-	    }
-	    prout(&quot; disappears.&quot;);
-	    game.quad[ix][iy] = IHWEB;
-	    ithere = ithx = ithy = 0;
-	    nenhere--;
-	    {
-		int dum, my;
-		dropin(IHBLANK, &amp;dum, &amp;my);
-	    }
-	    return;
-					
-	default: /* Problem! */
-	    skip(1);
-	    proutn(&quot;Don't know how to handle collision with &quot;);
-	    crmena(1, iquad, 2, ix, iy);
-	    skip(1);
-	    return;
-	}
-	break;
-    }
-    if(curwnd!=message_window) {
-	setwnd(message_window);
-    }
-    if (shoved) {
-	game.quad[jx][jy]=iquad;
-	game.quad[ix][iy]=IHDOT;
-	prout(&quot; displaced by blast to %s &quot;, cramlc(sector, jx, jy));
-	for_local_enemies(ll)
-	    game.kdist[ll] = game.kavgd[ll] = sqrt(square(sectx-game.kx[ll])+square(secty-game.ky[ll]));
-	sortkl();
-	return;
-    }
-    skip(1);
-    prout(&quot;Torpedo missed.&quot;);
-    return;
-}
-
-static void fry(double hit) 
-{
-    double ncrit, extradm;
-    int ktr=1, l, ll, j, cdam[NDEVICES];
-
-    /* a critical hit occured */
-    if (hit &lt; (275.0-25.0*skill)*(1.0+0.5*Rand())) return;
-
-    ncrit = 1.0 + hit/(500.0+100.0*Rand());
-    proutn(&quot;***CRITICAL HIT--&quot;);
-    /* Select devices and cause damage */
-    for (l = 0; l &lt; ncrit &amp;&amp; 0 &lt; NDEVICES; l++) {
-	do {
-	    j = NDEVICES*Rand();
-	    /* Cheat to prevent shuttle damage unless on ship */
-	} while 
-	      (game.damage[j]&lt;0.0 || (j==DSHUTTL &amp;&amp; iscraft!=1) || j==DDRAY);
-	cdam[l] = j;
-	extradm = (hit*damfac)/(ncrit*(75.0+25.0*Rand()));
-	game.damage[j] += extradm;
-	if (l &gt; 0) {
-	    for (ll=2; ll&lt;=l &amp;&amp; j != cdam[ll-1]; ll++) ;
-	    if (ll&lt;=l) continue;
-	    ktr += 1;
-	    if (ktr==3) skip(1);
-	    proutn(&quot; and &quot;);
-	}
-	proutn(device[j]);
-    }
-    prout(&quot; damaged.&quot;);
-    if (game.damage[DSHIELD] &amp;&amp; shldup) {
-	prout(&quot;***Shields knocked down.&quot;);
-	shldup=0;
-    }
-}
-
-void attack(int torps_ok) 
-{
-    /* torps_ok == 0 forces use of phasers in an attack */
-    int percent, ihurt=0, l, i=0, jx, jy, iquad, itflag;
-    int atackd = 0, attempt = 0;
-    double hit;
-    double pfac, dustfac, hitmax=0.0, hittot=0.0, chgfac=1.0, r;
-
-    iattak = 1;
-    if (alldone) return;
-#ifdef DEBUG
-    if (idebug) prout(&quot;ATTACK!&quot;);
-#endif
-
-    if (ithere) movetho();
-
-    if (neutz) { /* The one chance not to be attacked */
-	neutz = 0;
-	return;
-    }
-    if ((((comhere || ishere) &amp;&amp; (justin == 0)) || skill == SKILL_EMERITUS)&amp;&amp;(torps_ok!=0)) movcom();
-    if (nenhere==0 || (nenhere==1 &amp;&amp; iqhere &amp;&amp; iqengry==0)) return;
-    pfac = 1.0/inshld;
-    if (shldchg == 1) chgfac = 0.25+0.5*Rand();
-    skip(1);
-    if (skill &lt;= SKILL_FAIR) i = 2;
-    for_local_enemies(l) {
-	if (game.kpower[l] &lt; 0) continue;	/* too weak to attack */
-	/* compute hit strength and diminsh shield power */
-	r = Rand();
-	/* Increase chance of photon torpedos if docked or enemy energy low */
-	if (condit == IHDOCKED) r *= 0.25;
-	if (game.kpower[l] &lt; 500) r *= 0.25; 
-	jx = game.kx[l];
-	jy = game.ky[l];
-	iquad = game.quad[jx][jy];
-	if (iquad==IHT || (iquad==IHQUEST &amp;&amp; !iqengry)) continue;
-	itflag = (iquad == IHK &amp;&amp; r &gt; 0.0005) || !torps_ok ||
-	    (iquad==IHC &amp;&amp; r &gt; 0.015) ||
-	    (iquad==IHR &amp;&amp; r &gt; 0.3) ||
-	    (iquad==IHS &amp;&amp; r &gt; 0.07) ||
-	    (iquad==IHQUEST &amp;&amp; r &gt; 0.05);
-	if (itflag) {
-	    /* Enemy uses phasers */
-	    if (condit == IHDOCKED) continue; /* Don't waste the effort! */
-	    attempt = 1; /* Attempt to attack */
-	    dustfac = 0.8+0.05*Rand();
-	    hit = game.kpower[l]*pow(dustfac,game.kavgd[l]);
-	    game.kpower[l] *= 0.75;
-	}
-	else { /* Enemy used photon torpedo */
-	    double course = 1.90985*atan2((double)secty-jy, (double)jx-sectx);
-	    hit = 0;
-	    proutn(&quot;***TORPEDO INCOMING&quot;);
-	    if (game.damage[DSRSENS] &lt;= 0.0) {
-		proutn(&quot; From &quot;);
-		crmena(0, iquad, i, jx, jy);
-	    }
-	    attempt = 1;
-	    prout(&quot;  &quot;);
-	    r = (Rand()+Rand())*0.5 -0.5;
-	    r += 0.002*game.kpower[l]*r;
-	    torpedo(course, r, jx, jy, &amp;hit, 1, 1);
-	    if (KLINGREM==0) 
-		finish(FWON); /* Klingons did themselves in! */
-	    if (game.state.galaxy[quadx][quady].supernova || alldone) 
-		return; /* Supernova or finished */
-	    if (hit == 0) continue;
-	}
-	if (shldup != 0 || shldchg != 0 || condit==IHDOCKED) {
-	    /* shields will take hits */
-	    double absorb, hitsh, propor = pfac*shield*(condit==IHDOCKED ? 2.1 : 1.0);
-	    if(propor &lt; 0.1) propor = 0.1;
-	    hitsh = propor*chgfac*hit+1.0;
-	    atackd=1;
-	    absorb = 0.8*hitsh;
-	    if (absorb &gt; shield) absorb = shield;
-	    shield -= absorb;
-	    hit -= hitsh;
-	    if (condit==IHDOCKED) dock(0);
-	    if (propor &gt; 0.1 &amp;&amp; hit &lt; 0.005*energy) continue;
-	}
-	/* It's a hit -- print out hit size */
-	atackd = 1; /* We weren't going to check casualties, etc. if
-		       shields were down for some strange reason. This
-		       doesn't make any sense, so I've fixed it */
-	ihurt = 1;
-	proutn(&quot;%d unit hit&quot;, (int)hit);
-	if ((game.damage[DSRSENS] &gt; 0 &amp;&amp; itflag) || skill&lt;=SKILL_FAIR) {
-	    proutn(&quot; on the &quot;);
-	    crmshp();
-	}
-	if (game.damage[DSRSENS] &lt;= 0.0 &amp;&amp; itflag) {
-	    proutn(&quot; from &quot;);
-	    crmena(0, iquad, i, jx, jy);
-	}
-	skip(1);
-	/* Decide if hit is critical */
-	if (hit &gt; hitmax) hitmax = hit;
-	hittot += hit;
-	fry(hit);
-	prout(&quot;Hit %g energy %g&quot;, hit, energy);
-	energy -= hit;
-	if (condit==IHDOCKED) 
-	    dock(0);
-    }
-    if (energy &lt;= 0) {
-	/* Returning home upon your shield, not with it... */
-	finish(FBATTLE);
-	return;
-    }
-    if (attempt == 0 &amp;&amp; condit == IHDOCKED)
-	prout(&quot;***Enemies decide against attacking your ship.&quot;);
-    if (atackd == 0) return;
-    percent = 100.0*pfac*shield+0.5;
-    if (ihurt==0) {
-	/* Shields fully protect ship */
-	proutn(&quot;Enemy attack reduces shield strength to &quot;);
-    }
-    else {
-	/* Print message if starship suffered hit(s) */
-	skip(1);
-	proutn(&quot;Energy left %2d    shields &quot;, (int)energy);
-	if (shldup) proutn(&quot;up &quot;);
-	else if (game.damage[DSHIELD] == 0) proutn(&quot;down &quot;);
-	else proutn(&quot;damaged, &quot;);
-    }
-    prout(&quot;%d%%,   torpedoes left %d&quot;, percent, torps);
-    /* Check if anyone was hurt */
-    if (hitmax &gt;= 200 || hittot &gt;= 500) {
-	int icas= hittot*Rand()*0.015;
-	if (icas &gt;= 2) {
-	    skip(1);
-	    prout(&quot;Mc Coy-  \&quot;Sickbay to bridge.  We suffered %d casualties&quot;, icas);
-	    prout(&quot;   in that last attack.\&quot;&quot;);
-	    casual += icas;
-	}
-    }
-    /* After attack, reset average distance to enemies */
-    for_local_enemies(l)
-	game.kavgd[l] = game.kdist[l];
-    sortkl();
-    return;
-}
-		
-void deadkl(int ix, int iy, int type, int ixx, int iyy) 
-{
-    /* Added ixx and iyy allow enemy to &quot;move&quot; before dying */
-
-    int i,j;
-
-    skip(1);
-    crmena(1, type, 2, ixx, iyy);
-    /* Decide what kind of enemy it is and update approriately */
-    if (type == IHR) {
-	/* chalk up a Romulan */
-	game.state.galaxy[quadx][quady].romulans--;
-	irhere--;
-	game.state.nromrem--;
-    }
-    else if (type == IHT) {
-	/* Killed a Tholian */
-	ithere = 0;
-    }
-    else if (type == IHQUEST) {
-	/* Killed a Thingy */
-	iqhere=iqengry=thingx=thingy=0;
-    }
-    else {
-	/* Some type of a Klingon */
-	game.state.galaxy[quadx][quady].klingons--;
-	klhere--;
-	switch (type) {
-	case IHC:
-	    comhere = 0;
-	    for_commanders (i)
-		if (game.state.cx[i]==quadx &amp;&amp; game.state.cy[i]==quady) break;
-	    game.state.cx[i] = game.state.cx[game.state.remcom];
-	    game.state.cy[i] = game.state.cy[game.state.remcom];
-	    game.state.cx[game.state.remcom] = 0;
-	    game.state.cy[game.state.remcom] = 0;
-	    game.state.remcom--;
-	    game.future[FTBEAM] = FOREVER;
-	    if (game.state.remcom != 0)
-		game.future[FTBEAM] = game.state.date + expran(1.0*incom/game.state.remcom);
-	    break;
-	case IHK:
-	    game.state.remkl--;
-	    break;
-	case IHS:
-	    game.state.nscrem--;
-	    ishere = game.state.isx = game.state.isy = isatb = iscate = 0;
-	    game.future[FSCMOVE] = game.future[FSCDBAS] = FOREVER;
-	    break;
-	}
-    }
-
-    /* For each kind of enemy, finish message to player */
-    prout(&quot; destroyed.&quot;);
-    game.quad[ix][iy] = IHDOT;
-    if (KLINGREM==0) return;
-
-    game.state.remtime = game.state.remres/(game.state.remkl + 4*game.state.remcom);
-
-    /* Remove enemy ship from arrays describing local conditions */
-    if (game.future[FCDBAS] &lt; FOREVER &amp;&amp; batx==quadx &amp;&amp; baty==quady &amp;&amp; type==IHC)
-	game.future[FCDBAS] = FOREVER;
-    for_local_enemies(i)
-	if (game.kx[i]==ix &amp;&amp; game.ky[i]==iy) break;
-    nenhere--;
-    if (i &lt;= nenhere)  {
-	for (j=i; j&lt;=nenhere; j++) {
-	    game.kx[j] = game.kx[j+1];
-	    game.ky[j] = game.ky[j+1];
-	    game.kpower[j] = game.kpower[j+1];
-	    game.kavgd[j] = game.kdist[j] = game.kdist[j+1];
-	}
-    }
-    game.kx[nenhere+1] = 0;
-    game.ky[nenhere+1] = 0;
-    game.kdist[nenhere+1] = 0;
-    game.kavgd[nenhere+1] = 0;
-    game.kpower[nenhere+1] = 0;
-    return;
-}
-
-static int targetcheck(double x, double y, double *course) 
-{
-    double deltx, delty;
-    /* Return TRUE if target is invalid */
-    if (!VALID_SECTOR(x, y)) {
-	huh();
-	return 1;
-    }
-    deltx = 0.1*(y - secty);
-    delty = 0.1*(sectx - x);
-    if (deltx==0 &amp;&amp; delty== 0) {
-	skip(1);
-	prout(&quot;Spock-  \&quot;Bridge to sickbay.  Dr. McCoy,&quot;);
-	prout(&quot;  I recommend an immediate review of&quot;);
-	prout(&quot;  the Captain's psychological profile.\&quot;&quot;);
-	chew();
-	return 1;
-    }
-    *course = 1.90985932*atan2(deltx, delty);
-    return 0;
-}
-
-void photon(void) 
-{
-    double targ[4][3], course[4];
-    double r, dummy;
-    int key, n, i, osuabor;
-
-    ididit = 0;
-
-    if (game.damage[DPHOTON]) {
-	prout(&quot;Photon tubes damaged.&quot;);
-	chew();
-	return;
-    }
-    if (torps == 0) {
-	prout(&quot;No torpedoes left.&quot;);
-	chew();
-	return;
-    }
-    key = scan();
-    for (;;) {
-	if (key == IHALPHA) {
-	    huh();
-	    return;
-	}
-	else if (key == IHEOL) {
-	    prout(&quot;%d torpedoes left.&quot;, torps);
-	    proutn(&quot;Number of torpedoes to fire- &quot;);
-	    key = scan();
-	}
-	else /* key == IHREAL */ {
-	    n = aaitem + 0.5;
-	    if (n &lt;= 0) { /* abort command */
-		chew();
-		return;
-	    }
-	    if (n &gt; 3) {
-		chew();
-		prout(&quot;Maximum of 3 torpedoes per burst.&quot;);
-		key = IHEOL;
-		return;
-	    }
-	    if (n &lt;= torps) break;
-	    chew();
-	    key = IHEOL;
-	}
-    }
-    for (i = 1; i &lt;= n; i++) {
-	key = scan();
-	if (i==1 &amp;&amp; key == IHEOL) {
-	    break;	/* we will try prompting */
-	}
-	if (i==2 &amp;&amp; key == IHEOL) {
-	    /* direct all torpedoes at one target */
-	    while (i &lt;= n) {
-		targ[i][1] = targ[1][1];
-		targ[i][2] = targ[1][2];
-		course[i] = course[1];
-		i++;
-	    }
-	    break;
-	}
-	if (key != IHREAL) {
-	    huh();
-	    return;
-	}
-	targ[i][1] = aaitem;
-	key = scan();
-	if (key != IHREAL) {
-	    huh();
-	    return;
-	}
-	targ[i][2] = aaitem;
-	if (targetcheck(targ[i][1], targ[i][2], &amp;course[i])) return;
-    }
-    chew();
-    if (i == 1 &amp;&amp; key == IHEOL) {
-	/* prompt for each one */
-	for (i = 1; i &lt;= n; i++) {
-	    proutn(&quot;Target sector for torpedo number %d- &quot;, i);
-	    key = scan();
-	    if (key != IHREAL) {
-		huh();
-		return;
-	    }
-	    targ[i][1] = aaitem;
-	    key = scan();
-	    if (key != IHREAL) {
-		huh();
-		return;
-	    }
-	    targ[i][2] = aaitem;
-	    chew();
-	    if (targetcheck(targ[i][1], targ[i][2], &amp;course[i])) return;
-	}
-    }
-    ididit = 1;
-    /* Loop for moving &lt;n&gt; torpedoes */
-    osuabor = 0;
-    for (i = 1; i &lt;= n &amp;&amp; !osuabor; i++) {
-	if (condit != IHDOCKED) torps--;
-	r = (Rand()+Rand())*0.5 -0.5;
-	if (fabs(r) &gt;= 0.47) {
-	    /* misfire! */
-	    r = (Rand()+1.2) * r;
-	    if (n&gt;1) {
-		prouts(&quot;***TORPEDO NUMBER %d MISFIRES&quot;, i);
-	    }
-	    else prouts(&quot;***TORPEDO MISFIRES.&quot;);
-	    skip(1);
-	    if (i &lt; n)
-		prout(&quot;  Remainder of burst aborted.&quot;);
-	    osuabor=1;
-	    if (Rand() &lt;= 0.2) {
-		prout(&quot;***Photon tubes damaged by misfire.&quot;);
-		game.damage[DPHOTON] = damfac*(1.0+2.0*Rand());
-		break;
-	    }
-	}
-	if (shldup || condit == IHDOCKED) 
-	    r *= 1.0 + 0.0001*shield;
-	torpedo(course[i], r, sectx, secty, &amp;dummy, i, n);
-	if (alldone || game.state.galaxy[quadx][quady].supernova)
-	    return;
-    }
-    if (KLINGREM==0) finish(FWON);
-}
-
-	
-
-static void overheat(double rpow) 
-{
-    if (rpow &gt; 1500) {
-	double chekbrn = (rpow-1500.)*0.00038;
-	if (Rand() &lt;= chekbrn) {
-	    prout(&quot;Weapons officer Sulu-  \&quot;Phasers overheated, sir.\&quot;&quot;);
-	    game.damage[DPHASER] = damfac*(1.0 + Rand()) * (1.0+chekbrn);
-	}
-    }
-}
-
-static int checkshctrl(double rpow) 
-{
-    double hit;
-    int icas;
-	
-    skip(1);
-    if (Rand() &lt; .998) {
-	prout(&quot;Shields lowered.&quot;);
-	return 0;
-    }
-    /* Something bad has happened */
-    prouts(&quot;***RED ALERT!  RED ALERT!&quot;);
-    skip(2);
-    hit = rpow*shield/inshld;
-    energy -= rpow+hit*0.8;
-    shield -= hit*0.2;
-    if (energy &lt;= 0.0) {
-	prouts(&quot;Sulu-  \&quot;Captain! Shield malf***********************\&quot;&quot;);
-	skip(1);
-	stars();
-	finish(FPHASER);
-	return 1;
-    }
-    prouts(&quot;Sulu-  \&quot;Captain! Shield malfunction! Phaser fire contained!\&quot;&quot;);
-    skip(2);
-    prout(&quot;Lt. Uhura-  \&quot;Sir, all decks reporting damage.\&quot;&quot;);
-    icas = hit*Rand()*0.012;
-    skip(1);
-    fry(0.8*hit);
-    if (icas) {
-	skip(1);
-	prout(&quot;McCoy to bridge- \&quot;Severe radiation burns, Jim.&quot;);
-	prout(&quot;  %d casualties so far.\&quot;&quot;, icas);
-	casual -= icas;
-    }
-    skip(1);
-    prout(&quot;Phaser energy dispersed by shields.&quot;);
-    prout(&quot;Enemy unaffected.&quot;);
-    overheat(rpow);
-    return 1;
-}
-	
-
-void phasers(void) 
-{
-    double hits[21], rpow=0, extra, powrem, over, temp;
-    int kz = 0, k=1, i, irec=0; /* Cheating inhibitor */
-    int ifast=0, no=0, ipoop=1, msgflag = 1;
-    enum {NOTSET, MANUAL, FORCEMAN, AUTOMATIC} automode = NOTSET;
-    int key=0;
-
-    skip(1);
-    /* SR sensors and Computer */
-    if (game.damage[DSRSENS]+game.damage[DCOMPTR] &gt; 0) ipoop = 0;
-    if (condit == IHDOCKED) {
-	prout(&quot;Phasers can't be fired through base shields.&quot;);
-	chew();
-	return;
-    }
-    if (game.damage[DPHASER] != 0) {
-	prout(&quot;Phaser control damaged.&quot;);
-	chew();
-	return;
-    }
-    if (shldup) {
-	if (game.damage[DSHCTRL]) {
-	    prout(&quot;High speed shield control damaged.&quot;);
-	    chew();
-	    return;
-	}
-	if (energy &lt;= 200.0) {
-	    prout(&quot;Insufficient energy to activate high-speed shield control.&quot;);
-	    chew();
-	    return;
-	}
-	prout(&quot;Weapons Officer Sulu-  \&quot;High-speed shield control enabled, sir.\&quot;&quot;);
-	ifast = 1;
-		
-    }
-    /* Original code so convoluted, I re-did it all */
-    while (automode==NOTSET) {
-	key=scan();
-	if (key == IHALPHA) {
-	    if (isit(&quot;manual&quot;)) {
-		if (nenhere==0) {
-		    prout(&quot;There is no enemy present to select.&quot;);
-		    chew();
-		    key = IHEOL;
-		    automode=AUTOMATIC;
-		}
-		else {
-		    automode = MANUAL;
-		    key = scan();
-		}
-	    }
-	    else if (isit(&quot;automatic&quot;)) {
-		if ((!ipoop) &amp;&amp; nenhere != 0) {
-		    automode = FORCEMAN;
-		}
-		else {
-		    if (nenhere==0)
-			prout(&quot;Energy will be expended into space.&quot;);
-		    automode = AUTOMATIC;
-		    key = scan();
-		}
-	    }
-	    else if (isit(&quot;no&quot;)) {
-		no = 1;
-	    }
-	    else {
-		huh();
-		return;
-	    }
-	}
-	else if (key == IHREAL) {
-	    if (nenhere==0) {
-		prout(&quot;Energy will be expended into space.&quot;);
-		automode = AUTOMATIC;
-	    }
-	    else if (!ipoop)
-		automode = FORCEMAN;
-	    else
-		automode = AUTOMATIC;
-	}
-	else {
-	    /* IHEOL */
-	    if (nenhere==0) {
-		prout(&quot;Energy will be expended into space.&quot;);
-		automode = AUTOMATIC;
-	    }
-	    else if (!ipoop)
-		automode = FORCEMAN;
-	    else 
-		proutn(&quot;Manual or automatic? &quot;);
-	}
-    }
-				
-    switch (automode) {
-    case AUTOMATIC:
-	if (key == IHALPHA &amp;&amp; isit(&quot;no&quot;)) {
-	    no = 1;
-	    key = scan();
-	}
-	if (key != IHREAL &amp;&amp; nenhere != 0) {
-	    prout(&quot;Phasers locked on target. Energy available: %.2f&quot;,
-		  ifast?energy-200.0:energy,1,2);
-	}
-	irec=0;
-	do {
-	    chew();
-	    if (!kz) for_local_enemies(i)
-		irec+=fabs(game.kpower[i])/(PHASEFAC*pow(0.90,game.kdist[i]))*
-		    (1.01+0.05*Rand()) + 1.0;
-	    kz=1;
-	    proutn(&quot;(%d) units required. &quot;, irec);
-	    chew();
-	    proutn(&quot;Units to fire= &quot;);
-	    key = scan();
-	    if (key!=IHREAL) return;
-	    rpow = aaitem;
-	    if (rpow &gt; (ifast?energy-200:energy)) {
-		proutn(&quot;Energy available= %.2f&quot;,
-		       ifast?energy-200:energy);
-		skip(1);
-		key = IHEOL;
-	    }
-	} while (rpow &gt; (ifast?energy-200:energy));
-	if (rpow&lt;=0) {
-	    /* chicken out */
-	    chew();
-	    return;
-	}
-	if ((key=scan()) == IHALPHA &amp;&amp; isit(&quot;no&quot;)) {
-	    no = 1;
-	}
-	if (ifast) {
-	    energy -= 200; /* Go and do it! */
-	    if (checkshctrl(rpow)) return;
-	}
-	chew();
-	energy -= rpow;
-	extra = rpow;
-	if (nenhere) {
-	    extra = 0.0;
-	    powrem = rpow;
-	    for_local_enemies(i) {
-		hits[i] = 0.0;
-		if (powrem &lt;= 0) continue;
-		hits[i] = fabs(game.kpower[i])/(PHASEFAC*pow(0.90,game.kdist[i]));
-		over = (0.01 + 0.05*Rand())*hits[i];
-		temp = powrem;
-		powrem -= hits[i] + over;
-		if (powrem &lt;= 0 &amp;&amp; temp &lt; hits[i]) hits[i] = temp;
-		if (powrem &lt;= 0) over = 0.0;
-		extra += over;
-	    }
-	    if (powrem &gt; 0.0) extra += powrem;
-	    hittem(hits);
-	    ididit=1;
-	}
-	if (extra &gt; 0 &amp;&amp; alldone == 0) {
-	    if (ithere) {
-		proutn(&quot;*** Tholian web absorbs &quot;);
-		if (nenhere&gt;0) proutn(&quot;excess &quot;);
-		prout(&quot;phaser energy.&quot;);
-	    }
-	    else {
-		prout(&quot;%d expended on empty space.&quot;, (int)extra);
-	    }
-	}
-	break;
-
-    case FORCEMAN:
-	chew();
-	key = IHEOL;
-	if (game.damage[DCOMPTR]!=0)
-	    prout(&quot;Battle comuter damaged, manual file only.&quot;);
-	else {
-	    skip(1);
-	    prouts(&quot;---WORKING---&quot;);
-	    skip(1);
-	    prout(&quot;Short-range-sensors-damaged&quot;);
-	    prout(&quot;Insufficient-data-for-automatic-phaser-fire&quot;);
-	    prout(&quot;Manual-fire-must-be-used&quot;);
-	    skip(1);
-	}
-    case MANUAL:
-	rpow = 0.0;
-	for (k = 1; k &lt;= nenhere;) {
-	    int ii = game.kx[k], jj = game.ky[k];
-	    int ienm = game.quad[ii][jj];
-	    if (msgflag) {
-		proutn(&quot;Energy available= %.2f&quot;,
-		       energy-.006-(ifast?200:0));
-		skip(1);
-		msgflag = 0;
-		rpow = 0.0;
-	    }
-	    if (game.damage[DSRSENS] &amp;&amp; !(abs(sectx-ii) &lt; 2 &amp;&amp; abs(secty-jj) &lt; 2) &amp;&amp;
-		(ienm == IHC || ienm == IHS)) {
-		cramen(ienm);
-		prout(&quot; can't be located without short range scan.&quot;);
-		chew();
-		key = IHEOL;
-		hits[k] = 0; /* prevent overflow -- thanks to Alexei Voitenko */
-		k++;
-		continue;
-	    }
-	    if (key == IHEOL) {
-		chew();
-		if (ipoop &amp;&amp; k &gt; kz)
-		    irec=(fabs(game.kpower[k])/(PHASEFAC*pow(0.9,game.kdist[k])))*
-			(1.01+0.05*Rand()) + 1.0;
-		kz = k;
-		proutn(&quot;(&quot;);
-		if (game.damage[DCOMPTR]==0) proutn(&quot;%d&quot;, irec);
-		else proutn(&quot;??&quot;);
-		proutn(&quot;)  &quot;);
-		proutn(&quot;units to fire at &quot;);
-		crmena(0, ienm, 2, ii, jj);
-		proutn(&quot;-  &quot;);
-		key = scan();
-	    }
-	    if (key == IHALPHA &amp;&amp; isit(&quot;no&quot;)) {
-		no = 1;
-		key = scan();
-		continue;
-	    }
-	    if (key == IHALPHA) {
-		huh();
-		return;
-	    }
-	    if (key == IHEOL) {
-		if (k==1) { /* Let me say I'm baffled by this */
-		    msgflag = 1;
-		}
-		continue;
-	    }
-	    if (aaitem &lt; 0) {
-		/* abort out */
-		chew();
-		return;
-	    }
-	    hits[k] = aaitem;
-	    rpow += aaitem;
-	    /* If total requested is too much, inform and start over */
-				
-	    if (rpow &gt; (ifast?energy-200:energy)) {
-		prout(&quot;Available energy exceeded -- try again.&quot;);
-		chew();
-		return;
-	    }
-	    key = scan(); /* scan for next value */
-	    k++;
-	}
-	if (rpow == 0.0) {
-	    /* zero energy -- abort */
-	    chew();
-	    return;
-	}
-	if (key == IHALPHA &amp;&amp; isit(&quot;no&quot;)) {
-	    no = 1;
-	}
-	energy -= rpow;
-	chew();
-	if (ifast) {
-	    energy -= 200.0;
-	    if (checkshctrl(rpow)) return;
-	}
-	hittem(hits);
-	ididit=1;
-    case NOTSET:;	/* avoid gcc warning */
-    }
-    /* Say shield raised or malfunction, if necessary */
-    if (alldone) 
-	return;
-    if (ifast) {
-	skip(1);
-	if (no == 0) {
-	    if (Rand() &gt;= 0.99) {
-		prout(&quot;Sulu-  \&quot;Sir, the high-speed shield control has malfunctioned . . .&quot;);
-		prouts(&quot;         CLICK   CLICK   POP  . . .&quot;);
-		prout(&quot; No  response, sir!&quot;);
-		shldup = 0;
-	    }
-	    else
-		prout(&quot;Shields raised.&quot;);
-	}
-	else
-	    shldup = 0;
-    }
-    overheat(rpow);
-}
-
-void hittem(double *hits) 
-{
-    double kp, kpow, wham, hit, dustfac, kpini;
-    int nenhr2=nenhere, k=1, kk=1, ii, jj, ienm;
-
-    skip(1);
-
-    for (; k &lt;= nenhr2; k++, kk++) {
-	if ((wham = hits[k])==0) continue;
-	dustfac = 0.9 + 0.01*Rand();
-	hit = wham*pow(dustfac,game.kdist[kk]);
-	kpini = game.kpower[kk];
-	kp = fabs(kpini);
-	if (PHASEFAC*hit &lt; kp) kp = PHASEFAC*hit;
-	game.kpower[kk] -= (game.kpower[kk] &lt; 0 ? -kp: kp);
-	kpow = game.kpower[kk];
-	ii = game.kx[kk];
-	jj = game.ky[kk];
-	if (hit &gt; 0.005) {
-	    if (game.damage[DSRSENS]==0)
-		boom(ii, jj);
-	    proutn(&quot;%d unit hit on &quot;, (int)hit);
-	}
-	else
-	    proutn(&quot;Very small hit on &quot;);
-	ienm = game.quad[ii][jj];
-	if (ienm==IHQUEST) iqengry=1;
-	crmena(0,ienm,2,ii,jj);
-	skip(1);
-	if (kpow == 0) {
-	    deadkl(ii, jj, ienm, ii, jj);
-	    if (KLINGREM==0) finish(FWON);
-	    if (alldone) return;
-	    kk--; /* don't do the increment */
-	}
-	else /* decide whether or not to emasculate klingon */
-	    if (kpow &gt; 0 &amp;&amp; Rand() &gt;= 0.9 &amp;&amp;
-		kpow &lt;= ((0.4 + 0.4*Rand())*kpini)) {
-		prout(&quot;***Mr. Spock-  \&quot;Captain, the vessel at &quot;,
-		      cramlc(sector,ii,jj));
-		prout(&quot;   has just lost its firepower.\&quot;&quot;);
-		game.kpower[kk] = -kpow;
-	    }
-    }
-    return;
-}
-

Copied: trunk/compile (from rev 538, branches/at-work/compile)

Copied: trunk/config.guess (from rev 538, branches/at-work/config.guess)

Copied: trunk/config.rpath (from rev 538, branches/at-work/config.rpath)

Copied: trunk/config.sub (from rev 538, branches/at-work/config.sub)

Copied: trunk/configure (from rev 538, branches/at-work/configure)

Copied: trunk/configure.ac (from rev 538, branches/at-work/configure.ac)

Copied: trunk/depcomp (from rev 538, branches/at-work/depcomp)

Copied: trunk/doc (from rev 538, branches/at-work/doc)

Deleted: trunk/events.c
===================================================================
--- trunk/events.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/events.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,755 +0,0 @@
-#include &quot;sst.h&quot;
-#include &lt;math.h&gt;
-
-void events(void) 
-{
-    int ictbeam=0, ipage=0, istract=0, line, i=0, j, k, l, ixhold=0, iyhold=0;
-    double fintim = game.state.date + Time, datemin, xtime, repair, yank=0;
-    int radio_was_broken;
-
-#ifdef DEBUG
-    if (idebug) prout(&quot;EVENTS&quot;);
-#endif
-
-    radio_was_broken = (game.damage[DRADIO] != 0.0);
-
-    for (;;) {
-	/* Select earliest extraneous event, line==0 if no events */
-	line = FSPY;
-	if (alldone) return;
-	datemin = fintim;
-	for (l = 1; l &lt; NEVENTS; l++)
-	    if (game.future[l] &lt; datemin) {
-		line = l;
-		datemin = game.future[l];
-	    }
-	xtime = datemin-game.state.date;
-	game.state.date = datemin;
-	/* Decrement Federation resources and recompute remaining time */
-	game.state.remres -= (game.state.remkl+4*game.state.remcom)*xtime;
-	game.state.remtime = game.state.remres/(game.state.remkl+4*game.state.remcom);
-	if (game.state.remtime &lt;=0) {
-	    finish(FDEPLETE);
-	    return;
-	}
-	/* Is life support adequate? */
-	if (game.damage[DLIFSUP] &amp;&amp; condit != IHDOCKED) {
-	    if (lsupres &lt; xtime &amp;&amp; game.damage[DLIFSUP] &gt; lsupres) {
-		finish(FLIFESUP);
-		return;
-	    }
-	    lsupres -= xtime;
-	    if (game.damage[DLIFSUP] &lt;= xtime) lsupres = inlsr;
-	}
-	/* Fix devices */
-	repair = xtime;
-	if (condit == IHDOCKED) repair /= docfac;
-	/* Don't fix Deathray here */
-	for (l=0; l&lt;NDEVICES; l++)
-	    if (game.damage[l] &gt; 0.0 &amp;&amp; l != DDRAY)
-		game.damage[l] -= (game.damage[l]-repair &gt; 0.0 ? repair : game.damage[l]);
-	/* If radio repaired, update star chart and attack reports */
-	if (radio_was_broken &amp;&amp; game.damage[DRADIO] == 0.0) {
-	    prout(&quot;Lt. Uhura- \&quot;Captain, the sub-space radio is working and&quot;);
-	    prout(&quot;   surveillance reports are coming in.&quot;);
-	    skip(1);
-	    if (iseenit==0) {
-		attakreport(0);
-		iseenit = 1;
-	    }
-	    rechart();
-	    prout(&quot;   The star chart is now up to date.\&quot;&quot;);
-	    skip(1);
-	}
-	/* Cause extraneous event LINE to occur */
-	Time -= xtime;
-	switch (line) {
-	case FSNOVA: /* Supernova */
-	    if (ipage==0) pause_game(1);
-	    ipage=1;
-	    snova(0,0);
-	    game.future[FSNOVA] = game.state.date + expran(0.5*intime);
-	    if (game.state.galaxy[quadx][quady].supernova) return;
-	    break;
-	case FSPY: /* Check with spy to see if S.C. should tractor beam */
-	    if (game.state.nscrem == 0 ||
-		ictbeam+istract &gt; 0 ||
-		condit==IHDOCKED || isatb==1 || iscate==1) return;
-	    if (ientesc ||
-		(energy &lt; 2000 &amp;&amp; torps &lt; 4 &amp;&amp; shield &lt; 1250) ||
-		(game.damage[DPHASER]&gt;0 &amp;&amp; (game.damage[DPHOTON]&gt;0 || torps &lt; 4)) ||
-		(game.damage[DSHIELD] &gt; 0 &amp;&amp;
-		 (energy &lt; 2500 || game.damage[DPHASER] &gt; 0) &amp;&amp;
-		 (torps &lt; 5 || game.damage[DPHOTON] &gt; 0))) {
-		/* Tractor-beam her! */
-		istract=1;
-		yank = square(game.state.isx-quadx) + square(game.state.isy-quady);
-		/********* fall through to FTBEAM code ***********/
-	    }
-	    else return;
-	case FTBEAM: /* Tractor beam */
-	    if (line==FTBEAM) {
-		if (game.state.remcom == 0) {
-		    game.future[FTBEAM] = FOREVER;
-		    break;
-		}
-		i = Rand()*game.state.remcom+1.0;
-		yank = square(game.state.cx[i]-quadx) + square(game.state.cy[i]-quady);
-		if (istract || condit == IHDOCKED || yank == 0) {
-		    /* Drats! Have to reschedule */
-		    game.future[FTBEAM] = game.state.date + Time +
-			expran(1.5*intime/game.state.remcom);
-		    break;
-		}
-	    }
-	    /* tractor beaming cases merge here */
-	    yank = sqrt(yank);
-	    if (ipage==0) pause_game(1);
-	    ipage=1;
-	    Time = (10.0/(7.5*7.5))*yank; /* 7.5 is yank rate (warp 7.5) */
-	    ictbeam = 1;
-	    skip(1);
-	    proutn(&quot;***&quot;);
-	    crmshp();
-	    prout(&quot; caught in long range tractor beam--&quot;);
-	    /* If Kirk &amp; Co. screwing around on planet, handle */
-	    atover(1); /* atover(1) is Grab */
-	    if (alldone) return;
-	    if (icraft == 1) { /* Caught in Galileo? */
-		finish(FSTRACTOR);
-		return;
-	    }
-	    /* Check to see if shuttle is aboard */
-	    if (iscraft==0) {
-		skip(1);
-		if (Rand() &gt; 0.5) {
-		    prout(&quot;Galileo, left on the planet surface, is captured&quot;);
-		    prout(&quot;by aliens and made into a flying McDonald's.&quot;);
-		    game.damage[DSHUTTL] = -10;
-		    iscraft = -1;
-		}
-		else {
-		    prout(&quot;Galileo, left on the planet surface, is well hidden.&quot;);
-		}
-	    }
-	    if (line==0) {
-		quadx = game.state.isx;
-		quady = game.state.isy;
-	    }
-	    else {
-		quadx = game.state.cx[i];
-		quady = game.state.cy[i];
-	    }
-	    iran(QUADSIZE, &amp;sectx, &amp;secty);
-	    crmshp();
-	    proutn(&quot; is pulled to &quot;);
-	    proutn(cramlc(quadrant, quadx, quady));
-	    proutn(&quot;, &quot;);
-	    prout(cramlc(sector, sectx, secty));
-	    if (resting) {
-		prout(&quot;(Remainder of rest/repair period cancelled.)&quot;);
-		resting = 0;
-	    }
-	    if (shldup==0) {
-		if (game.damage[DSHIELD]==0 &amp;&amp; shield &gt; 0) {
-		    doshield(2); /* Shldsup */
-		    shldchg=0;
-		}
-		else prout(&quot;(Shields not currently useable.)&quot;);
-	    }
-	    newqad(0);
-	    /* Adjust finish time to time of tractor beaming */
-	    fintim = game.state.date+Time;
-	    attack(0);
-	    if (game.state.remcom &lt;= 0) game.future[FTBEAM] = FOREVER;
-	    else game.future[FTBEAM] = game.state.date+Time+expran(1.5*intime/game.state.remcom);
-	    break;
-	case FSNAP: /* Snapshot of the universe (for time warp) */
-	    game.snapsht = game.state;
-	    game.state.snap = 1;
-	    game.future[FSNAP] = game.state.date + expran(0.5 * intime);
-	    break;
-	case FBATTAK: /* Commander attacks starbase */
-	    if (game.state.remcom==0 || game.state.rembase==0) {
-		/* no can do */
-		game.future[FBATTAK] = game.future[FCDBAS] = FOREVER;
-		break;
-	    }
-	    i = 0;
-	    for_starbases(j) {
-		for_commanders(k)
-		    if (game.state.baseqx[j]==game.state.cx[k] &amp;&amp; game.state.baseqy[j]==game.state.cy[k] &amp;&amp;
-			(game.state.baseqx[j]!=quadx || game.state.baseqy[j]!=quady) &amp;&amp;
-			(game.state.baseqx[j]!=game.state.isx || game.state.baseqy[j]!=game.state.isy)) {
-			i = 1;
-			break;
-		    }
-		if (i == 1) break;
-	    }
-	    if (j&gt;game.state.rembase) {
-		/* no match found -- try later */
-		game.future[FBATTAK] = game.state.date + expran(0.3*intime);
-		game.future[FCDBAS] = FOREVER;
-		break;
-	    }
-	    /* commander + starbase combination found -- launch attack */
-	    batx = game.state.baseqx[j];
-	    baty = game.state.baseqy[j];
-	    game.future[FCDBAS] = game.state.date+1.0+3.0*Rand();
-	    if (isatb) /* extra time if SC already attacking */
-		game.future[FCDBAS] += game.future[FSCDBAS]-game.state.date;
-	    game.future[FBATTAK] = game.future[FCDBAS] +expran(0.3*intime);
-	    iseenit = 0;
-	    if (game.damage[DRADIO] != 0.0 &amp;&amp;
-		condit != IHDOCKED) break; /* No warning :-( */
-	    iseenit = 1;
-	    if (ipage==0) pause_game(1);
-	    ipage = 1;
-	    skip(1);
-	    proutn(&quot;Lt. Uhura-  \&quot;Captain, the starbase in &quot;);
-	    prout(cramlc(quadrant, batx, baty));
-	    prout(&quot;   reports that it is under attack and that it can&quot;);
-	    proutn(&quot;   hold out only until stardate %d&quot;,
-		   (int)game.future[FCDBAS]);
-	    prout(&quot;.\&quot;&quot;);
-	    if (resting) {
-		skip(1);
-		proutn(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot; &quot;);
-		if (ja()) {
-		    resting = 0;
-		    Time = 0.0;
-		    return;
-		}
-	    }
-	    break;
-	case FSCDBAS: /* Supercommander destroys base */
-	    game.future[FSCDBAS] = FOREVER;
-	    isatb = 2;
-	    if (!game.state.galaxy[game.state.isx][game.state.isy].starbase) 
-		break; /* WAS RETURN! */
-	    ixhold = batx;
-	    iyhold = baty;
-	    batx = game.state.isx;
-	    baty = game.state.isy;
-	case FCDBAS: /* Commander succeeds in destroying base */
-	    if (line==FCDBAS) {
-		game.future[FCDBAS] = FOREVER;
-		/* find the lucky pair */
-		for_commanders(i)
-		    if (game.state.cx[i]==batx &amp;&amp; game.state.cy[i]==baty) 
-			break;
-		if (i &gt; game.state.remcom || game.state.rembase == 0 ||
-		    !game.state.galaxy[batx][baty].starbase) {
-		    /* No action to take after all */
-		    batx = baty = 0;
-		    break;
-		}
-	    }
-	    /* Code merges here for any commander destroying base */
-	    /* Not perfect, but will have to do */
-	    /* Handle case where base is in same quadrant as starship */
-	    if (batx==quadx &amp;&amp; baty==quady) {
-		game.state.chart[batx][baty].starbase = FALSE;
-		game.quad[basex][basey]= IHDOT;
-		basex=basey=0;
-		newcnd();
-		skip(1);
-		prout(&quot;Spock-  \&quot;Captain, I believe the starbase has been destroyegame.state.\&quot;&quot;);
-	    }
-	    else if (game.state.rembase != 1 &amp;&amp;
-		     (game.damage[DRADIO] &lt;= 0.0 || condit == IHDOCKED)) {
-		/* Get word via subspace radio */
-		if (ipage==0) pause_game(1);
-		ipage = 1;
-		skip(1);
-		prout(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Command reports that&quot;);
-		proutn(&quot;   the starbase in &quot;);
-		proutn(cramlc(quadrant, batx, baty));
-		prout(&quot; has been destroyed by&quot;);
-		if (isatb==2) prout(&quot;the Klingon Super-Commander&quot;);
-		else prout(&quot;a Klingon Commander&quot;);
-		game.state.chart[batx][baty].starbase = FALSE;
-	    }
-	    /* Remove Starbase from galaxy */
-	    game.state.galaxy[batx][baty].starbase = FALSE;
-	    for_starbases(i)
-		if (game.state.baseqx[i]==batx &amp;&amp; game.state.baseqy[i]==baty) {
-		    game.state.baseqx[i]=game.state.baseqx[game.state.rembase];
-		    game.state.baseqy[i]=game.state.baseqy[game.state.rembase];
-		}
-	    game.state.rembase--;
-	    if (isatb == 2) {
-		/* reinstate a commander's base attack */
-		batx = ixhold;
-		baty = iyhold;
-		isatb = 0;
-	    }
-	    else {
-		batx = baty = 0;
-	    }
-	    break;
-	case FSCMOVE: /* Supercommander moves */
-	    game.future[FSCMOVE] = game.state.date+0.2777;
-	    if (ientesc+istract==0 &amp;&amp;
-		isatb!=1 &amp;&amp;
-		(iscate!=1 || justin==1)) scom(&amp;ipage);
-	    break;
-	case FDSPROB: /* Move deep space probe */
-	    game.future[FDSPROB] = game.state.date + 0.01;
-	    probex += probeinx;
-	    probey += probeiny;
-	    i = (int)(probex/QUADSIZE +0.05);
-	    j = (int)(probey/QUADSIZE + 0.05);
-	    if (probecx != i || probecy != j) {
-		probecx = i;
-		probecy = j;
-		if (!VALID_QUADRANT(i, j) ||
-		    game.state.galaxy[probecx][probecy].supernova) {
-		    // Left galaxy or ran into supernova
-		    if (game.damage[DRADIO]==0.0 || condit == IHDOCKED) {
-			if (ipage==0) pause_game(1);
-			ipage = 1;
-			skip(1);
-			proutn(&quot;Lt. Uhura-  \&quot;The deep space probe &quot;);
-			if (!VALID_QUADRANT(j, i))
-			    proutn(&quot;has left the galaxy&quot;);
-			else
-			    proutn(&quot;is no longer transmitting&quot;);
-			prout(&quot;.\&quot;&quot;);
-		    }
-		    game.future[FDSPROB] = FOREVER;
-		    break;
-		}
-		if (game.damage[DRADIO]==0.0   || condit == IHDOCKED) {
-		    if (ipage==0) pause_game(1);
-		    ipage = 1;
-		    skip(1);
-		    proutn(&quot;Lt. Uhura-  \&quot;The deep space probe is now in &quot;);
-		    proutn(cramlc(quadrant, probecx, probecy));
-		    prout(&quot;.\&quot;&quot;);
-		}
-	    }
-	    /* Update star chart if Radio is working or have access to
-	       radio. */
-	    if (game.damage[DRADIO] == 0.0 || condit == IHDOCKED) {
-		game.state.chart[probecx][probecy].klingons = game.state.galaxy[probecx][probecy].klingons;
-		game.state.chart[probecx][probecy].starbase = game.state.galaxy[probecx][probecy].starbase;
-		game.state.chart[probecx][probecy].stars = game.state.galaxy[probecx][probecy].stars;
-		game.state.galaxy[probecx][probecy].charted = TRUE;
-	    }
-	    proben--; // One less to travel
-	    if (proben == 0 &amp;&amp; isarmed &amp;&amp;
-		game.state.galaxy[probecx][probecy].stars) {
-		/* lets blow the sucker! */
-		snova(1,0);
-		game.future[FDSPROB] = FOREVER;
-		if (game.state.galaxy[quadx][quady].supernova) 
-		    return;
-	    }
-	    break;
-	}
-    }
-}
-
-				
-void wait(void) 
-{
-    int key;
-    double temp, delay, origTime;
-
-    ididit = 0;
-    for (;;) {
-	key = scan();
-	if (key  != IHEOL) break;
-	proutn(&quot;How long? &quot;);
-    }
-    chew();
-    if (key != IHREAL) {
-	huh();
-	return;
-    }
-    origTime = delay = aaitem;
-    if (delay &lt;= 0.0) return;
-    if (delay &gt;= game.state.remtime || nenhere != 0) {
-	proutn(&quot;Are you sure? &quot;);
-	if (ja() == 0) return;
-    }
-
-    /* Alternate resting periods (events) with attacks */
-
-    resting = 1;
-    do {
-	if (delay &lt;= 0) resting = 0;
-	if (resting == 0) {
-	    prout(&quot;%d stardates left.&quot;, (int)game.state.remtime);
-	    return;
-	}
-	temp = Time = delay;
-
-	if (nenhere) {
-	    double rtime = 1.0 + Rand();
-	    if (rtime &lt; temp) temp = rtime;
-	    Time = temp;
-	}
-	if (Time &lt; delay) attack(0);
-	if (alldone) return;
-	events();
-	ididit = 1;
-	if (alldone) return;
-	delay -= temp;
-	/* Repair Deathray if long rest at starbase */
-	if (origTime-delay &gt;= 9.99 &amp;&amp; condit == IHDOCKED)
-	    game.damage[DDRAY] = 0.0;
-    } while 
-	// leave if quadrant supernovas
-	(!game.state.galaxy[quadx][quady].supernova);
-
-    resting = 0;
-    Time = 0;
-}
-
-void nova(int ix, int iy) 
-{
-    static double course[] =
-	{0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5};
-    int bot, top, top2, hits[QUADSIZE+1][3], kount, icx, icy, mm, nn, j;
-    int iquad, iquad1, i, ll, newcx, newcy, ii, jj;
-    if (Rand() &lt; 0.05) {
-	/* Wow! We've supernova'ed */
-	snova(ix, iy);
-	return;
-    }
-
-    /* handle initial nova */
-    game.quad[ix][iy] = IHDOT;
-    crmena(1, IHSTAR, 2, ix, iy);
-    prout(&quot; novas.&quot;);
-    game.state.galaxy[quadx][quady].stars--;
-    game.state.starkl++;
-	
-    /* Set up stack to recursively trigger adjacent stars */
-    bot = top = top2 = 1;
-    kount = 0;
-    icx = icy = 0;
-    hits[1][1] = ix;
-    hits[1][2] = iy;
-    while (1) {
-	for (mm = bot; mm &lt;= top; mm++) 
-	    for (nn = 1; nn &lt;= 3; nn++)  /* nn,j represents coordinates around current */
-		for (j = 1; j &lt;= 3; j++) {
-		    if (j==2 &amp;&amp; nn== 2) continue;
-		    ii = hits[mm][1]+nn-2;
-		    jj = hits[mm][2]+j-2;
-		    if (!VALID_SECTOR(jj, ii)) continue;
-		    iquad = game.quad[ii][jj];
-		    switch (iquad) {
-		    // case IHDOT:	/* Empty space ends reaction
-		    // case IHQUEST:
-		    // case IHBLANK:
-		    // case IHT:
-		    // case IHWEB:
-		    default:
-			break;
-		    case IHSTAR: /* Affect another star */
-			if (Rand() &lt; 0.05) {
-			    /* This star supernovas */
-			    snova(ii,jj);
-			    return;
-			}
-			top2++;
-			hits[top2][1]=ii;
-			hits[top2][2]=jj;
-			game.state.galaxy[quadx][quady].stars -= 1;
-			game.state.starkl++;
-			crmena(1, IHSTAR, 2, ii, jj);
-			prout(&quot; novas.&quot;);
-			game.quad[ii][jj] = IHDOT;
-			break;
-		    case IHP: /* Destroy planet */
-			game.state.galaxy[quadx][quady].planets -= 1;
-			game.state.nplankl++;
-			crmena(1, IHP, 2, ii, jj);
-			prout(&quot; destroyed.&quot;);
-			DESTROY(&amp;game.state.plnets[iplnet]);
-			iplnet = plnetx = plnety = 0;
-			if (landed == 1) {
-			    finish(FPNOVA);
-			    return;
-			}
-			game.quad[ii][jj] = IHDOT;
-			break;
-		    case IHB: /* Destroy base */
-			game.state.galaxy[quadx][quady].starbase = FALSE;
-			for_starbases(i)
-			    if (game.state.baseqx[i]==quadx &amp;&amp; game.state.baseqy[i]==quady) 
-				break;
-			game.state.baseqx[i] = game.state.baseqx[game.state.rembase];
-			game.state.baseqy[i] = game.state.baseqy[game.state.rembase];
-			game.state.rembase--;
-			basex = basey = 0;
-			game.state.basekl++;
-			newcnd();
-			crmena(1, IHB, 2, ii, jj);
-			prout(&quot; destroyed.&quot;);
-			game.quad[ii][jj] = IHDOT;
-			break;
-		    case IHE: /* Buffet ship */
-		    case IHF:
-			prout(&quot;***Starship buffeted by nova.&quot;);
-			if (shldup) {
-			    if (shield &gt;= 2000.0) shield -= 2000.0;
-			    else {
-				double diff = 2000.0 - shield;
-				energy -= diff;
-				shield = 0.0;
-				shldup = 0;
-				prout(&quot;***Shields knocked out.&quot;);
-				game.damage[DSHIELD] += 0.005*damfac*Rand()*diff;
-			    }
-			}
-			else energy -= 2000.0;
-			if (energy &lt;= 0) {
-			    finish(FNOVA);
-			    return;
-			}
-			/* add in course nova contributes to kicking starship*/
-			icx += sectx-hits[mm][1];
-			icy += secty-hits[mm][2];
-			kount++;
-			break;
-		    case IHK: /* kill klingon */
-			deadkl(ii,jj,iquad, ii, jj);
-			break;
-		    case IHC: /* Damage/destroy big enemies */
-		    case IHS:
-		    case IHR:
-			for_local_enemies(ll)
-			    if (game.kx[ll]==ii &amp;&amp; game.ky[ll]==jj) break;
-			game.kpower[ll] -= 800.0; /* If firepower is lost, die */
-			if (game.kpower[ll] &lt;= 0.0) {
-			    deadkl(ii, jj, iquad, ii, jj);
-			    break;
-			}
-			newcx = ii + ii - hits[mm][1];
-			newcy = jj + jj - hits[mm][2];
-			crmena(1, iquad, 2, ii, jj);
-			proutn(&quot; damaged&quot;);
-			if (!VALID_SECTOR(newcx, newcy)) {
-			    /* can't leave quadrant */
-			    skip(1);
-			    break;
-			}
-			iquad1 = game.quad[newcx][newcy];
-			if (iquad1 == IHBLANK) {
-			    proutn(&quot;, blasted into &quot;);
-			    crmena(0, IHBLANK, 2, newcx, newcy);
-			    skip(1);
-			    deadkl(ii, jj, iquad, newcx, newcy);
-			    break;
-			}
-			if (iquad1 != IHDOT) {
-			    /* can't move into something else */
-			    skip(1);
-			    break;
-			}
-			proutn(&quot;, buffeted to &quot;);
-			proutn(cramlc(sector, newcx, newcy));
-			game.quad[ii][jj] = IHDOT;
-			game.quad[newcx][newcy] = iquad;
-			game.kx[ll] = newcx;
-			game.ky[ll] = newcy;
-			game.kavgd[ll] = sqrt(square(sectx-newcx)+square(secty-newcy));
-			game.kdist[ll] = game.kavgd[ll];
-			skip(1);
-			break;
-		    }
-		}
-	if (top == top2) 
-	    break;
-	bot = top + 1;
-	top = top2;
-    }
-    if (kount==0) 
-	return;
-
-    /* Starship affected by nova -- kick it away. */
-    dist = kount*0.1;
-    if (icx) icx = (icx &lt; 0 ? -1 : 1);
-    if (icy) icy = (icy &lt; 0 ? -1 : 1);
-    direc = course[3*(icx+1)+icy+2];
-    if (direc == 0.0) dist = 0.0;
-    if (dist == 0.0) return;
-    Time = 10.0*dist/16.0;
-    skip(1);
-    prout(&quot;Force of nova displaces starship.&quot;);
-    iattak=2;	/* Eliminates recursion problem */
-    imove();
-    Time = 10.0*dist/16.0;
-    return;
-}
-	
-	
-void snova(int insx, int insy) 
-{
-    int comdead, nqx=0, nqy=0, nsx, nsy, num=0, kldead, iscdead;
-    int nrmdead, npdead;
-    int incipient=0;
-
-    nsx = insy;
-    nsy = insy;
-
-    if (insy== 0) {
-	if (insx == 1) {
-	    /* NOVAMAX being used */
-	    nqx = probecx;
-	    nqy = probecy;
-	}
-	else {
-	    int stars = 0;
-	    /* Scheduled supernova -- select star */
-	    /* logic changed here so that we won't favor quadrants in top
-	       left of universe */
-	    for_quadrants(nqx) {
-		for_quadrants(nqy) {
-		    stars += game.state.galaxy[nqx][nqy].stars;
-		}
-	    }
-	    if (stars == 0) return; /* nothing to supernova exists */
-	    num = Rand()*stars + 1;
-	    for_quadrants(nqx) {
-		for_quadrants(nqy) {
-		    num -= game.state.galaxy[nqx][nqy].stars;
-		    if (num &lt;= 0) break;
-		}
-		if (num &lt;=0) break;
-	    }
-#ifdef DEBUG
-	    if (idebug) {
-		proutn(&quot;Super nova here?&quot;);
-		if (ja()==1) {
-		    nqx = quadx;
-		    nqy = quady;
-		}
-	    }
-#endif
-	}
-
-	if (nqx != quady || nqy != quady || justin != 0) {
-	    /* it isn't here, or we just entered (treat as inroute) */
-	    if (game.damage[DRADIO] == 0.0 || condit == IHDOCKED) {
-		skip(1);
-		prout(&quot;Message from Starfleet Command       Stardate %.2f&quot;, game.state.date);
-		prout(&quot;     Supernova in %s; caution advised.&quot;,
-		      cramlc(quadrant, nqx, nqy));
-	    }
-	}
-	else {
-	    /* we are in the quadrant! */
-	    incipient = 1;
-	    num = Rand()* game.state.galaxy[nqx][nqy].stars + 1;
-	    for_sectors(nsx) {
-		for_sectors(nsy) {
-		    if (game.quad[nsx][nsy]==IHSTAR) {
-			num--;
-			if (num==0) break;
-		    }
-		}
-		if (num==0) break;
-	    }
-	}
-    }
-    else {
-	incipient = 1;
-    }
-
-    if (incipient) {
-	skip(1);
-	prouts(&quot;***RED ALERT!  RED ALERT!&quot;);
-	skip(1);
-	prout(&quot;***Incipient supernova detected at &quot;, cramlc(sector, nsx, nsy));
-	nqx = quadx;
-	nqy = quady;
-	if (square(nsx-sectx) + square(nsy-secty) &lt;= 2.1) {
-	    proutn(&quot;Emergency override attempts t&quot;);
-	    prouts(&quot;***************&quot;);
-	    skip(1);
-	    stars();
-	    alldone=1;
-	}
-    }
-    /* destroy any Klingons in supernovaed quadrant */
-    kldead = game.state.galaxy[nqx][nqy].klingons;
-    game.state.galaxy[nqx][nqy].klingons = 0;
-    comdead = iscdead = 0;
-    if (nqx==game.state.isx &amp;&amp; nqy == game.state.isy) {
-	/* did in the Supercommander! */
-	game.state.nscrem = game.state.isx = game.state.isy = isatb = iscate = 0;
-	iscdead = 1;
-	game.future[FSCMOVE] = game.future[FSCDBAS] = FOREVER;
-    }
-    if (game.state.remcom) {
-	int maxloop = game.state.remcom, l;
-	for (l = 1; l &lt;= maxloop; l++) {
-	    if (game.state.cx[l] == nqx &amp;&amp; game.state.cy[l] == nqy) {
-		game.state.cx[l] = game.state.cx[game.state.remcom];
-		game.state.cy[l] = game.state.cy[game.state.remcom];
-		game.state.cx[game.state.remcom] = game.state.cy[game.state.remcom] = 0;
-		game.state.remcom--;
-		kldead--;
-		comdead++;
-		if (game.state.remcom==0) game.future[FTBEAM] = FOREVER;
-		break;
-	    }
-	}
-    }
-    game.state.remkl -= kldead;
-    /* destroy Romulans and planets in supernovaed quadrant */
-    nrmdead = game.state.galaxy[nqx][nqy].romulans;
-    game.state.galaxy[nqx][nqy].romulans = 0;
-    game.state.nromrem -= nrmdead;
-    npdead = num - nrmdead*10;
-    if (npdead) {
-	int l;
-	for (l = 0; l &lt; inplan; l++)
-	    if (game.state.plnets[l].x == nqx &amp;&amp; game.state.plnets[l].y == nqy) {
-		DESTROY(&amp;game.state.plnets[l]);
-	    }
-    }
-    /* Destroy any base in supernovaed quadrant */
-    if (game.state.rembase) {
-	int maxloop = game.state.rembase, l;
-	for (l = 1; l &lt;= maxloop; l++)
-	    if (game.state.baseqx[l]==nqx &amp;&amp; game.state.baseqy[l]==nqy) {
-		game.state.baseqx[l] = game.state.baseqx[game.state.rembase];
-		game.state.baseqy[l] = game.state.baseqy[game.state.rembase];
-		game.state.baseqx[game.state.rembase] = game.state.baseqy[game.state.rembase] = 0;
-		game.state.rembase--;
-		break;
-	    }
-    }
-    /* If starship caused supernova, tally up destruction */
-    if (insx) {
-	game.state.starkl += game.state.galaxy[nqx][nqy].stars;
-	game.state.basekl += game.state.galaxy[nqx][nqy].starbase;
-	game.state.nplankl += npdead;
-    }
-    /* mark supernova in galaxy and in star chart */
-    if ((quadx == nqx &amp;&amp; quady == nqy) ||
-	game.damage[DRADIO] == 0 ||
-	condit == IHDOCKED)
-	game.state.galaxy[nqx][nqy].supernova = TRUE;
-    /* If supernova destroys last klingons give special message */
-    if (KLINGREM==0 &amp;&amp; (nqx != quadx || nqy != quady)) {
-	skip(2);
-	if (insx == 0) prout(&quot;Lucky you!&quot;);
-	proutn(&quot;A supernova in %s has just destroyed the last Klingons.&quot;,
-	       cramlc(quadrant, nqx, nqy));
-	finish(FWON);
-	return;
-    }
-    /* if some Klingons remain, continue or die in supernova */
-    if (alldone) finish(FSNOVAED);
-    return;
-}
-		
-				

Deleted: trunk/finish.c
===================================================================
--- trunk/finish.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/finish.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,453 +0,0 @@
-#include &quot;sst.h&quot;
-#include &lt;string.h&gt;
-#include &lt;time.h&gt;
-
-void dstrct() 
-{
-    /* Finish with a BANG! */
-    chew();
-    if (game.damage[DCOMPTR] != 0.0) {
-	prout(&quot;Computer damaged; cannot execute destruct sequence.&quot;);
-	return;
-    }
-    prouts(&quot;---WORKING---&quot;); skip(1);
-    prouts(&quot;SELF-DESTRUCT-SEQUENCE-ACTIVATED&quot;); skip(1);
-    prouts(&quot;   10&quot;); skip(1);
-    prouts(&quot;       9&quot;); skip(1);
-    prouts(&quot;          8&quot;); skip(1);
-    prouts(&quot;             7&quot;); skip(1);
-    prouts(&quot;                6&quot;); skip(1);
-    skip(1);
-    prout(&quot;ENTER-CORRECT-PASSWORD-TO-CONTINUE-&quot;);
-    skip(1);
-    prout(&quot;SELF-DESTRUCT-SEQUENCE-OTHERWISE-&quot;);
-    skip(1);
-    prout(&quot;SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED&quot;);
-    skip(1);
-    scan();
-    chew();
-    if (strcmp(game.passwd, citem) != 0) {
-	prouts(&quot;PASSWORD-REJECTED;&quot;); skip(1);
-	prouts(&quot;CONTINUITY-EFFECTED&quot;);
-	skip(2);
-	return;
-    }
-    prouts(&quot;PASSWORD-ACCEPTED&quot;); skip(1);
-    prouts(&quot;                   5&quot;); skip(1);
-    prouts(&quot;                      4&quot;); skip(1);
-    prouts(&quot;                         3&quot;); skip(1);
-    prouts(&quot;                            2&quot;); skip(1);
-    prouts(&quot;                              1&quot;); skip(1);
-    if (Rand() &lt; 0.15) {
-	prouts(&quot;GOODBYE-CRUEL-WORLD&quot;);
-	skip(1);
-    }
-    kaboom();
-}
-
-void kaboom(void) 
-{
-    stars();
-    if (ship==IHE) prouts(&quot;***&quot;);
-    prouts(&quot;********* Entropy of &quot;);
-    crmshp();
-    prouts(&quot; maximized *********&quot;);
-    skip(1);
-    stars();
-    skip(1);
-    if (nenhere != 0) {
-	double whammo = 25.0 * energy;
-	int l=1;
-	while (l &lt;= nenhere) {
-	    if (game.kpower[l]*game.kdist[l] &lt;= whammo) 
-		deadkl(game.kx[l],game.ky[l], game.quad[game.kx[l]][game.ky[l]], game.kx[l], game.ky[l]);
-	    l++;
-	}
-    }
-    finish(FDILITHIUM);
-}
-				
-
-void finish(FINTYPE ifin) 
-{
-    int igotit = 0;
-    alldone = 1;
-    skip(3);
-    prout(&quot;It is stardate %.1f.&quot;, game.state.date);
-    skip(1);
-    switch (ifin) {
-    case FWON: // Game has been won
-	if (game.state.nromrem != 0)
-	    prout(&quot;The remaining %d Romulans surrender to Starfleet Command.&quot;,
-		  game.state.nromrem);
-
-	prout(&quot;You have smashed the Klingon invasion fleet and saved&quot;);
-	prout(&quot;the Federation.&quot;);
-	gamewon=1;
-	if (alive) {
-	    double badpt;
-	    badpt = 5.0*game.state.starkl + casual + 10.0*game.state.nplankl +
-		45.*nhelp+100.*game.state.basekl;
-	    if (ship == IHF) badpt += 100.0;
-	    else if (ship == 0) badpt += 200.0;
-	    if (badpt &lt; 100.0) badpt = 0.0;	// Close enough!
-	    if (game.state.date-indate &lt; 5.0 ||
-		// killsPerDate &gt;= RateMax
-		KLINGKILLED/(game.state.date-indate) &gt;=
-		0.1*skill*(skill+1.0) + 0.1 + 0.008*badpt) {
-		skip(1);
-		prout(&quot;In fact, you have done so well that Starfleet Command&quot;);
-		switch (skill) {
-		case SKILL_NOVICE:
-		    prout(&quot;promotes you one step in rank from \&quot;Novice\&quot; to \&quot;Fair\&quot;.&quot;);
-		    break;
-		case SKILL_FAIR:
-		    prout(&quot;promotes you one step in rank from \&quot;Fair\&quot; to \&quot;Good\&quot;.&quot;);
-		    break;
-		case SKILL_GOOD:
-		    prout(&quot;promotes you one step in rank from \&quot;Good\&quot; to \&quot;Expert\&quot;.&quot;);
-		    break;
-		case SKILL_EXPERT:
-		    prout(&quot;promotes you to Commodore Emeritus.&quot;);
-		    skip(1);
-		    prout(&quot;Now that you think you're really good, try playing&quot;);
-		    prout(&quot;the \&quot;Emeritus\&quot; game. It will splatter your ego.&quot;);
-		    break;
-		case SKILL_EMERITUS:
-		    skip(1);
-		    proutn(&quot;Computer-  &quot;);
-		    prouts(&quot;ERROR-ERROR-ERROR-ERROR&quot;);
-		    skip(2);
-		    prouts(&quot;  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM&quot;);
-		    skip(1);
-		    prouts(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;);
-		    skip(1);
-		    prouts(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;);
-		    skip(1);
-		    prouts(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;);
-		    skip(1);
-		    prouts(&quot;  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI&quot;);
-		    skip(2);
-		    prout(&quot;Now you can retire and write your own Star Trek game!&quot;);
-		    skip(1);
-		    break;
-		}
-		if (skill &gt;= SKILL_EXPERT) {
-		    if (thawed
-#ifdef DEBUG
-			&amp;&amp; !idebug
-#endif
-			)
-			prout(&quot;You cannot get a citation, so...&quot;);
-		    else {
-			proutn(&quot;Do you want your Commodore Emeritus Citation printed? &quot;);
-			chew();
-			if (ja()) {
-			    igotit = 1;
-			}
-		    }
-		}
-	    }
-	    // Only grant long life if alive (original didn't!)
-	    skip(1);
-	    prout(&quot;LIVE LONG AND PROSPER.&quot;);
-	}
-	score();
-	if (igotit != 0) plaque();
-	return;
-    case FDEPLETE: // Federation Resources Depleted
-	prout(&quot;Your time has run out and the Federation has been&quot;);
-	prout(&quot;conquered.  Your starship is now Klingon property,&quot;);
-	prout(&quot;and you are put on trial as a war criminal.  On the&quot;);
-	proutn(&quot;basis of your record, you are &quot;);
-	if (KLINGREM*3.0 &gt; INKLINGTOT) {
-	    prout(&quot;aquitted.&quot;);
-	    skip(1);
-	    prout(&quot;LIVE LONG AND PROSPER.&quot;);
-	}
-	else {
-	    prout(&quot;found guilty and&quot;);
-	    prout(&quot;sentenced to death by slow torture.&quot;);
-	    alive = 0;
-	}
-	score();
-	return;
-    case FLIFESUP:
-	prout(&quot;Your life support reserves have run out, and&quot;);
-	prout(&quot;you die of thirst, starvation, and asphyxiation.&quot;);
-	prout(&quot;Your starship is a derelict in space.&quot;);
-	break;
-    case FNRG:
-	prout(&quot;Your energy supply is exhausted.&quot;);
-	skip(1);
-	prout(&quot;Your starship is a derelict in space.&quot;);
-	break;
-    case FBATTLE:
-	proutn(&quot;The &quot;);
-	crmshp();
-	prout(&quot;has been destroyed in battle.&quot;);
-	skip(1);
-	prout(&quot;Dulce et decorum est pro patria mori.&quot;);
-	break;
-    case FNEG3:
-	prout(&quot;You have made three attempts to cross the negative energy&quot;);
-	prout(&quot;barrier which surrounds the galaxy.&quot;);
-	skip(1);
-	prout(&quot;Your navigation is abominable.&quot;);
-	score();
-	return;
-    case FNOVA:
-	prout(&quot;Your starship has been destroyed by a nova.&quot;);
-	prout(&quot;That was a great shot.&quot;);
-	skip(1);
-	break;
-    case FSNOVAED:
-	proutn(&quot;The &quot;);
-	crmshp();
-	prout(&quot; has been fried by a supernova.&quot;);
-	prout(&quot;...Not even cinders remain...&quot;);
-	break;
-    case FABANDN:
-	prout(&quot;You have been captured by the Klingons. If you still&quot;);
-	prout(&quot;had a starbase to be returned to, you would have been&quot;);
-	prout(&quot;repatriated and given another chance. Since you have&quot;);
-	prout(&quot;no starbases, you will be mercilessly tortured to death.&quot;);
-	break;
-    case FDILITHIUM:
-	prout(&quot;Your starship is now an expanding cloud of subatomic particles&quot;);
-	break;
-    case FMATERIALIZE:
-	prout(&quot;Starbase was unable to re-materialize your starship.&quot;);
-	prout(&quot;Sic transit gloria muntdi&quot;);
-	break;
-    case FPHASER:
-	proutn(&quot;The &quot;);
-	crmshp();
-	prout(&quot; has been cremated by its own phasers.&quot;);
-	break;
-    case FLOST:
-	prout(&quot;You and your landing party have been&quot;);
-	prout(&quot;converted to energy, disipating through space.&quot;);
-	break;
-    case FMINING:
-	prout(&quot;You are left with your landing party on&quot;);
-	prout(&quot;a wild jungle planet inhabited by primitive cannibals.&quot;);
-	skip(1);
-	prout(&quot;They are very fond of \&quot;Captain Kirk\&quot; soup.&quot;);
-	skip(1);
-	proutn(&quot;Without your leadership, the &quot;);
-	crmshp();
-	prout(&quot; is destroyed.&quot;);
-	break;
-    case FDPLANET:
-	prout(&quot;You and your mining party perish.&quot;);
-	skip(1);
-	prout(&quot;That was a great shot.&quot;);
-	skip(1);
-	break;
-    case FSSC:
-	prout(&quot;The Galileo is instantly annihilated by the supernova.&quot;);
-	// no break;
-    case FPNOVA:
-	prout(&quot;You and your mining party are atomized.&quot;);
-	skip(1);
-	proutn(&quot;Mr. Spock takes command of the &quot;);
-	crmshp();
-	prout(&quot; and&quot;);
-	prout(&quot;joins the Romulans, reigning terror on the Federation.&quot;);
-	break;
-    case FSTRACTOR:
-	prout(&quot;The shuttle craft Galileo is also caught,&quot;);
-	prout(&quot;and breaks up under the strain.&quot;);
-	skip(1);
-	prout(&quot;Your debris is scattered for millions of miles.&quot;);
-	proutn(&quot;Without your leadership, the &quot;);
-	crmshp();
-	prout(&quot; is destroyed.&quot;);
-	break;
-    case FDRAY:
-	prout(&quot;The mutants attack and kill Spock.&quot;);
-	prout(&quot;Your ship is captured by Klingons, and&quot;);
-	prout(&quot;your crew is put on display in a Klingon zoo.&quot;);
-	break;
-    case FTRIBBLE:
-	prout(&quot;Tribbles consume all remaining water,&quot;);
-	prout(&quot;food, and oxygen on your ship.&quot;);
-	skip(1);
-	prout(&quot;You die of thirst, starvation, and asphyxiation.&quot;);
-	prout(&quot;Your starship is a derelict in space.&quot;);
-	break;
-    case FHOLE:
-	prout(&quot;Your ship is drawn to the center of the black hole.&quot;);
-	prout(&quot;You are crushed into extremely dense matter.&quot;);
-	break;
-    }
-    if (ship==IHF) ship= 0;
-    else if (ship == IHE) ship = IHF;
-    alive = 0;
-    if (KLINGREM != 0) {
-	double goodies = game.state.remres/inresor;
-	double baddies = (game.state.remkl + 2.0*game.state.remcom)/(inkling+2.0*incom);
-	if (goodies/baddies &gt;= 1.0+0.5*Rand()) {
-	    prout(&quot;As a result of your actions, a treaty with the Klingon&quot;);
-	    prout(&quot;Empire has been signed. The terms of the treaty are&quot;);
-	    if (goodies/baddies &gt;= 3.0+Rand()) {
-		prout(&quot;favorable to the Federation.&quot;);
-		skip(1);
-		prout(&quot;Congratulations!&quot;);
-	    }
-	    else
-		prout(&quot;highly unfavorable to the Federation.&quot;);
-	}
-	else
-	    prout(&quot;The Federation will be destroyed.&quot;);
-    }
-    else {
-	prout(&quot;Since you took the last Klingon with you, you are a&quot;);
-	prout(&quot;martyr and a hero. Someday maybe they'll erect a&quot;);
-	prout(&quot;statue in your memory. Rest in peace, and try not&quot;);
-	prout(&quot;to think about pigeons.&quot;);
-	gamewon = 1;
-    }
-    score();
-}
-
-void score(void) 
-{
-    double timused = game.state.date - indate;
-    int ithperd, iwon, klship;
-
-    iskill = skill;
-    if ((timused == 0 || KLINGREM != 0) &amp;&amp; timused &lt; 5.0) timused = 5.0;
-    perdate = KLINGKILLED/timused;
-    ithperd = 500*perdate + 0.5;
-    iwon = 0;
-    if (gamewon) iwon = 100*skill;
-    if (ship == IHE) klship = 0;
-    else if (ship == IHF) klship = 1;
-    else klship = 2;
-    if (gamewon == 0) game.state.nromrem = 0; // None captured if no win
-    iscore = 10*NKILLK + 50*NKILLC + ithperd + iwon
-	- 100*game.state.basekl - 100*klship - 45*nhelp -5*game.state.starkl - casual
-	+ 20*NKILLROM + 200*NKILLSC - 10*game.state.nplankl + game.state.nromrem;
-    if (alive == 0) iscore -= 200;
-    skip(2);
-    prout(&quot;Your score --&quot;);
-    if (NKILLROM)
-	prout(&quot;%6d Romulans destroyed                 %5d&quot;,
-	      NKILLROM,20*NKILLROM);
-    if (game.state.nromrem)
-	prout(&quot;%6d Romulans captured                  %5d&quot;,
-	      game.state.nromrem, game.state.nromrem);
-    if (NKILLK)
-	prout(&quot;%6d ordinary Klingons destroyed        %5d&quot;,
-	      NKILLK, 10*NKILLK);
-    if (NKILLC)
-	prout(&quot;%6d Klingon commanders destroyed       %5d&quot;,
-	      NKILLC, 50*NKILLC);
-    if (NKILLSC)
-	prout(&quot;%6d Super-Commander destroyed          %5d&quot;,
-	      NKILLSC, 200*NKILLSC);
-    if (ithperd)
-	prout(&quot;%6.2f Klingons per stardate              %5d&quot;,
-	      perdate, ithperd);
-    if (game.state.starkl)
-	prout(&quot;%6d stars destroyed by your action     %5d&quot;,
-	      game.state.starkl, -5*game.state.starkl);
-    if (game.state.nplankl)
-	prout(&quot;%6d planets destroyed by your action   %5d&quot;,
-	      game.state.nplankl, -10*game.state.nplankl);
-    if (game.state.basekl)
-	prout(&quot;%6d bases destroyed by your action     %5d&quot;,
-	      game.state.basekl, -100*game.state.basekl);
-    if (nhelp)
-	prout(&quot;%6d calls for help from starbase       %5d&quot;,
-	      nhelp, -45*nhelp);
-    if (casual)
-	prout(&quot;%6d casualties incurred                %5d&quot;,
-	      casual, -casual);
-    if (klship)
-	prout(&quot;%6d ship(s) lost or destroyed          %5d&quot;,
-	      klship, -100*klship);
-    if (alive==0)
-	prout(&quot;Penalty for getting yourself killed        -200&quot;);
-    if (gamewon) {
-	proutn(&quot;Bonus for winning &quot;);
-	switch (skill) {
-	case SKILL_NOVICE:   proutn(&quot;Novice game  &quot;); break;
-	case SKILL_FAIR:     proutn(&quot;Fair game    &quot;); break;
-	case SKILL_GOOD:     proutn(&quot;Good game    &quot;); break;
-	case SKILL_EXPERT:   proutn(&quot;Expert game  &quot;); break;
-	case SKILL_EMERITUS: proutn(&quot;Emeritus game&quot;); break;
-	}
-	prout(&quot;           %5d&quot;, iwon);
-    }
-    skip(1);
-    prout(&quot;TOTAL SCORE                               %5d&quot;, iscore);
-}
-
-void plaque(void) {
-	FILE *fp=NULL;
-	time_t t;
-	char *timestring;
-	int nskip;
-	char winner[128];
-
-	skip(2);
-	
-	while (fp == NULL) {
-                proutn(&quot;File or device name for your plaque: &quot;);
-                cgetline(winner, sizeof(winner));
-		fp = fopen(winner, &quot;w&quot;);
-		if (fp==NULL) {
-                        prout(&quot;Invalid name.&quot;);
-		}
-	}
-
-        proutn(&quot;Enter name to go on plaque (up to 30 characters): &quot;);
-        cgetline(winner, sizeof(winner));
-	/* The 38 below must be 64 for 132-column paper */
-	nskip = 38 - strlen(winner)/2;
-
-	fprintf(fp,&quot;\n\n\n\n&quot;);
-	/* --------DRAW ENTERPRISE PICTURE. */
-        fprintf(fp, &quot;                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot; );
-	fprintf(fp, &quot;                                      EEE                      E  : :                                         :  E\n&quot; );
-	fprintf(fp, &quot;                                    EE   EEE                   E  : :                   NCC-1701              :  E\n&quot;);
-        fprintf(fp, &quot;EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n&quot;);
-        fprintf(fp, &quot; E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot;);
-	fprintf(fp, &quot;                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n&quot;);
-	fprintf(fp, &quot;                               EEEEEEE   EEEEE    E          E              E  E\n&quot;);
-	fprintf(fp, &quot;                                      EEE           E          E            E  E\n&quot;);
-	fprintf(fp, &quot;                                                       E         E          E  E\n&quot;);
-	fprintf(fp, &quot;                                                         EEEEEEEEEEEEE      E  E\n&quot;);
-	fprintf(fp, &quot;                                                      EEE :           EEEEEEE  EEEEEEEE\n&quot;);
-	fprintf(fp, &quot;                                                    :E    :                 EEEE       E\n&quot;);
-	fprintf(fp, &quot;                                                   .-E   -:-----                       E\n&quot;);
-	fprintf(fp, &quot;                                                    :E    :                            E\n&quot;);
-	fprintf(fp, &quot;                                                      EE  :                    EEEEEEEE\n&quot;);
-	fprintf(fp, &quot;                                                       EEEEEEEEEEEEEEEEEEEEEEE\n&quot;);
-	fprintf(fp, &quot;\n\n\n&quot;);
-	fprintf(fp, &quot;                                                       U. S. S. ENTERPRISE\n&quot;);
-	fprintf(fp, &quot;\n\n\n\n&quot;);
-	fprintf(fp, &quot;                                  For demonstrating outstanding ability as a starship captain\n&quot;);
-	fprintf(fp, &quot;\n&quot;);
-	fprintf(fp, &quot;                                                Starfleet Command bestows to you\n&quot;);
-	fprintf(fp, &quot;\n&quot;);
-	fprintf(fp,&quot;%*s%s\n\n&quot;, nskip, &quot;&quot;, winner);
-	fprintf(fp, &quot;                                                           the rank of\n\n&quot;);
-	fprintf(fp, &quot;                                                       \&quot;Commodore Emeritus\&quot;\n\n&quot;);
-	fprintf(fp, &quot;                                                          &quot;);
-	switch (iskill) {
-		case SKILL_EXPERT: fprintf(fp,&quot; Expert level\n\n&quot;); break;
-		case SKILL_EMERITUS: fprintf(fp,&quot;Emeritus level\n\n&quot;); break;
-		default: fprintf(fp,&quot; Cheat level\n\n&quot;); break;
-	}
-	t = time(NULL);
-	timestring = ctime(&amp;t);
-	fprintf(fp, &quot;                                                 This day of %.6s %.4s, %.8s\n\n&quot;,
-			timestring+4, timestring+20, timestring+11);
-	fprintf(fp,&quot;                                                        Your score:  %d\n\n&quot;, iscore);
-	fprintf(fp,&quot;                                                    Klingons per stardate:  %.2f\n&quot;, perdate);
-	fclose(fp);
-}

Copied: trunk/install-sh (from rev 538, branches/at-work/install-sh)

Deleted: trunk/io.c
===================================================================
--- trunk/io.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/io.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,439 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;termios.h&gt;
-#include &lt;curses.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;stdarg.h&gt;
-
-#include &quot;sst.h&quot;
-#include &quot;sstlinux.h&quot;
-
-static int rows, linecount;	/* for paging */
-
-WINDOW *curwnd;
-
-static void outro(void)
-/* wrap up, either normally or due to signal */
-{
-    if (game.options &amp; OPTION_CURSES) {
-	clear();
-	curs_set(1);
-	(void)refresh();
-	(void)resetterm();
-	//(void)echo();
-	(void)endwin();
-	putchar('\n');
-    }
-}
-
-void iostart(void) 
-{
-    if (!(game.options &amp; OPTION_CURSES)) {
-	rows = atoi(getenv(&quot;LINES&quot;));
-    } else {
-	if (atexit(outro)){
-	    fprintf(stderr,&quot;Unable to register outro(), exiting...\n&quot;);
-	    exit(1);
-	}
-	(void)initscr();
-#ifdef KEY_MIN
-	keypad(stdscr, TRUE);
-#endif /* KEY_MIN */
-	(void)saveterm();
-	(void)nonl();
-	(void)cbreak();
-#ifdef A_COLOR
-	{
-	    start_color();
-	    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
-	    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
-	    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
-	    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
-	    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
-	    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
-	    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
-	    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
-	}
-#endif /* A_COLOR */
-	//(void)noecho();
-	fullscreen_window = stdscr;
-	srscan_window     = newwin(12, 25, 0,       0);
-	report_window     = newwin(10, 0,  1,       25);
-	lrscan_window     = newwin(10, 0,  0,       64); 
-	message_window    = newwin(0,  0,  12,      0);
-	prompt_window     = newwin(1,  0,  LINES-2, 0); 
-	scrollok(message_window, TRUE);
-	setwnd(fullscreen_window);
-	textcolor(DEFAULT);
-    }
-}
-
-
-void waitfor(void)
-/* wait for user action -- OK to do nothing if on a TTY */
-{
-    if (game.options &amp; OPTION_CURSES)
-	getch();
-}
-
-void pause_game(int i) 
-{
-    char *prompt;
-    char buf[BUFSIZ];
-    if (i==1) {
-	if (skill &gt; SKILL_FAIR)
-	    prompt = &quot;[ANOUNCEMENT ARRIVING...]&quot;;
-	else
-	    prompt = &quot;[IMPORTANT ANNOUNCEMENT ARRIVING -- PRESS ENTER TO CONTINUE]&quot;;
-    }
-    else {
-	if (skill &gt; SKILL_FAIR)
-	    prompt = &quot;[CONTINUE?]&quot;;
-	else
-	    prompt = &quot;[PRESS ENTER TO CONTINUE]&quot;;
-
-    }
-    if (game.options &amp; OPTION_CURSES) {
-	drawmaps(0);
-	setwnd(prompt_window);
-	wclear(prompt_window);
-	waddstr(prompt_window, prompt);
-	wgetnstr(prompt_window, buf, sizeof(buf));
-	wclear(prompt_window);
-	wrefresh(prompt_window);
-	setwnd(message_window);
-    } else {
-	putchar('\n');
-	proutn(prompt);
-	fgets(buf, sizeof(buf), stdin);
-	if (i != 0) {
-	    int j;
-	    for (j = 0; j &lt; rows; j++)
-		putchar('\n');
-	}
-	linecount = 0;
-    }
-}
-
-
-void skip(int i) 
-{
-    while (i-- &gt; 0) {
-	if (game.options &amp; OPTION_CURSES) {
-	    if (curwnd == message_window &amp;&amp; linecount &gt;= getmaxy(curwnd) - 3) {
-		pause_game(0);
-		clrscr();
-	    } else {
-		proutn(&quot;\n&quot;);
-		if (curwnd == message_window)
-		    linecount++;
-	    }
-	} else {
-	    linecount++;
-	    if (linecount &gt;= rows)
-		pause_game(0);
-	    else
-		putchar('\n');
-	}
-    }
-}
-
-static void vproutn(char *fmt, va_list ap) 
-{
-    if (game.options &amp; OPTION_CURSES) {
-	vwprintw(curwnd, fmt, ap);
-	wrefresh(curwnd);
-    }
-    else
-	vprintf(fmt, ap);
-}
-
-void proutn(char *fmt, ...) 
-{
-    va_list ap;
-    va_start(ap, fmt);
-    vproutn(fmt, ap);
-    va_end(ap);
-}
-
-void prout(char *fmt, ...) 
-{
-    va_list ap;
-    va_start(ap, fmt);
-    vproutn(fmt, ap);
-    va_end(ap);
-    skip(1);
-}
-
-void prouts(char *fmt, ...) 
-/* print slowly! */
-{
-    char *s, buf[BUFSIZ];
-    va_list ap;
-    va_start(ap, fmt);
-    vsprintf(buf, fmt, ap);
-    va_end(ap);
-    for (s = buf; *s; s++) {
-	delay(30);
-	if (game.options &amp; OPTION_CURSES) {
-	    waddch(curwnd, *s);
-	    wrefresh(curwnd);
-	}
-	else {
-	    putchar(*s);
-	    fflush(stdout);
-	}
-    }
-}
-
-void cgetline(char *line, int max)
-{
-    if (game.options &amp; OPTION_CURSES) {
-	wgetnstr(curwnd, line, max);
-	strcat(line, &quot;\n&quot;);
-	wrefresh(curwnd);
-    } else {
-	fgets(line, max, stdin);
-    }
-    line[strlen(line)-1] = '\0';
-}
-
-void setwnd(WINDOW *wnd)
-/* change windows -- OK for this to be a no-op in tty mode */
-{
-    if (game.options &amp; OPTION_CURSES) {
-     curwnd=wnd;
-     curs_set(wnd == fullscreen_window || wnd == message_window || wnd == prompt_window);
-    }
-}
-
-void clreol (void)
-/* clear to end of line -- can be a no-op in tty mode */
-{
-   if (game.options &amp; OPTION_CURSES) {
-       wclrtoeol(curwnd);
-       wrefresh(curwnd);
-   }
-}
-
-void clrscr (void)
-/* clear screen -- can be a no-op in tty mode */
-{
-   if (game.options &amp; OPTION_CURSES) {
-       wclear(curwnd);
-       wmove(curwnd,0,0);
-       wrefresh(curwnd);
-   }
-   linecount = 0;
-}
-
-void textcolor (int color)
-{
-#ifdef A_COLOR
-    if (game.options &amp; OPTION_CURSES) {
-	switch(color) {
-	case DEFAULT: 
-	    wattrset(curwnd, 0);
-	    break;
-	case BLACK: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_BLACK));
-	    break;
-	case BLUE: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_BLUE));
-	    break;
-	case GREEN: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_GREEN));
-	    break;
-	case CYAN: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_CYAN));
-	    break;
-	case RED: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_RED));
-	    break;
-	case MAGENTA: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_MAGENTA));
-	    break;
-	case BROWN: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_YELLOW));
-	    break;
-	case LIGHTGRAY: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_WHITE));
-	    break;
-	case DARKGRAY: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_BLACK) | A_BOLD);
-	    break;
-	case LIGHTBLUE: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_BLUE) | A_BOLD);
-	    break;
-	case LIGHTGREEN: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_GREEN) | A_BOLD);
-	    break;
-	case LIGHTCYAN: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_CYAN) | A_BOLD);
-	    break;
-	case LIGHTRED: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_RED) | A_BOLD);
-	    break;
-	case LIGHTMAGENTA: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_MAGENTA) | A_BOLD);
-	    break;
-	case YELLOW: 
-	    wattron(curwnd, COLOR_PAIR(COLOR_YELLOW) | A_BOLD);
-	    break;
-	case WHITE:
-	    wattron(curwnd, COLOR_PAIR(COLOR_WHITE) | A_BOLD);
-	    break;
-	}
-    }
-#endif /* A_COLOR */
-}
-
-void highvideo (void)
-{
-    if (game.options &amp; OPTION_CURSES) {
-	wattron(curwnd, A_REVERSE);
-    }
-}
- 
-void commandhook(char *cmd, int before) {
-}
-
-/*
- * Things past this point have policy implications.
- */
-
-void drawmaps(short l)
-/* hook to be called after moving to redraw maps */
-{
-    if (game.options &amp; OPTION_CURSES) {
-	if (l == 1)
-	    sensor();
-        setwnd(srscan_window);
-        wmove(curwnd, 0, 0);
-        enqueue(&quot;no&quot;);
-        srscan(SCAN_FULL);
-	if (l != 2) {
-	    setwnd(report_window);
-	    wclear(report_window);
-	    wmove(report_window, 0, 0);
-	    srscan(SCAN_NO_LEFTSIDE);
-	    setwnd(lrscan_window);
-	    wclear(lrscan_window);
-	    wmove(lrscan_window, 0, 0);
-	    enqueue(&quot;l&quot;);
-	    lrscan();
-	}
-    }
-}
-
-static void put_srscan_sym(int x, int y, char sym)
-{
-    wmove(srscan_window, x+1, y*2+2);
-    waddch(srscan_window, sym);
-    wrefresh(srscan_window);
-}
-
-void boom(int ii, int jj)
-/* enemy fall down, go boom */ 
-{
-    if (game.options &amp; OPTION_CURSES) {
-	drawmaps(2);
-	setwnd(srscan_window);
-	wattron(srscan_window, A_REVERSE);
-	put_srscan_sym(ii, jj, game.quad[ii][jj]);
-	sound(500);
-	delay(1000);
-	nosound();
-	wattroff(srscan_window, A_REVERSE);
-	put_srscan_sym(ii, jj, game.quad[ii][jj]);
-	delay(500);
-	setwnd(message_window);
-    }
-} 
-
-void warble(void)
-/* sound and visual effects for teleportation */
-{
-    if (game.options &amp; OPTION_CURSES) {
-	drawmaps(2);
-	setwnd(message_window);
-	sound(50);
-    }
-    prouts(&quot;     . . . . .     &quot;);
-    if (game.options &amp; OPTION_CURSES) {
-	delay(1000);
-	nosound();
-    }
-}
-
-void tracktorpedo(int ix, int iy, int l, int i, int n, int iquad)
-/* torpedo-track animation */
-{
-    if (!game.options &amp; OPTION_CURSES) {
-	if (l == 1) {
-	    if (n != 1) {
-		skip(1);
-		proutn(&quot;Track for torpedo number %d-  &quot;, i);
-	    }
-	    else {
-		skip(1);
-		proutn(&quot;Torpedo track- &quot;);
-	    }
-	} else if (l==4 || l==9) 
-	    skip(1);
-	proutn(&quot;%d - %d   &quot;, ix, iy);
-    } else {
-	if (game.damage[DSRSENS]==0 || condit==IHDOCKED) {
-	    if (i != 1 &amp;&amp; l == 1) {
-		drawmaps(2);
-		delay(400);
-	    }
-	    if ((iquad==IHDOT)||(iquad==IHBLANK)){
-		put_srscan_sym(ix, iy, '+');
-		sound(l*10);
-		delay(100);
-		nosound();
-		put_srscan_sym(ix, iy, iquad);
-	    }
-	    else {
-		wattron(curwnd, A_REVERSE);
-		put_srscan_sym(ix, iy, iquad);
-		sound(500);
-		delay(1000);
-		nosound();
-		wattroff(curwnd, A_REVERSE);
-		put_srscan_sym(ix, iy, iquad);
-	    }
-	} else {
-	    proutn(&quot;%d - %d   &quot;, ix, iy);
-	}
-    }
-}
-
-void makechart(void) 
-{
-    if (game.options &amp; OPTION_CURSES) {
-	setwnd(message_window);
-	wclear(message_window);
-	chart(0);
-    }
-}
-
-void setpassword(void) 
-{
-    if (!(game.options &amp; OPTION_CURSES)) {
-	while (TRUE) {
-	    scan();
-	    strcpy(game.passwd, citem);
-	    chew();
-	    if (*game.passwd != 0) break;
-	    proutn(&quot;Please type in a secret password-&quot;);
-	}
-    } else {
-	int i;
-        for(i=0;i&lt;3;i++) game.passwd[i]=(char)(97+(int)(Rand()*25));
-        game.passwd[3]=0;
-    }
-}
-

Copied: trunk/m4 (from rev 538, branches/at-work/m4)

Deleted: trunk/makehelp.py
===================================================================
--- trunk/makehelp.py	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/makehelp.py	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,45 +0,0 @@
-#!/usr/bin/env python
-#
-# Generate an on-line help file for SST 2K from the text generated from
-# the XML documentation.
-#
-# By Eric S. Raymond for the Super Star Trek project
-import os, re, sys
-
-enddelim = &quot;********\n&quot;
-
-# This is the part most likely to bit-rot
-beginmarker1 = &quot;Mnemonic:&quot;
-endmarker1 = &quot;Miscellaneous Notes&quot;
-beginmarker2 = &quot; ABBREV&quot;
-endmarker2 = &quot;Game History and Modifications&quot;
-
-fp = open(&quot;sst-doc.txt&quot;, &quot;r&quot;)
-savetext = &quot;&quot;
-state = 0
-while True:
-    line = fp.readline()
-    if not line:
-        break
-    if state == 0 and line.startswith(beginmarker1):
-        line = &quot;%% &quot; + line[12:].lstrip()
-        state = 1
-    if state == 0 and line.startswith(beginmarker2):
-        savetext += enddelim + &quot;%% ABBREV\n&quot;
-        state = 2
-    if state == 1:
-        if line.find(endmarker1) &gt; -1:
-            state = 0
-    if state == 2:
-        if line.find(endmarker2) &gt; -1:
-            state = 0
-    if state:
-        savetext += line
-
-# Remove the section titles
-savetext = re.sub(&quot;\n+.*\n*Mnemonic:\\s*&quot;, &quot;\n********\n%% &quot;, savetext)
-
-# Hack Unicode non-breaking spaces into ordinary spaces
-savetext = savetext.replace(&quot;\xc2\xa0&quot;, &quot; &quot;).replace(&quot;\240&quot;, &quot;&quot;)
-
-sys.stdout.write(savetext + enddelim)

Copied: trunk/missing (from rev 538, branches/at-work/missing)

Copied: trunk/mkinstalldirs (from rev 538, branches/at-work/mkinstalldirs)

Deleted: trunk/moving.c
===================================================================
--- trunk/moving.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/moving.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,1009 +0,0 @@
-#include &lt;unistd.h&gt;
-#include &quot;sstlinux.h&quot;
-#include &quot;sst.h&quot;
-
-static void getcd(int, int);
-
-void imove(void) 
-{
-    double angle, deltax, deltay, bigger, x, y,
-        finald, finalx, finaly, stopegy, probf;
-    int trbeam = 0, n, l, ix=0, iy=0, kink, kinks, iquad;
-
-    if (inorbit) {
-	prout(&quot;Helmsman Sulu- \&quot;Leaving standard orbit.\&quot;&quot;);
-	inorbit = FALSE;
-    }
-
-    angle = ((15.0 - direc) * 0.5235988);
-    deltax = -sin(angle);
-    deltay = cos(angle);
-    if (fabs(deltax) &gt; fabs(deltay))
-	bigger = fabs(deltax);
-    else
-	bigger = fabs(deltay);
-		
-    deltay /= bigger;
-    deltax /= bigger;
-
-    /* If tractor beam is to occur, don't move full distance */
-    if (game.state.date+Time &gt;= game.future[FTBEAM]) {
-	trbeam = 1;
-	condit = IHRED;
-	dist = dist*(game.future[FTBEAM]-game.state.date)/Time + 0.1;
-	Time = game.future[FTBEAM] - game.state.date + 1e-5;
-    }
-    /* Move within the quadrant */
-    game.quad[sectx][secty] = IHDOT;
-    x = sectx;
-    y = secty;
-    n = 10.0*dist*bigger+0.5;
-
-    if (n &gt; 0) {
-	for (l = 1; l &lt;= n; l++) {
-	    ix = (x += deltax) + 0.5;
-	    iy = (y += deltay) + 0.5;
-	    if (!VALID_SECTOR(ix, iy)) {
-		/* Leaving quadrant -- allow final enemy attack */
-		/* Don't do it if being pushed by Nova */
-		if (nenhere != 0 &amp;&amp; iattak != 2) {
-		    newcnd();
-		    for_local_enemies(l) {
-			finald = sqrt((ix-game.kx[l])*(double)(ix-game.kx[l]) +
-				      (iy-game.ky[l])*(double)(iy-game.ky[l]));
-			game.kavgd[l] = 0.5 * (finald+game.kdist[l]);
-		    }
-		    /*
-		     * Stas Sergeev added the condition
-		     * that attacks only happen if Klingons
-		     * are present and your skill is good.
-		     */
-		    if (skill &gt; SKILL_GOOD &amp;&amp; klhere &gt; 0 &amp;&amp; !game.state.galaxy[quadx][quady].supernova)
-			attack(0);
-		    if (alldone) return;
-		}
-		/* compute final position -- new quadrant and sector */
-		x = QUADSIZE*(quadx-1)+sectx;
-		y = QUADSIZE*(quady-1)+secty;
-		ix = x+10.0*dist*bigger*deltax+0.5;
-		iy = y+10.0*dist*bigger*deltay+0.5;
-		/* check for edge of galaxy */
-		kinks = 0;
-		do {
-		    kink = 0;
-		    if (ix &lt;= 0) {
-			ix = -ix + 1;
-			kink = 1;
-		    }
-		    if (iy &lt;= 0) {
-			iy = -iy + 1;
-			kink = 1;
-		    }
-		    if (ix &gt; GALSIZE*QUADSIZE) {
-			ix = (GALSIZE*QUADSIZE*2)+1 - ix;
-			kink = 1;
-		    }
-		    if (iy &gt; GALSIZE*QUADSIZE) {
-			iy = (GALSIZE*QUADSIZE*2)+1 - iy;
-			kink = 1;
-		    }
-		    if (kink) kinks = 1;
-		} while (kink);
-
-		if (kinks) {
-		    nkinks += 1;
-		    if (nkinks == 3) {
-			/* Three strikes -- you're out! */
-			finish(FNEG3);
-			return;
-		    }
-		    skip(1);
-		    prout(&quot;YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER&quot;);
-		    prout(&quot;AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,&quot;);
-		    prout(&quot;YOU WILL BE DESTROYED.&quot;);
-		}
-		/* Compute final position in new quadrant */
-		if (trbeam) return; /* Don't bother if we are to be beamed */
-		quadx = (ix+(QUADSIZE-1))/QUADSIZE;
-		quady = (iy+(QUADSIZE-1))/QUADSIZE;
-		sectx = ix - QUADSIZE*(quadx-1);
-		secty = iy - QUADSIZE*(quady-1);
-		skip(1);
-		prout(&quot;Entering %s.&quot;,
-		      cramlc(quadrant, quadx, quady));
-		game.quad[sectx][secty] = ship;
-		newqad(0);
-		if (skill&gt;SKILL_NOVICE) attack(0);
-		return;
-	    }
-	    iquad = game.quad[ix][iy];
-	    if (iquad != IHDOT) {
-		/* object encountered in flight path */
-		stopegy = 50.0*dist/Time;
-		dist=0.1*sqrt((sectx-ix)*(double)(sectx-ix) +
-			      (secty-iy)*(double)(secty-iy));
-		switch (iquad) {
-		case IHT: /* Ram a Tholian */
-		case IHK: /* Ram enemy ship */
-		case IHC:
-		case IHS:
-		case IHR:
-		case IHQUEST:
-		    sectx = ix;
-		    secty = iy;
-		    ram(0, iquad, sectx, secty);
-		    finalx = sectx;
-		    finaly = secty;
-		    break;
-		case IHBLANK:
-		    skip(1);
-		    prouts(&quot;***RED ALERT!  RED ALERT!&quot;);
-		    skip(1);
-		    proutn(&quot;***&quot;);
-		    crmshp();
-		    proutn(&quot; pulled into black hole at &quot;);
-		    prout(cramlc(sector, ix, iy));
-		    /*
-		     * Getting pulled into a black hole was certain
-		     * death in Almy's original.  Stas Sergeev added a
-		     * possibility that you'll get timewarped instead.
-		     */
-		    n=0;
-		    for (l=0;l&lt;NDEVICES;l++)
-			if (game.damage[l]&gt;0) 
-			    n++;
-		    probf=pow(1.4,(energy+shield)/5000.0-1.0)*pow(1.3,1.0/(n+1)-1.0);
-		    if ((game.options &amp; OPTION_BLKHOLE) &amp;&amp; Rand()&gt;probf) 
-			timwrp();
-		    else 
-			finish(FHOLE);
-		    return;
-		default:
-		    /* something else */
-		    skip(1);
-		    crmshp();
-		    if (iquad == IHWEB)
-			proutn(&quot; encounters Tholian web at &quot;);
-		    else
-			proutn(&quot; blocked by object at &quot;);
-		    proutn(cramlc(sector, ix,iy));
-		    prout(&quot;;&quot;);
-		    proutn(&quot;Emergency stop required &quot;);
-		    prout(&quot;%2d units of energy.&quot;, (int)stopegy);
-		    energy -= stopegy;
-		    finalx = x-deltax+0.5;
-		    sectx = finalx;
-		    finaly = y-deltay+0.5;
-		    secty = finaly;
-		    if (energy &lt;= 0) {
-			finish(FNRG);
-			return;
-		    }
-		    break;
-		}
-		goto no_quad_change;	/* sorry! */
-	    }
-	}
-	dist = 0.1*sqrt((sectx-ix)*(double)(sectx-ix) +
-			(secty-iy)*(double)(secty-iy));
-	sectx = ix;
-	secty = iy;
-    }
-    finalx = sectx;
-    finaly = secty;
-no_quad_change:
-    /* No quadrant change -- compute new avg enemy distances */
-    game.quad[sectx][secty] = ship;
-    if (nenhere) {
-	for_local_enemies(l) {
-	    finald = sqrt((ix-game.kx[l])*(double)(ix-game.kx[l]) +
-			  (iy-game.ky[l])*(double)(iy-game.ky[l]));
-	    game.kavgd[l] = 0.5 * (finald+game.kdist[l]);
-	    game.kdist[l] = finald;
-	}
-	sortkl();
-	if (!game.state.galaxy[quadx][quady].supernova &amp;&amp; iattak == 0)
-	    attack(0);
-	for_local_enemies(l) game.kavgd[l] = game.kdist[l];
-    }
-    newcnd();
-    iattak = 0;
-    drawmaps(0);
-    setwnd(message_window);
-    return;
-}
-
-void dock(int l) 
-{
-    chew();
-    if (condit == IHDOCKED &amp;&amp; l) {
-	prout(&quot;Already docked.&quot;);
-	return;
-    }
-    if (inorbit) {
-	prout(&quot;You must first leave standard orbit.&quot;);
-	return;
-    }
-    if (basex==0 || abs(sectx-basex) &gt; 1 || abs(secty-basey) &gt; 1) {
-	crmshp();
-	prout(&quot; not adjacent to base.&quot;);
-	return;
-    }
-    condit = IHDOCKED;
-    if (l) prout(&quot;Docked.&quot;);
-    ididit=1;
-    if (energy &lt; inenrg) energy = inenrg;
-    shield = inshld;
-    torps = intorps;
-    lsupres = inlsr;
-    if (game.damage[DRADIO] == 0.0 &amp;&amp;
-	(game.future[FCDBAS] &lt; FOREVER || isatb == 1) &amp;&amp; iseenit == 0) {
-	/* get attack report from base */
-	prout(&quot;Lt. Uhura- \&quot;Captain, an important message from the starbase:\&quot;&quot;);
-	attakreport(0);
-	iseenit = 1;
-    }
-}
-
-static void getcd(int isprobe, int akey) {
-	/* This program originally required input in terms of a (clock)
-	   direction and distance. Somewhere in history, it was changed to
-	   cartesian coordinates. So we need to convert. I think
-	   &quot;manual&quot; input should still be done this way -- it's a real
-	   pain if the computer isn't working! Manual mode is still confusing
-	   because it involves giving x and y motions, yet the coordinates
-	   are always displayed y - x, where +y is downward! */
-
-	
-        int irowq=quadx, icolq=quady, irows, icols, itemp=0, iprompt=0, key=0;
-	double xi, xj, xk, xl;
-	double deltax, deltay;
-	int automatic = -1;
-
-	/* Get course direction and distance. If user types bad values, return
-	   with DIREC = -1.0. */
-
-	direc = -1.0;
-	
-	if (landed == 1 &amp;&amp; !isprobe) {
-		prout(&quot;Dummy! You can't leave standard orbit until you&quot;);
-		proutn(&quot;are back aboard the &quot;);
-		crmshp();
-		prout(&quot;.&quot;);
-		chew();
-		return;
-	}
-	while (automatic == -1) {
-		if (game.damage[DCOMPTR]) {
-			if (isprobe)
-				prout(&quot;Computer damaged; manual navigation only&quot;);
-			else
-				prout(&quot;Computer damaged; manual movement only&quot;);
-			chew();
-			automatic = 0;
-			key = IHEOL;
-			break;
-		}
-		if (isprobe &amp;&amp; akey != -1) {
-			/* For probe launch, use pre-scaned value first time */
-			key = akey;
-			akey = -1;
-		}
-		else 
-			key = scan();
-
-		if (key == IHEOL) {
-			proutn(&quot;Manual or automatic- &quot;);
-			iprompt = 1;
-			chew();
-		}
-		else if (key == IHALPHA) {
-			if (isit(&quot;manual&quot;)) {
-				automatic =0;
-				key = scan();
-				break;
-			}
-			else if (isit(&quot;automatic&quot;)) {
-				automatic = 1;
-				key = scan();
-				break;
-			}
-			else {
-				huh();
-				chew();
-				return;
-			}
-		}
-		else { /* numeric */
-			if (isprobe)
-				prout(&quot;(Manual navigation assumed.)&quot;);
-			else
-				prout(&quot;(Manual movement assumed.)&quot;);
-			automatic = 0;
-			break;
-		}
-	}
-
-	if (automatic) {
-		while (key == IHEOL) {
-			if (isprobe)
-				proutn(&quot;Target quadrant or quadrant&amp;sector- &quot;);
-			else
-				proutn(&quot;Destination sector or quadrant&amp;sector- &quot;);
-			chew();
-			iprompt = 1;
-			key = scan();
-		}
-
-		if (key != IHREAL) {
-			huh();
-			return;
-		}
-		xi = aaitem;
-		key = scan();
-		if (key != IHREAL){
-			huh();
-			return;
-		}
-		xj = aaitem;
-		key = scan();
-		if (key == IHREAL) {
-			/* both quadrant and sector specified */
-			xk = aaitem;
-			key = scan();
-			if (key != IHREAL) {
-				huh();
-				return;
-			}
-			xl = aaitem;
-
-			irowq = xi + 0.5;
-			icolq = xj + 0.5;
-			irows = xk + 0.5;
-			icols = xl + 0.5;
-		}
-		else {
-			if (isprobe) {
-				/* only quadrant specified -- go to center of dest quad */
-				irowq = xi + 0.5;
-				icolq = xj + 0.5;
-				irows = icols = 5;
-			}
-			else {
-				irows = xi + 0.5;
-				icols = xj + 0.5;
-			}
-			itemp = 1;
-		}
-		if (!VALID_QUADRANT(icolq,irowq)||!VALID_SECTOR(icols,irows)) {
-		    huh();
-		    return;
-		}
-		skip(1);
-		if (!isprobe) {
-			if (itemp) {
-				if (iprompt) {
-					prout(&quot;Helmsman Sulu- \&quot;Course locked in for %s.\&quot;&quot;,
-						cramlc(sector, irows, icols));
-				}
-			}
-			else prout(&quot;Ensign Chekov- \&quot;Course laid in, Captain.\&quot;&quot;);
-		}
-		deltax = icolq - quady + 0.1*(icols-secty);
-		deltay = quadx - irowq + 0.1*(sectx-irows);
-	}
-	else { /* manual */
-		while (key == IHEOL) {
-			proutn(&quot;X and Y displacements- &quot;);
-			chew();
-			iprompt = 1;
-			key = scan();
-		}
-		itemp = 2;
-		if (key != IHREAL) {
-			huh();
-			return;
-		}
-		deltax = aaitem;
-		key = scan();
-		if (key != IHREAL) {
-			huh();
-			return;
-		}
-		deltay = aaitem;
-	}
-	/* Check for zero movement */
-	if (deltax == 0 &amp;&amp; deltay == 0) {
-		chew();
-		return;
-	}
-	if (itemp == 2 &amp;&amp; !isprobe) {
-		skip(1);
-		prout(&quot;Helmsman Sulu- \&quot;Aye, Sir.\&quot;&quot;);
-	}
-	dist = sqrt(deltax*deltax + deltay*deltay);
-	direc = atan2(deltax, deltay)*1.90985932;
-	if (direc &lt; 0.0) direc += 12.0;
-	chew();
-	return;
-
-}
-		
-
-
-void impuls(void) 
-{
-    double power;
-
-    ididit = 0;
-    if (game.damage[DIMPULS]) {
-	chew();
-	skip(1);
-	prout(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;);
-	return;
-    }
-
-    if (energy &gt; 30.0) {
-	getcd(FALSE, 0);
-	if (direc == -1.0) return;
-	power = 20.0 + 100.0*dist;
-    }
-    else
-	power = 30.0;
-
-    if (power &gt;= energy) {
-	/* Insufficient power for trip */
-	skip(1);
-	prout(&quot;First Officer Spock- \&quot;Captain, the impulse engines&quot;);
-	prout(&quot;require 20.0 units to engage, plus 100.0 units per&quot;);
-	if (energy &gt; 30) {
-	    proutn(&quot;quadrant.  We can go, therefore, a maximum of %d&quot;, 
-		   (int)(0.01 * (energy-20.0)-0.05));
-	    prout(&quot; quadrants.\&quot;&quot;);
-	}
-	else {
-	    prout(&quot;quadrant.  They are, therefore, useless.\&quot;&quot;);
-	}
-	chew();
-	return;
-    }
-    /* Make sure enough time is left for the trip */
-    Time = dist/0.095;
-    if (Time &gt;= game.state.remtime) {
-	prout(&quot;First Officer Spock- \&quot;Captain, our speed under impulse&quot;);
-	prout(&quot;power is only 0.95 sectors per stardate. Are you sure&quot;);
-	proutn(&quot;we dare spend the time?\&quot; &quot;);
-	if (ja() == 0) return;
-    }
-    /* Activate impulse engines and pay the cost */
-    imove();
-    ididit = 1;
-    if (alldone) return;
-    power = 20.0 + 100.0*dist;
-    energy -= power;
-    Time = dist/0.095;
-    if (energy &lt;= 0) finish(FNRG);
-    return;
-}
-
-
-void warp(int i) 
-{
-    int blooey=0, twarp=0, iwarp;
-    double power;
-
-    if (i!=2) { /* Not WARPX entry */
-	ididit = 0;
-	if (game.damage[DWARPEN] &gt; 10.0) {
-	    chew();
-	    skip(1);
-	    prout(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;);
-	    return;
-	}
-	if (game.damage[DWARPEN] &gt; 0.0 &amp;&amp; warpfac &gt; 4.0) {
-	    chew();
-	    skip(1);
-	    prout(&quot;Engineer Scott- \&quot;Sorry, Captain. Until this damage&quot;);
-	    prout(&quot;  is repaired, I can only give you warp 4.\&quot;&quot;);
-	    return;
-	}
-			
-	/* Read in course and distance */
-	getcd(FALSE, 0);
-	if (direc == -1.0) return;
-
-	/* Make sure starship has enough energy for the trip */
-	power = (dist+0.05)*warpfac*warpfac*warpfac*(shldup+1);
-
-
-	if (power &gt;= energy) {
-	    /* Insufficient power for trip */
-	    ididit = 0;
-	    skip(1);
-	    prout(&quot;Engineering to bridge--&quot;);
-	    if (shldup==0 || 0.5*power &gt; energy) {
-		iwarp = pow((energy/(dist+0.05)), 0.333333333);
-		if (iwarp &lt;= 0) {
-		    prout(&quot;We can't do it, Captain. We haven't the energy.&quot;);
-		}
-		else {
-		    proutn(&quot;We haven't the energy, but we could do it at warp %d&quot;, iwarp);
-		    if (shldup) {
-			prout(&quot;,&quot;);
-			prout(&quot;if you'll lower the shields.&quot;);
-		    }
-		    else
-			prout(&quot;.&quot;);
-		}
-	    }
-	    else
-		prout(&quot;We haven't the energy to go that far with the shields up.&quot;);
-	    return;
-	}
-						
-	/* Make sure enough time is left for the trip */
-	Time = 10.0*dist/wfacsq;
-	if (Time &gt;= 0.8*game.state.remtime) {
-	    skip(1);
-	    prout(&quot;First Officer Spock- \&quot;Captain, I compute that such&quot;);
-	    proutn(&quot;  a trip would require approximately %2.0f&quot;,
-		   100.0*Time/game.state.remtime);
-	    prout(&quot; percent of our&quot;);
-	    proutn(&quot;  remaining time.  Are you sure this is wise?\&quot; &quot;);
-	    if (ja() == 0) { ididit = 0; Time=0; return;}
-	}
-    }
-    /* Entry WARPX */
-    if (warpfac &gt; 6.0) {
-	/* Decide if engine damage will occur */
-	double prob = dist*(6.0-warpfac)*(6.0-warpfac)/66.666666666;
-	if (prob &gt; Rand()) {
-	    blooey = 1;
-	    dist = Rand()*dist;
-	}
-	/* Decide if time warp will occur */
-	if (0.5*dist*pow(7.0,warpfac-10.0) &gt; Rand()) twarp=1;
-#ifdef DEBUG
-	if (idebug &amp;&amp;warpfac==10 &amp;&amp; twarp==0) {
-	    blooey=0;
-	    proutn(&quot;Force time warp? &quot;);
-	    if (ja()==1) twarp=1;
-	}
-#endif
-	if (blooey || twarp) {
-	    /* If time warp or engine damage, check path */
-	    /* If it is obstructed, don't do warp or damage */
-	    double angle = ((15.0-direc)*0.5235998);
-	    double deltax = -sin(angle);
-	    double deltay = cos(angle);
-	    double bigger, x, y;
-	    int n, l, ix, iy;
-	    if (fabs(deltax) &gt; fabs(deltay))
-		bigger = fabs(deltax);
-	    else
-		bigger = fabs(deltay);
-			
-	    deltax /= bigger;
-	    deltay /= bigger;
-	    n = 10.0 * dist * bigger +0.5;
-	    x = sectx;
-	    y = secty;
-	    for (l = 1; l &lt;= n; l++) {
-		x += deltax;
-		ix = x + 0.5;
-		y += deltay;
-		iy = y +0.5;
-		if (!VALID_SECTOR(ix, iy)) break;
-		if (game.quad[ix][iy] != IHDOT) {
-		    blooey = 0;
-		    twarp = 0;
-		}
-	    }
-	}
-    }
-				
-
-    /* Activate Warp Engines and pay the cost */
-    imove();
-    if (alldone) return;
-    energy -= dist*warpfac*warpfac*warpfac*(shldup+1);
-    if (energy &lt;= 0) finish(FNRG);
-    Time = 10.0*dist/wfacsq;
-    if (twarp) timwrp();
-    if (blooey) {
-	game.damage[DWARPEN] = damfac*(3.0*Rand()+1.0);
-	skip(1);
-	prout(&quot;Engineering to bridge--&quot;);
-	prout(&quot;  Scott here.  The warp engines are damaged.&quot;);
-	prout(&quot;  We'll have to reduce speed to warp 4.&quot;);
-    }
-    ididit = 1;
-    return;
-}
-
-
-
-void setwrp(void) 
-{
-    int key;
-    double oldfac;
-	
-    while ((key=scan()) == IHEOL) {
-	chew();
-	proutn(&quot;Warp factor- &quot;);
-    }
-    chew();
-    if (key != IHREAL) {
-	huh();
-	return;
-    }
-    if (game.damage[DWARPEN] &gt; 10.0) {
-	prout(&quot;Warp engines inoperative.&quot;);
-	return;
-    }
-    if (game.damage[DWARPEN] &gt; 0.0 &amp;&amp; aaitem &gt; 4.0) {
-	prout(&quot;Engineer Scott- \&quot;I'm doing my best, Captain,&quot;);
-	prout(&quot;  but right now we can only go warp 4.\&quot;&quot;);
-	return;
-    }
-    if (aaitem &gt; 10.0) {
-	prout(&quot;Helmsman Sulu- \&quot;Our top speed is warp 10, Captain.\&quot;&quot;);
-	return;
-    }
-    if (aaitem &lt; 1.0) {
-	prout(&quot;Helmsman Sulu- \&quot;We can't go below warp 1, Captain.\&quot;&quot;);
-	return;
-    }
-    oldfac = warpfac;
-    warpfac = aaitem;
-    wfacsq=warpfac*warpfac;
-    if (warpfac &lt;= oldfac || warpfac &lt;= 6.0) {
-	proutn(&quot;Helmsman Sulu- \&quot;Warp factor %d, Captain.\&quot;&quot;, 
-	       (int)warpfac);
-	return;
-    }
-    if (warpfac &lt; 8.00) {
-	prout(&quot;Engineer Scott- \&quot;Aye, but our maximum safe speed is warp 6.\&quot;&quot;);
-	return;
-    }
-    if (warpfac == 10.0) {
-	prout(&quot;Engineer Scott- \&quot;Aye, Captain, we'll try it.\&quot;&quot;);
-	return;
-    }
-    prout(&quot;Engineer Scott- \&quot;Aye, Captain, but our engines may not take it.\&quot;&quot;);
-    return;
-}
-
-void atover(int igrab) 
-{
-    double power, distreq;
-
-    chew();
-    /* is captain on planet? */
-    if (landed==1) {
-	if (game.damage[DTRANSP]) {
-	    finish(FPNOVA);
-	    return;
-	}
-	prout(&quot;Scotty rushes to the transporter controls.&quot;);
-	if (shldup) {
-	    prout(&quot;But with the shields up it's hopeless.&quot;);
-	    finish(FPNOVA);
-	}
-	prouts(&quot;His desperate attempt to rescue you . . .&quot;);
-	if (Rand() &lt;= 0.5) {
-	    prout(&quot;fails.&quot;);
-	    finish(FPNOVA);
-	    return;
-	}
-	prout(&quot;SUCCEEDS!&quot;);
-	if (imine) {
-	    imine = 0;
-	    proutn(&quot;The crystals mined were &quot;);
-	    if (Rand() &lt;= 0.25) {
-		prout(&quot;lost.&quot;);
-	    }
-	    else {
-		prout(&quot;saved.&quot;);
-		icrystl = 1;
-	    }
-	}
-    }
-    if (igrab) return;
-
-    /* Check to see if captain in shuttle craft */
-    if (icraft) finish(FSTRACTOR);
-    if (alldone) return;
-
-    /* Inform captain of attempt to reach safety */
-    skip(1);
-    do {
-	if (justin) {
-	    prouts(&quot;***RED ALERT!  READ ALERT!&quot;);
-	    skip(1);
-	    proutn(&quot;The &quot;);
-	    crmshp();
-	    prout(&quot; has stopped in a quadrant containing&quot;);
-	    prouts(&quot;   a supernova.&quot;);
-	    skip(2);
-	}
-	proutn(&quot;***Emergency automatic override attempts to hurl &quot;);
-	crmshp();
-	skip(1);
-	prout(&quot;safely out of quadrant.&quot;);
-	if (game.damage[DRADIO] == 0.0)
-	    game.state.galaxy[quadx][quady].charted = TRUE;
-	/* Try to use warp engines */
-	if (game.damage[DWARPEN]) {
-	    skip(1);
-	    prout(&quot;Warp engines damaged.&quot;);
-	    finish(FSNOVAED);
-	    return;
-	}
-	warpfac = 6.0+2.0*Rand();
-	wfacsq = warpfac * warpfac;
-	prout(&quot;Warp factor set to %d&quot;, (int)warpfac);
-	power = 0.75*energy;
-	dist = power/(warpfac*warpfac*warpfac*(shldup+1));
-	distreq = 1.4142+Rand();
-	if (distreq &lt; dist) dist = distreq;
-	Time = 10.0*dist/wfacsq;
-	direc = 12.0*Rand();	/* How dumb! */
-	justin = 0;
-	inorbit = 0;
-	warp(2);
-	if (justin == 0) {
-	    /* This is bad news, we didn't leave quadrant. */
-	    if (alldone) return;
-	    skip(1);
-	    prout(&quot;Insufficient energy to leave quadrant.&quot;);
-	    finish(FSNOVAED);
-	    return;
-	}
-    } while 
-	/* Repeat if another snova */
-	(game.state.galaxy[quadx][quady].supernova);
-    if (KLINGREM==0) 
-	finish(FWON); /* Snova killed remaining enemy. */
-}
-
-void timwrp() 
-{
-    int l, gotit;
-    prout(&quot;***TIME WARP ENTERED.&quot;);
-    if (game.state.snap &amp;&amp; Rand() &lt; 0.5) {
-	/* Go back in time */
-	prout(&quot;You are traveling backwards in time %d stardates.&quot;,
-	      (int)(game.state.date-game.snapsht.date));
-	game.state = game.snapsht;
-	game.state.snap = 0;
-	if (game.state.remcom) {
-	    game.future[FTBEAM] = game.state.date + expran(intime/game.state.remcom);
-	    game.future[FBATTAK] = game.state.date + expran(0.3*intime);
-	}
-	game.future[FSNOVA] = game.state.date + expran(0.5*intime);
-	game.future[FSNAP] = game.state.date +expran(0.25*game.state.remtime); /* next snapshot will
-										  be sooner */
-	if (game.state.nscrem) game.future[FSCMOVE] = 0.2777;
-	isatb = 0;
-	game.future[FCDBAS] = game.future[FSCDBAS] = FOREVER;
-	batx = baty = 0;
-
-	/* Make sure Galileo is consistant -- Snapshot may have been taken
-	   when on planet, which would give us two Galileos! */
-	gotit = 0;
-	for (l = 0; l &lt; inplan; l++) {
-	    if (game.state.plnets[l].known == shuttle_down) {
-		gotit = 1;
-		if (iscraft==1 &amp;&amp; ship==IHE) {
-		    prout(&quot;Checkov-  \&quot;Security reports the Galileo has disappeared, Sir!&quot;);
-		    iscraft = 0;
-		}
-	    }
-	}
-	/* Likewise, if in the original time the Galileo was abandoned, but
-	   was on ship earlier, it would have vanished -- lets restore it */
-	if (iscraft==0 &amp;&amp; gotit==0 &amp;&amp; game.damage[DSHUTTL] &gt;= 0.0) {
-	    prout(&quot;Checkov-  \&quot;Security reports the Galileo has reappeared in the dock!\&quot;&quot;);
-	    iscraft = 1;
-	}
-	/* 
-	 * There used to be code to do the actual reconstrction here,
-	 * but the starchart is now part of the snapshotted galaxy state.
-	 */
-	prout(&quot;Spock has reconstructed a correct star chart from memory&quot;);
-    }
-    else {
-	/* Go forward in time */
-	Time = -0.5*intime*log(Rand());
-	prout(&quot;You are traveling forward in time %d stardates.&quot;, (int)Time);
-	/* cheat to make sure no tractor beams occur during time warp */
-	game.future[FTBEAM] += Time;
-	game.damage[DRADIO] += Time;
-    }
-    newqad(0);
-    events();	/* Stas Sergeev added this -- do pending events */
-}
-
-void probe(void) 
-{
-    double angle, bigger;
-    int key;
-    /* New code to launch a deep space probe */
-    if (nprobes == 0) {
-	chew();
-	skip(1);
-	if (ship == IHE) 
-	    prout(&quot;Engineer Scott- \&quot;We have no more deep space probes, Sir.\&quot;&quot;);
-	else
-	    prout(&quot;Ye Faerie Queene has no deep space probes.&quot;);
-	return;
-    }
-    if (game.damage[DDSP] != 0.0) {
-	chew();
-	skip(1);
-	prout(&quot;Engineer Scott- \&quot;The probe launcher is damaged, Sir.\&quot;&quot;);
-	return;
-    }
-    if (game.future[FDSPROB] != FOREVER) {
-	chew();
-	skip(1);
-	if (game.damage[DRADIO] != 0 &amp;&amp; condit != IHDOCKED) {
-	    prout(&quot;Spock-  \&quot;Records show the previous probe has not yet&quot;);
-	    prout(&quot;   reached its destination.\&quot;&quot;);
-	}
-	else
-	    prout(&quot;Uhura- \&quot;The previous probe is still reporting data, Sir.\&quot;&quot;);
-	return;
-    }
-    key = scan();
-
-    if (key == IHEOL) {
-	/* slow mode, so let Kirk know how many probes there are left */
-	prout(nprobes==1 ? &quot;%d probe left.&quot; : &quot;%d probes left.&quot;, nprobes);
-	proutn(&quot;Are you sure you want to fire a probe? &quot;);
-	if (ja()==0) return;
-    }
-
-    isarmed = FALSE;
-    if (key == IHALPHA &amp;&amp; strcmp(citem,&quot;armed&quot;) == 0) {
-	isarmed = TRUE;
-	key = scan();
-    }
-    else if (key == IHEOL) {
-	proutn(&quot;Arm NOVAMAX warhead? &quot;);
-	isarmed = ja();
-    }
-    getcd(TRUE, key);
-    if (direc == -1.0) return;
-    nprobes--;
-    angle = ((15.0 - direc) * 0.5235988);
-    probeinx = -sin(angle);
-    probeiny = cos(angle);
-    if (fabs(probeinx) &gt; fabs(probeiny))
-	bigger = fabs(probeinx);
-    else
-	bigger = fabs(probeiny);
-		
-    probeiny /= bigger;
-    probeinx /= bigger;
-    proben = 10.0*dist*bigger +0.5;
-    probex = quadx*QUADSIZE + sectx - 1;	// We will use better packing than original
-    probey = quady*QUADSIZE + secty - 1;
-    probecx = quadx;
-    probecy = quady;
-    game.future[FDSPROB] = game.state.date + 0.01; // Time to move one sector
-    prout(&quot;Ensign Chekov-  \&quot;The deep space probe is launched, Captain.\&quot;&quot;);
-    ididit = 1;
-    return;
-}
-
-void help(void) 
-{
-    /* There's more than one way to move in this game! */
-    double ddist, xdist, probf;
-    int line = 0, l, ix, iy;
-
-    chew();
-    /* Test for conditions which prevent calling for help */
-    if (condit == IHDOCKED) {
-	prout(&quot;Lt. Uhura-  \&quot;But Captain, we're already docked.\&quot;&quot;);
-	return;
-    }
-    if (game.damage[DRADIO] != 0) {
-	prout(&quot;Subspace radio damaged.&quot;);
-	return;
-    }
-    if (game.state.rembase==0) {
-	prout(&quot;Lt. Uhura-  \&quot;Captain, I'm not getting any response from Starbase.\&quot;&quot;);
-	return;
-    }
-    if (landed == 1) {
-	proutn(&quot;You must be aboard the &quot;);
-	crmshp();
-	prout(&quot;.&quot;);
-	return;
-    }
-    /* OK -- call for help from nearest starbase */
-    nhelp++;
-    if (basex!=0) {
-	/* There's one in this quadrant */
-	ddist = sqrt(square(basex-sectx)+square(basey-secty));
-    }
-    else {
-	ddist = FOREVER;
-	for_starbases(l) {
-	    xdist=10.0*sqrt(square(game.state.baseqx[l]-quadx)+square(game.state.baseqy[l]-quady));
-	    if (xdist &lt; ddist) {
-		ddist = xdist;
-		line = l;
-	    }
-	}
-	/* Since starbase not in quadrant, set up new quadrant */
-	quadx = game.state.baseqx[line];
-	quady = game.state.baseqy[line];
-	newqad(1);
-    }
-    /* dematerialize starship */
-    game.quad[sectx][secty]=IHDOT;
-    proutn(&quot;Starbase in %s responds--&quot;, cramlc(quadrant, quadx, quady));
-    proutn(&quot;&quot;);
-    crmshp();
-    prout(&quot; dematerializes.&quot;);
-    sectx=0;
-    for (l = 1; l &lt;= 5; l++) {
-	ix = basex+3.0*Rand()-1;
-	iy = basey+3.0*Rand()-1;
-	if (VALID_SECTOR(ix,iy) &amp;&amp; game.quad[ix][iy]==IHDOT) {
-	    /* found one -- finish up */
-	    sectx=ix;
-	    secty=iy;
-	    break;
-	}
-    }
-    if (sectx==0){
-	prout(&quot;You have been lost in space...&quot;);
-	finish(FMATERIALIZE);
-	return;
-    }
-    /* Give starbase three chances to rematerialize starship */
-    probf = pow((1.0 - pow(0.98,ddist)), 0.33333333);
-    for (l = 1; l &lt;= 3; l++) {
-	switch (l) {
-	case 1: proutn(&quot;1st&quot;); break;
-	case 2: proutn(&quot;2nd&quot;); break;
-	case 3: proutn(&quot;3rd&quot;); break;
-	}
-	proutn(&quot; attempt to re-materialize &quot;);
-	crmshp();
-	switch (l){
-	case 1: game.quad[ix][iy]=IHMATER0;
-	    break;
-	case 2: game.quad[ix][iy]=IHMATER1;
-	    break;
-	case 3: game.quad[ix][iy]=IHMATER2;
-	    break;
-	}
-	textcolor(RED);
-	warble();
-	if (Rand() &gt; probf) break;
-	prout(&quot;fails.&quot;);
-	delay(500);
-	textcolor(DEFAULT);
-    }
-    if (l &gt; 3) {
-	game.quad[ix][iy]=IHQUEST;
-	alive = 0;
-	drawmaps(1);
-	setwnd(message_window);
-	finish(FMATERIALIZE);
-	return;
-    }
-    game.quad[ix][iy]=ship;
-    textcolor(GREEN);
-    prout(&quot;succeeds.&quot;);
-    textcolor(DEFAULT);
-    dock(0);
-    skip(1);
-    prout(&quot;Lt. Uhura-  \&quot;Captain, we made it!\&quot;&quot;);
-}

Deleted: trunk/planets.c
===================================================================
--- trunk/planets.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/planets.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,506 +0,0 @@
-#include &quot;sst.h&quot;
-
-static char *classes[] = {&quot;M&quot;,&quot;N&quot;,&quot;O&quot;};
-
-static int consumeTime(void) 
-{
-/* I think most of this avoidance was caused by overlay scheme.
-   Let's see what happens if all events can occur here */
-
-//  double asave;
-    ididit = 1;
-#if 0
-    /* Don't worry about this */
-    if (future[FTBEAM] &lt;= game.state.date+Time &amp;&amp; game.state.remcom != 0 &amp;&amp; condit != IHDOCKED) {
-	/* We are about to be tractor beamed -- operation fails */
-	return 1;
-    }
-#endif
-//	asave = future[FSNOVA];
-//	future[FSNOVA] = FOREVER; /* defer supernovas */
-    events();	/* Used to avoid if future[FSCMOVE] within time */
-//	future[FSNOVA] = asave;
-    /*fails if game over, quadrant super-novas or we've moved to new quadrant*/
-    if (alldone || game.state.galaxy[quadx][quady].supernova || justin != 0) return 1;
-    return 0;
-}
-
-void preport(void) 
-{
-    int iknow = 0, i;
-    skip(1);
-    chew();
-    prout(&quot;Spock-  \&quot;Planet report follows, Captain.\&quot;&quot;);
-    skip(1);
-    for (i = 0; i &lt; inplan; i++) {
-	if (game.state.plnets[i].known != unknown
-#ifdef DEBUG
-	    || ( idebug &amp;&amp; game.state.plnets[i].x !=0)
-#endif
-	    ) {
-	    iknow = 1;
-#ifdef DEBUG
-	    if (idebug &amp;&amp; game.state.plnets[i].known==unknown) proutn(&quot;(Unknown) &quot;);
-#endif
-	    proutn(cramlc(quadrant, game.state.plnets[i].x, game.state.plnets[i].y));
-	    proutn(&quot;   class &quot;);
-	    proutn(classes[game.state.plnets[i].pclass]);
-	    proutn(&quot;   &quot;);
-	    if (game.state.plnets[i].crystals == 0) proutn(&quot;no &quot;);
-	    prout(&quot;dilithium crystals present.&quot;);
-	    if (game.state.plnets[i].known==shuttle_down) 
-		prout(&quot;    Shuttle Craft Galileo on surface.&quot;);
-	}
-    }
-    if (iknow==0) prout(&quot;No information available.&quot;);
-}
-
-void orbit(void) 
-{
-    skip(1);
-    chew();
-    if (inorbit!=0) {
-	prout(&quot;Already in standard orbit.&quot;);
-	return;
-    }
-    if (game.damage[DWARPEN] != 0 &amp;&amp; game.damage[DIMPULS] != 0) {
-	prout(&quot;Both warp and impulse engines damaged.&quot;);
-	return;
-    }
-    if (plnetx == 0 || abs(sectx-plnetx) &gt; 1 || abs(secty-plnety) &gt; 1) {
-	crmshp();
-	prout(&quot; not adjacent to planet.&quot;);
-	skip(1);
-	return;
-    }
-    Time = 0.02+0.03*Rand();
-    prout(&quot;Helmsman Sulu-  \&quot;Entering standard orbit, Sir.\&quot;&quot;);
-    newcnd();
-    if (consumeTime()) return;
-    game.height = (1400.0+7200.0*Rand());
-    prout(&quot;Sulu-  \&quot;Entered orbit at altitude %.2f kilometers.\&quot;&quot;, game.height);
-    inorbit = 1;
-    ididit=1;
-}
-
-void sensor(void) 
-{
-    skip(1);
-    chew();
-    if (game.damage[DSRSENS] != 0.0) {
-	prout(&quot;Short range sensors damaged.&quot;);
-	return;
-    }
-    if (!plnetx &amp;&amp; (game.options &amp; OPTION_TTY)) {
-	prout(&quot;Spock- \&quot;No planet in this quadrant, Captain.\&quot;&quot;);
-	return;
-    }
-    if ((plnetx != 0)&amp;&amp; (game.state.plnets[iplnet].known == unknown)) {
-	prout(&quot;Spock-  \&quot;Sensor scan for %s-&quot;, cramlc(quadrant, quadx, quady));
-	skip(1);
-	prout(&quot;         Planet at %s is of class %s.&quot;, 
-	      cramlc(sector, plnetx, plnety),
-	      classes[game.state.plnets[iplnet].pclass]);
-	if (game.state.plnets[iplnet].known==shuttle_down) 
-	    prout(&quot;         Sensors show Galileo still on surface.&quot;);
-	proutn(&quot;         Readings indicate&quot;);
-	if (game.state.plnets[iplnet].crystals == 0) proutn(&quot; no&quot;);
-	prout(&quot; dilithium crystals present.\&quot;&quot;);
-	if (game.state.plnets[iplnet].known == unknown) game.state.plnets[iplnet].known = known;
-    }
-}
-
-void beam(void) 
-{
-    chew();
-    skip(1);
-    if (game.damage[DTRANSP] != 0) {
-	prout(&quot;Transporter damaged.&quot;);
-	if (game.damage[DSHUTTL]==0 &amp;&amp; (game.state.plnets[iplnet].known==shuttle_down || iscraft == 1)) {
-	    skip(1);
-	    proutn(&quot;Spock-  \&quot;May I suggest the shuttle craft, Sir?\&quot; &quot;);
-	    if (ja() != 0) shuttle();
-	}
-	return;
-    }
-    if (inorbit==0) {
-	crmshp();
-	prout(&quot; not in standard orbit.&quot;);
-	return;
-    }
-    if (shldup!=0) {
-	prout(&quot;Impossible to transport through shields.&quot;);
-	return;
-    }
-    if (game.state.plnets[iplnet].known==unknown) {
-	prout(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;);
-	prout(&quot;  and Starfleet Regulations clearly state that in this situation&quot;);
-	prout(&quot;  you may not go down.\&quot;&quot;);
-	return;
-    }
-    if (landed==1) {
-	/* Coming from planet */
-	if (game.state.plnets[iplnet].known==shuttle_down) {
-	    proutn(&quot;Spock-  \&quot;Wouldn't you rather take the Galileo?\&quot; &quot;);
-	    if (ja() != 0) {
-		chew();
-		return;
-	    }
-	    prout(&quot;Your crew hides the Galileo to prevent capture by aliens.&quot;);
-	}
-	prout(&quot;Landing party assembled, ready to beam up.&quot;);
-	skip(1);
-	prout(&quot;Kirk whips out communicator...&quot;);
-	prouts(&quot;BEEP  BEEP  BEEP&quot;);
-	skip(2);
-	prout(&quot;\&quot;Kirk to enterprise-  Lock on coordinates...energize.\&quot;&quot;);
-    }
-    else {
-	/* Going to planet */
-	if (game.state.plnets[iplnet].crystals==0) {
-	    prout(&quot;Spock-  \&quot;Captain, I fail to see the logic in&quot;);
-	    prout(&quot;  exploring a planet with no dilithium crystals.&quot;);
-	    proutn(&quot;  Are you sure this is wise?\&quot; &quot;);
-	    if (ja()==0) {
-		chew();
-		return;
-	    }
-	}
-	prout(&quot;Scotty-  \&quot;Transporter room ready, Sir.\&quot;&quot;);
-	skip(1);
-	prout(&quot;Kirk, and landing party prepare to beam down to planet surface.&quot;);
-	skip(1);
-	prout(&quot;Kirk-  \&quot;Energize.\&quot;&quot;);
-    }
-    ididit=1;
-    skip(1);
-    prouts(&quot;WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .&quot;);
-    skip(2);
-    if (Rand() &gt; 0.98) {
-	prouts(&quot;BOOOIIIOOOIIOOOOIIIOIING . . .&quot;);
-	skip(2);
-	prout(&quot;Scotty-  \&quot;Oh my God!  I've lost them.\&quot;&quot;);
-	finish(FLOST);
-	return;
-    }
-    prouts(&quot;.    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW&quot;);
-    skip(2);
-    prout(&quot;Transport complete.&quot;);
-    landed = -landed;
-    if (landed==1 &amp;&amp; game.state.plnets[iplnet].known==shuttle_down) {
-	prout(&quot;The shuttle craft Galileo is here!&quot;);
-    }
-    if (landed!=1 &amp;&amp; imine==1) {
-	icrystl = 1;
-	cryprob = 0.05;
-    }
-    imine = 0;
-    return;
-}
-
-void mine(void) 
-{
-    skip(1);
-    chew();
-    if (landed!= 1) {
-	prout(&quot;Mining party not on planet.&quot;);
-	return;
-    }
-    if (game.state.plnets[iplnet].crystals == 0) {
-	prout(&quot;No dilithium crystals on this planet.&quot;);
-	return;
-    }
-    if (imine == 1) {
-	prout(&quot;You've already mined enough crystals for this trip.&quot;);
-	return;
-    }
-    if (icrystl == 1 &amp;&amp; cryprob == 0.05) {
-	proutn(&quot;With all those fresh crystals aboard the &quot;);
-	crmshp();
-	skip(1);
-	prout(&quot;there's no reason to mine more at this time.&quot;);
-	return;
-    }
-    Time = (0.1+0.2*Rand())*game.state.plnets[iplnet].pclass;
-    if (consumeTime()) return;
-    prout(&quot;Mining operation complete.&quot;);
-    imine = 1;
-    ididit=1;
-}
-
-void usecrystals(void) 
-{
-    ididit=0;
-    skip(1);
-    chew();
-    if (icrystl!=1) {
-	prout(&quot;No dilithium crystals available.&quot;);
-	return;
-    }
-    if (energy &gt;= 1000) {
-	prout(&quot;Spock-  \&quot;Captain, Starfleet Regulations prohibit such an operation&quot;);
-	prout(&quot;  except when condition Yellow exists.&quot;);
-	return;
-    }
-    prout(&quot;Spock- \&quot;Captain, I must warn you that loading&quot;);
-    prout(&quot;  raw dilithium crystals into the ship's power&quot;);
-    prout(&quot;  system may risk a severe explosion.&quot;);
-    proutn(&quot;  Are you sure this is wise?\&quot; &quot;);
-    if (ja()==0) {
-	chew();
-	return;
-    }
-    skip(1);
-    prout(&quot;Engineering Officer Scott-  \&quot;(GULP) Aye Sir.&quot;);
-    prout(&quot;  Mr. Spock and I will try it.\&quot;&quot;);
-    skip(1);
-    prout(&quot;Spock-  \&quot;Crystals in place, Sir.&quot;);
-    prout(&quot;  Ready to activate circuit.\&quot;&quot;);
-    skip(1);
-    prouts(&quot;Scotty-  \&quot;Keep your fingers crossed, Sir!\&quot;&quot;);
-    skip(1);
-    if (Rand() &lt;= cryprob) {
-	prouts(&quot;  \&quot;Activating now! - - No good!  It's***&quot;);
-	skip(2);
-	prouts(&quot;***RED ALERT!  RED A*L********************************&quot;);
-	skip(1);
-	stars();
-	prouts(&quot;******************   KA-BOOM!!!!   *******************&quot;);
-	skip(1);
-	kaboom();
-	return;
-    }
-    energy += 5000.0*(1.0 + 0.9*Rand());
-    prouts(&quot;  \&quot;Activating now! - - &quot;);
-    prout(&quot;The instruments&quot;);
-    prout(&quot;   are going crazy, but I think it's&quot;);
-    prout(&quot;   going to work!!  Congratulations, Sir!\&quot;&quot;);
-    cryprob *= 2.0;
-    ididit=1;
-}
-
-void shuttle(void) 
-{
-    chew();
-    skip(1);
-    if(game.damage[DSHUTTL] != 0.0) {
-	if (game.damage[DSHUTTL] == -1.0) {
-	    if (inorbit &amp;&amp; game.state.plnets[iplnet].known == shuttle_down)
-		prout(&quot;Ye Faerie Queene has no shuttle craft bay to dock it at.&quot;);
-	    else
-		prout(&quot;Ye Faerie Queene had no shuttle craft.&quot;);
-	}
-	else if (game.damage[DSHUTTL] &gt; 0)
-	    prout(&quot;The Galileo is damaged.&quot;);
-	else prout(&quot;Shuttle craft is now serving Big Macs.&quot;);
-	return;
-    }
-    if (inorbit==0) {
-	crmshp();
-	prout(&quot; not in standard orbit.&quot;);
-	return;
-    }
-    if ((game.state.plnets[iplnet].known != shuttle_down) &amp;&amp; iscraft != 1) {
-	prout(&quot;Shuttle craft not currently available.&quot;);
-	return;
-    }
-    if (landed==-1 &amp;&amp; game.state.plnets[iplnet].known==shuttle_down) {
-	prout(&quot;You will have to beam down to retrieve the shuttle craft.&quot;);
-	return;
-    }
-    if (shldup!=0 || condit == IHDOCKED) {
-	prout(&quot;Shuttle craft cannot pass through shields.&quot;);
-	return;
-    }
-    if (game.state.plnets[iplnet].known==unknown) {
-	prout(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;);
-	prout(&quot;  and Starfleet Regulations clearly state that in this situation&quot;);
-	prout(&quot;  you may not fly down.\&quot;&quot;);
-	return;
-    }
-    Time = 3.0e-5*game.height;
-    if (Time &gt;= 0.8*game.state.remtime) {
-	prout(&quot;First Officer Spock-  \&quot;Captain, I compute that such&quot;);
-	proutn(&quot;  a maneuver would require approximately 2d%% of our&quot;,
-	       (int)(100*Time/game.state.remtime));
-	prout(&quot;remaining time.&quot;);
-	proutn(&quot;Are you sure this is wise?\&quot; &quot;);
-	if (ja()==0) {
-	    Time = 0.0;
-	    return;
-	}
-    }
-    if (landed == 1) {
-	/* Kirk on planet */
-	if (iscraft==1) {
-	    /* Galileo on ship! */
-	    if (game.damage[DTRANSP]==0) {
-		proutn(&quot;Spock-  \&quot;Would you rather use the transporter?\&quot; &quot;);
-		if (ja() != 0) {
-		    beam();
-		    return;
-		}
-		proutn(&quot;Shuttle crew&quot;);
-	    }
-	    else
-		proutn(&quot;Rescue party&quot;);
-	    prout(&quot; boards Galileo and swoops toward planet surface.&quot;);
-	    iscraft = 0;
-	    skip(1);
-	    if (consumeTime()) return;
-	    game.state.plnets[iplnet].known=shuttle_down;
-	    prout(&quot;Trip complete.&quot;);
-	    return;
-	}
-	else {
-	    /* Ready to go back to ship */
-	    prout(&quot;You and your mining party board the&quot;);
-	    prout(&quot;shuttle craft for the trip back to the Enterprise.&quot;);
-	    skip(1);
-	    prout(&quot;The short hop begins . . .&quot;);
-	    game.state.plnets[iplnet].known=known;
-	    icraft = 1;
-	    skip(1);
-	    landed = -1;
-	    if (consumeTime()) return;
-	    iscraft = 1;
-	    icraft = 0;
-	    if (imine!=0) {
-		icrystl = 1;
-		cryprob = 0.05;
-	    }
-	    imine = 0;
-	    prout(&quot;Trip complete.&quot;);
-	    return;
-	}
-    }
-    else {
-	/* Kirk on ship */
-	/* and so is Galileo */
-	prout(&quot;Mining party assembles in the hangar deck,&quot;);
-	prout(&quot;ready to board the shuttle craft \&quot;Galileo\&quot;.&quot;);
-	skip(1);
-	prouts(&quot;The hangar doors open; the trip begins.&quot;);
-	skip(1);
-	icraft = 1;
-	iscraft = 0;
-	if (consumeTime()) return;
-	game.state.plnets[iplnet].known = shuttle_down;
-	landed = 1;
-	icraft = 0;
-	prout(&quot;Trip complete&quot;);
-	return;
-    }
-}
-
-void deathray(void) 
-{
-    double dprob, r = Rand();
-	
-    ididit = 0;
-    skip(1);
-    chew();
-    if (ship != IHE) {
-	prout(&quot;Ye Faerie Queene has no death ray.&quot;);
-	return;
-    }
-    if (nenhere==0) {
-	prout(&quot;Sulu-  \&quot;But Sir, there are no enemies in this quadrant.\&quot;&quot;);
-	return;
-    }
-    if (game.damage[DDRAY] &gt; 0.0) {
-	prout(&quot;Death Ray is damaged.&quot;);
-	return;
-    }
-    prout(&quot;Spock-  \&quot;Captain, the 'Experimental Death Ray'&quot;);
-    prout(&quot;  is highly unpredictible.  Considering the alternatives,&quot;);
-    proutn(&quot;  are you sure this is wise?\&quot; &quot;);
-    if (ja()==0) return;
-    prout(&quot;Spock-  \&quot;Acknowledged.\&quot;&quot;);
-    skip(1);
-    ididit=1;
-    prouts(&quot;WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE&quot;);
-    skip(1);
-    prout(&quot;Crew scrambles in emergency preparation.&quot;);
-    prout(&quot;Spock and Scotty ready the death ray and&quot;);
-    prout(&quot;prepare to channel all ship's power to the device.&quot;);
-    skip(1);
-    prout(&quot;Spock-  \&quot;Preparations complete, sir.\&quot;&quot;);
-    prout(&quot;Kirk-  \&quot;Engage!\&quot;&quot;);
-    skip(1);
-    prouts(&quot;WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&quot;);
-    skip(1);
-    dprob = .30;
-    if (game.options &amp; OPTION_PLAIN)
-	dprob = .5;
-    if (r &gt; dprob) {
-	prouts(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;);
-	skip(2);
-	while (nenhere &gt; 0)
-	    deadkl(game.kx[1],game.ky[1],game.quad[game.kx[1]][game.ky[1]],game.kx[1],game.ky[1]);
-	prout(&quot;Ensign Chekov-  \&quot;Congratulations, Captain!\&quot;&quot;);
-	if (KLINGREM == 0) finish(FWON);
-	if ((game.options &amp; OPTION_PLAIN) == 0) {
-	    prout(&quot;Spock-  \&quot;Captain, I believe the `Experimental Death Ray'&quot;);
-	    if (Rand() &lt;= 0.05) {
-		prout(&quot;   is still operational.\&quot;&quot;);
-	    }
-	    else {
-		prout(&quot;   has been rendered nonfunctional.\&quot;&quot;);
-		game.damage[DDRAY] = 39.95;
-	    }
-	}
-	return;
-    }
-    r = Rand();	// Pick failure method 
-    if (r &lt;= .30) {
-	prouts(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;);
-	skip(1);
-	prouts(&quot;***RED ALERT!  RED ALERT!&quot;);
-	skip(1);
-	prout(&quot;***MATTER-ANTIMATTER IMPLOSION IMMINENT!&quot;);
-	skip(1);
-	prouts(&quot;***RED ALERT!  RED A*L********************************&quot;);
-	skip(1);
-	stars();
-	prouts(&quot;******************   KA-BOOM!!!!   *******************&quot;);
-	skip(1);
-	kaboom();
-	return;
-    }
-    if (r &lt;= .55) {
-	prouts(&quot;Sulu- \&quot;Captain!  Yagabandaghangrapl, brachriigringlanbla!\&quot;&quot;);
-	skip(1);
-	prout(&quot;Lt. Uhura-  \&quot;Graaeek!  Graaeek!\&quot;&quot;);
-	skip(1);
-	prout(&quot;Spock-  \&quot;Fascinating!  . . . All humans aboard&quot;);
-	prout(&quot;  have apparently been transformed into strange mutations.&quot;);
-	prout(&quot;  Vulcans do not seem to be affected.&quot;);
-	skip(1);
-	prout(&quot;Kirk-  \&quot;Raauch!  Raauch!\&quot;&quot;);
-	finish(FDRAY);
-	return;
-    }
-    if (r &lt;= 0.75) {
-	int i,j;
-	prouts(&quot;Sulu- \&quot;Captain!  It's   --WHAT?!?!\&quot;&quot;);
-	skip(2);
-	proutn(&quot;Spock-  \&quot;I believe the word is&quot;);
-	prouts(&quot; *ASTONISHING*&quot;);
-	prout(&quot; Mr. Sulu.&quot;);
-	for_sectors(i)
-	    for_sectors(j)
-		if (game.quad[i][j] == IHDOT) game.quad[i][j] = IHQUEST;
-	prout(&quot;  Captain, our quadrant is now infested with&quot;);
-	prouts(&quot; - - - - - -  *THINGS*.&quot;);
-	skip(1);
-	prout(&quot;  I have no logical explanation.\&quot;&quot;);
-	return;
-    }
-    prouts(&quot;Sulu- \&quot;Captain!  The Death Ray is creating tribbles!\&quot;&quot;);
-    skip(1);
-    prout(&quot;Scotty-  \&quot;There are so many tribbles down here&quot;);
-    prout(&quot;  in Engineering, we can't move for 'em, Captain.\&quot;&quot;);
-    finish(FTRIBBLE);
-    return;
-}

Copied: trunk/po (from rev 538, branches/at-work/po)

Deleted: trunk/reports.c
===================================================================
--- trunk/reports.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/reports.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,537 +0,0 @@
-#include &quot;sst.h&quot;
-#include &lt;math.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-void attakreport(int curt) 
-{
-    if (!curt) {
-	if (game.future[FCDBAS] &lt; FOREVER) {
-	    prout(&quot;Starbase in %s is currently under Commander attack.&quot;,
-		  cramlc(quadrant, batx, baty));
-	    prout(&quot;It can hold out until Stardate %d.&quot;, 
-		  (int)game.future[FCDBAS]);
-	}
-	if (isatb == 1) {
-	    prout(&quot;Starbase in %s is under Super-commander attack.&quot;,
-		  cramlc(quadrant, game.state.isx, game.state.isy));
-	    prout(&quot;It can hold out until Stardate %d.&quot;, 
-		  (int)game.future[FSCDBAS]);
-	}
-    } else {
-        if (game.future[FCDBAS] &lt; FOREVER)
-	    proutn(&quot;Base in %i - %i attacked by C. Alive until %.1f&quot;, batx, baty, game.future[FCDBAS]);
-        if (isatb == 1)
-	    proutn(&quot;Base in %i - %i attacked by S. Alive until %.1f&quot;, game.state.isx, game.state.isy, game.future[FSCDBAS]);
-    }
-    clreol();
-}
-	
-
-void report(void) 
-{
-    char *s1,*s2,*s3;
-
-    chew();
-    s1 = (thawed?&quot;thawed &quot;:&quot;&quot;);
-    switch (length) {
-    case 1: s2=&quot;short&quot;; break;
-    case 2: s2=&quot;medium&quot;; break;
-    case 4: s2=&quot;long&quot;; break;
-    default: s2=&quot;unknown length&quot;; break;
-    }
-    switch (skill) {
-    case SKILL_NOVICE: s3=&quot;novice&quot;; break;
-    case SKILL_FAIR: s3=&quot;fair&quot;; break;
-    case SKILL_GOOD: s3=&quot;good&quot;; break;
-    case SKILL_EXPERT: s3=&quot;expert&quot;; break;
-    case SKILL_EMERITUS: s3=&quot;emeritus&quot;; break;
-    default: s3=&quot;skilled&quot;; break;
-    }
-    prout(&quot;&quot;);
-    prout(&quot;You %s playing a %s%s %s game.&quot;,
-	  alldone? &quot;were&quot;: &quot;are now&quot;, s1, s2, s3);
-    if (skill&gt;SKILL_GOOD &amp;&amp; thawed &amp;&amp; !alldone) prout(&quot;No plaque is allowed.&quot;);
-    if (tourn) prout(&quot;This is tournament game %d.&quot;, tourn);
-    prout(&quot;Your secret password is \&quot;%s\&quot;&quot;,game.passwd);
-    proutn(&quot;%d of %d Klingons have been killed&quot;, KLINGKILLED, INKLINGTOT);
-    if (NKILLC) prout(&quot;, including %d Commander%s.&quot;, NKILLC, NKILLC==1?&quot;&quot;:&quot;s&quot;);
-    else if (NKILLK + NKILLSC &gt; 0) prout(&quot;, but no Commanders.&quot;);
-    else prout(&quot;.&quot;);
-    if (skill &gt; SKILL_FAIR) prout(&quot;The Super Commander has %sbeen destroyed.&quot;,
-				  game.state.nscrem?&quot;not &quot;:&quot;&quot;);
-    if (game.state.rembase != inbase) {
-	proutn(&quot;There &quot;);
-	if (inbase-game.state.rembase==1) proutn(&quot;has been 1 base&quot;);
-	else {
-	    proutn(&quot;have been %d bases&quot;, inbase-game.state.rembase);
-	}
-	prout(&quot; destroyed, %d remaining.&quot;, game.state.rembase);
-    }
-    else prout(&quot;There are %d bases.&quot;, inbase);
-    if (game.damage[DRADIO] == 0.0 || condit == IHDOCKED || iseenit) {
-	/* Don't report this if not seen and
-	   either the radio is dead or not at base! */
-	attakreport(0);
-	iseenit = 1;
-    }
-    if (casual) prout(&quot;%d casualt%s suffered so far.&quot;,
-		      casual, casual==1? &quot;y&quot; : &quot;ies&quot;);
-    if (nhelp) prout(&quot;There were %d call%s for help.&quot;,
-		     nhelp, nhelp==1 ? &quot;&quot; : &quot;s&quot;);
-    if (ship == IHE) {
-	proutn(&quot;You have &quot;);
-	if (nprobes) proutn(&quot;%d&quot;, nprobes);
-	else proutn(&quot;no&quot;);
-	proutn(&quot; deep space probe&quot;);
-	if (nprobes!=1) proutn(&quot;s&quot;);
-	prout(&quot;.&quot;);
-    }
-    if ((game.damage[DRADIO] == 0.0 || condit == IHDOCKED)&amp;&amp;
-	game.future[FDSPROB] != FOREVER) {
-	if (isarmed) 
-	    proutn(&quot;An armed deep space probe is in&quot;);
-	else
-	    proutn(&quot;A deep space probe is in&quot;);
-	proutn(cramlc(quadrant, probecx, probecy));
-	prout(&quot;.&quot;);
-    }
-    if (icrystl) {
-	if (cryprob &lt;= .05)
-	    prout(&quot;Dilithium crystals aboard ship... not yet used.&quot;);
-	else {
-	    int i=0;
-	    double ai = 0.05;
-	    while (cryprob &gt; ai) {
-		ai *= 2.0;
-		i++;
-	    }
-	    prout(&quot;Dilithium crystals have been used %d time%s.&quot;,
-		  i, i==1? &quot;&quot; : &quot;s&quot;);
-	}
-    }
-    skip(1);
-}
-	
-void lrscan(void) 
-{
-    int x, y;
-    chew();
-    if (game.damage[DLRSENS] != 0.0) {
-	/* Now allow base's sensors if docked */
-	if (condit != IHDOCKED) {
-	    prout(&quot;LONG-RANGE SENSORS DAMAGED.&quot;);
-	    return;
-	}
-	prout(&quot;Starbase's long-range scan&quot;);
-    }
-    else {
-	prout(&quot;Long-range scan&quot;);
-    }
-    for (x = quadx-1; x &lt;= quadx+1; x++) {
-	proutn(&quot; &quot;);
-	for (y = quady-1; y &lt;= quady+1; y++) {
-	    if (!VALID_QUADRANT(x, y))
-		proutn(&quot;  -1&quot;);
-	    else {
-		if (!game.damage[DRADIO])
-		    game.state.galaxy[x][y].charted = TRUE;
-		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons;
-		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase;
-		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars;
-		if (game.state.galaxy[x][y].supernova) 
-		    proutn(&quot; ***&quot;);
-		else
-		    proutn(&quot; %3d&quot;, game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars);
-	    }
-	}
-	prout(&quot; &quot;);
-    }
-}
-
-void dreprt(void) 
-{
-    int jdam = FALSE, i;
-    chew();
-
-    for (i = 0; i &lt; NDEVICES; i++) {
-	if (game.damage[i] &gt; 0.0) {
-	    if (!jdam) {
-		prout(&quot;DEVICE            -REPAIR TIMES-&quot;);
-		prout(&quot;                IN FLIGHT   DOCKED&quot;);
-		jdam = TRUE;
-	    }
-	    prout(&quot;  %16s %8.2f  %8.2f&quot;, 
-		  device[i],
-		  game.damage[i]+0.05,
-		  docfac*game.damage[i]+0.005);
-	}
-    }
-    if (!jdam) prout(&quot;All devices functional.&quot;);
-}
-
-void rechart(void)
-/* update the chart in the Enterprise's computer from galaxy data */
-{
-    int i, j;
-    lastchart = game.state.date;
-    for_quadrants(i)
-	for_quadrants(j) 
-	    if (game.state.galaxy[i][j].charted) {
-		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons;
-		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase;
-		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars;
-	    }
-}
-
-void chart(int nn) 
-{
-    int i,j;
-    chew();
-
-    if (game.damage[DRADIO] == 0.0)
-	rechart();
-
-    if (lastchart &lt; game.state.date &amp;&amp; condit == IHDOCKED) {
-	prout(&quot;Spock-  \&quot;I revised the Star Chart from the starbase's records.\&quot;&quot;);
-	rechart();
-    }
-
-    if (nn == 0) prout(&quot;       STAR CHART FOR THE KNOWN GALAXY&quot;);
-    if (game.state.date &gt; lastchart)
-	prout(&quot;(Last surveillance update %d stardates ago).&quot;,
-	      (int)(game.state.date-lastchart));
-    prout(&quot;      1    2    3    4    5    6    7    8&quot;);
-    for_quadrants(i) {
-	proutn(&quot;%d |&quot;, i);
-	for_quadrants(j) {
-	    char buf[4];
-	    if ((game.options &amp; OPTION_SHOWME) &amp;&amp; i == quadx &amp;&amp; j == quady)
-		proutn(&quot;&lt;&quot;);
-	    else
-		proutn(&quot; &quot;);
-	    if (game.state.galaxy[i][j].supernova)
-		strcpy(buf, &quot;***&quot;);
-	    else if (!game.state.galaxy[i][j].charted &amp;&amp; game.state.galaxy[i][j].starbase)
-		strcpy(buf, &quot;.1.&quot;);
-	    else if (game.state.galaxy[i][j].charted)
-		sprintf(buf, &quot;%3d&quot;, game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars);
-	    else
-		strcpy(buf, &quot;...&quot;);
-	    proutn(buf);
-	    if ((game.options &amp; OPTION_SHOWME) &amp;&amp; i == quadx &amp;&amp; j == quady)
-		proutn(&quot;&gt;&quot;);
-	    else
-		proutn(&quot; &quot;);
-	}
-	proutn(&quot;  |&quot;);
-	if (i&lt;GALSIZE) skip(1);
-    }
-}
-
-static void sectscan(int goodScan, int i, int j) 
-{
-    if (goodScan || (abs(i-sectx)&lt;= 1 &amp;&amp; abs(j-secty) &lt;= 1)){
-	if ((game.quad[i][j]==IHMATER0)||(game.quad[i][j]==IHMATER1)||(game.quad[i][j]==IHMATER2)||(game.quad[i][j]==IHE)||(game.quad[i][j]==IHF)){
-	    switch (condit) {
-	    case IHRED: textcolor(RED); break;
-	    case IHGREEN: textcolor(GREEN); break;
-	    case IHYELLOW: textcolor(YELLOW); break;
-	    case IHDOCKED: textcolor(CYAN); break;
-	    case IHDEAD: textcolor(BROWN);
-	    }
-	    if (game.quad[i][j] != ship) 
-		highvideo();
-	}
-	proutn(&quot;%c &quot;,game.quad[i][j]);
-	textcolor(DEFAULT);
-    }
-    else
-	proutn(&quot;- &quot;);
-}
-
-static void status(int req) 
-{
-    char *cp = NULL;
-    int t, dam = 0;
-    switch (req) {
-    case 1:
-	proutn(&quot;Stardate      %.1f, Time Left %.2f&quot;, game.state.date, game.state.remtime);
-	break;
-    case 2:
-	if (condit != IHDOCKED) newcnd();
-	switch (condit) {
-	case IHRED: cp = &quot;RED&quot;; break;
-	case IHGREEN: cp = &quot;GREEN&quot;; break;
-	case IHYELLOW: cp = &quot;YELLOW&quot;; break;
-	case IHDOCKED: cp = &quot;DOCKED&quot;; break;
-	case IHDEAD: cp=&quot;DEAD&quot;; break;
-	}
-	for (t=0;t&lt;NDEVICES;t++)
-	    if (game.damage[t]&gt;0) 
-		dam++;
-	proutn(&quot;Condition     %s, %i DAMAGES&quot;, cp, dam);
-	break;
-    case 3:
-	proutn(&quot;Position      %d - %d , %d - %d&quot;,
-	       quadx, quady, sectx, secty);
-	break;
-    case 4:
-	proutn(&quot;Life Support  &quot;);
-	if (game.damage[DLIFSUP] != 0.0) {
-	    if (condit == IHDOCKED)
-		proutn(&quot;DAMAGED, Base provides&quot;);
-	    else
-		proutn(&quot;DAMAGED, reserves=%4.2f&quot;, lsupres);
-	}
-	else
-	    proutn(&quot;ACTIVE&quot;);
-	break;
-    case 5:
-	proutn(&quot;Warp Factor   %.1f&quot;, warpfac);
-	break;
-    case 6:
-	proutn(&quot;Energy        %.2f&quot;, energy);
-	if (icrystl &amp;&amp; (game.options &amp; OPTION_SHOWME))	/* ESR */
-	    proutn(&quot; (have crystals)&quot;);
-	break;
-    case 7:
-	proutn(&quot;Torpedoes     %d&quot;, torps);
-	break;
-    case 8:
-	proutn(&quot;Shields       &quot;);
-	if (game.damage[DSHIELD] != 0)
-	    proutn(&quot;DAMAGED,&quot;);
-	else if (shldup)
-	    proutn(&quot;UP,&quot;);
-	else
-	    proutn(&quot;DOWN,&quot;);
-	proutn(&quot; %d%% %.1f units&quot;,
-	       (int)((100.0*shield)/inshld + 0.5), shield);
-	break;
-    case 9:
-	proutn(&quot;Klingons Left %d&quot;, KLINGREM);
-	break;
-    case 10:
-	attakreport(1);
-	break;
-    }
-}
-		
-int srscan(int l) 
-{
-    static char requests[][3] =
-	{&quot;&quot;,&quot;da&quot;,&quot;co&quot;,&quot;po&quot;,&quot;ls&quot;,&quot;wa&quot;,&quot;en&quot;,&quot;to&quot;,&quot;sh&quot;,&quot;kl&quot;,&quot;ti&quot;};
-    int leftside=TRUE, rightside=TRUE, i, j, jj, req=0, nn=FALSE;
-    int goodScan=TRUE;
-    switch (l) {
-    case SCAN_FULL: // SRSCAN
-	if (game.damage[DSRSENS] != 0) {
-	    /* Allow base's sensors if docked */
-	    if (condit != IHDOCKED) {
-		prout(&quot;   S.R. SENSORS DAMAGED!&quot;);
-		goodScan=FALSE;
-	    }
-	    else
-		prout(&quot;  [Using Base's sensors]&quot;);
-	}
-	else prout(&quot;     Short-range scan&quot;);
-	if (goodScan &amp;&amp; !game.damage[DRADIO]) { 
-	    game.state.chart[quadx][quady].klingons = game.state.galaxy[quadx][quady].klingons;
-	    game.state.chart[quadx][quady].starbase = game.state.galaxy[quadx][quady].starbase;
-	    game.state.chart[quadx][quady].stars = game.state.galaxy[quadx][quady].stars;
-	    game.state.galaxy[quadx][quady].charted = TRUE;
-	}
-	scan();
-	if (isit(&quot;chart&quot;)) nn = TRUE;
-	if (isit(&quot;no&quot;)) rightside = FALSE;
-	chew();
-	prout(&quot;    1 2 3 4 5 6 7 8 9 10&quot;);
-	break;
-    case SCAN_REQUEST:
-	while (scan() == IHEOL)
-	    proutn(&quot;Information desired? &quot;);
-	chew();
-	for (req = 1; req &lt;= sizeof(requests)/sizeof(requests[0]); req++)
-	    if (strncmp(citem,requests[req],min(2,strlen(citem)))==0)
-		break;
-	if (req &gt; sizeof(requests)/sizeof(requests[0])) {
-	    prout(&quot;UNRECOGNIZED REQUEST. Legal requests are:&quot;);
-	    prout(&quot;  date, condition, position, lsupport, warpfactor,&quot;);
-	    prout(&quot;  energy, torpedoes, shields, klingons, time, bases.&quot;);
-	    return FALSE;
-	}
-	// no break
-    case SCAN_STATUS: // STATUS
-	chew();
-	leftside = FALSE;
-	skip(1);
-	// no break
-    case SCAN_NO_LEFTSIDE: // REQUEST
-	leftside=FALSE;
-	break;
-    }
-    if (condit != IHDOCKED) newcnd();
-    for (i = 1; i &lt;= max(QUADSIZE, sizeof(requests)/sizeof(requests[0])); i++) {
-	jj = (req!=0 ? req : i);
-	if (leftside &amp;&amp; i &lt;= QUADSIZE) {
-	    proutn(&quot;%2d  &quot;, i);
-	    for_sectors(j) {
-		sectscan(goodScan, i, j);
-	    }
-	}
-	if (rightside)
-	    status(jj);
-	if (i&lt;sizeof(requests)/sizeof(requests[0])) skip(1);
-	if (req!=0) return(goodScan);
-    }
-    prout(&quot;&quot;);
-    if (nn) chart(1);
-    return(goodScan);
-}
-			
-			
-void eta(void)
-{
-    int ix1, ix2, iy1, iy2, prompt=FALSE;
-    int wfl;
-    double ttime, twarp, tpower;
-    if (game.damage[DCOMPTR] != 0.0) {
-	prout(&quot;COMPUTER DAMAGED, USE A POCKET CALCULATOR.&quot;);
-	skip(1);
-	return;
-    }
-    if (scan() != IHREAL) {
-	prompt = TRUE;
-	chew();
-	proutn(&quot;Destination quadrant and/or sector? &quot;);
-	if (scan()!=IHREAL) {
-	    huh();
-	    return;
-	}
-    }
-    iy1 = aaitem +0.5;
-    if (scan() != IHREAL) {
-	huh();
-	return;
-    }
-    ix1 = aaitem + 0.5;
-    if (scan() == IHREAL) {
-	iy2 = aaitem + 0.5;
-	if (scan() != IHREAL) {
-	    huh();
-	    return;
-	}
-	ix2 = aaitem + 0.5;
-    }
-    else {
-	if (quady&gt;ix1) ix2 = 1;
-	else ix2=QUADSIZE;
-	if (quadx&gt;iy1) iy2 = 1;
-	else iy2=QUADSIZE;
-    }
-
-    if (!VALID_QUADRANT(ix1, iy1) || !VALID_SECTOR(ix2, iy2)) {
-	huh();
-	return;
-    }
-    dist = sqrt(square(iy1-quadx+0.1*(iy2-sectx))+
-		square(ix1-quady+0.1*(ix2-secty)));
-    wfl = FALSE;
-
-    if (prompt) prout(&quot;Answer \&quot;no\&quot; if you don't know the value:&quot;);
-    while (TRUE) {
-	chew();
-	proutn(&quot;Time or arrival date? &quot;);
-	if (scan()==IHREAL) {
-	    ttime = aaitem;
-	    if (ttime &gt; game.state.date) ttime -= game.state.date; // Actually a star date
-	    if (ttime &lt;= 1e-10 ||
-		(twarp=(floor(sqrt((10.0*dist)/ttime)*10.0)+1.0)/10.0) &gt; 10) {
-		prout(&quot;We'll never make it, sir.&quot;);
-		chew();
-		return;
-	    }
-	    if (twarp &lt; 1.0) twarp = 1.0;
-	    break;
-	}
-	chew();
-	proutn(&quot;Warp factor? &quot;);
-	if (scan()== IHREAL) {
-	    wfl = TRUE;
-	    twarp = aaitem;
-	    if (twarp&lt;1.0 || twarp &gt; 10.0) {
-		huh();
-		return;
-	    }
-	    break;
-	}
-	prout(&quot;Captain, certainly you can give me one of these.&quot;);
-    }
-    while (TRUE) {
-	chew();
-	ttime = (10.0*dist)/square(twarp);
-	tpower = dist*twarp*twarp*twarp*(shldup+1);
-	if (tpower &gt;= energy) {
-	    prout(&quot;Insufficient energy, sir.&quot;);
-	    if (shldup==0 || tpower &gt; energy*2.0) {
-		if (!wfl) return;
-		proutn(&quot;New warp factor to try? &quot;);
-		if (scan() == IHREAL) {
-		    wfl = TRUE;
-		    twarp = aaitem;
-		    if (twarp&lt;1.0 || twarp &gt; 10.0) {
-			huh();
-			return;
-		    }
-		    continue;
-		}
-		else {
-		    chew();
-		    skip(1);
-		    return;
-		}
-	    }
-	    prout(&quot;But if you lower your shields,&quot;);
-	    proutn(&quot;remaining&quot;);
-	    tpower /= 2;
-	}
-	else
-	    proutn(&quot;Remaining&quot;);
-	prout(&quot; energy will be %.2f.&quot;, energy-tpower);
-	if (wfl) {
-	    prout(&quot;And we will arrive at stardate %.2f.&quot;,
-		  game.state.date+ttime);
-	}
-	else if (twarp==1.0)
-	    prout(&quot;Any warp speed is adequate.&quot;);
-	else {
-	    prout(&quot;Minimum warp needed is %.2f,&quot;, twarp);
-	    prout(&quot;and we will arrive at stardate %.2f.&quot;,
-		  game.state.date+ttime);
-	}
-	if (game.state.remtime &lt; ttime)
-	    prout(&quot;Unfortunately, the Federation will be destroyed by then.&quot;);
-	if (twarp &gt; 6.0)
-	    prout(&quot;You'll be taking risks at that speed, Captain&quot;);
-	if ((isatb==1 &amp;&amp; game.state.isy == ix1 &amp;&amp; game.state.isx == iy1 &amp;&amp;
-	     game.future[FSCDBAS]&lt; ttime+game.state.date)||
-	    (game.future[FCDBAS]&lt;ttime+game.state.date &amp;&amp; baty==ix1 &amp;&amp; batx == iy1))
-	    prout(&quot;The starbase there will be destroyed by then.&quot;);
-	proutn(&quot;New warp factor to try? &quot;);
-	if (scan() == IHREAL) {
-	    wfl = TRUE;
-	    twarp = aaitem;
-	    if (twarp&lt;1.0 || twarp &gt; 10.0) {
-		huh();
-		return;
-	    }
-	}
-	else {
-	    chew();
-	    skip(1);
-	    return;
-	}
-    }
-			
-}

Deleted: trunk/setup.c
===================================================================
--- trunk/setup.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/setup.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,742 +0,0 @@
-#include &lt;time.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &quot;sst.h&quot;
-
-static long filelength(int fd) {
-struct stat buf;
-    fstat(fd, &amp;buf);
-    return buf.st_size;
-}
-
-void prelim(void) 
-{
-    skip(2);
-    prout(&quot;-SUPER- STAR TREK&quot;);
-    skip(1);
-#ifdef __HISTORICAL__
-    prout(&quot;Latest update-21 Sept 78&quot;);
-    skip(1);
-#endif /* __HISTORICAL__ */
-}
-
-void freeze(int boss) 
-{
-    FILE *fp;
-    int key;
-    if (boss) {
-	strcpy(citem, &quot;emsave.trk&quot;);
-    }
-    else {
-	if ((key = scan()) == IHEOL) {
-	    proutn(&quot;File name: &quot;);
-	    key = scan();
-	}
-	if (key != IHALPHA) {
-	    huh();
-	    return;
-	}
-	chew();
-	if (strchr(citem, '.') == NULL) {
-	    strcat(citem, &quot;.trk&quot;);
-	}
-    }
-    if ((fp = fopen(citem, &quot;wb&quot;)) == NULL) {
-	proutn(&quot;Can't freeze game as file &quot;);
-	proutn(citem);
-	skip(1);
-	return;
-    }
-    strcpy(game.magic, SSTMAGIC);
-    fwrite(&amp;game, sizeof(game), 1, fp);
-
-    fclose(fp);
-
-    /* I hope that's enough! */
-}
-
-
-int thaw(void) 
-{
-    FILE *fp;
-    int key;
-
-    game.passwd[0] = '\0';
-    if ((key = scan()) == IHEOL) {
-	proutn(&quot;File name: &quot;);
-	key = scan();
-    }
-    if (key != IHALPHA) {
-	huh();
-	return 1;
-    }
-    chew();
-    if (strchr(citem, '.') == NULL) {
-	strcat(citem, &quot;.trk&quot;);
-    }
-    if ((fp = fopen(citem, &quot;rb&quot;)) == NULL) {
-	proutn(&quot;Can't find game file &quot;);
-	proutn(citem);
-	skip(1);
-	return 1;
-    }
-    fread(&amp;game, sizeof(game), 1, fp);
-    if (feof(fp) || ftell(fp) != filelength(fileno(fp)) || strcmp(game.magic, SSTMAGIC)) {
-	prout(&quot;Game file format is bad, should begin with &quot; SSTMAGIC);
-	skip(1);
-	fclose(fp);
-	return 1;
-    }
-
-    fclose(fp);
-
-    return 0;
-}
-
-void abandn(void) 
-{
-    int nb, l;
-
-    chew();
-    if (condit==IHDOCKED) {
-	if (ship!=IHE) {
-	    prout(&quot;You cannot abandon Ye Faerie Queene.&quot;);
-	    return;
-	}
-    }
-    else {
-	/* Must take shuttle craft to exit */
-	if (game.damage[DSHUTTL]==-1) {
-	    prout(&quot;Ye Faerie Queene has no shuttle craft.&quot;);
-	    return;
-	}
-	if (game.damage[DSHUTTL]&lt;0) {
-	    prout(&quot;Shuttle craft now serving Big Mac's.&quot;);
-	    return;
-	}
-	if (game.damage[DSHUTTL]&gt;0) {
-	    prout(&quot;Shuttle craft damaged.&quot;);
-	    return;
-	}
-	if (landed==1) {
-	    prout(&quot;You must be aboard the Enterprise.&quot;);
-	    return;
-	}
-	if (iscraft!=1) {
-	    prout(&quot;Shuttle craft not currently available.&quot;);
-	    return;
-	}
-	/* Print abandon ship messages */
-	skip(1);
-	prouts(&quot;***ABANDON SHIP!  ABANDON SHIP!&quot;);
-	skip(1);
-	prouts(&quot;***ALL HANDS ABANDON SHIP!&quot;);
-	skip(2);
-	prout(&quot;Captain and crew escape in shuttle craft.&quot;);
-	prout(&quot;Remainder of ship's complement beam down&quot;);
-	prout(&quot;to nearest habitable planet.&quot;);
-	if (game.state.rembase==0) {
-	    /* Ops! no place to go... */
-	    finish(FABANDN);
-	    return;
-	}
-	/* If at least one base left, give 'em the Faerie Queene */
-	skip(1);
-	icrystl = 0; /* crystals are lost */
-	nprobes = 0; /* No probes */
-	prout(&quot;You are captured by Klingons and released to&quot;);
-	prout(&quot;the Federation in a prisoner-of-war exchange.&quot;);
-	nb = Rand()*game.state.rembase+1;
-	/* Set up quadrant and position FQ adjacient to base */
-	if (quadx!=game.state.baseqx[nb] || quady!=game.state.baseqy[nb]) {
-	    quadx = game.state.baseqx[nb];
-	    quady = game.state.baseqy[nb];
-	    sectx = secty = 5;
-	    newqad(1);
-	}
-	for (;;) {
-	    /* position next to base by trial and error */
-	    game.quad[sectx][secty] = IHDOT;
-	    for_sectors(l) {
-		sectx = 3.0*Rand() - 1.0 + basex;
-		secty = 3.0*Rand() - 1.0 + basey;
-		if (VALID_SECTOR(sectx, secty) &amp;&amp;
-		    game.quad[sectx][secty] == IHDOT) break;
-	    }
-	    if (l &lt; QUADSIZE+1) break; /* found a spot */
-	    sectx=QUADSIZE/2;
-	    secty=QUADSIZE/2;
-	    newqad(1);
-	}
-    }
-    /* Get new commission */
-    game.quad[sectx][secty] = ship = IHF;
-    prout(&quot;Starfleet puts you in command of another ship,&quot;);
-    prout(&quot;the Faerie Queene, which is antiquated but,&quot;);
-    prout(&quot;still useable.&quot;);
-    if (icrystl!=0) prout(&quot;The dilithium crystals have been moved.&quot;);
-    imine=0;
-    iscraft=0; /* Gallileo disappears */
-    /* Resupply ship */
-    condit=IHDOCKED;
-    for (l = 0; l &lt; NDEVICES; l++) 
-	game.damage[l] = 0.0;
-    game.damage[DSHUTTL] = -1;
-    energy = inenrg = 3000.0;
-    shield = inshld = 1250.0;
-    torps = intorps = 6;
-    lsupres=inlsr=3.0;
-    shldup=0;
-    warpfac=5.0;
-    wfacsq=25.0;
-    return;
-}
-	
-void setup(int needprompt) 
-{
-    int i,j, krem, klumper;
-    int ix, iy;
-#ifdef DEBUG
-    idebug = 0;
-#endif
-    //  Decide how many of everything
-    if (choose(needprompt)) return; // frozen game
-    // Prepare the Enterprise
-    alldone = gamewon = 0;
-    ship = IHE;
-    energy = inenrg = 5000.0;
-    shield = inshld = 2500.0;
-    shldchg = shldup = 0;
-    inlsr = 4.0;
-    lsupres = 4.0;
-    iran(GALSIZE, &amp;quadx, &amp;quady);
-    iran(QUADSIZE, &amp;sectx, &amp;secty);
-    torps = intorps = 10;
-    nprobes = (int)(3.0*Rand() + 2.0);	/* Give them 2-4 of these wonders */
-    warpfac = 5.0;
-    wfacsq = warpfac * warpfac;
-    for (i=0; i &lt; NDEVICES; i++) 
-	game.damage[i] = 0.0;
-    // Set up assorted game parameters
-    batx = baty = 0;
-    game.state.date = indate = 100.0*(int)(31.0*Rand()+20.0);
-    nkinks = nhelp = resting = casual = 0;
-    isatb = iscate = imine = icrystl = icraft = game.state.nplankl = 0;
-    game.state.starkl = game.state.basekl = 0;
-    iscraft = 1;
-    landed = -1;
-    alive = 1;
-    docfac = 0.25;
-    for_quadrants(i)
-	for_quadrants(j) {
-	    game.state.galaxy[i][j].charted = 0;
-	    game.state.galaxy[i][j].planets = 0;
-	    game.state.galaxy[i][j].romulans = 0;
-	    game.state.galaxy[i][j].klingons = 0;
-	    game.state.galaxy[i][j].starbase = 0;
-	    game.state.galaxy[i][j].supernova = 0;
-	}
-    // Initialize times for extraneous events
-    game.future[FSNOVA] = game.state.date + expran(0.5 * intime);
-    game.future[FTBEAM] = game.state.date + expran(1.5 * (intime / game.state.remcom));
-    game.future[FSNAP] = game.state.date + 1.0 + Rand(); // Force an early snapshot
-    game.future[FBATTAK] = game.state.date + expran(0.3*intime);
-    game.future[FCDBAS] = FOREVER;
-    game.future[FSCMOVE] = game.state.nscrem ? game.state.date+0.2777 : FOREVER;
-    game.future[FSCDBAS] = FOREVER;
-    game.future[FDSPROB] = FOREVER;
-    // Starchart is functional but we've never seen it
-    lastchart = FOREVER;
-    // Put stars in the galaxy
-    instar = 0;
-    for_quadrants(i)
-	for_quadrants(j) {
-	    int k = Rand()*9.0 + 1.0;
-	    instar += k;
-	    game.state.galaxy[i][j].stars = k;
-	}
-    // Locate star bases in galaxy
-    for (i = 1; i &lt;= inbase; i++) {
-	int contflag;
-	do {
-	    do iran(GALSIZE, &amp;ix, &amp;iy);
-	    while (game.state.galaxy[ix][iy].starbase);
-	    contflag = FALSE;
-	    for (j = i-1; j &gt; 0; j--) {
-		/* Improved placement algorithm to spread out bases */
-		double distq = square(ix-game.state.baseqx[j]) + square(iy-game.state.baseqy[j]);
-		if (distq &lt; 6.0*(BASEMAX+1-inbase) &amp;&amp; Rand() &lt; 0.75) {
-		    contflag = TRUE;
-#ifdef DEBUG
-		    prout(&quot;DEBUG: Abandoning base #%d at %d-%d&quot;, i, ix, iy);
-#endif
-		    break;
-		}
-#ifdef DEBUG
-		else if (distq &lt; 6.0 * (BASEMAX+1-inbase)) {
-		    prout(&quot;DEBUG: saving base #%d, close to #%d&quot;, i, j);
-		}
-#endif
-	    }
-	} while (contflag);
-			
-	game.state.baseqx[i] = ix;
-	game.state.baseqy[i] = iy;
-	game.state.galaxy[ix][iy].starbase = 1;
-	game.state.chart[ix][iy].starbase = 1;
-    }
-    // Position ordinary Klingon Battle Cruisers
-    krem = inkling;
-    klumper = 0.25*skill*(9.0-length)+1.0;
-    if (klumper &gt; 9) klumper = 9; // Can't have more than 9 in quadrant
-    do {
-	double r = Rand();
-	int klump = (1.0 - r*r)*klumper;
-	if (klump &gt; krem) klump = krem;
-	krem -= klump;
-	do iran(GALSIZE,&amp;ix,&amp;iy);
-	while (game.state.galaxy[ix][iy].supernova ||
-		game.state.galaxy[ix][iy].klingons + klump &gt; 9);
-	game.state.galaxy[ix][iy].klingons += klump;
-    } while (krem &gt; 0);
-    // Position Klingon Commander Ships
-#ifdef DEBUG
-    klumper = 1;
-#endif
-    for (i = 1; i &lt;= incom; i++) {
-	do {
-	    do { /* IF debugging, put commanders by bases, always! */
-#ifdef DEBUG
-		if (idebug &amp;&amp; klumper &lt;= inbase) {
-		    ix = game.state.baseqx[klumper];
-		    iy = game.state.baseqy[klumper];
-		    klumper++;
-		}
-		else
-#endif
-		    iran(GALSIZE, &amp;ix, &amp;iy);
-	    }
-	    while ((!game.state.galaxy[ix][iy].klingons &amp;&amp; Rand() &lt; 0.75)||
-		   game.state.galaxy[ix][iy].supernova||
-		   game.state.galaxy[ix][iy].klingons &gt; 8);
-	    // check for duplicate
-	    for (j = 1; j &lt; i; j++)
-		if (game.state.cx[j]==ix &amp;&amp; game.state.cy[j]==iy) break;
-	} while (j &lt; i);
-	game.state.galaxy[ix][iy].klingons++;
-	game.state.cx[i] = ix;
-	game.state.cy[i] = iy;
-    }
-    // Locate planets in galaxy
-    for (i = 0; i &lt; inplan; i++) {
-	do iran(GALSIZE, &amp;ix, &amp;iy); while (game.state.galaxy[ix][iy].planets);
-	game.state.galaxy[ix][iy].planets = 1;
-	game.state.plnets[i].x = ix;
-	game.state.plnets[i].y = iy;
-	game.state.plnets[i].pclass = Rand()*3.0; // Planet class M N or O
-	game.state.plnets[i].crystals = 1.5*Rand();		// 1 in 3 chance of crystals
-	game.state.plnets[i].known = unknown;
-    }
-    // Locate Romulans
-    for (i = 1; i &lt;= game.state.nromrem; i++) {
-	iran(GALSIZE, &amp;ix, &amp;iy);
-	game.state.galaxy[ix][iy].romulans = 1;
-    }
-    // Locate the Super Commander
-    if (game.state.nscrem &gt; 0) {
-	do iran(GALSIZE, &amp;ix, &amp;iy);
-	while (game.state.galaxy[ix][iy].supernova || game.state.galaxy[ix][iy].klingons &gt; 8);
-	game.state.isx = ix;
-	game.state.isy = iy;
-	game.state.galaxy[ix][iy].klingons++;
-    }
-    // Place thing (in tournament game, thingx == -1, don't want one!)
-    if (thingx != -1) {
-	iran(GALSIZE, &amp;thingx, &amp;thingy);
-    }
-    else {
-	thingx = thingy = 0;
-    }
-
-//	idate = date;
-    skip(2);
-    game.state.snap = 0;
-		
-    if (skill == SKILL_NOVICE) {
-	prout(&quot;It is stardate %d. The Federation is being attacked by&quot;,
-	      (int)game.state.date);
-	prout(&quot;a deadly Klingon invasion force. As captain of the United&quot;);
-	prout(&quot;Starship U.S.S. Enterprise, it is your mission to seek out&quot;);
-	prout(&quot;and destroy this invasion force of %d battle cruisers.&quot;,
-	      INKLINGTOT);
-	prout(&quot;You have an initial allotment of %d stardates to complete&quot;, (int)intime);
-	prout(&quot;your mission.  As you proceed you may be given more time.&quot;);
-	prout(&quot;&quot;);
-	prout(&quot;You will have %d supporting starbases.&quot;, inbase);
-	proutn(&quot;Starbase locations-  &quot;);
-    }
-    else {
-	prout(&quot;Stardate %d.&quot;, (int)game.state.date);
-	prout(&quot;&quot;);
-	prout(&quot;%d Klingons.&quot;, INKLINGTOT);
-	prout(&quot;An unknown number of Romulans.&quot;);
-	if (game.state.nscrem) prout(&quot;and one (GULP) Super-Commander.&quot;);
-	prout(&quot;%d stardates.&quot;,(int)intime);
-	proutn(&quot;%d starbases in &quot;, inbase);
-    }
-    for (i = 1; i &lt;= inbase; i++) {
-	proutn(cramlc(0, game.state.baseqx[i], game.state.baseqy[i]));
-	proutn(&quot;  &quot;);
-    }
-    skip(2);
-    proutn(&quot;The Enterprise is currently in &quot;);
-    proutn(cramlc(quadrant, quadx, quady));
-    proutn(&quot; &quot;);
-    proutn(cramlc(sector, sectx, secty));
-    skip(2);
-    prout(&quot;Good Luck!&quot;);
-    if (game.state.nscrem) prout(&quot;  YOU'LL NEED IT.&quot;);
-    waitfor();
-    newqad(0);
-    if (nenhere-iqhere-ithere) shldup=1.0;
-    if (neutz) attack(0);	// bad luck to start in a Romulan Neutral Zone
-}
-
-void randomize(void) 
-{
-    srand((int)time(NULL));
-}
-
-int choose(int needprompt) 
-{
-    while (TRUE) {
-	tourn = 0;
-	thawed = 0;
-	skill = SKILL_NONE;
-	length = 0;
-	if (needprompt) /* Can start with command line options */
-	    proutn(&quot;Would you like a regular, tournament, or saved game? &quot;);
-	scan();
-	if (strlen(citem)==0) continue; // Try again
-	if (isit(&quot;tournament&quot;)) {
-	    while (scan() == IHEOL) {
-		proutn(&quot;Type in tournament number-&quot;);
-	    }
-	    if (aaitem == 0) {
-		chew();
-		continue; // We don't want a blank entry
-	    }
-	    tourn = (int)aaitem;
-	    thingx = -1;
-	    srand((unsigned int)(int)aaitem);
-	    break;
-	}
-	if (isit(&quot;saved&quot;) || isit(&quot;frozen&quot;)) {
-	    if (thaw()) continue;
-	    chew();
-	    if (*game.passwd==0) continue;
-	    if (!alldone) thawed = 1; // No plaque if not finished
-	    report();
-	    waitfor();
-	    return TRUE;
-	}
-	if (isit(&quot;regular&quot;)) break;
-	proutn(&quot;What is \&quot;&quot;);
-	proutn(citem);
-	prout(&quot;\&quot;?&quot;);
-	chew();
-    }
-    while (length==0 || skill==SKILL_NONE) {
-	if (scan() == IHALPHA) {
-	    if (isit(&quot;short&quot;)) length = 1;
-	    else if (isit(&quot;medium&quot;)) length = 2;
-	    else if (isit(&quot;long&quot;)) length = 4;
-	    else if (isit(&quot;novice&quot;)) skill = SKILL_NOVICE;
-	    else if (isit(&quot;fair&quot;)) skill = SKILL_FAIR;
-	    else if (isit(&quot;good&quot;)) skill = SKILL_GOOD;
-	    else if (isit(&quot;expert&quot;)) skill = SKILL_EXPERT;
-	    else if (isit(&quot;emeritus&quot;)) skill = SKILL_EMERITUS;
-	    else {
-		proutn(&quot;What is \&quot;&quot;);
-		proutn(citem);
-		prout(&quot;\&quot;?&quot;);
-	    }
-	}
-	else {
-	    chew();
-	    if (length==0) proutn(&quot;Would you like a Short, Medium, or Long game? &quot;);
-	    else if (skill == SKILL_NONE) proutn(&quot;Are you a Novice, Fair, Good, Expert, or Emeritus player? &quot;);
-	}
-    }
-    // Choose game options -- added by ESR for SST2K
-    if (scan() != IHALPHA) {
-	chew();
-	proutn(&quot;Choose your game options: &quot;);
-	scan();
-    }
-    if (isit(&quot;plain&quot;)) {
-	// Approximates the UT FORTRAN version.
-	game.options &amp;=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE);
-	game.options |= OPTION_PLAIN;
-    } 
-    else if (isit(&quot;almy&quot;)) {
-	// Approximates Tom Almy's version.
-	game.options &amp;=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE);
-	game.options |= OPTION_ALMY;
-    }
-    else if (isit(&quot;fancy&quot;))
-	/* do nothing */;
-    else if (strlen(citem)) {
-	    proutn(&quot;What is \&quot;&quot;);
-	    proutn(citem);
-	    prout(&quot;\&quot;?&quot;);
-    }
-    setpassword();
-#ifdef DEBUG
-    if (strcmp(game.passwd, &quot;debug&quot;)==0) idebug = 1;
-#endif
-
-    // Use parameters to generate initial values of things
-    damfac = 0.5 * skill;
-    game.state.rembase = 2.0 + Rand()*(BASEMAX-2.0);
-    inbase = game.state.rembase;
-    if (game.options &amp; OPTION_PLANETS)
-	inplan = (PLNETMAX/2) + (PLNETMAX/2+1)*Rand();
-    game.state.nromrem = inrom = (2.0+Rand())*skill;
-    game.state.nscrem = inscom = (skill &gt; SKILL_FAIR ? 1 : 0);
-    game.state.remtime = 7.0 * length;
-    intime = game.state.remtime;
-    game.state.remkl = inkling = 2.0*intime*((skill+1 - 2*Rand())*skill*0.1+.15);
-    incom = skill + 0.0625*inkling*Rand();
-    game.state.remcom = min(10, incom);
-    incom = game.state.remcom;
-    game.state.remres = (inkling+4*incom)*intime;
-    inresor = game.state.remres;
-    if (inkling &gt; 50) {
-	inbase = (game.state.rembase += 1);
-    }
-    return FALSE;
-}
-
-void dropin(int iquad, int *ix, int *iy) 
-{
-    do iran(QUADSIZE, ix, iy);
-    while (game.quad[*ix][*iy] != IHDOT);
-    game.quad[*ix][*iy] = iquad;
-}
-
-void newcnd(void) 
-{
-    condit = IHGREEN;
-    if (energy &lt; 1000.0) condit = IHYELLOW;
-    if (game.state.galaxy[quadx][quady].klingons || game.state.galaxy[quadx][quady].romulans)
-	condit = IHRED;
-    if (!alive) condit=IHDEAD;
-}
-
-
-void newqad(int shutup) 
-{
-    int i, j, ix, iy, nplan;
-
-    iattak = 1;
-    justin = 1;
-    basex = basey = 0;
-    klhere = 0;
-    comhere = 0;
-    plnetx = plnety = 0;
-    ishere = 0;
-    irhere = 0;
-    iplnet = 0;
-    nenhere = 0;
-    neutz = 0;
-    inorbit = 0;
-    landed = -1;
-    ientesc = 0;
-    ithere = 0;
-    iqhere=0;
-    iqengry=0;
-    iseenit = 0;
-    if (iscate) {
-	// Attempt to escape Super-commander, so tbeam back!
-	iscate = 0;
-	ientesc = 1;
-    }
-    // Clear quadrant
-    for_sectors(i)
-	for_sectors(j) 
-	    game.quad[i][j] = IHDOT;
-    // cope with supernova
-    if (game.state.galaxy[quadx][quady].supernova)
-	return;
-    klhere = game.state.galaxy[quadx][quady].klingons;
-    irhere = game.state.galaxy[quadx][quady].romulans;
-    nplan  = game.state.galaxy[quadx][quady].planets;
-    nenhere = klhere + irhere;
-
-    // Position Starship
-    game.quad[sectx][secty] = ship;
-
-    if (game.state.galaxy[quadx][quady].klingons) {
-	// Position ordinary Klingons
-	for (i = 1; i &lt;= klhere; i++) {
-	    dropin(IHK, &amp;ix, &amp;iy);
-	    game.kx[i] = ix;
-	    game.ky[i] = iy;
-	    game.kdist[i] = game.kavgd[i] = sqrt(square(sectx-ix) + square(secty-iy));
-	    game.kpower[i] = Rand()*150.0 +300.0 +25.0*skill;
-	}
-	// If we need a commander, promote a Klingon
-	for_commanders(i)
-	    if (game.state.cx[i]==quadx &amp;&amp; game.state.cy[i]==quady) break;
-			
-	if (i &lt;= game.state.remcom) {
-	    game.quad[ix][iy] = IHC;
-	    game.kpower[klhere] = 950.0+400.0*Rand()+50.0*skill;
-	    comhere = 1;
-	}
-
-	// If we need a super-commander, promote a Klingon
-	if (quadx == game.state.isx &amp;&amp; quady == game.state.isy) {
-	    game.quad[game.kx[1]][game.ky[1]] = IHS;
-	    game.kpower[1] = 1175.0 + 400.0*Rand() + 125.0*skill;
-	    iscate = game.state.remkl&gt;1;
-	    ishere = 1;
-	}
-    }
-    // Put in Romulans if needed
-    for (i = klhere+1; i &lt;= nenhere; i++) {
-	dropin(IHR, &amp;ix, &amp;iy);
-	game.kx[i] = ix;
-	game.ky[i] = iy;
-	game.kdist[i] = game.kavgd[i] = sqrt(square(sectx-ix) + square(secty-iy));
-	game.kpower[i] = Rand()*400.0 + 450.0 + 50.0*skill;
-    }
-    // If quadrant needs a starbase, put it in
-    if (game.state.galaxy[quadx][quady].starbase)
-	dropin(IHB, &amp;basex, &amp;basey);
-	
-    if (nplan) {
-	// If quadrant needs a planet, put it in
-	for (i=0; i &lt; inplan; i++)
-	    if (game.state.plnets[i].x == quadx &amp;&amp; game.state.plnets[i].y == quady) break;
-	if (i &lt; inplan) {
-	    iplnet = i;
-	    dropin(IHP, &amp;plnetx, &amp;plnety);
-	}
-    }
-    // Check for condition
-    newcnd();
-    // And finally the stars
-    for (i = 1; i &lt;= game.state.galaxy[quadx][quady].stars; i++) 
-	dropin(IHSTAR, &amp;ix, &amp;iy);
-
-    // Check for RNZ
-    if (irhere &gt; 0 &amp;&amp; klhere == 0) {
-	neutz = 1;
-	if (game.damage[DRADIO] &lt;= 0.0) {
-	    skip(1);
-	    prout(&quot;LT. Uhura- \&quot;Captain, an urgent message.&quot;);
-	    prout(&quot;  I'll put it on audio.\&quot;  CLICK&quot;);
-	    skip(1);
-	    prout(&quot;INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE.&quot;);
-	    prout(&quot;LEAVE AT ONCE, OR YOU WILL BE DESTROYED!&quot;);
-	}
-    }
-
-    if (shutup==0) {
-	// Put in THING if needed
-	if (thingx == quadx &amp;&amp; thingy == quady) {
-	    dropin(IHQUEST, &amp;ix, &amp;iy);
-	    iran(GALSIZE, &amp;thingx, &amp;thingy);
-	    nenhere++;
-	    iqhere=1;
-	    game.kx[nenhere] = ix;
-	    game.ky[nenhere] = iy;
-	    game.kdist[nenhere] = game.kavgd[nenhere] =
-		sqrt(square(sectx-ix) + square(secty-iy));
-	    game.kpower[nenhere] = Rand()*6000.0 +500.0 +250.0*skill;
-	    if (game.damage[DSRSENS] == 0.0) {
-		skip(1);
-		prout(&quot;MR. SPOCK- \&quot;Captain, this is most unusual.&quot;);
-		prout(&quot;    Please examine your short-range scan.\&quot;&quot;);
-	    }
-	}
-    }
-
-    // Decide if quadrant needs a Tholian
-    if (game.options &amp; OPTION_THOLIAN) {
-	if ((skill &lt; SKILL_GOOD &amp;&amp; Rand() &lt;= 0.02) ||   /* Lighten up if skill is low */
-	    (skill == SKILL_GOOD &amp;&amp; Rand() &lt;= 0.05) ||
-	    (skill &gt; SKILL_GOOD &amp;&amp; Rand() &lt;= 0.08)
-    #ifdef DEBUG
-	    || strcmp(game.passwd, &quot;tholianx&quot;)==0
-    #endif
-	    ) {
-	    do {
-		ithx = Rand() &gt; 0.5 ? QUADSIZE : 1;
-		ithy = Rand() &gt; 0.5 ? QUADSIZE : 1;
-	    } while (game.quad[ithx][ithy] != IHDOT);
-	    game.quad[ithx][ithy] = IHT;
-	    ithere = 1;
-	    nenhere++;
-	    game.kx[nenhere] = ithx;
-	    game.ky[nenhere] = ithy;
-	    game.kdist[nenhere] = game.kavgd[nenhere] =
-		sqrt(square(sectx-ithx) + square(secty-ithy));
-	    game.kpower[nenhere] = Rand()*400.0 +100.0 +25.0*skill;
-	    /* Reserve unocupied corners */
-	    if (game.quad[1][1]==IHDOT) game.quad[1][1] = 'X';
-	    if (game.quad[1][QUADSIZE]==IHDOT) game.quad[1][QUADSIZE] = 'X';
-	    if (game.quad[QUADSIZE][1]==IHDOT) game.quad[QUADSIZE][1] = 'X';
-	    if (game.quad[QUADSIZE][QUADSIZE]==IHDOT) game.quad[QUADSIZE][QUADSIZE] = 'X';
-	}
-    }
-
-    sortkl();
-
-    // Put in a few black holes
-    for (i = 1; i &lt;= 3; i++)
-	if (Rand() &gt; 0.5) 
-	    dropin(IHBLANK, &amp;ix, &amp;iy);
-
-    // Take out X's in corners if Tholian present
-    if (ithere) {
-	if (game.quad[1][1]=='X') game.quad[1][1] = IHDOT;
-	if (game.quad[1][QUADSIZE]=='X') game.quad[1][QUADSIZE] = IHDOT;
-	if (game.quad[QUADSIZE][1]=='X') game.quad[QUADSIZE][1] = IHDOT;
-	if (game.quad[QUADSIZE][QUADSIZE]=='X') game.quad[QUADSIZE][QUADSIZE] = IHDOT;
-    }		
-}
-
-void sortkl(void) 
-{
-    double t;
-    int sw, j, k;
-
-    // The author liked bubble sort. So we will use it. :-(
-
-    if (nenhere-iqhere-ithere &lt; 2) return;
-
-    do {
-	sw = FALSE;
-	for (j = 1; j &lt; nenhere; j++)
-	    if (game.kdist[j] &gt; game.kdist[j+1]) {
-		sw = TRUE;
-		t = game.kdist[j];
-		game.kdist[j] = game.kdist[j+1];
-		game.kdist[j+1] = t;
-		t = game.kavgd[j];
-		game.kavgd[j] = game.kavgd[j+1];
-		game.kavgd[j+1] = t;
-		k = game.kx[j];
-		game.kx[j] = game.kx[j+1];
-		game.kx[j+1] = k;
-		k = game.ky[j];
-		game.ky[j] = game.ky[j+1];
-		game.ky[j+1] = k;
-		t = game.kpower[j];
-		game.kpower[j] = game.kpower[j+1];
-		game.kpower[j+1] = t;
-	    }
-    } while (sw);
-}

Copied: trunk/src (from rev 538, branches/at-work/src)

Deleted: trunk/sst-doc.xml
===================================================================
--- trunk/sst-doc.xml	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sst-doc.xml	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,1964 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
-&lt;!DOCTYPE book PUBLIC 
-    &quot;-//OASIS//DTD DocBook XML V4.1.2//EN&quot; 
-    &quot;docbook/docbookxx.dtd&quot;[
-&lt;!ENTITY sst-site      &quot;<A HREF="http://sst.berlios.de/">http://sst.berlios.de/</A>&quot;&gt;
-&lt;!ENTITY retro         &quot;<A HREF="http://catb.org/~esr/retro/">http://catb.org/~esr/retro/</A>&quot;&gt;
-]&gt;
-&lt;book&gt;
-&lt;bookinfo&gt;
-&lt;title&gt;Super Star Trek&lt;/title&gt;
-
-&lt;authorgroup&gt;
-&lt;author&gt;
-  &lt;firstname&gt;David&lt;/firstname&gt;
-  &lt;surname&gt;Matuzsek&lt;/surname&gt;
-&lt;/author&gt;
-&lt;author&gt;
-  &lt;firstname&gt;Paul&lt;/firstname&gt;
-  &lt;surname&gt;Reynolds&lt;/surname&gt;
-&lt;/author&gt;
-&lt;author&gt;
-  &lt;firstname&gt;Tom&lt;/firstname&gt;
-  &lt;surname&gt;Almy&lt;/surname&gt;
-&lt;/author&gt;
-&lt;author&gt;
-  &lt;firstname&gt;Stas&lt;/firstname&gt;
-  &lt;surname&gt;Sergeev&lt;/surname&gt;
-&lt;/author&gt;
-&lt;author&gt;
-  &lt;firstname&gt;Eric&lt;/firstname&gt;
-  &lt;othername&gt;Steven&lt;/othername&gt;
-  &lt;surname&gt;Raymond&lt;/surname&gt;
-&lt;/author&gt;
-&lt;/authorgroup&gt;
-
-&lt;legalnotice&gt;
-&lt;para&gt;Permission is hereby granted for the copying, distribution,
-modification and use of this program and associated documentation
-for recreational purposes, provided that all references to the
-authors are retained.  However, permission is not and will not be
-granted for the sale or promotional use of this program or program
-documentation, or for use in any situation in which profit may be
-considered an objective, since it is the desire of the authors to
-respect the copyrights of the originators of Star Trek.&lt;/para&gt;
-&lt;/legalnotice&gt;
-&lt;/bookinfo&gt;
-
-
-&lt;dedication&gt;
-&lt;literallayout format='linespecific' class='monospaced'&gt;
-                SSSSS   U   U   PPPPP   EEEEE   RRRRR
-                S       U   U   P   P   E       R   R
-                SSSSS   U   U   PPPPP   EEEE    RRRRR
-                    S   U   U   P       E       R  R
-                SSSSS   UUUUU   P       EEEEE   R   R
-
-
-                 SSSSSSS  TTTTTTTT     A     RRRRRRR
-                SSSSSSSS  TTTTTTTT    AAA    RRRRRRRR
-               SS            TT       AAA    RR     RR
-               SSSSSSS       TT      AA AA   RR     RR
-                SSSSSSS      TT      AA AA   RRRRRRRR
-                      SS     TT     AAAAAAA  RRRRRRR
-                      SS     TT     AAAAAAA  RR   RR
-               SSSSSSSS      TT    AA     AA RR    RR
-               SSSSSSS       TT    AA     AA RR     RR
-    
-    
-    
-                TTTTTTTT RRRRRRR   EEEEEEEEE KK     KK
-                TTTTTTTT RRRRRRRR  EEEEEEEEE KK    KK
-                   TT    RR     RR EE        KK   KK
-                   TT    RR     RR EEEEEE    KKKKKK
-                   TT    RRRRRRRR  EEEEEE    KKKKK
-                   TT    RRRRRRR   EE        KK  KK
-                   TT    RR   RR   EE        KK   KK
-                   TT    RR    RR  EEEEEEEEE KK    KK
-                   TT    RR     RR EEEEEEEEE KK     KK
-
-
-                     Produced For Your Enjoyment
-
-                                 By
-
-                            David Matuszek
-                                 and
-                            Paul Reynolds
-
-                        With Modifications By
-                              Don Smith
-
-                            Resurrected By
-                               Tom Almy
-
-			  Curses Interface By
-                              Stas Sergeev 
-
-		SST 2K polishing and historical research by
-			     Eric S. Raymond
-&lt;/literallayout&gt;
-&lt;/dedication&gt;
-
-&lt;chapter&gt;&lt;title&gt;Introduction&lt;/title&gt;
-&lt;para&gt;The Organian Peace Treaty has collapsed, and the Federation is at war
-with the Klingon Empire.  Joining the Klingons against the Federation
-are the members of the &lt;quote&gt;Romulan Star Empire.&lt;/quote&gt;  As commander of the
-Starship U.S.S. Enterprise, your job is to wipe out the Klingon
-invasion fleet and make the galaxy safe for democracy.&lt;/para&gt;
-
-&lt;para&gt;Your battleground is the entire galaxy, which for convenience is
-divided up into eight rows of eight quadrants each, like a
-checkerboard.  Rows are numbered from top to bottom, and columns are
-numbered left to right, so quadrant 1 - 8 would be in the upper right
-hand corner of the galaxy.&lt;/para&gt;
-
-&lt;para&gt;During battle you will be concerned only with those enemies that
-occupy the same quadrant as yourself.  Quadrants are divided up into
-sectors: ten rows of ten sectors each. Sectors are numbered in the
-same way as quadrants, so the sector in the upper right corner is
-sector 1 - 10.  You have a short-range scanner which allows you to
-look at the entire quadrant in a single display.&lt;/para&gt;
-
-&lt;para&gt;Enemies recharge during your absence.  If you leave a quadrant
-containing a weakened enemy, when you return to that quadrant he will
-be strong again.  Also, each time you enter a quadrant, the positions
-of everthing in the quadrant (except your ship) are randomized, to
-save you the trouble of trying to remember where everything in the
-quadrant is.  Notice that this refers only to the positions of things
-in the quadrant&mdash;the numbers of each kind of thing are not changed
-(except for black holes and the Super-commander, which move around
-the galaxy).  If you kill something, it stays dead.&lt;/para&gt;
-
-&lt;para&gt;The Romulans are not as serious a threat to the Federation as the
-Klingons.  For one thing, there are not as many of them.  For
-another, the Romulans are not as treacherous.  However, Romulans are
-not to be trifled with, especially when you are in violation of the
-Romulan Neutral Zone.&lt;/para&gt;
-
-&lt;para&gt;There are two kinds of Klingons: Ordinary Klingons, which are
-bad enough, and Klingon Commanders, which are even worse.  Commanders
-are about three times stronger than ordinary Klingons.  Commanders are
-more resistant to your weapons.  Commanders can move about during
-battle while Ordinary Klingons stay put.  And finally, Commanders have
-a thing called a &lt;quote&gt;long-range tractor beam&lt;/quote&gt; which they can
-use, at random intervals, to yank you away from what you are doing
-into their quadrant, to do battle with them.  There is also a special
-commander, called the &lt;quote&gt;Super-commander.&lt;/quote&gt; This character
-is so bad he is reserved for the Good, Expert, and Emeritus games.
-Fortunately, there is just one Super-commander in a game.  In addition
-to the undesirable traits of Commanders, he can move from quadrant to
-quadrant at will, seeking out and destroying your starbases and any
-helpful planets he runs across.  He also has a spy planted aboard your
-ship, giving him valuable information about your condition.  Using
-this information, he can do dastardly things like tractor beam your
-ship when you are in bad shape.  And once you've been tractor beamed
-by the Super-commander &mdash;&lt;/para&gt;
-
-&lt;para&gt;But the advantages are not all on the side of the enemy.  Your ship
-is more powerful, and has better weapons.  Besides, in the this
-galaxy there are from two to five starbases, at which you can stop to
-refuel and lick your wounds, safe from phaser attack or tractor
-beams.  But you had best not dally there too long, since time is not
-on your side.  The Klingons are not just after you; they are
-attacking the entire Federation.  There is always a finite &lt;quote&gt;time
-left,&lt;/quote&gt; which is how much longer the Federation can hold out if you
-just sit on your fat behind and do nothing.  As you wipe out
-Klingons, you reduce the rate at which the invasion fleet weakens the
-Federation, and so the time left until the Federation collapses may
-actually increase.  Since Klingons are the main threat to the
-Federation, the Romulans do not figure into the &lt;quote&gt;time left.&lt;/quote&gt;  In
-fact, you need not kill all the Romulans to win.  If you can get all
-the Klingons, the Federation will abide forever, and you have won the
-game.&lt;/para&gt;
-
-&lt;para&gt;Space is vast, and it takes precious time to move from one place to
-another.  In comparison, other things happen so quickly that we
-assume they take no time at all. Two ways that time can pass are when
-you move, or when you issue a command to sit still and rest for a
-period of time.  You will sometimes want to do the latter, since the
-various devices aboard your starship may be damaged and require time
-to repair.  Of course, repairs can be made more quickly at a starbase
-than than can in flight.&lt;/para&gt;
-
-&lt;para&gt;In addition to Klingons, Romulans, and starbases, the galaxy
-contains (surprise) stars.  Mostly, stars are a nuisance and just get
-in your way.  You can trigger a star into going nova by shooting one
-of your photon torpedoes at it.  When a star novas, it does a lot of
-dammage to anything immediately adjacent to it.  If another star is
-adjacent to a nova, it too will go nova.  Stars may also occasionally
-go supernova; a supernova in a quadrant destroys everything in the
-quadrant andmakes the quadrant permanently uninhabitable.  You may
-&lt;quote&gt;jump over&lt;/quote&gt; a quadrant containing a supernova when you
-move, but you should not stop there.&lt;/para&gt;
-
-&lt;para&gt;Supernovas may happen spontaneously, without provocation.  If a
-supernova occurs in the same quadrant you are in, your starship has an
-&lt;quote&gt;emergency automatic override&lt;/quote&gt; which picks some random
-direction and some random warp factor, and tries to throw you clear of
-the supernova. If the supernova occurs in some other quadrant, you
-just get a warning message from starfleet about it (provided, of
-course, that your subspace radio is working).&lt;/para&gt;
-
-&lt;para&gt;Also a few planets are scattered through the galaxy.  These can
-sometimes be a great help since some of them will have &lt;quote&gt;dilithium
-crystals,&lt;/quote&gt; which are capable of replenishing the ship's energy
-supply.  You can either beam down to the planet surface using the
-transporter, or take the shuttle craft &lt;quote&gt;Galileo&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;para&gt;Finally, each quadrant will contain from zero to three black
-holes.  These can deflect or swallow torpedoes passing near them. They
-also swallow enemy ships knocked into them.  If your ship enters one
-&mdash;&lt;/para&gt;
-
-&lt;para&gt;Star Trek is a rich game, full of detail.  These instructions are
-written at a moderate level&mdash;no attempt has been made fully to
-describe everything about the game, but there is quite a bit more
-here than you need to get started.  If you are new to the game, just
-get a rough idea of the kinds of commands available, and start
-playing.  After a game or two you will have learned everthing
-important, and the detailed command descriptions which follow will be
-a lot more meaningful to you.&lt;/para&gt;
-
-&lt;para&gt;You have weapons: phasers and photon torpedoes. You have a defense:
-deflector shields.  You can look at things: long-range scaners,
-short-range scanners, and a star chart.  You can move about, under
-warp drive or impulse power.  You can also dock at a starbase, rest
-while repairs are being made, abandon ship, self destruct, or give up
-and start a new game.&lt;/para&gt;
-
-&lt;para&gt;The Klingons are waiting.&lt;/para&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;Starting the Game&lt;/title&gt;
-
-&lt;para&gt;The program will ask you some setup questions.  You can give it 
-command-line arguments that will be treated as answers.  Any token
-may be abbreviated to a unique prefix.&lt;/para&gt;
-
-&lt;para&gt;The first question concerns whether you want a regullar,
-tournament, or saved game.  For discussion, see the &lt;link
-linkend=&quot;freeze&quot;&gt;description of the freeze command&lt;/link&gt;.&lt;/para&gt;
-
-&lt;para&gt;The second question will concern the length of the game.  
-Longer games include more enemies.&lt;/para&gt;
-
-&lt;para&gt;The third question will set the game's difficulty level.
-You should probably start out at the novice level, even if you are
-already familiar with one of the other versions of the Star Trek
-game&mdash;but, of course, the level of game you play is up to you.  If
-you want to start at the Expert level, go ahead.  It's your funeral.
-The Emeritus game is strictly for masochists.&lt;/para&gt;
-
-&lt;para&gt;The fourth question, new in SST2K, sets your game options.  A
-blank answer or 'fancy' enables all SST2K features.  The option
-'plain' disables a number of features (Tholians, planets &amp;
-dilithium, Thingies shooting back, deep-space-probes, Klingon ramming
-and movement, time-warping through black holes, death-ray upgrade),
-approximating the original CDC 6600 FORTRAN game from UT Austin.  The
-option 'almy' approximates Tom Almy's C translation from 1979,
-disabling Thingies shooting back, base shields, and time-warping
-through black holes.&lt;/para&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;How To Issue Commands&lt;/title&gt;
-
-&lt;para&gt;When the game is waiting for you to enter a command it will
-print out&lt;/para&gt;
-
-&lt;screen&gt;
-	COMMAND&gt;
-&lt;/screen&gt;
-
-&lt;para&gt;You may then type in your command.  All you have to remember for each
-command is the mnemonic. For example, if you want to move straight up
-one quadrant, you can type in the mnemonic (case insensitive)&lt;/para&gt;
-
-&lt;screen&gt;
-	move
-&lt;/screen&gt;
-
-&lt;para&gt;and the computer will prompt you with&lt;/para&gt;
-
-&lt;screen&gt;
-	Manual or automatic- 
-&lt;/screen&gt;
-
-&lt;para&gt;Say you type in &lt;quote&gt;manual&lt;/quote&gt;. The computer then responds&lt;/para&gt;
-
-&lt;screen&gt;
-	X and Y displacements- 
-&lt;/screen&gt;
-
-&lt;para&gt;Now you type in &lt;quote&gt;0 1&lt;/quote&gt; which specifies an X movement of zero and a Y
-movement of one.&lt;/para&gt;
-
-&lt;para&gt;When you have learned the commands, you can avoid being prompted
-simply by typing in the information without waiting to be asked for
-it. For example, in the above example, you could simply type in&lt;/para&gt;
-
-&lt;screen&gt;
-	move manual 0 1
-&lt;/screen&gt;
-
-&lt;para&gt;and it will be done.  Or you could type in&lt;/para&gt;
-
-&lt;screen&gt;
-	move manual
-&lt;/screen&gt;
-
-&lt;para&gt;and when the computer responds with the displacement prompt, you
-can type in&lt;/para&gt;
-
-&lt;screen&gt;
-	0 1
-&lt;/screen&gt;
-
-&lt;para&gt;and it will understand.&lt;/para&gt;
-
-&lt;para&gt;You can abbreviate most mnemonics.  For &lt;quote&gt;move&lt;/quote&gt;, you can use any
-of&lt;/para&gt;
-
-&lt;screen&gt;
-	move mov mo m
-&lt;/screen&gt;
-
-&lt;para&gt;successfully.  For your safety, certain critical commands (such as to
-abandon ship) must be written out in full.  Also, in a few cases two
-or more commands begin with the same letter, and in this case that
-letter refers to a particular one of the commands; to get the other,
-your abbreviation must be two or more characters long.  This sounds
-complicated, but you will learn the abbreviations qGuickly enough.&lt;/para&gt;
-
-&lt;para&gt;What this all boils down to is:&lt;/para&gt;
-
-&lt;orderedlist&gt;
-&lt;listitem&gt;&lt;para&gt;You can abbreviate practically anything&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;If you forget, the computer will prompt you&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;If you remember, you can type it all on one line&lt;/para&gt;&lt;/listitem&gt;
-&lt;/orderedlist&gt;
-
-&lt;para&gt;If you are part way through entering a command and you change your
-minde, you can cancel the command by typing -1 as one of the
-parameters, with the exception of the manual move command.&lt;/para&gt;
-
-&lt;para&gt;If anything is not clear to you, experiment.  The worst you can do is
-lose a game or two.&lt;/para&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;List of Commands&lt;/title&gt;
-
-&lt;sect1&gt;&lt;title&gt;Short-Range Scan&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  SRSCAN
-Shortest abbreviation:  S
-Full commands:  SRSCAN
-                SRSCAN NO
-                SRSCAN CHART
-&lt;/literallayout&gt;
-
-&lt;!-- This is new in SST 2K --&gt;
-&lt;para&gt;If you are using the screen-oriented interface, this command is
-suppressed; instead, a short-range scan will always be present on the
-screen.&lt;/para&gt;
-
-&lt;para&gt;The short-range scan gives you a considerable amount of information
-about the quadrant your starship is in.  A short-range scan is best
-described by an example.&lt;/para&gt;
-
-&lt;screen&gt;
-         1 2 3 4 5 6 7 8 9 10
-      1  * . . . . R . . . .  Stardate      2516.3
-      2  . . . E . . . . . .  Condition     RED  
-      3  . . . . . * . B . .  Position      5 - 1, 2 - 4
-      4  . . . S . . . . . .  Life Support  DAMAGED, Reserves=2.30
-      5  . . . . . . . K . .  Warp Factor   5.0
-      6  . K .   . . . . * .  Energy        2176.24
-      7  . . . . . P . . . .  Torpedoes     3
-      8  . . . . * . . . . .  Shields       UP, 42% 1050.0 units
-      9  . * . . * . . . C .  Klingons Left 12
-     10  . . . . . . . . . .  Time Left     3.72
-&lt;/screen&gt;
-
-&lt;para&gt;The left part is a picture of the quadrant.  The E at sector 2 -
-4 represents the Enterprise; the B at sector 3 - 8 is a starbase.
-There are ordinary Klingons (K) at sectors 5 - 8 and 6 - 2, and a
-Klingon Commander (C) at 9 - 9.  The (GULP)
-&lt;quote&gt;Super-commander&lt;/quote&gt; (S) is occupies sector 4 - 4, and a
-Romulan (R) is at 1 - 6.  A planet (P) is at sector 7 - 6.  There are
-also a large number of stars (*). The periods (.) are just empty
-space&mdash;they are printed to help you get your bearings.  Sector 6
-- 4 contains a black hole ( ).&lt;/para&gt;
-
-&lt;para&gt;The information on the right is assorted status information. You
-can get this alone with the STATUS command.  The status information
-will be absent if you type &lt;quote&gt;N&lt;/quote&gt; after SRSCAN.  Otherwise
-status information will be presented.&lt;/para&gt;
-
-&lt;para&gt;If you type &lt;quote&gt;C&lt;/quote&gt; after SRSCAN, you will be given a
-short-range scan and a Star Chart.&lt;/para&gt;
-
-&lt;para&gt;Short-range scans are free.  That is, they use up no energy and no
-time.  If you are in battle, doing a short-range scan does not give
-the enemies another chance to hit you.  You can safely do a
-short-range scan anytime you like.&lt;/para&gt;
-
-&lt;para&gt;If your short-range sensors are damaged, this command will only show
-the contents of adjacent sectors.&lt;/para&gt;
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Status Report&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  STATUS
-Shortest abbreviation: ST
-&lt;/literallayout&gt;
-
-&lt;!-- This is new in SST 2K --&gt; 
-&lt;para&gt;If you are using the screen-oriented interface, this command is
-suppressed; instead, a full status report will always be present on the
-screen.&lt;/para&gt;
-
-&lt;para&gt;This command gives you information about the current state of your
-starship as follows:&lt;/para&gt;
-
-&lt;variablelist&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;STARDATE&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;The current date. A stardate is the same as a day.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;CONDITION&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;There are four possible conditions:&lt;/para&gt;
-    &lt;variablelist&gt;
-    &lt;varlistentry&gt;
-    &lt;term&gt;DOCKED&lt;/term&gt;
-    &lt;listitem&gt;&lt;para&gt;docked at starbase.&lt;/para&gt;&lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;varlistentry&gt;
-    &lt;term&gt;RED&lt;/term&gt;
-    &lt;listitem&gt;&lt;para&gt;in battle.&lt;/para&gt;&lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;varlistentry&gt;
-    &lt;term&gt;YELLOW&lt;/term&gt;
-    &lt;listitem&gt;&lt;para&gt;low on energy (&lt;1000 units)&lt;/para&gt;&lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;varlistentry&gt;
-    &lt;term&gt;GREEN&lt;/term&gt;
-    &lt;listitem&gt;&lt;para&gt;none of the above&lt;/para&gt;&lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;/variablelist&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;POSITION&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;Quadrant is given first, then sector&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;LIFE SUPPOR&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;If &lt;quote&gt;ACTIVE&lt;/quote&gt; then life support systems are functioning
-normally. If on &lt;quote&gt;RESERVES&lt;/quote&gt; the number is how many stardates your
-reserve food, air, etc. will last&mdash;you must get repairs made or get to
-starbase before your reserves run out.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;WARP FACTOR&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;What your warp factor is currently set to.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;ENERGY&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;The amount of energy you have left. If it drops to zero, you die.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;TORPEDOES&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;How many photon torpedoes you have left.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;SHIELDS&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;Whether your shields are up or down, how strong they are
-(what percentage of a hit they can deflect), and shield energy.&lt;/para&gt; 
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;KLINGONS LEFT&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;How many of the Klingons are still out there.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;TIME LEFT&lt;/term&gt;
-&lt;listitem&gt;
-&lt;para&gt;How long the Federation can hold out against the
-present number of Klingons; that is, how long until the end
-if you do nothing in the meantime.  If you kill Klingons
-quickly, this number will go up&mdash;if not, it will go down.  If
-it reaches zero, the federation is conquered and you lose.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;/variablelist&gt;
-
-&lt;para&gt;Status information is free&mdash;it uses no time or energy, and
-if you are in battle, the Klingons are not given another chance to hit
-you.&lt;/para&gt;
-
-&lt;para&gt;Status information can also be obtained by doing a short-range scan.
-See the SRSCAN command for details.&lt;/para&gt;
-
-&lt;para&gt;Each item of information can be obtained singly by requesting it.
-See REQUEST command for details.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Long-Range Scan&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  LRSCAN
-Shortest abbreviation:  L
-&lt;/literallayout&gt;
-
-&lt;!-- This is new in SST 2K --&gt; 
-&lt;para&gt;If you are using the screen-oriented interface, this command is
-suppressed; instead, a long-range scan will always be present on the
-screen.&lt;/para&gt;
-
-&lt;para&gt;A long-range scan gives you general information about where you are
-and what is around you.  Here is an example output.&lt;/para&gt;
-
-&lt;screen&gt;
-    Long-range scan for Quadrant 5 - 1
-       -1  107  103
-       -1  316    5
-       -1  105 1000
-&lt;/screen&gt;
-
-&lt;para&gt;This scan says that you are in row 5, column 1 of the 8 by 8 galaxy.
-The numbers in the scan indicate how many of each kind of thing there
-is in your quadrant and all adjacent quadrants.  The digits are
-interpreted as follows.&lt;/para&gt;
-
-&lt;informaltable&gt;
-&lt;tgroup cols='2'&gt;
-&lt;tbody&gt;
-&lt;row&gt;
-  &lt;entry&gt;Thousands digit:&lt;/entry&gt;
-  &lt;entry&gt;1000 indicates a supernova (only)&lt;/entry&gt;
-&lt;/row&gt;
-&lt;row&gt;
-  &lt;entry&gt;Hundreds digit:&lt;/entry&gt;
-  &lt;entry&gt;number of Klingons present&lt;/entry&gt;
-&lt;/row&gt;
-&lt;row&gt;
-  &lt;entry&gt;Tens digit:&lt;/entry&gt;
-  &lt;entry&gt;number of starbases present&lt;/entry&gt;
-&lt;/row&gt;
-&lt;row&gt;
-  &lt;entry&gt;Ones digit:&lt;/entry&gt;
-  &lt;entry&gt;number of stars present&lt;/entry&gt;
-&lt;/row&gt;
-&lt;/tbody&gt;
-&lt;/tgroup&gt;
-&lt;/informaltable&gt;
-
-&lt;para&gt;For example, in your quadrant (5 - 1) the number is 316, which
-indicates 3 Klingons, 1 starbase, and 6 stars.  The long-range
-scanner does not distinguish between ordinary Klingons and Klingon
-command ships.  If there is a supernova, as in the quadrant below and
-to your right (quadrant 6 - 2), there is nothing else in the
-quadrant. &lt;/para&gt;
-
-&lt;para&gt;Romulans possess a &lt;quote&gt;cloaking device&lt;/quote&gt; which prevents
-their detection by long-range scan.  Because of this fact, Starfleet
-Command is never sure how many Romulans are &lt;quote&gt;out there&lt;/quote&gt;.
-When you kill the last Klingon, the remaining Romulans surrender to
-the Federation.&lt;/para&gt;
-
-&lt;para&gt;Planets are also undetectable by long-range scan.  The only way to
-detect a planet is to find it in your current quadrant with the
-short-range sensors.&lt;/para&gt;
-
-&lt;para&gt;Since you are in column 1, there are no quadrants to your left. The
-minus ones indicate the negative energy barrier at the edge of the
-galaxy, which you are not permitted to cross.&lt;/para&gt;
-
-&lt;para&gt;Long-range scans are free.  They use up no energy or time, and can be
-done safely regardless of battle conditions.&lt;/para&gt;
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Star Chart&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  CHART
-Shortest abbreviation:  C
-&lt;/literallayout&gt;
-
-&lt;para&gt;As you proceed in the game, you learn more and more about what things
-are where in the galaxy. When ever you first do a scan in a quadrant,
-telemetry sensors are ejected which will report any changes in the
-quadrant(s) back to your ship, providing the sub-space radio is
-working. Spock will enter this information in the chart. If the radio
-is not working, Spock can only enter new information discovered from
-scans, and information in other quadrants may be obsolete.&lt;/para&gt;
-
-&lt;para&gt;The chart looks like an 8 by 8 array of numbers.  These numbers are
-interpreted exactly as they are on a long-range scan. A period (.) in
-place of a digit means you do not know that information yet.  For
-example, ... means you know nothing about the quadrant, while .1.
-menas you know it contains a base, but an unknown number of Klingons
-and stars.&lt;/para&gt;
-
-&lt;para&gt;Looking at the star chart is a free operation.  It costs neither time
-nor energy, and can be done safely whether in or out of battle.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Damage Report&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  DAMAGES
-Shortest abbreviation:  DA
-&lt;/literallayout&gt;
-
-&lt;para&gt;At any time you may ask for a damage report to find out what devices
-are damaged and how long it will take to repair them.  Naturally,
-repairs proceed faster at a starbase.&lt;/para&gt;
-
-&lt;para&gt;If you suffer damages while moving, it is possible that a subsequent
-damage report will not show any damage.  This happens if the time
-spent on the move exceeds the repair time, since in this case the
-damaged devices were fixed en route.&lt;/para&gt;
-
-&lt;para&gt;Damage reports are free.  They use no energy or time, and can be done
-safely even in the midst of battle.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Move Under Warp Drive&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  MOVE
-Shortest abbreviation:  M
-Full command:  MOVE MANUAL &lt;displacement&gt;
-               MOVE AUTOMATIC &lt;destination&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command is the usual way to move from one place to another
-within the galaxy.  You move under warp drive, according to the
-current warp factor (see &lt;quote&gt;WARP FACTOR&lt;/quote&gt;).&lt;/para&gt;
-
-&lt;para&gt;There are two command modes for movement: MANUAL and AUTOMATIC.
-The manual mode requires the following format:&lt;/para&gt;
-
-&lt;screen&gt;
-	MOVE MANUAL &lt;deltax&gt; &lt;deltay&gt;
-&lt;/screen&gt;
-
-&lt;para&gt;&lt;deltax&gt; and &lt;deltay&gt; are the horizontal and vertical
-displacements for your starship, in quadrants; a displacement of one
-sector is 0.1 quadrants.  Specifying &lt;deltax&gt; and &lt;deltay&gt;
-causes your ship to move in a straight line to the specified
-destination. If &lt;deltay&gt; is omitted, it is assumed zero. For
-example, the shortest possible command to move one sector to the right
-would be&lt;/para&gt;
-
-&lt;screen&gt;
-	M M .1
-&lt;/screen&gt;
-
-&lt;para&gt;The following examples of manual movement refer to the short-range
-scan shown earlier.&lt;/para&gt;
-
-&lt;screen&gt;
-  Destination Sector	Manual Movement command
-	3 - 1			M M -.3 -.1
-	2 - 1			M M -.3
-	1 - 2			M M -.2 .1
-	1 - 4			M M 0 .1
-  (leaving quadrant)		M M 0 .2
-&lt;/screen&gt;
-
-&lt;para&gt;The automatic mode is as follows:&lt;/para&gt;
-
-&lt;screen&gt;
-	MOVE AUTOMATIC &lt;qrow&gt; &lt;qcol&gt; &lt;srow&gt; &lt;scol&gt;
-&lt;/screen&gt;
-
-&lt;para&gt;&lt;para&gt;where &lt;qrow&gt; and &lt;qcol&gt; are the row and column
-numbers of the destination quadrant, and &lt;srow&gt; and &lt;scol&gt;
-are the row and column numbers of the destination sector in that
-quadrant.  This command also moves your ship in a straight line path
-to the destination.  For moving within a quadrant, &lt;qrow&gt; and
-&lt;qcol&gt; may be omitted. For example, to move to sector 2 - 9 in
-the current quadrant, the shortest command would be&lt;/para&gt;
-
-&lt;screen&gt;
-	M A 2 9
-&lt;/screen&gt;
-
-&lt;para&gt;To move to quadrant 3 - 7, sector 5 - 8, type&lt;/para&gt;
-
-&lt;screen&gt;
-	M A 3 7 5 8
-&lt;/screen&gt;
-
-&lt;para&gt;and it will be done.  In automatic mode, either two or four numbers
-must be supplied.&lt;/para&gt;
-
-&lt;para&gt;Automatic mode utilizes the ship's &lt;quote&gt;battle computer.&lt;/quote&gt;  If the
-computer is damaged, manual movement must be used.&lt;/para&gt;
-
-&lt;para&gt;If warp engines are damaged less than 10 stardates (undocked) you can
-still go warp 4.&lt;/para&gt;
-
-&lt;para&gt;It uses time and energy to move.  How much time and how much energy
-depends on your current warp factor, the distance you move, and
-whether your shields are up.  The higher the warp factor, the faster
-you move, but higher warp factors require more energy.  You may move
-with your shields up, but this doubles the energy required.&lt;/para&gt;
-
-&lt;para&gt;You can move within a quadrant without being attacked if you just
-entered the quadrant or have been attacked since your last move
-command.  This enables you to move and hit them before they
-retaliate.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Warp Factor&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  WARP
-Shortest abbreviation:  W
-Full command:  WARP &lt;number&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;Your warp factor controls the speed of your starship.  The larger the
-warp factor, the faster you go and the more energy you use.&lt;/para&gt;
-
-&lt;para&gt;Your minimum warp factor is 1.0 and your maximum warp factor is 10.0
-(which is 100 times as fast and uses 1000 times as much energy).  At
-speeds above warp 6 there is some danger of causing damage to your
-warp engines; this damage is larger at higher warp factors and also
-depends on how far you go at that warp factor.&lt;/para&gt;
-
-&lt;para&gt;At exactly warp 10 there is some probability of entering a
-so-called &lt;quote&gt;time warp&lt;/quote&gt; and being thrown foward or backward
-in time.  The farther you go at warp 10, the greater is the
-probability of entering the time warp.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Impulse Engines&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  IMPULSE
-Shortest abbreviation:  I
-Full command:  IMPULSE MANUAL &lt;displacement&gt;
-               IMPULSE AUTOMATIC &lt;destination&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;The impulse engines give you a way to move when your warp engines are
-damaged.  They move you at a speed of 0.95 sectors per stardate,
-which is the equivalent of a warp factor of about 0.975, so they are
-much too slow to use except in emergencies.&lt;/para&gt;
-
-&lt;para&gt;Movement commands are indicated just as in the &lt;quote&gt;MOVE&lt;/quote&gt; command.&lt;/para&gt;
-
-&lt;para&gt;The impulse engines require 20 units of energy to engage, plus 10
-units per sector (100 units per quadrant) traveled. It does not cost
-extra to move with the shields up.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Deflector Shields&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  SHIELDS
-Shortest abbreviation:  SH
-Full commands:  SHIELDS UP
-                SHIELDS DOWN
-                SHIELDS TRANSFER &lt;amount of energy to transfer&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;Your deflector shields are a defensive device to protect you from
-Klingon attacks (and nearby novas).  As the shields protect you, they
-gradually weaken.  A shield strength of 75%, for example, means that
-the next time a Klingon hits you, your shields will deflect 75% of
-the hit, and let 25% get through to hurt you.&lt;/para&gt;
-
-&lt;para&gt;It costs 50 units of energy to raise shields, nothing to lower them.
-You may move with your shields up; this costs nothing under impulse
-power, but doubles the energy required for warp drive.&lt;/para&gt;
-
-&lt;para&gt;Each time you raise or lower your shields, the Klingons have another
-chance to attack.  Since shields do not raise and lower
-instantaneously, the hits you receive will be intermediate between
-what they would be if the shields were completely up or completely
-down. &lt;/para&gt;
-
-&lt;para&gt;You may not fire phasers through your shields.  However you may
-use the &lt;quote&gt;high-speed shield control&lt;/quote&gt; to lower shields,
-fire phasers, and raise the shields again before the Klingons can
-react.  Since rapid lowering and raising of the shields requires more
-energy than normal speed operation, it costs you 200 units of energy
-to activate this control.  It is automatically activated when you fire
-phasers while shields are up.  You may fire photon torpedoes, but they
-may be deflected considerably from their intended course as they pass
-through the shields (depending on shield strength).&lt;/para&gt;
-
-&lt;para&gt;You may transfer energy beteen the ship's energy (given as
-&lt;quote&gt;Energy&lt;/quote&gt; in the status) and the shields.  The word
-&lt;quote&gt;TRANSFER&lt;/quote&gt; may be abbreviated &lt;quote&gt;T&lt;/quote&gt;.  The
-ammount of energy to transfer is the number of units of energy you
-wish to take from the ship's energy and put into the shields.  If you
-specify an negative number, energy is drained from the shields to the
-ship.  Transfering energy constitutes a turn.  If you transfer energy
-to the shields while you are under attack, they will be at the new
-energy level when you are next hit.&lt;/para&gt;
-
-&lt;para&gt;Enemy torpedoes hitting your ship explode on your shields (if they
-are up) and have essentially the same effect as phaser hits.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Phasers&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  PHASERS
-Shortest abbreviation:  P
-Full commands:  PHASERS AUTOMATIC &lt;AMOUNT TO FIRE&gt; &lt;NO&gt;
-                PHASERS &lt;AMOUNT TO FIRE&gt; &lt;NO&gt;
-                PHASERS MANUAL &lt;NO&gt; &lt;AMOUNT 1&gt; &lt;AMOUNT 2&gt;...&lt;AMOUNT N&gt; 
-&lt;/literallayout&gt;
-
-&lt;para&gt;Phasers are energy weapons. As you fire phasers at Klingons, you
-specify an &lt;quote&gt;amount to fire&lt;/quote&gt; which is drawn from your
-energy reserves.  The amount of total hit required to kill an enemy is
-partly random.  but also depends on skill level.&lt;/para&gt;
-
-&lt;para&gt;The average hit required to kill an ordinary Klingon varies from 200
-units in the Novice game to 250 units in the Emeritus game.
-Commanders normally require from 600 (Novice) to 700 (Emeritus).  The
-Super-commander requres from 875 (Good) to 1000 (Emeritus). Romulans
-require an average of 350 (Novice) to 450 (Emeritus).&lt;/para&gt;
-
-&lt;para&gt;Hits on enemies are cumulative, as long as you don't leave the
-quadrant. &lt;/para&gt;
-
-&lt;para&gt;In general, not all that you fire will reach the Klingons.  The
-farther away they are, the less phaser energy will reach them. If a
-Klingon is adjacent to you, he will receive about 90% of the phaser
-energy directed at him; a Klingon 5 sectors away will receive about
-60% and a Klingon 10 sectors away will receive about 35%. There is
-some randomness involved, so these figures are not exact. Phasers
-have no effect beyond the boundaries of the quadrant you are in.&lt;/para&gt;
-
-&lt;para&gt;Phasers may overheat (and be damaged) if you fire too large a burst
-at once. Firing up to 1500 units is safe.  From 1500 on up the
-probability of overheat increases with the amount fired.&lt;/para&gt;
-
-&lt;para&gt;If phaser firing is automatic, the computer decides how to
-divide up your &lt;amount to fire&gt; among the Klingons present.  If
-phaser firing is manual, you specify how much energy to fire at each
-Klingon present (nearest first), rather than just specifying a total
-amount.  You can abreviate &lt;quote&gt;MANUAL&lt;/quote&gt; and
-&lt;quote&gt;AUTOMATIC&lt;/quote&gt; to one or more letters; if you mention
-neither, automatic fire is usually assumed.&lt;/para&gt;
-
-&lt;para&gt;Battle computer information is available by firing phasers manually,
-and allowing the computer to prompt you.  If you enter zero for the
-amount to fire at each enemy, you will get a complete report, without
-cost.  The battle computer will tell you how much phaser energy to
-fire at each enemy for a sure kill.  This information appears in
-parentheses prior to the prompt for each enemy.  Since the amount is
-computed from sensor data, if either the computer or the S.R. sensors
-are damaged, this information will be unavailable, and phasers must
-be fired manually.&lt;/para&gt;
-
-&lt;para&gt;A safety interlock prevents phasers from being fired through
-the shields.  If this were not so, the shields would contain your fire
-and you would fry yourself.  However, you may utilize the
-&lt;quote&gt;high-speed shield control&lt;/quote&gt; to drop shields, fire
-phasers, and raise shields before the enemy can react.  Since it takes
-more energy to work the shields rapidly with a shot, it costs you 200
-units of energy each time you activate this control.  It is
-automatically activated when you fire phasers while the shields are
-up. By specifying the &lt;no&gt; option, shields are not raised after
-firing.&lt;/para&gt;
-
-&lt;para&gt;Phasers have no effect on starbases (which are shielded) or on
-stars.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Report&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  REPORT
-Shortest abbreviation: REP
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command supplies you with information about the state of the
-current game.  Its purpose is to remind you of things that you have
-learned during play, but may have forgotten, and cannot otherwise
-retrieve if you are not playing at a hard-copy terminal.&lt;/para&gt;
-
-&lt;para&gt;You are told the following things:&lt;/para&gt;
-
-&lt;itemizedlist&gt;
-&lt;listitem&gt;&lt;para&gt;The length and skill level of the game you are playing&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;The original number of Klingons&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;How many Klingons you have destroyed&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;Whether the Super-Commander has been destroyed&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;How many bases have been destroyed&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;How many bases are left&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;What bases (if any) are under attack; your subspace radio
-must have been working since the attack to get this 
-information.&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;How many casualties you have suffered&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;How many times you have called for help.&lt;/para&gt;&lt;/listitem&gt;
-&lt;/itemizedlist&gt;
-
-&lt;para&gt;This same information is automatically given to you when you start to
-play a frozen game.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Computer&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  COMPUTER
-Shortest abbreviation: CO
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command allows using the ship's computer (if functional) to
-calculate travel times and energy usage.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Photon Torpedoes&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  PHOTONS
-Shortest abbreviation:  PHO
-Full commands:  PHOTONS &lt;NUMBER&gt; &lt;TARG1&gt; &lt;TARG2&gt; &lt;TARG3&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;Photon torpedoes are projectile weapons&mdash;you either hit what you aim
-at, or you don't.  There are no &lt;quote&gt;partial hits&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;para&gt;One photon torpedo will usually kill one ordinary Klingon, but it
-usually takes about two for a Klingon Commander.  Photon torpedoes
-can also blow up stars and starbases, if you aren't careful.&lt;/para&gt;
-
-&lt;para&gt;You may fire photon torpedoes singly, or in bursts of two or three.
-Each torpedo is individually targetable.  The computer will prompt
-you, asking for the target sector for each torpedo.  Alternately, you
-may specify each target in the command line.&lt;/para&gt;
-
-&lt;para&gt;Photon torpedoes cannot be aimed precisely&mdash;there is always some
-randomness involved in the direction they go.  Photon torpedoes may
-be fired with your shields up, but as they pass through the shields
-they are randomly deflected from their intended course even more.&lt;/para&gt;
-
-&lt;para&gt;Photon torpedoes are proximity-fused.  The closer they explode to the
-enemy, the more damage they do.  There is a hit &lt;quote&gt;window&lt;/quote&gt; about one
-sector wide.  If the torpedo misses the hit window, it does not
-explode and the enemy is unaffected.  Photon torpedoes are only
-effective within the quadrant.  They have no effect on things in
-adjacent quadrants.&lt;/para&gt;
-
-&lt;para&gt;If more than one torpedo is fired and only one target sector is
-specified, all torpedoes are fired at that sector.  For example, to
-fire two torpedoes at sector 3 - 4, you type&lt;/para&gt;
-
-&lt;screen&gt;
-     PHO 2 3 4           (or)           PHO 2 3 4 3 4
-&lt;/screen&gt;
-
-&lt;para&gt;To fire torpedoes at, consecutively, sectors 2 - 6, 1 - 10, and 4 -
-7, type&lt;/para&gt;
-
-&lt;screen&gt;
-     PHO 3 2 6 1 10 4 7
-&lt;/screen&gt;
-
-&lt;para&gt;There is no restriction to fire directly at a sector.  For example,
-you can enter&lt;/para&gt;
-
-&lt;screen&gt;
-       PHO 1 3 2.5
-&lt;/screen&gt;
-
-&lt;para&gt;to aim between two sectors.  However, sector numbers must be 1 to 10
-inclusive.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Dock at Starbase&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  DOCK
-Shortest abbreviation:  D
-&lt;/literallayout&gt;
-
-&lt;para&gt;You may dock your starship whenever you are in one of the eight
-sector positions immediately adjacent to a starbase.  When you dock,
-your starship is resupplied with energy, shield energy photon
-torpedoes, and life support reserves.  Repairs also proceed faster at
-starbase, so if some of your devices are damaged, you may wish to stay
-at base (by using the &lt;quote&gt;REST&lt;/quote&gt; command) until they are
-fixed.  If your ship has more than its normal maximum energy (which
-can happen if you've loaded crystals) the ship's energy is not
-changed.&lt;/para&gt;
-
-&lt;para&gt;You may not dock while in standard orbit around a planet.&lt;/para&gt;
-
-&lt;para&gt;Starbases have their own deflector shields, so you are completely
-safe from phaser attack while docked.  You are also safe from
-long-range tractor beams.&lt;/para&gt;
-
-&lt;para&gt;Starbases also have both short and long range sensors, which you can
-use if yours are broken. There's also a subspace radio to get
-information about happenings in the galaxy. Mr. Spock will update the
-star chart if your ask for it while docked and your own radio is dead.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Rest&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  REST
-Shortest abbreviation:  R
-Full command:  REST &lt;NUMBER OF STARDATES&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command simply allows the specified number of stardates to go
-by.  This is useful if you have suffered damages and wish to wait
-until repairs are made before you go back into battle.&lt;/para&gt;
-
-&lt;para&gt;It is not generally advisable to rest while you are under attack by
-Klingons.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Call Starbase for Help&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  MAYDAY
-(No abbreviation)
-&lt;/literallayout&gt;
-
-&lt;para&gt;[Originally, this command was called &lt;quote&gt;HELP&lt;/quote&gt;, but
-these days that might be misconstrued as an attempt to browae built-in
-documentation! In some later versions it was CALL.]&lt;/para&gt;
-
-&lt;para&gt;When you get into serious trouble, you may call a starbase for
-help.  Starbases have a device called a &lt;quote&gt;long-range transporter
-beam&lt;/quote&gt; which they can use to teleport you to base.  This works
-by dematerializing your starship at its current position and
-re-materializing it adjacent to the nearest starbase.  Teleportation
-is instantaneous, and starbase supplies the required energy&mdash;all
-you have to do is let them know (via subspace radio) that you need to
-be rescued.&lt;/para&gt;
-
-&lt;para&gt;This command should be employed only when absolutely necessary.  In
-the first place, calling for help is an admission on your part that
-you got yourself into something you cannot get yourself out of, and
-you are heavily penalized for this in the final scoring.  Secondly,
-the long-range transporter beam is not reliable&mdash;starbase can always
-manage to dematerialize your starship, but (depending on distance)
-may or may not be able to re-materialize you again.  The long-range
-transporter beam has no absolute maximum range; if you are in the
-same quadrant as a starbase, you have a good chance (about 90%) of
-re-materializing successfully.  your chances drop to roughly 50-50 at
-just over 3 quadrants.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Abandon Ship&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  ABANDON
-(no abbreviation)
-&lt;/literallayout&gt;
-
-&lt;para&gt;You may abandon the Enterprise if necessary.  If there is still a
-starbase in the galaxy, you will be sent there and put in charge of a
-weaker ship, the Faerie Queene.&lt;/para&gt;
-
-&lt;para&gt;The Faerie Queene cannot be abandoned.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Self-Destruct&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  DESTRUCT
-(no abbreviation)
-&lt;/literallayout&gt;
-
-&lt;para&gt;You may self-destruct, thus killing yourself and ending the game.  If
-there are nearby Klingons, you may take a few of them with you (the
-more energy you have left, the bigger the bang).&lt;/para&gt;
-
-&lt;para&gt;In order to self-destruct you must remember the password you typed in
-at the beginning of the game.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Quit Game&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  QUIT
-(no abbreviation)
-&lt;/literallayout&gt;
-
-&lt;para&gt;Immediately cancel the current game; no conclusion is reached.  You
-will be given an opportunity to start a new game or to leave the Star
-Trek program.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Sensor-Scan&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  SENSORS
-Shortest abbreviation:  SE
-&lt;/literallayout&gt;
-
-&lt;para&gt;Utilizing the short-range sensors, science officer Spock gives you a
-readout on any planet in your quadrant.  Planets come in three
-classes: M, N, and O.  Only class M planets have earth-like
-conditions.  Spock informs you if the planet has any dilithium
-crystals.  Sensor scans are free.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Enter Standard Orbit&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  ORBIT
-Shortest abbreviation:  O
-&lt;/literallayout&gt;
-
-&lt;para&gt;To land on a planet you must first be in standard orbit.  You achieve
-this in a manner similar to docking at starbase.  Moving to one of
-the eight sector positions immediately adjacent to the planet, you
-give the orbit command which puts your ship into standard orbit about
-the planet.  Since this is a maneuver, a small amount of time is
-used; negligible energy is required.  If enemies are present, they
-will attack.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Transporter Travel&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  TRANSPORT
-Shortest abbreviation:  T
-&lt;/literallayout&gt;
-
-&lt;para&gt;The transporter is a device which can convert any physical object
-into energy, beam the energy through space, and reconstruct the
-physical object at some destination.  Transporting is one way to land
-on a planet.  Since the transporter has a limited range, you must be
-in standard orbit to beam down to a planet.  Shields must be down
-while transporting.&lt;/para&gt;
-
-&lt;para&gt;The transport command is used to beam a landing party onto a planet
-to mine &lt;quote&gt;dilithium crystals&lt;/quote&gt;.  Each time the command is given the
-landing party (which you lead) moves from the ship to the planet, or
-vice-versa.&lt;/para&gt;
-
-&lt;para&gt;You are advised against needless transporting, since like all
-devices, the transporter will sometimes malfunction.&lt;/para&gt;
-
-&lt;para&gt;The transporter consumes negligible time and energy.  Its use does
-not constitute a &lt;quote&gt;turn&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Shuttle Craft&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  SHUTTLE
-Shortest abbreviation:  SHU
-&lt;/literallayout&gt;
-
-&lt;para&gt;An alternate way to travel to and from planets.  Because of limited
-range, you must be in standard orbit to use the shuttle craft, named
-&quot;Galileo&quot;.  Shields must be down.&lt;/para&gt;
-
-&lt;para&gt;Unlike transporting, use of the shuttle craft does constitute a
-&lt;quote&gt;turn&lt;/quote&gt; since time is consumed.  The time naturally
-depends on orbit altitude, and is equal to 3.0e-5 times altitude.
-Shuttling uses no ship energy.&lt;/para&gt;
-
-&lt;para&gt;You should use the same travel device going from the planet to the
-ship as you use to go from the ship to the planet. However it is
-possible to transport to the planet and have the Galileo crew come
-and pick your landing party up, or to take the Galileo to the planet
-and then transport back, leaving the shuttle craft on the planet.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Mine Dilithium Crystals&lt;/title&gt;
-
-&lt;literallayout&gt;  
-Mnemonic:  MINE
-Shortest abbreviation:  MI
-&lt;/literallayout&gt;
-
-&lt;para&gt;Once you and your mining party are on the surface of a planet which
-has dilithium crystals, this command will dig them for you.&lt;/para&gt;
-
-&lt;para&gt;Mining requires time and constitutes a &lt;quote&gt;turn&lt;/quote&gt;.  No
-energy is used.  Class M planets require 0.1 to 0.3 stardates to mine.
-Class N planets take twice as long, and class O planets take three
-times as long.&lt;/para&gt;
-
-&lt;para&gt;Dilithium crystals contain enormous energy in a form that is readily
-released in the ship's power system.  It is an excellent idea to mine
-them whenever possible, for use in emergencies.  You keep the
-crystals until the game is over or you abandon ship when not at a
-starbase.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Load Dilithium Crystals&lt;/title&gt;
-
-&lt;literallayout&gt;  
-Mnemonic:  CRYSTALS
-Shortest abbreviation:  CR
-&lt;/literallayout&gt;
-
-&lt;para&gt;This is a very powerful command which should be used with caution.
-Once you have dilithium crystals aboard ship, this command will
-instruct engineering officer Scott and Mr. Spock to place a raw
-dilithium crystal into the power channel of the ship's
-matter-antimatter converter.  When it works, this command will
-greatly boost the ship's energy.&lt;/para&gt;
-
-&lt;para&gt;Because the crystals are raw and impure, instabilities can occur in
-the power channel.  Usually Scotty can control these.  When he
-cannot, the results are disastrous. Scotty will use those crystals
-that appear to be most stable first.&lt;/para&gt;
-
-&lt;para&gt;Since using raw dilithium crystals for this purpose entails
-considerable risk, Starfleet Regulations allow its use only during
-&quot;condition yellow&quot;.  No time or energy is used.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Planet Report&lt;/title&gt;
-
-&lt;literallayout&gt;  
-Mnemonic:  PLANETS
-Shortest abbreviation:  PL
-&lt;/literallayout&gt;
-
-&lt;para&gt;Mr. Spock presents you a list of the available information on planets
-in the galaxy.  Since planets do not show up on long-range scans, the
-only way to obtain this information is with the &lt;quote&gt;SENSORS&lt;/quote&gt; command.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1 id=&quot;freeze&quot;&gt;&lt;title&gt;Freeze&lt;/title&gt;
-
-&lt;literallayout&gt; 
-Mnemonic:  FREEZE
-(no abbreviation)
-Full command:  FREEZE &lt;FILE NAME&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;The purpose of the FREEZE command is to allow a player to save the
-current state of the game, so that it can be finished later.  A
-plaque may not be generated from a frozen game. A file with the
-specified &lt;file name&gt; and type '.TRK' is created (if necessary) in
-the current directory, and all pertinent information about the game
-is written to that file. The game may be continued as usual or be
-terminated at the user's option.&lt;/para&gt;
-
-&lt;para&gt;To restart a game created by the &lt;quote&gt;FREEZE&lt;/quote&gt; command,
-the user need only type &lt;quote&gt;FROZEN&lt;/quote&gt; in response to the
-initial question about the type of game desired, followed by the
-&lt;file name&gt;.&lt;/para&gt;
-
-&lt;para&gt;NOTE: A &lt;quote&gt;tournament&lt;/quote&gt; game is like a frozen game,
-with the following differences.  (1) Tournament games always start
-from the beginning, while a frozen game can start at any point.  (2)
-Tournament games require only that the player remember the name or
-number of the tournament, while the information about a frozen game
-must be kept on a file. Tournament games can be frozen, but then they
-behave like regular frozen games.&lt;/para&gt;
-
-&lt;para&gt;A point worth noting is that 'FREEZE' does not save the seed for the
-random number generator, so that identical actions after restarting
-the same frozen game can lead to different results.  However,
-identical actions after starting a given tournament game always lead
-to the same results.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Request&lt;/title&gt;
-
-&lt;literallayout&gt;  
-Mnemonic:  REQUEST
-Shortest abbreviation:  REQ
-Full command:  REQUEST &lt;ITEM&gt;
-&lt;/literallayout&gt;
-
-&lt;!-- This is new in SST 2K --&gt; 
-&lt;para&gt;If you are using the screen-oriented interface, this command is
-suppressed; instead, a full status report will always be present on the
-screen.&lt;/para&gt;
-
-&lt;para&gt;This command allows you to get any single piece of information
-from the &lt;STATUS&gt; command.  &lt;ITEM&gt; specifies which
-information as follows:&lt;/para&gt;
-
-&lt;informaltable&gt; 
-&lt;tgroup cols='3'&gt;
-&lt;thead&gt;
-&lt;row&gt;
-  &lt;entry&gt;Information&lt;/entry&gt;
-  &lt;entry&gt;Mnemonic for &lt;item&gt;&lt;/entry&gt;
-  &lt;entry&gt;Shortest Abbreviation&lt;/entry&gt;
-&lt;/row&gt;
-&lt;/thead&gt;
-&lt;tbody&gt;
-&lt;row&gt;&lt;entry&gt;STARDATE&lt;/entry&gt;    &lt;entry&gt;DATE&lt;/entry&gt;      &lt;entry&gt;D&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;CONDITION&lt;/entry&gt;   &lt;entry&gt;CONDITION&lt;/entry&gt; &lt;entry&gt;C&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;POSITION&lt;/entry&gt;    &lt;entry&gt;POSITION&lt;/entry&gt;  &lt;entry&gt;P&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;LIFE SUPPORT&lt;/entry&gt;&lt;entry&gt;LSUPPORT&lt;/entry&gt;  &lt;entry&gt;L&lt;/entry&gt;&lt;/row&gt; 
-&lt;row&gt;&lt;entry&gt;WARP FACTOR&lt;/entry&gt; &lt;entry&gt;WARPFACTOR&lt;/entry&gt;&lt;entry&gt;W&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;ENERGY&lt;/entry&gt;      &lt;entry&gt;ENERGY&lt;/entry&gt;    &lt;entry&gt;E&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;TORPEDOES&lt;/entry&gt;   &lt;entry&gt;TORPEDOES&lt;/entry&gt; &lt;entry&gt;T&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;SHIELDS&lt;/entry&gt;     &lt;entry&gt;SHIELDS&lt;/entry&gt;   &lt;entry&gt;S&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;KLINGONS LEFT&lt;/entry&gt;&lt;entry&gt;KLINGONS&lt;/entry&gt; &lt;entry&gt;K&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;TIME LEFT&lt;/entry&gt;   &lt;entry&gt;TIME&lt;/entry&gt;     &lt;entry&gt;TI&lt;/entry&gt;&lt;/row&gt;
-&lt;row&gt;&lt;entry&gt;BASES LEFT&lt;/entry&gt;   &lt;entry&gt;BASES&lt;/entry&gt;   &lt;entry&gt;BA&lt;/entry&gt;&lt;/row&gt;
-&lt;/tbody&gt;
-&lt;/tgroup&gt;
-&lt;/informaltable&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Experimental Death Ray&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  DEATHRAY
-(No abbreviation)
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command should be used only in those desperate cases where
-you have absolutely no alternative.  The death ray uses energy to
-rearrange matter.  Unfortunately, its working principles are not yet
-thoroughly understood, and the results are highly
-unpredictable.&lt;/para&gt;
-
-&lt;para&gt;The only good thing that can result is the destruction of all
-enemies in your current quadrant.  This will happen about 70% of the
-time.  Only enemies are destroyed; starbases, stars, and planets are
-unaffected.&lt;/para&gt;
-
-&lt;para&gt;Constituting the remaining 30% are results varying from bad to
-fatal.&lt;/para&gt;
-
-&lt;para&gt;The death ray requires no energy or time, but if you survive, enemies
-will hit you.&lt;/para&gt;
-
-&lt;para&gt;The Faerie Queene has no death ray.&lt;/para&gt;
-
-&lt;para&gt;If the death ray is damaged in its use, it must be totally replaced.
-This can only be done at starbase.  Because it is a very complex
-device, it takes 9.99 stardates at base to replace the death ray.
-The death ray cannot be repaired in flight.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Launch Deep Space Probe&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  PROBE
-Shortest abbreviation:  PR
-Full command:  PROBE &lt;ARMED&gt; MANUAL &lt;displacement&gt;
-               PROBE &lt;ARMED&gt; AUTOMATIC &lt;destination&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;The Enterprise carries a limited number of Long Range Probes. These
-fly to the end of the galaxy and report back a count of the number of
-important things found in each quadrant through which it went. The
-probe flies at warp 10, and therefore uses time during its flight.
-Results are reported immediately via subspace radio and are recorded
-in the star chart.&lt;/para&gt;
-
-&lt;para&gt;The probe can also be armed with a NOVAMAX warhead. When launched
-with the warhead armed, the probe flies the same except as soon as it
-reaches the target location, it detonates the warhead in the heart of
-a star, causing a supernova and destroying everything in the
-quadrant. It then flies no further. There must be a star in the
-target quadrant for the NOVAMAX to function. &lt;/para&gt;
-
-&lt;para&gt;The probe can fly around objects in a galaxy, but is destroyed if it
-enters a quadrant containing a supernova, or if it leaves the galaxy.&lt;/para&gt;
-
-&lt;para&gt;The target location is specified in the same manner as the MOVE
-command, however for automatic movement, if only one pair of
-coordinates are specified they are assumed to be the quadrant and not
-the sector in the current quadrant!&lt;/para&gt;
-
-&lt;para&gt;The Faerie Queene has no probes.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Emergency Exit&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  EMEXIT
-Shortest abbreviation:  E
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command provides a quick way to exit from the game when you
-observe a Klingon battle cruiser approaching your terminal.  Its
-effect is to freeze the game on the file 'EMSAVE.TRK' in your current
-directory, erase the screen, and exit.&lt;/para&gt;
-
-&lt;para&gt;Of course, you do lose the chance to get a plaque when you use this
-maneuver.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Ask for Help&lt;/title&gt;
-
-&lt;literallayout&gt;
-Mnemonic:  HELP
-Full command:  HELP &lt;command&gt;
-&lt;/literallayout&gt;
-
-&lt;para&gt;This command reads the appropriate section from the SST.DOC file,
-providing the file is in the current directory.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;Miscellaneous Notes&lt;/title&gt;
-
-&lt;para&gt;Starbases can be attacked by either commanders or by the
-&lt;quote&gt;Super-Commander&lt;/quote&gt;.  When this happens, you will be
-notified by subspace radio, provided it is working.  The message will
-inform you how long the base under attack can last.  Since the
-&lt;quote&gt;Super-Commander&lt;/quote&gt; is more powerful than an ordinary
-commander, he can destroy a base more quickly.&lt;/para&gt;
-
-&lt;para&gt;The &lt;quote&gt;Super-Commander&lt;/quote&gt; travels around the galaxy at
-a speed of about warp 6 or 7.  His movement is strictly time based;
-the more time passes, the further he can go.&lt;/para&gt;
-
-&lt;para&gt;Scattered through the galaxy are certain zones of control,
-collectively designated the &lt;quote&gt;Romulan Neutral Zone&lt;/quote&gt;.  Any
-quadrant which contains Romulans without Klingons is part of the
-Neutral Zone, except if a base is present.  Since Romulans do not show
-on either the long-range scan or the star chart, it is easy for you to
-stumble into this zone.  When you do, if your subspace radio is
-working, you will receive a warning message from the Romulan, politely
-asking you to leave.&lt;/para&gt;
-
-&lt;para&gt;In general, Romulans are a galactic nuisance.&lt;/para&gt;
-
-&lt;para&gt;The high-speed shield control is fairly reliable, but it has been
-known to malfunction.&lt;/para&gt;
-
-&lt;para&gt;You can observe the galactic movements of the
-&lt;quote&gt;Super-Commander&lt;/quote&gt; on the star chart, provided he is in
-territory you have scanned and your subspace radio is working.&lt;/para&gt;
-
-&lt;para&gt;Periodically, you will receive intelligence reports from
-starfleet command, indicating the current quadrant of the
-&lt;quote&gt;Super-Commander&lt;/quote&gt;.  Your subspace radio must be working,
-of course.&lt;/para&gt;
-
-&lt;para&gt;Each quadrant will contain from 0 to 3 black holes.  Torpedoes
-entering a black hole disappear.  In fact, anything entering a black
-hole disappears, permanently.  If you can displace an enemy into one,
-he is a goner.  Black holes do not necessarily remain in a quadrant.
-they are transient phenomena.&lt;/para&gt;
-
-&lt;para&gt;Commanders will ram your ship, killing themselves and inflicting
-heavy damage to you, if they should happen to decide to advance into
-your sector.&lt;/para&gt;
-
-&lt;para&gt;You can get a list of commands by typing
-&lt;quote&gt;COMMANDS&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;Scoring&lt;/title&gt;
-
-&lt;para&gt;Scoring is fairly simple.  You get points for good things, and you
-lose points for bad things.&lt;/para&gt;
-
-&lt;para&gt;You gain&mdash;&lt;/para&gt;
-
-&lt;orderedlist&gt;
-&lt;listitem&gt;&lt;para&gt;10 points for each ordinary Klingon you kill,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;50 points for each commander you kill,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;200 points for killing the &lt;quote&gt;Super-Commander&lt;/quote&gt;,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;20 points for each Romulan killed,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;1 point for each Romulan captured.&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;100 times your average Klingon/stardate kill rate.  If you lose
-the game, your kill rate is based on a minimum of 5 stardates.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;You get a bonus if you win the game, based on your rating:&lt;/para&gt;
-&lt;para&gt;Novice=100, Fair=200, Good=300, Expert=400, Emeritus=500.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/orderedlist&gt;
-
-&lt;para&gt;You lose&mdash;&lt;/para&gt;
-
-&lt;orderedlist&gt;
-&lt;listitem&gt;&lt;para&gt;200 points if you get yourself killed,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;100 points for each starbase you destroy,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;100 points for each starship you lose,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;45 points for each time you had to call for help,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;10 points for each planet you destroyed,&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;5 points for each star you destroyed, and&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;1 point for each casualty you incurred.&lt;/para&gt;&lt;/listitem&gt;
-&lt;/orderedlist&gt;
-
-&lt;para&gt;In addition to your score, you may also be promoted one grade in rank
-if you play well enough.  Promotion is based primarily on your
-Klingon/stardate kill rate, since this is the best indicator of
-whether you are ready to go on to the next higher rating.  However,
-if you have lost 100 or more points in penalties, the required kill
-rate goes up. Normally, the required kill rate is 0.1 * skill *
-(skill + 1.0) + 0.1, where skill ranges from 1 for Novice to 5 for
-Emeritus.&lt;/para&gt;
-
-&lt;para&gt;You can be promoted from any level.  There is a special
-promotion available if you go beyond the &lt;quote&gt;Expert&lt;/quote&gt; range.
-You can also have a certificate of merit printed with your name, date,
-and Klingon kill rate, provided you are promoted from either the
-&lt;quote&gt;Expert&lt;/quote&gt; or &lt;quote&gt;Emeritus&lt;/quote&gt; levels. This
-&lt;quote&gt;plaque&lt;/quote&gt; requires a 132 column printer. You may need
-print the certificate to a file, import it into your word processor,
-selecting Courier 8pt font, and then print in &lt;quote&gt;landscape
-orientation&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;Handy Reference Page&lt;/title&gt;
-
-&lt;literallayout format='linespecific' class='monospaced'&gt;
- ABBREV    FULL COMMAND                           DEVICE USED
- ------    ------------                           -----------
- ABANDON   ABANDON                                shuttle craft
- C         CHART                                  (none)
- CO        COMPUTER                               computer
- CR        CRYSTALS                               (none)
- DA        DAMAGES                                (none)
- DEATHRAY  DEATHRAY                               (none)  
- DESTRUCT  DESTRUCT                               computer
- D         DOCK                                   (none)
- E         EMEXIT                                 (none)
- FREEZE    FREEZE &lt;FILE NAME&gt;                     (none)
- I         IMPULSE &lt;MANUAL&gt; &lt;DISPLACEMENT&gt;        impulse engines
-           IMPULSE AUTOMATIC &lt;DESTINATION&gt;        impulse engines and computer
- L         LRSCAN                                 long-range sensors
- MAYDAY    MAYDAY (for help)                      subspace radio
- MI        MINE                                   (none)
- M         MOVE &lt;MANUAL&gt; &lt;DISPLACEMENT&gt;           warp engines
-           MOVE AUTOMATIC &lt;DESTINATION&gt;           warp engines and computer
- O         ORBIT                                  warp or impulse engines
- P         PHASERS &lt;TOTAL AMOUNT&gt;                 phasers and computer
-           PHASERS AUTOMATIC &lt;TOTAL AMOUNT&gt;       phasers, computer, sr sensors
-           PHASERS MANUAL &lt;AMT1&gt; &lt;AMT2&gt; ...       phasers
- PHO       PHOTONS &lt;NUMBER&gt; &lt;TARGETS&gt;             torpedo tubes 
- PL        PLANETS                                (none)
- PR        PROBE &lt;ARMED&gt; &lt;MANUAL&gt; &lt;DISPLACEMENT&gt;  probe launcher, radio 
-           PROBE &lt;ARMED&gt; AUTOMATIC &lt;DESTINATION&gt;  launcher, radio, computer
- REP       REPORT                                 (none)
- REQ       REQUEST                                (none)
- R         REST &lt;NUMBER OF STARDATES&gt;             (none)
- QUIT      QUIT                                   (none)
- S         SRSCAN &lt;NO or CHART&gt;                   short-range sensors
- SE        SENSORS                                short-range sensors
- SH        SHIELDS &lt;UP, DOWN, or TRANSFER&gt;        deflector shields
- SHU       SHUTTLE                                shuttle craft
- ST        STATUS                                 (none)
- T         TRANSPORT                              transporter
- W         WARP &lt;FACTOR&gt;                          (none)
-
- L. R. Scan:   thousands digit:   supernova
-               hundreds digit:    Klingons
-               tens digit:        starbases
-               ones digit:        stars
-               period (.):        digit not known (star chart only)
-
-Courses are given in manual mode in X - Y displacements; in automatic
-    mode as destination quadrant and/or sector.  Manual mode is default.
-Distances are given in quadrants.  A distance of one sector is 0.1 quadrant.
-Ordinary Klingons have about 400 units of energy, Commanders about
-    1200.  Romulans normally have about 800 units of energy, and the
-    (GULP) &quot;Super-Commander&quot; has about 1800.
-Phaser fire diminishes to about 60 percent at 5 sectors.  Up to 1500
-    units may be fired in a single burst without danger of overheat.
-Warp 6 is the fastest safe speed.  At higher speeds, engine damage
-    may occur.  At warp 10 you may enter a time warp.
-Shields cost 50 units of energy to raise, and double the power
-    requirements of moving under warp drive.  Engaging the high-speed
-    shield control requires 200 units of energy.
-Warp drive requires (distance)*(warp factor cubed) units of energy
-    to travel at a speed of (warp factor squared)/10 quadrants per stardate.
-Impulse engines require 20 units to warm up, plus 100 units per
-     quadrant.  Speed is just under one sector per stardate.
-&lt;/literallayout&gt;
-
-&lt;/chapter&gt;
-&lt;chapter&gt;&lt;title&gt;Game History and Modifications&lt;/title&gt;
-
-&lt;sect1&gt;&lt;title&gt;Origins&lt;/title&gt;
-
-&lt;para&gt;The original Star Trek seems to have been written by Mike
-Mayfield at the beginning of the 1970s.  His first version was in
-BASIC for a Sigma 7 in 1971; in 1972 he rewrote it in Hewlett Packard
-BASIC. The source is &lt;ulink
-url=&quot;&amp;sst-site;www/historic/mayfield.basic&quot;&gt;available&lt;/ulink&gt; on the
-SST2K website. In January 1975 it became part of the DECUS library
-under the name &lt;ulink
-url='<A HREF="http://www.trailing-edge.com/~shoppa/decus/110174.html">http://www.trailing-edge.com/~shoppa/decus/110174.html</A>'&gt;SPACWR&lt;/ulink&gt;.&lt;/para&gt;
-
-&lt;para&gt;While some people claim to have recollections of playing Trek
-games in the late 1960s, the earlier ones seem actually to have been
-variants of
-&lt;ulink url='<A HREF="http://en.wikipedia.org/wiki/Spacewar!">http://en.wikipedia.org/wiki/Spacewar!</A>'&gt;
-SPACEWAR&lt;/ulink&gt;, the earlier space-combat game on the
-PDP-1. Mayfield &lt;ulink
-url='<A HREF="http://www3.sympatico.ca/maury/games/space/star_trek.html">http://www3.sympatico.ca/maury/games/space/star_trek.html</A>'&gt;wrote
-in 2000&lt;/ulink&gt; that he invented the Trek-style galactic grid, and the
-evidence seems to back that up.  Some of the confusion probably stems 
-from the fact that Mayfield's original and several early descendants 
-were distributed under the name SPACWR.&lt;/para&gt;
-
-&lt;para&gt;Many different versions radiated from Mayfield's original; most
-of the ones in BASIC are descended from a SPACWR version that David
-Ahl published in &lt;citetitle&gt;101 BASIC Computer Games&lt;/citetitle&gt;,
-July 1973. This was a port of Mayfield's version obtained from the HP
-Contributed Programs library.  &lt;/para&gt;
-
-&lt;para&gt;Our SST2K is descended from a Taurus BASIC program by Grady
-Hicks dated 5 April 1973. This does not appear to have been derived
-from Ahl's SPACWR. The header says &quot;GENERAL IDEA STOLEN FROM
-PENN. U.&quot;, and the game has several features not present in SPACEWR:
-notably, the Death Ray, ramming, and the Klingon summons to surrender.
-And, of course, it predates Ahl's book.  The source is &lt;ulink
-url=&quot;&amp;sst-site;www/historic/UT-Trek.basic&quot;&gt;available&lt;/ulink&gt; on the
-SST2K website.&lt;/para&gt;
-
-&lt;para&gt;Dave Matuszek, Paul Reynolds et. al. at UT Austin played the
-Hicks version on a CDC6600, but disliked the long load time and
-extreme slowness of the BASIC program. (David Matuszek notes that the
-Hicks version he played had a habit of throwing long
-quotes from Marcus Aurelius at the users, a feature he found
-intolerable on a TTY at 110 baud.  It must, therefore, have been
-rather longer than  the one we have.)  The Austin crew proceeded to
-write their own Trek game, loosely based on the Hicks version, in
-CDC6600 FORTRAN.  At that time, it was just called &quot;Star Trek&quot;; the
-&quot;Super&quot; was added by later developers. In the rest of this history
-we'll call it the &quot;UT FORTRAN&quot; version.&lt;/para&gt;
-
-&lt;para&gt;At the time the UT FORTRAN source was last translated to C it emitted
-the message &quot;Latest update-21 Sept 78&quot;.  Thus, it actually predated
-(and may have influenced) the best-known BASIC version, the &quot;Super
-Star Trek&quot; published by David Ahl in his November 1978 sequel
-&lt;citetitle&gt;BASIC Computer Games&lt;/citetitle&gt;.&lt;/para&gt;
-
-&lt;para&gt;This 1978 &quot;Super Star Trek&quot; had been reworked by Robert Leedom and
-friends from (according to Leedom) Mayfield's HP port. There is
-internal evidence to suggest that at least some features of Leedom's
-SST may have derived from the UT FORTRAN version.  In particular, Dave
-Matuszek recalls implementing command words to replace the original
-numeric command codes, a feature Leedom's SST also had but the
-1973 and 1975 SPACWRs did not.&lt;/para&gt;
-
-&lt;para&gt;One signature trait of the UT FORTRAN game and its descendants
-is that the sectors are 10x10 (rather than the 8x8 in Mike Mayfield's
-1972 original and its BASIC descendants).  The UT FORTRAN version also
-preserves the original numbered quadrants rather than the
-astronomically-named quadrants introduced in Ahl's SST and its
-descendants.&lt;/para&gt;
-
-&lt;!-- Dave thinks his Fortran Star Trek used the clockface for quadrant --&gt;
-&lt;!-- navigation. --&gt;
-
-&lt;para&gt;Eric Allman's BSD Trek game is one of these, also descended from
-the UT FORTRAN version via translation to C.  However, the mainline version
-(now SST2K) has had a lot more stuff folded into it over the years
-&mdash; deep space probes, dilithium mining, the Tholian Web, and so
-forth.&lt;/para&gt;
-&lt;/sect1&gt;
-
-&lt;sect1&gt;&lt;title&gt;Tom Almy's story&lt;/title&gt;
-
-&lt;para&gt;Back in (about) 1977 I got a copy of the Super Star Trek game for
-the CDC 6600 mainframe computer. Someone had converted it to PDP-11
-Fortran but couldn't get it to run because of its size. I modified
-the program to use overlays and managed to shoehorn it in on the 56k
-byte machine.&lt;/para&gt;
-
-&lt;para&gt;I liked the game so much I put some time into fixing bugs, mainly
-what could be called continuity errors and loopholes in the game's
-logic. We even played a couple tournaments.&lt;/para&gt;
-
-&lt;para&gt;In 1979, I lost access to that PDP-11. I did save the source code
-listing. In 1995, missing that old friend, I started converting the
-program into portable ANSI C. It's been slow, tedious work that took
-over a year to accomplish.&lt;/para&gt;
-
-&lt;para&gt;In early 1997, I got the bright idea to look for references to
-&lt;quote&gt;Super Star Trek&lt;/quote&gt; on the World Wide Web. There weren't
-many hits, but there was one that came up with 1979 Fortran sources!
-This version had a few additional features that mine didn't have,
-however mine had some feature it didn't have. So I merged its features
-that I liked. I also took a peek at the DECUS version (a port, less
-sources, to the PDP-10), and some other variations.&lt;/para&gt;
-
-&lt;para&gt;Modifications I made:&lt;/para&gt;
-
-&lt;para&gt;Compared to original version, I've changed the
-&lt;quote&gt;help&lt;/quote&gt; command to &lt;quote&gt;call&lt;/quote&gt; and the
-&lt;quote&gt;terminate&lt;/quote&gt; command to &lt;quote&gt;quit&lt;/quote&gt; to better
-match user expectations. The DECUS version apparently made those
-changes as well as changing &lt;quote&gt;freeze&lt;/quote&gt; to
-&lt;quote&gt;save&lt;/quote&gt;. However I like &lt;quote&gt;freeze&lt;/quote&gt;.&lt;/para&gt;
-
-&lt;para&gt;I added EMEXIT from the 1979 version.&lt;/para&gt;
-
-&lt;para&gt;That later version also mentions srscan and lrscan working when
-docked (using the starbase's scanners), so I made some changes here
-to do this (and indicating that fact to the player), and then
-realized the base would have a subspace radio as well &mdash; doing a
-Chart when docked updates the star chart, and all radio reports will
-be heard. The Dock command will also give a report if a base is under
-attack.&lt;/para&gt;
-
-&lt;para&gt;It also had some added logic to spread the initial positioning of
-bases. That made sense to add because most people abort games with
-bad base placement.&lt;/para&gt;
-
-&lt;para&gt;The experimental deathray originally had only a 5% chance of success,
-but could be used repeatedly. I guess after a couple years of use, it
-was less &lt;quote&gt;experimental&lt;/quote&gt; because the 1979 version had a 70% success
-rate. However it was prone to breaking after use. I upgraded the
-deathray, but kept the original set of failure modes (great humor!).&lt;/para&gt;
-
-&lt;para&gt;I put in the Tholian Web code from the 1979 version.&lt;/para&gt;
-
-&lt;para&gt;I added code so that Romulans and regular Klingons could move in 
-advanced games. I re-enabled the code which allows enemy ships to
-ram the Enterprise; it had never worked right. The 1979 version
-seems to have it all fixed up, but I'm still not overly happy with
-the algorithm.&lt;/para&gt;
-
-&lt;para&gt;The DECUS version had a Deep Space Probe. Looked like a good idea
-so I implemented it based on its description.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Stas Sergeev's story&lt;/title&gt;
-
-&lt;para&gt;I started from an older Tom Almy version and added features I had
-seen in other mainframe variants of the game, I wrote a screen-oriented 
-interface for it based on the curses library.&lt;/para&gt;
-
-&lt;itemizedlist&gt;
-&lt;listitem&gt;
-&lt;para&gt;The Space Thingy can be shoved, if you ram it, and can fire back if 
-fired upon.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;The Tholian can be hit with phasers.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;When you are docked, base covers you with an almost invincible shields 
-      (a commander can still ram you, or a Romulan can destroy the base,
-      or a SCom can even succeed with direct attack IIRC, but this rarely 
-      happens).&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;SCom can't escape from you if no more enemies remain (without this, 
-      chasing SCom can take an eternity).&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Probe target you enter is now the destination quadrant. Before I don't 
-      remember what it was, but it was something I had difficulty using.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Secret password is now autogenerated.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Victory plaque is adjusted for A4 paper rather than 132-column greenbar
-:-)&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Phasers now tells you how much energy needed, but only if the computer 
-is alive.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Planets are auto-scanned when you enter the quadrant.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Mining or using crystals in presense of enemy now yields an attack.
-There are other minor adjustments to what yields an attack
-and what does not.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Ramming a black hole is no longer instant death.  There is a
-chance you might get timewarped instead.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;&quot;freeze&quot; command reverts to &quot;save&quot;, most people will understand this
-better anyway.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;listitem&gt;
-&lt;para&gt;Screen-oriented interface, with sensor scans always up.&lt;/para&gt;
-&lt;/listitem&gt;
-&lt;/itemizedlist&gt;
-
-&lt;para&gt;My changes got merged into SST2K in 2005, and I work on it now.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Eric Raymond's story&lt;/title&gt;
-
-&lt;para&gt;I played the FORTRAN version of this game in the late 1970s on a
-DEC minicomputer.  In the late 1980s Dave Matuszek and I became
-friends; I was vaguely aware that he had had something to do with the
-original Star Trek game.  In October 2004, sitting in Dave's living
-room, we got to talking about the game and I realized it would make a
-great exhibit for the &lt;ulink
-url='&retro;'&gt;Retrocomputing Museum&lt;/ulink&gt;.&lt;/para&gt;
-
-&lt;para&gt;A few quick web searches later we found Tom Almy's page.  We
-downloaded his code and Dave verified that that it was a direct
-descendent of UT Super Star Trek &mdash; even though it had been translated
-to C, he was able to recognize names and techniques from the FORTRAN
-version he co-wrote.&lt;/para&gt;
-
-&lt;para&gt;This game became an open-source project; see the &lt;ulink
-url='<A HREF="http://developer.berlios.de/projects/sst/">http://developer.berlios.de/projects/sst/</A>'&gt;project
-site&lt;/ulink&gt;.&lt;/para&gt;
-
-&lt;para&gt;After I launched the Berlios project, Stas Sergeev contacted me.
-We worked together to merge in his changes.&lt;/para&gt;
-
-&lt;para&gt;Modifications I've made:&lt;/para&gt;
-
-&lt;itemizedlist&gt;
-&lt;listitem&gt;&lt;para&gt;
-I converted the flat-text SST.DOC file to XML-Docbook so it can be
-webbed. (That's what you're reading now.)
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-The command-help code needed a rewrite because the flat-text form of
-the documentation is now generated from XML and doesn't have the
-easily recognizable section delimiters it used to.  I wrote a script
-to filter that flat-text form into an sst.doc that's easy to parse for
-command descriptions, and changed some logic in sst.c to match.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-I've cleaned up a lot of grubby FORTRANisms in the code internals --
-used sizeof(), replaced magic numeric constants with #defines,
-that sort of thing.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-I fixed a surprising number of typos in the code and documentation.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-All the game state now lives in one big structure that can be
-written to and read from disk as one blob.  The write gives it an
-an identifiable magic number and the thaw logic checks for same. 
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-I made the internal pager work, and in the process got rid of a number
-of platform dependencies in the code.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-The HELP/CALL/SOS command is now MAYDAY.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-Status report now indicates if dilithium crystals are on board.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-At Dave's prompting, restored the Space Thingy's original elusive behavior.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-Clean separation of game engine from the UI code, improving Stas
-Sergeev's excellent work on the curses interface.
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;/itemizedlist&gt;
-
-&lt;para&gt;Here are some good pages on the history of Star Trek games:&lt;/para&gt;
-
-&lt;itemizedlist&gt;
-&lt;listitem&gt;&lt;para&gt;
-&lt;ulink url='<A HREF="http://www.dunnington.u-net.com/public/startrek/">http://www.dunnington.u-net.com/public/startrek/</A>'&gt;<A HREF="http://www.dunnington.u-net.com/public/startrek/&lt;/ulink">http://www.dunnington.u-net.com/public/startrek/&lt;/ulink</A>&gt;
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-&lt;ulink url='<A HREF="http://www3.sympatico.ca/maury/games/space/star_trek.html">http://www3.sympatico.ca/maury/games/space/star_trek.html</A>'&gt;<A HREF="http://www3.sympatico.ca/maury/games/space/star_trek.html&lt;/ulink">http://www3.sympatico.ca/maury/games/space/star_trek.html&lt;/ulink</A>&gt;
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;
-&lt;ulink url='<A HREF="http://www.cactus.org/%7Enystrom/startrek.html">http://www.cactus.org/%7Enystrom/startrek.html</A>'&gt;<A HREF="http://www.cactus.org/%7Enystrom/startrek.html&lt;/ulink">http://www.cactus.org/%7Enystrom/startrek.html&lt;/ulink</A>&gt;
-&lt;/para&gt;&lt;/listitem&gt;
-&lt;/itemizedlist&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;Authors' Acknowledgments&lt;/title&gt;
-
-&lt;para&gt;These are the original acknowledgments by Dave Matuszek and Paul
-Reynolds:&lt;/para&gt;
-
-&lt;para&gt;The authors would like to thank Professor Michael Duggan for his
-encouragement and administrative assistance with the development of
-the Star Trek game, without which it might never have been completed.&lt;/para&gt;
-
-&lt;para&gt;Much credit is due to Patrick McGehearty and Rich Cohen, who assisted
-with the original design of the game and contributed greatly to its
-conceptual development.&lt;/para&gt;
-
-&lt;para&gt;Thanks are also due to Carl Strange, Hardy Tichenor and Steven Bruell
-for their assistance with certain coding problems.&lt;/para&gt;
-
-&lt;para&gt;This game was inspired by and rather loosely based on an earlier
-game, programmed in the BASIC language, by Jim Korp and Grady Hicks.
-It is the authors' understanding that the BASIC game was in turn
-derived from a still earlier version in use at Penn State University.&lt;/para&gt;
-
-&lt;/sect1&gt;
-&lt;sect1&gt;&lt;title&gt;References&lt;/title&gt;
-
-&lt;orderedlist&gt;
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;Star Trek&lt;/citetitle&gt; (the original television
-series), produced and directed by Gene Rodenberry.&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;Star Trek&lt;/citetitle&gt; (the animated
-television series), produced by Gene Rodenberry and directed by Hal
-Sutherland.  Also excellent, and not just kiddie fare.  If you enjoyed
-the original series you should enjoy this one (unless you have some
-sort of a hangup about watching cartoons).&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;The Making of Star Trek&lt;/citetitle&gt;, by
-Steven E. Whitfield and Gene Rodenberry.  The best and most complete
-readily available book about Star Trek.  (Ballantine
-Books)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;The World of Star Trek&lt;/citetitle&gt;, by
-David Gerrold.  Similiar in scope to the above book.
-(Bantam)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;The Star Trek Guide&lt;/citetitle&gt;, third revision 4/17/67, by Gene
-Roddenberry.  The original writer's guide for the television
-series, but less comprehensive than (3) above.
-(Norway Productions)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;The Trouble With Tribbles&lt;/citetitle&gt;, by
-David Gerrold.  Includes the complete script of this popular show.
-(Ballantine Books)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;Star Trek&lt;/citetitle&gt;, &lt;citetitle&gt;Star Trek
-2&lt;/citetitle&gt;, ..., &lt;citetitle&gt;Star Trek 9&lt;/citetitle&gt;, by James
-Blish.  The original shows in short story form.
-(Bantam)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;&lt;citetitle&gt;Spock Must Die&lt;/citetitle&gt;, by James Blish.
-An original novel, but rather similar to the show &lt;citetitle&gt;The Enemy
-Within&lt;/citetitle&gt;.  (Bantam)&lt;/para&gt;&lt;/listitem&gt;
-
-&lt;listitem&gt;&lt;para&gt;Model kits of the Enterprise and a &lt;quote&gt;Klingon
-Battle-Cruiser&lt;/quote&gt; by AMT Corporation are available at most hobby
-shops.&lt;/para&gt;&lt;/listitem&gt;
-&lt;/orderedlist&gt;
-
-&lt;/sect1&gt;
-&lt;/chapter&gt;
-&lt;/book&gt;

Deleted: trunk/sst-layer.xsl
===================================================================
--- trunk/sst-layer.xsl	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sst-layer.xsl	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,11 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;xsl:stylesheet xmlns:xsl=&quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;
-                version=&quot;1.0&quot;&gt;
-
-&lt;!-- force an encoding we can throw on an xterm window --&gt;
-&lt;xsl:output method=&quot;html&quot;
-            encoding=&quot;ISO-8859-1&quot;
-            indent=&quot;no&quot;/&gt;
-
-&lt;/xsl:stylesheet&gt;
-

Deleted: trunk/sst.c
===================================================================
--- trunk/sst.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sst.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,846 +0,0 @@
-#define INCLUDED	// Define externs here
-#include &lt;ctype.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;time.h&gt;
-#include &quot;sstlinux.h&quot;
-#include &quot;sst.h&quot;
-
-#ifndef SSTDOC
-#define SSTDOC	&quot;sst.doc&quot;
-#endif
-	
-/*
-
-Dave Matuszek says:
-
-   SRSCAN, MOVE, PHASERS, CALL, STATUS, IMPULSE, PHOTONS, ABANDON,
-   LRSCAN, WARP, SHIELDS, DESTRUCT, CHART, REST, DOCK, QUIT, and DAMAGE
-   were in the original non-&quot;super&quot; version of UT FORTRAN Star Trek.
-
-   Tholians weren't in the original. Dave is dubious about their merits.
-   (They are now controlled by OPTION_THOLIAN and turned off if the game
-   type is &quot;plain&quot;.)
-
-   Planets and dilithium crystals weren't in the original.  Dave is OK
-   with this idea. (It's now controlled by OPTION_PLANETS and turned 
-   off if the game type is &quot;plain&quot;.)
-
-   Dave says the bit about the Galileo getting turned into a
-   McDonald's is &quot;consistant with our original vision&quot;.  (This has been
-   left permanently enabled, as it can only happen if OPTION_PLANETS
-   is on.)
-
-   Dave also says the Space Thingy should not be preserved across saved
-   games, so you can't prove to others that you've seen it.  He says it
-   shouldn't fire back, either.  It should do nothing except scream and
-   disappear when hit by photon torpedos.  It's OK that it may move
-   when attacked, but it didn't in the original.  (Whether the Thingy
-   can fire back is now controlled by OPTION_THINGY and turned off if the
-   game type is &quot;plain&quot; or &quot;almy&quot;.  The no-save behavior has been restored.)
-
-   The Faerie Queen, black holes, and time warping were in the original.
-
-Here are Tom Almy's changes:
-
-   In early 1997, I got the bright idea to look for references to
-   &quot;Super Star Trek&quot; on the World Wide Web. There weren't many hits,
-   but there was one that came up with 1979 Fortran sources! This
-   version had a few additional features that mine didn't have,
-   however mine had some feature it didn't have. So I merged its
-   features that I liked. I also took a peek at the DECUS version (a
-   port, less sources, to the PDP-10), and some other variations.
-
-   1, Compared to the original UT version, I've changed the &quot;help&quot; command to
-      &quot;call&quot; and the &quot;terminate&quot; command to &quot;quit&quot; to better match
-      user expectations. The DECUS version apparently made those changes
-      as well as changing &quot;freeze&quot; to &quot;save&quot;. However I like &quot;freeze&quot;.
-      (Both &quot;freeze&quot; and &quot;save&quot; work in SST2K.)
-
-   2. The experimental deathray originally had only a 5% chance of
-      success, but could be used repeatedly. I guess after a couple
-      years of use, it was less &quot;experimental&quot; because the 1979
-      version had a 70% success rate. However it was prone to breaking
-      after use. I upgraded the deathray, but kept the original set of
-      failure modes (great humor!).  (Now controlled by OPTION_DEATHRAY
-      and turned off if game type is &quot;plain&quot;.)
-
-   3. The 1979 version also mentions srscan and lrscan working when
-      docked (using the starbase's scanners), so I made some changes here
-      to do this (and indicating that fact to the player), and then realized
-      the base would have a subspace radio as well -- doing a Chart when docked
-      updates the star chart, and all radio reports will be heard. The Dock
-      command will also give a report if a base is under attack.
-
-   4. Tholian Web from the 1979 version.  (Now controlled by
-      OPTION_THOLIAN and turned off if game type is &quot;plain&quot;.)
-
-   5. Enemies can ram the Enterprise. (Now controlled by OPTION_RAMMING
-      and turned off if game type is &quot;plain&quot;.)
-
-   6. Regular Klingons and Romulans can move in Expert and Emeritus games. 
-      This code could use improvement. (Now controlled by OPTION_MVBADDY
-      and turned off if game type is &quot;plain&quot;.)
-
-   7. The deep-space probe feature from the DECUS version.  (Now controlled
-      by OPTION_PROBE and turned off if game type is &quot;plain&quot;).
-
-   8. 'emexit' command from the 1979 version.
-
-   9. Bugfix: Klingon commander movements are no longer reported if long-range 
-      sensors are damaged.
-
-   10. Bugfix: Better base positioning at startup (more spread out).
-      That made sense to add because most people abort games with 
-      bad base placement.
-
-   In June 2002, I fixed two known bugs and a documentation typo.
-   In June 2004 I fixed a number of bugs involving: 1) parsing invalid
-   numbers, 2) manual phasers when SR scan is damaged and commander is
-   present, 3) time warping into the future, 4) hang when moving
-   klingons in crowded quadrants.  (These fixes are in SST2K.)
-
-Here are Stas Sergeev's changes:
-
-   1. The Space Thingy can be shoved, if you ram it, and can fire back if 
-      fired upon. (Now controlled by OPTION_THINGY and turned off if game 
-      type is &quot;plain&quot; or &quot;almy&quot;.)
-
-   2. When you are docked, base covers you with an almost invincible shield. 
-      (A commander can still ram you, or a Romulan can destroy the base,
-      or a SCom can even succeed with direct attack IIRC, but this rarely 
-      happens.)  (Now controlled by OPTION_BASE and turned off if game 
-      type is &quot;plain&quot; or &quot;almy&quot;.)
-
-   3. Ramming a black hole is no longer instant death.  There is a
-      chance you might get timewarped instead. (Now controlled by 
-      OPTION_BLKHOLE and turned off if game type is &quot;plain&quot; or &quot;almy&quot;.)
-
-   4. The Tholian can be hit with phasers.
-
-   5. SCom can't escape from you if no more enemies remain 
-      (without this, chasing SCom can take an eternity).
-
-   6. Probe target you enter is now the destination quadrant. Before I don't 
-      remember what it was, but it was something I had difficulty using.
-
-   7. Secret password is now autogenerated.
-
-   8. &quot;Plaque&quot; is adjusted for A4 paper :-)
-
-   9. Phasers now tells you how much energy needed, but only if the computer 
-      is alive.
-
-   10. Planets are auto-scanned when you enter the quadrant.
-
-   11. Mining or using crystals in presense of enemy now yields an attack.
-       There are other minor adjustments to what yields an attack
-       and what does not.
-
-   12. &quot;freeze&quot; command reverts to &quot;save&quot;, most people will understand this
-       better anyway. (SST2K recognizes both.)
-
-   13. Screen-oriented interface, with sensor scans always up.  (SST2K
-       supports both screen-oriented and TTY modes.)
-
-Eric Raymond's changes:
-
-Mainly, I translated this C code out of FORTRAN into C -- created #defines
-for a lot of magic numbers and refactored the heck out of it.
-
-   1. &quot;sos&quot; and &quot;call&quot; becomes &quot;mayday&quot;, &quot;freeze&quot; and &quot;save&quot; are both good.
-
-   2. Status report now indicates when dilithium crystals are on board.
-
-   3. Per Dave Matuszek's remarks, Thingy state is never saved across games.
-
-   4. Added game option selection so you can play a close (but not bug-for-
-      bug identical) approximation of older versions.
-*/
-
-/* the input queue */
-static char line[128], *linep = line;
-
-static struct 
-{
-    char *name;
-    int value;
-    unsigned long option;
-}
-commands[] = {
-#define SRSCAN	0
-	{&quot;SRSCAN&quot;,	SRSCAN,		OPTION_TTY},
-#define STATUS	1
-	{&quot;STATUS&quot;,	STATUS,		OPTION_TTY},
-#define REQUEST	2
-	{&quot;REQUEST&quot;,	REQUEST,	OPTION_TTY},
-#define LRSCAN	3
-	{&quot;LRSCAN&quot;,	LRSCAN,		OPTION_TTY},
-#define PHASERS	4
-	{&quot;PHASERS&quot;,	PHASERS,	0},
-#define TORPEDO	5
-        {&quot;TORPEDO&quot;,	TORPEDO,	0},
-	{&quot;PHOTONS&quot;,	TORPEDO,	0},
-#define MOVE	6
-	{&quot;MOVE&quot;,	MOVE,		0},
-#define SHIELDS	7
-	{&quot;SHIELDS&quot;,	SHIELDS,	0},
-#define DOCK	8
-	{&quot;DOCK&quot;,	DOCK,		0},
-#define DAMAGES	9
-	{&quot;DAMAGES&quot;,	DAMAGES,	0},
-#define CHART	10
-	{&quot;CHART&quot;,	CHART,		0},
-#define IMPULSE	11
-	{&quot;IMPULSE&quot;,	IMPULSE,	0},
-#define REST	12
-	{&quot;REST&quot;,	REST,		0},
-#define WARP	13
-	{&quot;WARP&quot;,	WARP,		0},
-#define SCORE	14
-	{&quot;SCORE&quot;,	SCORE,		0},
-#define SENSORS	15
-	{&quot;SENSORS&quot;,	SENSORS,	OPTION_PLANETS},
-#define ORBIT	16
-	{&quot;ORBIT&quot;,	ORBIT,		OPTION_PLANETS},
-#define TRANSPORT	17
-	{&quot;TRANSPORT&quot;,	TRANSPORT,	OPTION_PLANETS},
-#define MINE	18
-	{&quot;MINE&quot;,	MINE,		OPTION_PLANETS},
-#define CRYSTALS	19
-	{&quot;CRYSTALS&quot;,	CRYSTALS,	OPTION_PLANETS},
-#define SHUTTLE	20
-	{&quot;SHUTTLE&quot;,	SHUTTLE,	OPTION_PLANETS},
-#define PLANETS	21
-	{&quot;PLANETS&quot;,	PLANETS,	OPTION_PLANETS},
-#define REPORT	22
-	{&quot;REPORT&quot;,	REPORT,		0},
-#define COMPUTER	23
-	{&quot;COMPUTER&quot;,	COMPUTER,      	0},
-#define COMMANDS	24
-	{&quot;COMMANDS&quot;,	COMMANDS,      	0},
-#define EMEXIT	25
-	{&quot;EMEXIT&quot;,	EMEXIT,		0},
-#define PROBE	26
-	{&quot;PROBE&quot;,	PROBE,		OPTION_PROBE},
-#define SAVE	27
-	{&quot;SAVE&quot;,	SAVE,		0},
-	{&quot;FREEZE&quot;,	SAVE,		0},
-#define ABANDON	28
-	{&quot;ABANDON&quot;,	ABANDON,	0},
-#define DESTRUCT	29
-	{&quot;DESTRUCT&quot;,	DESTRUCT,	0},
-#define DEATHRAY	30
-	{&quot;DEATHRAY&quot;,	DEATHRAY,	0},
-#define DEBUGCMD	31
-	{&quot;DEBUG&quot;,	DEBUGCMD,	0},
-#define MAYDAY	32
-	{&quot;MAYDAY&quot;,	MAYDAY,		0},
-	//{&quot;SOS&quot;,		MAYDAY,		0},
-	//{&quot;CALL&quot;,	MAYDAY,		0},
-#define QUIT	33
-	{&quot;QUIT&quot;,	QUIT,		0},
-#define HELP	34
-	{&quot;HELP&quot;,	HELP,		0},
-};
-
-#define NUMCOMMANDS	sizeof(commands)/sizeof(commands[0])
-#define ACCEPT(i)	(!commands[i].option || (commands[i].option &amp; game.options))
-
-static void listCommands(void) {
-    int i, k = 0;
-    proutn(&quot;LEGAL COMMANDS ARE:&quot;);
-    for (i = 0; i &lt; NUMCOMMANDS; i++) {
-	if (!ACCEPT(i))
-	    continue;
-	if (k % 5 == 0)
-	    skip(1);
-	proutn(&quot;%-12s &quot;, commands[i].name); 
-	k++;
-    }
-    skip(1);
-}
-
-static void helpme(void) 
-{
-    int i, j;
-    char cmdbuf[32], *cp;
-    char linebuf[132];
-    FILE *fp;
-    /* Give help on commands */
-    int key;
-    key = scan();
-    while (TRUE) {
-	if (key == IHEOL) {
-	    setwnd(prompt_window);
-	    proutn(&quot;Help on what command? &quot;);
-	    key = scan();
-	}
-	setwnd(message_window);
-	if (key == IHEOL) return;
-	for (i = 0; i &lt; NUMCOMMANDS; i++) {
-	    if (ACCEPT(i) &amp;&amp; strcasecmp(commands[i].name, citem)==0) {
-		i = commands[i].value;
-		break;
-	    }
-	}
-	if (i != NUMCOMMANDS) break;
-	skip(1);
-	prout(&quot;Valid commands:&quot;);
-	listCommands();
-	key = IHEOL;
-	chew();
-	skip(1);
-    }
-    if (i == COMMANDS) {
-	strcpy(cmdbuf, &quot; ABBREV&quot;);
-    }
-    else {
-	for (j = 0; commands[i].name[j]; j++)
-	    cmdbuf[j] = toupper(commands[i].name[j]);
-	cmdbuf[j] = '\0';
-    }
-    fp = fopen(SSTDOC, &quot;r&quot;);
-    if (fp == NULL) {
-	prout(&quot;Spock-  \&quot;Captain, that information is missing from the&quot;);
-	prout(&quot;   computer.\&quot;&quot;);
-	/*
-	 * This used to continue: &quot;You need to find SST.DOC and put 
-	 * it in the current directory.&quot;
-	 */
-	return;
-    }
-    for (;;) {
-	if (fgets(linebuf, sizeof(linebuf), fp) == NULL) {
-	    prout(&quot;Spock- \&quot;Captain, there is no information on that command.\&quot;&quot;);
-	    fclose(fp);
-	    return;
-	}
-	if (linebuf[0] == '%' &amp;&amp; linebuf[1] == '%'&amp;&amp; linebuf[2] == ' ') {
-	    for (cp = linebuf+3; isspace(*cp); cp++)
-		continue;
-	    linebuf[strlen(linebuf)-1] = '\0';
-	    if (strcasecmp(cp, cmdbuf) == 0)
-		break;
-	}
-    }
-
-    skip(1);
-    prout(&quot;Spock- \&quot;Captain, I've found the following information:\&quot;&quot;);
-    skip(1);
-
-    while (fgets(linebuf, sizeof(linebuf),fp)) {
-	if (strstr(linebuf, &quot;******&quot;))
-	    break;
-	proutn(linebuf);
-    }
-    fclose(fp);
-}
-
-void enqueue(char *s) 
-{
-    strcpy(line, s);
-}
-
-static void makemoves(void) 
-{
-    int i, v = 0, hitme;
-    clrscr();
-    setwnd(message_window);
-    while (TRUE) { /* command loop */
-	drawmaps(1);
-	while (TRUE)  { /* get a command */
-	    hitme = FALSE;
-	    justin = 0;
-	    Time = 0.0;
-	    i = -1;
-	    chew();
-	    setwnd(prompt_window);
-	    clrscr();
-	    proutn(&quot;COMMAND&gt; &quot;);
-	    if (scan() == IHEOL) {
-		makechart();
-		continue;
-	    }
-	    ididit=0;
-	    clrscr();
-	    setwnd(message_window);
-	    clrscr();
-	    for (i=0; i &lt; ABANDON; i++)
-		if (ACCEPT(i) &amp;&amp; isit(commands[i].name)) {
-		    v = commands[i].value;
-		    break;
-		}
-	    if (i &lt; ABANDON &amp;&amp; (!commands[i].option || (commands[i].option &amp; game.options))) 
-		break;
-	    for (; i &lt; NUMCOMMANDS; i++)
-		if (ACCEPT(i) &amp;&amp; strcasecmp(commands[i].name, citem) == 0) {
-		    v = commands[i].value;
-		    break;
-		}
-	    if (i &lt; NUMCOMMANDS &amp;&amp; (!commands[i].option || (commands[i].option &amp; game.options))) 
-		break;
-	    listCommands();
-	}
-	commandhook(commands[i].name, TRUE);
-	switch (v) { /* command switch */
-	case SRSCAN:                 // srscan
-	    srscan(SCAN_FULL);
-	    break;
-	case STATUS:                 // status
-	    srscan(SCAN_STATUS);
-	    break;
-	case REQUEST:			// status request 
-	    srscan(SCAN_REQUEST);
-	    break;
-	case LRSCAN:			// lrscan
-	    lrscan();
-	    break;
-	case PHASERS:			// phasers
-	    phasers();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case TORPEDO:			// photons
-	    photon();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case MOVE:			// move
-	    warp(1);
-	    break;
-	case SHIELDS:			// shields
-	    doshield(1);
-	    if (ididit) {
-		hitme=TRUE;
-		shldchg = 0;
-	    }
-	    break;
-	case DOCK:			// dock
-	    dock(1);
-	    if (ididit) attack(0);
-	    break;
-	case DAMAGES:			// damages
-	    dreprt();
-	    break;
-	case CHART:			// chart
-	    chart(0);
-	    break;
-	case IMPULSE:			// impulse
-	    impuls();
-	    break;
-	case REST:			// rest
-	    wait();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case WARP:			// warp
-	    setwrp();
-	    break;
-	case SCORE:           	 	// score
-	    score();
-	    break;
-	case SENSORS:			// sensors
-	    sensor();
-	    break;
-	case ORBIT:			// orbit
-	    orbit();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case TRANSPORT:			// transport &quot;beam&quot;
-	    beam();
-	    break;
-	case MINE:			// mine
-	    mine();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case CRYSTALS:			// crystals
-	    usecrystals();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case SHUTTLE:			// shuttle
-	    shuttle();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case PLANETS:			// Planet list
-	    preport();
-	    break;
-	case REPORT:			// Game Report 
-	    report();
-	    break;
-	case COMPUTER:			// use COMPUTER!
-	    eta();
-	    break;
-	case COMMANDS:
-	    listCommands();
-	    break;
-	case EMEXIT:			// Emergency exit
-	    clrscr();			// Hide screen
-	    freeze(TRUE);		// forced save
-	    exit(1);			// And quick exit
-	    break;
-	case PROBE:
-	    probe();			// Launch probe
-	    if (ididit) hitme = TRUE;
-	    break;
-	case ABANDON:			// Abandon Ship
-	    abandn();
-	    break;
-	case DESTRUCT:			// Self Destruct
-	    dstrct();
-	    break;
-	case SAVE:			// Save Game
-	    freeze(FALSE);
-	    clrscr();
-	    if (skill &gt; SKILL_GOOD)
-		prout(&quot;WARNING--Saved games produce no plaques!&quot;);
-	    break;
-	case DEATHRAY:			// Try a desparation measure
-	    deathray();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case DEBUGCMD:			// What do we want for debug???
-#ifdef DEBUG
-	    debugme();
-#endif
-	    break;
-	case MAYDAY:			// Call for help
-	    help();
-	    if (ididit) hitme = TRUE;
-	    break;
-	case QUIT:
-	    alldone = 1;		// quit the game
-#ifdef DEBUG
-	    if (idebug) score();
-#endif
-	    break;
-	case HELP:
-	    helpme();	// get help
-	    break;
-	}
-	commandhook(commands[i].name, FALSE);
-	for (;;) {
-	    if (alldone) break;		// Game has ended
-#ifdef DEBUG
-	    if (idebug) prout(&quot;2500&quot;);
-#endif
-	    if (Time != 0.0) {
-		events();
-		if (alldone) break;	// Events did us in
-	    }
-	    if (game.state.galaxy[quadx][quady].supernova) { // Galaxy went Nova!
-		atover(0);
-		continue;
-	    }
-	    if (hitme &amp;&amp; justin==0) {
-		attack(2);
-		if (alldone) break;
-		if (game.state.galaxy[quadx][quady].supernova) {	// went NOVA! 
-		    atover(0);
-		    hitme = TRUE;
-		    continue;
-		}
-	    }
-	    break;
-	}
-	if (alldone) break;
-    }
-}
-
-
-int main(int argc, char **argv) 
-{
-    int i, option;
-
-    game.options = OPTION_ALL &amp;~ (OPTION_IOMODES | OPTION_SHOWME | OPTION_PLAIN | OPTION_ALMY);
-    if (getenv(&quot;TERM&quot;))
-	game.options |= OPTION_CURSES | OPTION_SHOWME;
-    else
-	game.options |= OPTION_TTY;
-
-    while ((option = getopt(argc, argv, &quot;t&quot;)) != -1) {
-	switch (option) {
-	case 't':
-	    game.options |= OPTION_TTY;
-	    game.options &amp;=~ OPTION_CURSES;
-	    break;
-	default:
-	    fprintf(stderr, &quot;usage: sst [-t] [startcommand...].\n&quot;);
-	    exit(0);
-	}
-    }
-
-    randomize();
-    iostart();
-
-    line[0] = '\0';
-    for (i = optind; i &lt; argc;  i++) {
-	strcat(line, argv[i]);
-	strcat(line, &quot; &quot;);
-    }
-    while (TRUE) { /* Play a game */
-	setwnd(fullscreen_window);
-#ifdef DEBUG
-	prout(&quot;INITIAL OPTIONS: %0lx&quot;, game.options);
-#endif /* DEBUG */
-	clrscr();
-	prelim();
-	setup(line[0] == '\0');
-	if (alldone) {
-	    score();
-	    alldone = 0;
-	}
-	else makemoves();
-	skip(1);
-	stars();
-	skip(1);
-
-	if (tourn &amp;&amp; alldone) {
-	    proutn(&quot;Do you want your score recorded?&quot;);
-	    if (ja()) {
-		chew2();
-		freeze(FALSE);
-	    }
-	}
-	proutn(&quot;Do you want to play again? &quot;);
-	if (!ja()) break;
-    }
-    skip(1);
-    prout(&quot;May the Great Bird of the Galaxy roost upon your home planet.&quot;);
-    return 0;
-}
-
-
-void cramen(int i) 
-{
-    /* return an enemy */
-    char *s;
-	
-    switch (i) {
-    case IHR: s = &quot;Romulan&quot;; break;
-    case IHK: s = &quot;Klingon&quot;; break;
-    case IHC: s = &quot;Commander&quot;; break;
-    case IHS: s = &quot;Super-commander&quot;; break;
-    case IHSTAR: s = &quot;Star&quot;; break;
-    case IHP: s = &quot;Planet&quot;; break;
-    case IHB: s = &quot;Starbase&quot;; break;
-    case IHBLANK: s = &quot;Black hole&quot;; break;
-    case IHT: s = &quot;Tholian&quot;; break;
-    case IHWEB: s = &quot;Tholian web&quot;; break;
-    case IHQUEST: s = &quot;Stranger&quot;; break;
-    default: s = &quot;Unknown??&quot;; break;
-    }
-    proutn(s);
-}
-
-char *cramlc(enum loctype key, int x, int y)
-{
-    static char buf[32];
-    buf[0] = '\0';
-    if (key == quadrant) strcpy(buf, &quot;Quadrant &quot;);
-    else if (key == sector) strcpy(buf, &quot;Sector &quot;);
-    sprintf(buf+strlen(buf), &quot;%d - %d&quot;, x, y);
-    return buf;
-}
-
-void crmena(int i, int enemy, int key, int x, int y) 
-{
-    if (i == 1) proutn(&quot;***&quot;);
-    cramen(enemy);
-    proutn(&quot; at &quot;);
-    proutn(cramlc(key, x, y));
-}
-
-void crmshp(void) 
-{
-    char *s;
-    switch (ship) {
-    case IHE: s = &quot;Enterprise&quot;; break;
-    case IHF: s = &quot;Faerie Queene&quot;; break;
-    default:  s = &quot;Ship???&quot;; break;
-    }
-    proutn(s);
-}
-
-void stars(void) 
-{
-    prouts(&quot;******************************************************&quot;);
-    skip(1);
-}
-
-double expran(double avrage) 
-{
-    return -avrage*log(1e-7 + Rand());
-}
-
-double Rand(void) {
-	return rand()/(1.0 + (double)RAND_MAX);
-}
-
-void iran(int size, int *i, int *j) 
-{
-    *i = Rand()*(size*1.0) + 1.0;
-    *j = Rand()*(size*1.0) + 1.0;
-}
-
-void chew(void)
-{
-    linep = line;
-    *linep = 0;
-}
-
-void chew2(void) 
-{
-    /* return IHEOL next time */
-    linep = line+1;
-    *linep = 0;
-}
-
-int scan(void) 
-{
-    int i;
-    char *cp;
-
-    // Init result
-    aaitem = 0.0;
-    *citem = 0;
-
-    // Read a line if nothing here
-    if (*linep == 0) {
-	if (linep != line) {
-	    chew();
-	    return IHEOL;
-	}
-	cgetline(line, sizeof(line));
-	fflush(stdin);
-	if (curwnd==prompt_window){
-	    clrscr();
-	    setwnd(message_window);
-	    clrscr();
-	}
-	linep = line;
-    }
-    // Skip leading white space
-    while (*linep == ' ') linep++;
-    // Nothing left
-    if (*linep == 0) {
-	chew();
-	return IHEOL;
-    }
-    if (isdigit(*linep) || *linep=='+' || *linep=='-' || *linep=='.') {
-	// treat as a number
-	i = 0;
-	if (sscanf(linep, &quot;%lf%n&quot;, &amp;aaitem, &amp;i) &lt; 1) {
-	    linep = line; // Invalid numbers are ignored
-	    *linep = 0;
-	    return IHEOL;
-	}
-	else {
-	    // skip to end
-	    linep += i;
-	    return IHREAL;
-	}
-    }
-    // Treat as alpha
-    cp = citem;
-    while (*linep &amp;&amp; *linep!=' ') {
-	if ((cp - citem) &lt; 9) *cp++ = tolower(*linep);
-	linep++;
-    }
-    *cp = 0;
-    return IHALPHA;
-}
-
-int ja(void) 
-{
-    chew();
-    while (TRUE) {
-	scan();
-	chew();
-	if (*citem == 'y') return TRUE;
-	if (*citem == 'n') return FALSE;
-	proutn(&quot;Please answer with \&quot;Y\&quot; or \&quot;N\&quot;: &quot;);
-    }
-}
-
-void huh(void) 
-{
-    chew();
-    skip(1);
-    prout(&quot;Beg your pardon, Captain?&quot;);
-}
-
-int isit(char *s) 
-{
-    /* New function -- compares s to scanned citem and returns true if it
-       matches to the length of s */
-
-    return strncasecmp(s, citem, max(1, strlen(citem))) == 0;
-
-}
-
-#ifdef DEBUG
-void debugme(void) 
-{
-    proutn(&quot;Reset levels? &quot;);
-    if (ja() != 0) {
-	if (energy &lt; inenrg) energy = inenrg;
-	shield = inshld;
-	torps = intorps;
-	lsupres = inlsr;
-    }
-    proutn(&quot;Reset damage? &quot;);
-    if (ja() != 0) {
-	int i;
-	for (i=0; i &lt; NDEVICES; i++) 
-	    if (game.damage[i] &gt; 0.0) 
-		game.damage[i] = 0.0;
-    }
-    proutn(&quot;Toggle idebug? &quot;);
-    if (ja() != 0) {
-	idebug = !idebug;
-	if (idebug) prout(&quot;Debug output ON&quot;);
-	else prout(&quot;Debug output OFF&quot;);
-    }
-    proutn(&quot;Cause selective damage? &quot;);
-    if (ja() != 0) {
-	int i, key;
-	for (i=0; i &lt; NDEVICES; i++) {
-	    proutn(&quot;Kill &quot;);
-	    proutn(device[i]);
-	    proutn(&quot;? &quot;);
-	    chew();
-	    key = scan();
-	    if (key == IHALPHA &amp;&amp;  isit(&quot;y&quot;)) {
-		game.damage[i] = 10.0;
-	    }
-	}
-    }
-    proutn(&quot;Examine/change events? &quot;);
-    if (ja() != 0) {
-	int i;
-	for (i = 1; i &lt; NEVENTS; i++) {
-	    int key;
-	    if (game.future[i] == FOREVER) continue;
-	    switch (i) {
-	    case FSNOVA:  proutn(&quot;Supernova       &quot;); break;
-	    case FTBEAM:  proutn(&quot;T Beam          &quot;); break;
-	    case FSNAP:   proutn(&quot;Snapshot        &quot;); break;
-	    case FBATTAK: proutn(&quot;Base Attack     &quot;); break;
-	    case FCDBAS:  proutn(&quot;Base Destroy    &quot;); break;
-	    case FSCMOVE: proutn(&quot;SC Move         &quot;); break;
-	    case FSCDBAS: proutn(&quot;SC Base Destroy &quot;); break;
-	    }
-	    proutn(&quot;%.2f&quot;, game.future[i]-game.state.date);
-	    chew();
-	    proutn(&quot;  ?&quot;);
-	    key = scan();
-	    if (key == IHREAL) {
-		game.future[i] = game.state.date + aaitem;
-	    }
-	}
-	chew();
-    }
-    proutn(&quot;Induce supernova here? &quot;);
-    if (ja() != 0) {
-	game.state.galaxy[quadx][quady].supernova = TRUE;
-	atover(1);
-    }
-}
-#endif

Deleted: trunk/sst.h
===================================================================
--- trunk/sst.h	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sst.h	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,528 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;curses.h&gt;
-#ifndef INCLUDED
-#define EXTERN extern
-#else
-#define EXTERN
-#endif
-
-#define min(x, y)	((x)&lt;(y)?(x):(y))
-#define max(x, y)	((x)&gt;(y)?(x):(y))
-
-// #define DEBUG
-
-#define PHASEFAC (2.0)
-#define PLNETMAX (10)
-#define GALSIZE	(8)
-#define QUADSIZE (10)
-#define BASEMAX	(5)
-
-/*
- * These macros hide the difference between 0-origin and 1-origin addressing.
- * They're a step towards de-FORTRANizing the code.
- */
-#define VALID_QUADRANT(x, y)	((x)&gt;=1 &amp;&amp; (x)&lt;=GALSIZE &amp;&amp; (y)&gt;=1 &amp;&amp; (y)&lt;=GALSIZE)
-#define VALID_SECTOR(x, y)	((x)&gt;=1 &amp;&amp; (x)&lt;=QUADSIZE &amp;&amp; (y)&gt;=1 &amp;&amp; (y)&lt;=QUADSIZE)
-#define for_quadrants(i)	for (i = 1; i &lt;= GALSIZE; i++)
-#define for_sectors(i)		for (i = 1; i &lt;= QUADSIZE; i++)
-#define for_commanders(i)	for (i = 1; i &lt;= game.state.remcom; i++)
-#define for_local_enemies(i)	for (i = 1; i &lt;= nenhere; i++)
-#define for_starbases(i)	for (i = 1; i &lt;= game.state.rembase; i++)
-
-typedef struct {
-    int x;	/* Quadrant location of planet */
-    int y;
-    enum {M=0, N=1, O=2} pclass;
-    int crystals; /* has crystals */
-    enum {unknown, known, shuttle_down} known;
-} planet;
-
-#define DESTROY(pl)	memset(pl, '\0', sizeof(planet))
-
-typedef struct {
-    int snap,		// snapshot taken
-	remkl,			// remaining klingons
-	remcom,			// remaining commanders
-	nscrem,			// remaining super commanders
-	rembase,		// remaining bases
-	starkl,			// destroyed stars
-	basekl,			// destroyed bases
-	cx[QUADSIZE+1],cy[QUADSIZE+1],	// Commander quadrant coordinates
-	baseqx[BASEMAX+1],		// Base quadrant X
-	baseqy[BASEMAX+1],		// Base quadrant Y
-	isx, isy,		// Coordinate of Super Commander
-	nromrem,		// Romulans remaining
-	nplankl;		// destroyed planets
-	planet plnets[PLNETMAX];  // Planet information
-	double date,		// stardate
-	    remres,		// remaining resources
-	    remtime;		// remaining time
-    struct {
-	int stars;
-	int planets;
-	int starbase;
-	int klingons;
-	int romulans;
-	int supernova;
-	int charted;
-    } galaxy[GALSIZE+1][GALSIZE+1]; 	// The Galaxy (subscript 0 not used)
-    struct {
-	int stars;
-	int starbase;
-	int klingons;
-    } chart[GALSIZE+1][GALSIZE+1]; 	// the starchart (subscript 0 not used)
-} snapshot;				// Data that is snapshot
-
-#define NKILLK (inkling - game.state.remkl)
-#define NKILLC (incom - game.state.remcom)
-#define NKILLSC (inscom - game.state.nscrem)
-#define NKILLROM (inrom - game.state.nromrem)
-#define KLINGREM (game.state.remkl + game.state.remcom + game.state.nscrem)
-#define INKLINGTOT (inkling + incom + inscom)
-#define KLINGKILLED (INKLINGTOT - KLINGREM)
-
-#define SKILL_NONE	0
-#define SKILL_NOVICE	1
-#define SKILL_FAIR	2
-#define SKILL_GOOD	3
-#define SKILL_EXPERT	4
-#define SKILL_EMERITUS	5
-
-/* game options */
-#define OPTION_ALL	0xffffffff
-#define OPTION_TTY	0x00000001	/* old interface */
-#define OPTION_CURSES	0x00000002	/* new interface */
-#define OPTION_IOMODES	0x00000003	/* cover both interfaces */
-#define OPTION_PLANETS	0x00000004	/* planets and mining */
-#define OPTION_THOLIAN	0x00000008	/* Tholians and their webs */
-#define OPTION_THINGY	0x00000010	/* Space Thingy can shoot back */
-#define OPTION_PROBE	0x00000020	/* deep-space probes */
-#define OPTION_SHOWME	0x00000040	/* bracket Enterprise in chart */
-#define OPTION_RAMMING	0x00000080	/* enemies may ram Enterprise */
-#define OPTION_MVBADDY	0x00000100	/* more enemies can move */
-#define OPTION_BLKHOLE	0x00000200	/* black hole may timewarp you */
-#define OPTION_BASE	0x00000400	/* bases have good shields */
-#define OPTION_PLAIN	0x01000000	/* user chose plain game */
-#define OPTION_ALMY	0x02000000	/* user chose Almy variant */
-
-/* Define devices */
-#define DSRSENS 0
-#define DLRSENS 1
-#define DPHASER 2
-#define DPHOTON 3
-#define DLIFSUP 4
-#define DWARPEN 5
-#define DIMPULS 6
-#define DSHIELD 7
-#define DRADIO  8
-#define DSHUTTL 9
-#define DCOMPTR 10
-#define DTRANSP 11
-#define DSHCTRL 12
-#define DDRAY   13  // Added deathray
-#define DDSP    14  // Added deep space probe
-#define NDEVICES (15)	// Number of devices
-
-#define FOREVER	1e30
-
-/* Define future events */
-#define FSPY	0	// Spy event happens always (no future[] entry)
-					// can cause SC to tractor beam Enterprise
-#define FSNOVA  1   // Supernova
-#define FTBEAM  2   // Commander tractor beams Enterprise
-#define FSNAP   3   // Snapshot for time warp
-#define FBATTAK 4   // Commander attacks base
-#define FCDBAS  5   // Commander destroys base
-#define FSCMOVE 6   // Supercommander moves (might attack base)
-#define FSCDBAS 7   // Supercommander destroys base
-#define FDSPROB 8   // Move deep space probe
-#define NEVENTS (9)
-
-// Scalar variables that are needed for freezing the game
-// are placed in a structure. #defines are used to access by their
-// original names. Gee, I could have done this with the d structure,
-// but I just didn't think of it back when I started.
-
-#define SSTMAGIC	&quot;SST2.0\n&quot;
-
-EXTERN WINDOW *curwnd;
-
-EXTERN struct {
-    char magic[sizeof(SSTMAGIC)];
-    unsigned long options;
-    snapshot state;
-    snapshot snapsht;
-    char quad[QUADSIZE+1][QUADSIZE+1];		// contents of our quadrant
-    double kpower[(QUADSIZE+1)*(QUADSIZE+1)];		// enemy energy levels
-    double kdist[(QUADSIZE+1)*(QUADSIZE+1)];		// enemy distances
-    double kavgd[(QUADSIZE+1)*(QUADSIZE+1)];		// average distances
-    double damage[NDEVICES];	// damage encountered
-    double future[NEVENTS];	// future events
-    char passwd[10];		// Self Destruct password
-    int kx[(QUADSIZE+1)*(QUADSIZE+1)];			// enemy sector locations
-    int ky[(QUADSIZE+1)*(QUADSIZE+1)];
-    /* members with macro definitions start here */
-    int inkling,
-	inbase,
-	incom,
-	inscom,
-	inrom,
-	instar,
-	intorps,
-	condit,
-	torps,
-	ship,
-	quadx,
-	quady,
-	sectx,
-	secty,
-	length,
-	skill,
-	basex,
-	basey,
-	klhere,
-	comhere,
-	casual,
-	nhelp,
-	nkinks,
-	ididit,
-	gamewon,
-	alive,
-	justin,
-	alldone,
-	shldchg,
-	plnetx,
-	plnety,
-	inorbit,
-	landed,
-	iplnet,
-	imine,
-	inplan,
-	nenhere,
-	ishere,
-	neutz,
-	irhere,
-	icraft,
-	ientesc,
-	iscraft,
-	isatb,
-	iscate,
-#ifdef DEBUG
-	idebug,
-#endif
-	iattak,
-	icrystl,
-	tourn,
-	thawed,
-	batx,
-	baty,
-	ithere,
-	ithx,
-	ithy,
-	iseenit,
-	probecx,
-	probecy,
-	proben,
-	isarmed,
-	nprobes;
-    double inresor,
-	intime,
-	inenrg,
-	inshld,
-	inlsr,
-	indate,
-	energy,
-	shield,
-	shldup,
-	warpfac,
-	wfacsq,
-	lsupres,
-	dist,
-	direc,
-	Time,
-	docfac,
-	resting,
-	damfac,
-	lastchart,
-	cryprob,
-	probex,
-	probey,
-	probeinx,
-	probeiny,
-	height;
-} game;
-
-#define inkling game.inkling		// Initial number of klingons
-#define inbase game.inbase		// Initial number of bases
-#define incom game.incom		// Initian number of commanders
-#define inscom game.inscom		// Initian number of commanders
-#define inrom game.inrom		// Initian number of commanders
-#define instar game.instar		// Initial stars
-#define intorps game.intorps		// Initial/Max torpedoes
-#define condit game.condit		// Condition (red/yellow/green/docked)
-#define torps game.torps		// number of torpedoes
-#define ship game.ship			// Ship type -- 'E' is Enterprise
-#define quadx game.quadx		// where we are
-#define quady game.quady		//
-#define sectx game.sectx		// where we are
-#define secty game.secty		//
-#define length game.length		// length of game
-#define skill game.skill		// skill level
-#define basex game.basex		// position of base in current quad
-#define basey game.basey		//
-#define klhere game.klhere		// klingons here
-#define comhere game.comhere		// commanders here
-#define casual game.casual		// causalties
-#define nhelp game.nhelp		// calls for help
-#define nkinks game.nkinks		//
-#define ididit game.ididit		// Action taken -- allows enemy to attack
-#define gamewon game.gamewon		// Finished!
-#define alive game.alive		// We are alive (not killed)
-#define justin game.justin		// just entered quadrant
-#define alldone game.alldone		// game is now finished
-#define shldchg game.shldchg		// shield is changing (affects efficiency)
-#define plnetx game.plnetx		// location of planet in quadrant
-#define plnety game.plnety		//
-#define inorbit game.inorbit		// orbiting
-#define landed game.landed		// party on planet (1), on ship (-1)
-#define iplnet game.iplnet		// planet # in quadrant
-#define imine game.imine		// mining
-#define inplan game.inplan		// initial planets
-#define nenhere game.nenhere		// Number of enemies in quadrant
-#define ishere game.ishere		// Super-commander in quandrant
-#define neutz game.neutz		// Romulan Neutral Zone
-#define irhere game.irhere		// Romulans in quadrant
-#define icraft game.icraft		// Kirk in Galileo
-#define ientesc game.ientesc		// Attempted escape from supercommander
-#define iscraft game.iscraft		// =1 if craft on ship, -1 if removed from game
-#define isatb game.isatb		// =1 if SuperCommander is attacking base
-#define iscate game.iscate		// Super Commander is here
-#ifdef DEBUG
-#define idebug game.idebug		// Debug mode
-#endif
-#define iattak game.iattak		// attack recursion elimination (was cracks[4])
-#define icrystl game.icrystl		// dilithium crystals aboard
-#define tourn game.tourn		// Tournament number
-#define thawed game.thawed		// Thawed game
-#define batx game.batx			// Base coordinates being attacked
-#define baty game.baty			//
-#define ithere game.ithere		// Tholean is here 
-#define ithx game.ithx			// coordinates of tholean
-#define ithy game.ithy
-#define iseenit game.iseenit		// Seen base attack report
-#define inresor game.inresor		// initial resources
-#define intime game.intime		// initial time
-#define inenrg game.inenrg		// Initial/Max Energy
-#define inshld game.inshld		// Initial/Max Shield
-#define inlsr game.inlsr		// initial life support resources
-#define indate game.indate		// Initial date
-#define energy game.energy		// Energy level
-#define shield game.shield		// Shield level
-#define shldup game.shldup		// Shields are up
-#define warpfac game.warpfac		// Warp speed
-#define wfacsq game.wfacsq		// squared warp factor
-#define lsupres game.lsupres		// life support reserves
-#define dist game.dist			// movement distance
-#define direc game.direc		// movement direction
-#define Time game.Time			// time taken by current operation
-#define docfac game.docfac		// repair factor when docking (constant?)
-#define resting game.resting		// rest time
-#define damfac game.damfac		// damage factor
-#define lastchart game.lastchart	// time star chart was last updated
-#define cryprob game.cryprob		// probability that crystal will work
-#define probex game.probex		// location of probe
-#define probey game.probey
-#define probecx game.probecx		// current probe quadrant
-#define probecy game.probecy	
-#define probeinx game.probeinx		// Probe x,y increment
-#define probeiny game.probeiny		
-#define proben game.proben		// number of moves for probe
-#define isarmed game.isarmed		// Probe is armed
-#define nprobes game.nprobes		// number of probes available
-
-/* the following global state doesn't need to be saved */
-EXTERN char	*device[NDEVICES];
-EXTERN int iscore, iskill; // Common PLAQ
-EXTERN double perdate;
-EXTERN double aaitem;
-EXTERN char citem[10];
-
-/* the Space Thingy's global state should *not* be saved! */
-EXTERN int thingx, thingy, iqhere, iqengry;
-
-typedef enum {FWON, FDEPLETE, FLIFESUP, FNRG, FBATTLE,
-              FNEG3, FNOVA, FSNOVAED, FABANDN, FDILITHIUM,
-			  FMATERIALIZE, FPHASER, FLOST, FMINING, FDPLANET,
-			  FPNOVA, FSSC, FSTRACTOR, FDRAY, FTRIBBLE,
-			  FHOLE} FINTYPE ;
-enum loctype {neither, quadrant, sector};
-
-#ifdef INCLUDED
-char *device[NDEVICES] = {
-	&quot;S. R. Sensors&quot;,
-	&quot;L. R. Sensors&quot;,
-	&quot;Phasers&quot;,
-	&quot;Photon Tubes&quot;,
-	&quot;Life Support&quot;,
-	&quot;Warp Engines&quot;,
-	&quot;Impulse Engines&quot;,
-	&quot;Shields&quot;,
-	&quot;Subspace Radio&quot;,
-	&quot;Shuttle Craft&quot;,
-	&quot;Computer&quot;,
-	&quot;Transporter&quot;,
-	&quot;Shield Control&quot;,
-	&quot;Death Ray&quot;,
-	&quot;D. S. Probe&quot;};									
-#endif
-
-#ifndef TRUE
-#define TRUE (1)
-#define FALSE (0)
-#endif
-
-#define IHR 'R'
-#define IHK 'K'
-#define IHC 'C'
-#define IHS 'S'
-#define IHSTAR '*'
-#define IHP 'P'
-#define IHB 'B'
-#define IHBLANK ' '
-#define IHDOT '.'
-#define IHQUEST '?'
-#define IHE 'E'
-#define IHF 'F'
-#define IHT 'T'
-#define IHWEB '#'
-#define IHGREEN 'G'
-#define IHYELLOW 'Y'
-#define IHRED 'R'
-#define IHDOCKED 'D'
-#define IHDEAD 'Z'
-#define IHMATER0 '-'
-#define IHMATER1 'o'
-#define IHMATER2 '0'
-
-
-/* Function prototypes */
-void prelim(void);
-void attack(int);
-int choose(int);
-void setup(int);
-void score(void);
-void atover(int);
-int srscan(int);
-void lrscan(void);
-void phasers(void);
-void photon(void);
-void warp(int);
-void doshield(int);
-void dock(int);
-void dreprt(void);
-void chart(int);
-void rechart(void);
-void impuls(void);
-void wait(void);
-void setwrp(void);
-void events(void);
-void report(void);
-void eta(void);
-void help(void);
-void abandn(void);
-void finish(FINTYPE);
-void dstrct(void);
-void kaboom(void);
-void freeze(int);
-int thaw(void);
-void plaque(void);
-int scan(void);
-#define IHEOL (0)
-#define IHALPHA (1)
-#define IHREAL (2)
-void chew(void);
-void chew2(void);
-void skip(int);
-void prout(char *, ...);
-void proutn(char *, ...);
-void stars(void);
-void newqad(int);
-int ja(void);
-void cramen(int);
-void crmshp(void);
-char *cramlc(enum loctype, int, int);
-double expran(double);
-double Rand(void);
-void iran(int, int *, int *);
-#define square(i) ((i)*(i))
-void dropin(int, int*, int*);
-void newcnd(void);
-void sortkl(void);
-void imove(void);
-void ram(int, int, int, int);
-void crmena(int, int, int, int, int);
-void deadkl(int, int, int, int, int);
-void timwrp(void);
-void movcom(void);
-void torpedo(double, double, int, int, double *, int, int);
-void huh(void);
-void pause_game(int);
-void nova(int, int);
-void snova(int, int);
-void scom(int *);
-void hittem(double *);
-void prouts(char *, ...);
-int isit(char *);
-void preport(void);
-void orbit(void);
-void sensor(void);
-void drawmaps(short);
-void beam(void);
-void mine(void);
-void usecrystals(void);
-void shuttle(void);
-void deathray(void);
-void debugme(void);
-void attakreport(int);
-void movetho(void);
-void probe(void);
-void iostart(void);
-void setwnd(WINDOW *);
-void warble(void);
-void boom(int ii, int jj);
-void tracktorpedo(int ix, int iy, int l, int i, int n, int iquad);
-void cgetline(char *, int);
-void waitfor(void);
-void setpassword(void);
-void commandhook(char *, int);
-void makechart(void);
-void enqueue(char *);
-
-/* mode arguments for srscan() */
-#define SCAN_FULL		1
-#define SCAN_REQUEST		2
-#define SCAN_STATUS		3
-#define SCAN_NO_LEFTSIDE	4
-
-WINDOW *fullscreen_window;
-WINDOW *srscan_window;
-WINDOW *report_window;
-WINDOW *lrscan_window;
-WINDOW *message_window;
-WINDOW *prompt_window;
-
-extern void clreol(void);
-extern void clrscr(void);
-extern void textcolor(int color);
-extern void highvideo(void);
-
-enum COLORS {
-   DEFAULT,
-   BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY,
-   DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, WHITE
-};
-
-#define DAMAGED	128	/* marker for damaged ship in starmap */

Deleted: trunk/sst.xml
===================================================================
--- trunk/sst.xml	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sst.xml	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,67 +0,0 @@
-&lt;!DOCTYPE refentry PUBLIC 
-   &quot;-//OASIS//DTD DocBook XML V4.1.2//EN&quot;
-   &quot;docbook/docbookx.dtd&quot;&gt;
-&lt;refentry id='sst.6'&gt;
-&lt;refmeta&gt;
-&lt;refentrytitle&gt;sst&lt;/refentrytitle&gt;
-&lt;manvolnum&gt;6&lt;/manvolnum&gt;
-&lt;refmiscinfo class='date'&gt;Nov 1 2004&lt;/refmiscinfo&gt;
-&lt;/refmeta&gt;
-&lt;refnamediv id='name'&gt;
-&lt;refname&gt;sst&lt;/refname&gt;
-&lt;refpurpose&gt;the classic Super Star Trek game&lt;/refpurpose&gt;
-&lt;/refnamediv&gt;
-&lt;refsynopsisdiv id='synopsis'&gt;
-
-&lt;cmdsynopsis&gt;
-&lt;command&gt;sst&lt;/command&gt;
-&lt;arg choice='opt'&gt;-t &lt;/arg&gt; 
-&lt;arg rep='repeat' &gt;&lt;replaceable&gt;command&lt;/replaceable&gt;&lt;/arg&gt;  
-&lt;/cmdsynopsis&gt;
-
-&lt;/refsynopsisdiv&gt;
-
-&lt;refsect1 id='description'&gt;&lt;title&gt;DESCRIPTION&lt;/title&gt;
-
-&lt;para&gt;The Organian Peace Treaty has collapsed, and the Federation is
-at war with the Klingon Empire. Joining the Klingons against the
-Federation are the members of the Romulan Star Empire. As commander
-of the Starship U.S.S. Enterprise, your job is to wipe out the Klingon
-invasion fleet and make the galaxy safe for democracy.&lt;/para&gt;
-
-&lt;para&gt;This is one of the great early classic computer games from the
-1970s and still has a remarkable amount of play value. Run
-&lt;command&gt;sst&lt;/command&gt; in a terminal window to start it.  Typing
-'comands' at the prompt will list all commands; help is available for
-each one individually as well.  Full documentation is &lt;ulink
-url='<A HREF="http://sst.berlios.de/sst-doc.html">http://sst.berlios.de/sst-doc.html</A>'&gt;browseable&lt;/ulink&gt;.  On
-systems where &lt;filename&gt;/usr/share/doc/sst/&lt;/filename&gt; is a legal
-filename, it will probably be installed there as well.&lt;/para&gt;
-
-&lt;para&gt;There is one option -t, which forces the original pure-tty mode.
-Normally sst tries to come up in full-screen mode that assumes it is
-running on a cursor-addressable terminal or terminal emulator.&lt;/para&gt;
-
-&lt;para&gt;Input tokens for the setup prompts will be read from the
-remainder of the command line before standard input.  Thus, for
-example, you can invoke the program as&lt;/para&gt;
-
-&lt;programlisting&gt;
-sst regular medium good fancy
-&lt;/programlisting&gt;
-
-&lt;para&gt;to start a regular medium game as a good player in 'fancy'
-mode (all features enabled).&lt;/para&gt;
-&lt;/refsect1&gt;
-
-&lt;refsect1 id='authors'&gt;&lt;title&gt;AUTHORS&lt;/title&gt; 
-&lt;para&gt;Super Star Trek was designed and written by David Matuszek, Paul
-Reynolds, and Don Smith in the 1970s.  It was resurrected by Tom Almy.
-The screen-oriented interface is by Stas Sergeev. This version has
-been cleaned up and documented by Eric S. Raymond
-&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">esr at snark.thyrsus.com</A>&lt;/email&gt;.  There is a &lt;ulink
-url='<A HREF="https://developer.berlios.de/projects/sst/">https://developer.berlios.de/projects/sst/</A>'&gt;project
-page&lt;/ulink&gt;.&lt;/para&gt;
-&lt;/refsect1&gt;
-&lt;/refentry&gt;
-

Deleted: trunk/sstlinux.c
===================================================================
--- trunk/sstlinux.c	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sstlinux.c	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,18 +0,0 @@
-#include &lt;sys/types.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;sys/ioctl.h&gt;
-#include &lt;linux/kd.h&gt;
-#include &quot;sstlinux.h&quot;
-
-static int fd = 0;
-
-void sound(unsigned int freq)
-{
-    if(fd==0) fd=open(&quot;/dev/console&quot;, O_RDONLY);
-    if(fd&gt;0) ioctl(fd, KDMKTONE, 1193180/freq + (0xFFFF&lt;&lt;16));
-}
-
-void nosound(void)
-{
-    if(fd&gt;0) ioctl(fd, KDMKTONE, 0);
-}

Deleted: trunk/sstlinux.h
===================================================================
--- trunk/sstlinux.h	2006-09-13 17:20:21 UTC (rev 540)
+++ trunk/sstlinux.h	2006-09-13 17:20:32 UTC (rev 541)
@@ -1,10 +0,0 @@
-#ifndef __SSTLINUX_H
-#define __SSTLINUX_H
-
-void sound(unsigned int);
-void nosound(void);
-
-#define delay(x) usleep(x*1000)
-#define randomize() srand((unsigned)time(NULL))
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000007.html">[Sst-commit-watch] r540 - trunk
</A></li>
	<LI>Next message: <A HREF="000008.html">[Sst-commit-watch] r542 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">More information about the Sst-commit-watch
mailing list</a><br>
</body></html>
