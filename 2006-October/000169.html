<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Sst-commit-watch] r702 - branches/c-version/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/sst-commit-watch/2006-October/index.html" >
   <LINK REL="made" HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r702%20-%20branches/c-version/src&In-Reply-To=%3C200610070835.k978ZvKl004951%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000168.html">
   <LINK REL="Next"  HREF="000170.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Sst-commit-watch] r702 - branches/c-version/src</H1>
    <B>stsp at BerliOS</B> 
    <A HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r702%20-%20branches/c-version/src&In-Reply-To=%3C200610070835.k978ZvKl004951%40sheep.berlios.de%3E"
       TITLE="[Sst-commit-watch] r702 - branches/c-version/src">stsp at mail.berlios.de
       </A><BR>
    <I>Sat Oct  7 10:35:57 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000168.html">[Sst-commit-watch] r701 - branches
</A></li>
        <LI>Next message: <A HREF="000170.html">[Sst-commit-watch] r703 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#169">[ date ]</a>
              <a href="thread.html#169">[ thread ]</a>
              <a href="subject.html#169">[ subject ]</a>
              <a href="author.html#169">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stsp
Date: 2006-10-07 10:35:56 +0200 (Sat, 07 Oct 2006)
New Revision: 702

Removed:
   branches/c-version/src/sst.py
Log:
remove sst.py

Deleted: branches/c-version/src/sst.py
===================================================================
--- branches/c-version/src/sst.py	2006-10-07 08:32:49 UTC (rev 701)
+++ branches/c-version/src/sst.py	2006-10-07 08:35:56 UTC (rev 702)
@@ -1,6801 +0,0 @@
-#!/usr/bin/env python
-&quot;&quot;&quot;
-sst.py =-- Super Star Trek in Python
-
-This code is a Python translation of a C translation of a FORTRAN original.
-The FORTRANness still shows in many ways, notably the use of a lot of
-parallel arrays where a more modern language would use structures
-or objects.  (However, 1-origin array indexing was fixed.)
-
-Dave Matuszek says:
-
-SRSCAN, MOVE, PHASERS, CALL, STATUS, IMPULSE, PHOTONS, ABANDON,
-LRSCAN, WARP, SHIELDS, DESTRUCT, CHART, REST, DOCK, QUIT, and DAMAGE
-were in the original non-&quot;super&quot; version of UT FORTRAN Star Trek.
-
-Tholians were not in the original. Dave is dubious about their merits.
-(They are now controlled by OPTION_THOLIAN and turned off if the game
-type is &quot;plain&quot;.)
-
-Planets and dilithium crystals were not in the original.  Dave is OK
-with this idea. (It's now controlled by OPTION_PLANETS and turned 
-off if the game type is &quot;plain&quot;.)
-
-Dave says the bit about the Galileo getting turned into a
-McDonald's is &quot;consistant with our original vision&quot;.  (This has been
-left permanently enabled, as it can only happen if OPTION_PLANETS
-is on.)
-
-Dave also says the Space Thingy should not be preserved across saved
-games, so you can't prove to others that you've seen it.  He says it
-shouldn't fire back, either.  It should do nothing except scream and
-disappear when hit by photon torpedos.  It's OK that it may move
-when attacked, but it didn't in the original.  (Whether the Thingy
-can fire back is now controlled by OPTION_THINGY and turned off if the
-game type is &quot;plain&quot; or &quot;almy&quot;.  The no-save behavior has been restored.)
-
-The Faerie Queen, black holes, and time warping were in the original.
-
-Here are Tom Almy's changes:
-
-In early 1997, I got the bright idea to look for references to
-&quot;Super Star Trek&quot; on the World Wide Web. There weren't many hits,
-but there was one that came up with 1979 Fortran sources! This
-version had a few additional features that mine didn't have,
-however mine had some feature it didn't have. So I merged its
-features that I liked. I also took a peek at the DECUS version (a
-port, less sources, to the PDP-10), and some other variations.
-
-1, Compared to the original UT version, I've changed the &quot;help&quot; command to
-&quot;call&quot; and the &quot;terminate&quot; command to &quot;quit&quot; to better match
-user expectations. The DECUS version apparently made those changes
-as well as changing &quot;freeze&quot; to &quot;save&quot;. However I like &quot;freeze&quot;.
-(Both &quot;freeze&quot; and &quot;save&quot; work in SST2K.)
-
-2. The experimental deathray originally had only a 5% chance of
-success, but could be used repeatedly. I guess after a couple
-years of use, it was less &quot;experimental&quot; because the 1979
-version had a 70% success rate. However it was prone to breaking
-after use. I upgraded the deathray, but kept the original set of
-failure modes (great humor!).  (Now controlled by OPTION_DEATHRAY
-and turned off if game type is &quot;plain&quot;.)
-
-3. The 1979 version also mentions srscan and lrscan working when
-docked (using the starbase's scanners), so I made some changes here
-to do this (and indicating that fact to the player), and then realized
-the base would have a subspace radio as well -- doing a Chart when docked
-updates the star chart, and all radio reports will be heard. The Dock
-command will also give a report if a base is under attack.
-
-4. Tholian Web from the 1979 version.  (Now controlled by
-OPTION_THOLIAN and turned off if game type is &quot;plain&quot;.)
-
-5. Enemies can ram the Enterprise. (Now controlled by OPTION_RAMMING
-and turned off if game type is &quot;plain&quot;.)
-
-6. Regular Klingons and Romulans can move in Expert and Emeritus games. 
-This code could use improvement. (Now controlled by OPTION_MVBADDY
-and turned off if game type is &quot;plain&quot;.)
-
-7. The deep-space probe feature from the DECUS version.  (Now controlled
-by OPTION_PROBE and turned off if game type is &quot;plain&quot;).
-
-8. 'emexit' command from the 1979 version.
-
-9. Bugfix: Klingon commander movements are no longer reported if long-range 
-sensors are damaged.
-
-10. Bugfix: Better base positioning at startup (more spread out).
-That made sense to add because most people abort games with 
-bad base placement.
-
-In June 2002, I fixed two known bugs and a documentation typo.
-In June 2004 I fixed a number of bugs involving: 1) parsing invalid
-numbers, 2) manual phasers when SR scan is damaged and commander is
-present, 3) time warping into the future, 4) hang when moving
-klingons in crowded quadrants.  (These fixes are in SST2K.)
-
-Here are Stas Sergeev's changes:
-
-1. The Space Thingy can be shoved, if you ram it, and can fire back if 
-fired upon. (Now controlled by OPTION_THINGY and turned off if game 
-type is &quot;plain&quot; or &quot;almy&quot;.)
-
-2. When you are docked, base covers you with an almost invincible shield. 
-(A commander can still ram you, or a Romulan can destroy the base,
-or a SCom can even succeed with direct attack IIRC, but this rarely 
-happens.)  (Now controlled by OPTION_BASE and turned off if game 
-type is &quot;plain&quot; or &quot;almy&quot;.)
-
-3. Ramming a black hole is no longer instant death.  There is a
-chance you might get timewarped instead. (Now controlled by 
-OPTION_BLKHOLE and turned off if game type is &quot;plain&quot; or &quot;almy&quot;.)
-
-4. The Tholian can be hit with phasers.
-
-5. SCom can't escape from you if no more enemies remain 
-(without this, chasing SCom can take an eternity).
-
-6. Probe target you enter is now the destination quadrant. Before I don't 
-remember what it was, but it was something I had difficulty using.
-
-7. Secret password is now autogenerated.
-
-8. &quot;Plaque&quot; is adjusted for A4 paper :-)
-
-9. Phasers now tells you how much energy needed, but only if the computer 
-is alive.
-
-10. Planets are auto-scanned when you enter the quadrant.
-
-11. Mining or using crystals in presense of enemy now yields an attack.
-There are other minor adjustments to what yields an attack
-and what does not.
-
-12. &quot;freeze&quot; command reverts to &quot;save&quot;, most people will understand this
-better anyway. (SST2K recognizes both.)
-
-13. Screen-oriented interface, with sensor scans always up.  (SST2K
-supports both screen-oriented and TTY modes.)
-
-Eric Raymond's changes:
-
-Mainly, I translated this C code out of FORTRAN into C -- created #defines
-for a lot of magic numbers and refactored the heck out of it.
-
-1. &quot;sos&quot; and &quot;call&quot; becomes &quot;mayday&quot;, &quot;freeze&quot; and &quot;save&quot; are both good.
-
-2. Status report now indicates when dilithium crystals are on board.
-
-3. Per Dave Matuszek's remarks, Thingy state is never saved across games.
-
-4. Added game option selection so you can play a close (but not bug-for-
-bug identical) approximation of older versions.
-
-5. Half the quadrants now have inhabited planets, from which one 
-cannot mine dilithium (there will still be the same additional number
-of dilithium-bearing planets).  Torpedoing an inhabited world is *bad*.
-There is BSD-Trek-like logic for Klingons to attack and enslave 
-inhabited worlds, producing more ships (only is skill is 'good' or 
-better). (Controlled by OPTION_WORLDS and turned off if game 
-type is &quot;plain&quot; or &quot;almy&quot;.)
-
-6. User input is now logged so we can do regression testing.
-
-7. More BSD-Trek features: You can now lose if your entire crew
-dies in battle.  When abandoning ship in a game with inhabited
-worlds enabled, they must have one in the quadrant to beam down
-to; otherwise they die in space and this counts heavily against
-your score.  Docking at a starbase replenishes your crew.
-
-8. Still more BSD-Trek: we now have a weighted damage table.
-Also, the nav subsystem (enabling automatic course
-setting) can be damaged separately from the main computer (which
-handles weapons targeting, ETA calculation, and self-destruct).
-
-After these features were added, I translated this into Python and added
-more:
-
-9. A long-range scan is done silently whenever you call CHART; thus
-the LRSCAN command is no longer needed.  (Controlled by OPTION_AUTOSCAN
-and turned off if game type is &quot;plain&quot; or &quot;almy&quot;.)
-&quot;&quot;&quot;
-import os,sys,math,curses,time,atexit,readline,cPickle,random,getopt,copy
-
-SSTDOC  	= &quot;/usr/share/doc/sst/sst.doc&quot;
-DOC_NAME	= &quot;sst.doc&quot;
-
-# Stub to be replaced
-def _(str): return str
-
-PHASEFAC	= 2.0
-GALSIZE 	= 8
-NINHAB  	= (GALSIZE * GALSIZE / 2)
-MAXUNINHAB	= 10
-PLNETMAX	= (NINHAB + MAXUNINHAB)
-QUADSIZE	= 10
-BASEMIN		= 2
-BASEMAX 	= (GALSIZE * GALSIZE / 12)
-MAXKLGAME	= 127
-MAXKLQUAD	= 9
-FULLCREW	= 428	# BSD Trek was 387, that's wrong 
-FOREVER 	= 1e30
-MAXBURST	= 3
-
-# These functions hide the difference between 0-origin and 1-origin addressing.
-def VALID_QUADRANT(x, y):	return ((x)&gt;=0 and (x)&lt;GALSIZE and (y)&gt;=0 and (y)&lt;GALSIZE)
-def VALID_SECTOR(x, y):	return ((x)&gt;=0 and (x)&lt;QUADSIZE and (y)&gt;=0 and (y)&lt;QUADSIZE)
-
-def square(i):		return ((i)*(i))
-def distance(c1, c2):	return math.sqrt(square(c1.x - c2.x) + square(c1.y - c2.y))
-def invalidate(w):	w.x = w.y = 0
-def is_valid(w):	return (w.x != 0 and w.y != 0)
-
-# How to represent features
-IHR = 'R',
-IHK = 'K',
-IHC = 'C',
-IHS = 'S',
-IHSTAR = '*',
-IHP = 'P',
-IHW = '@',
-IHB = 'B',
-IHBLANK = ' ',
-IHDOT = '.',
-IHQUEST = '?',
-IHE = 'E',
-IHF = 'F',
-IHT = 'T',
-IHWEB = '#',
-IHMATER0 = '-',
-IHMATER1 = 'o',
-IHMATER2 = '0'
-
-IHEOL = '\n'
-IHREAL = 0.0
-IHALPHA = &quot; &quot;
-
-class coord:
-    def __init__(self, x=None, y=None):
-        self.x = x
-        self.y = y
-    def invalidate(self):
-        self.x = self.y = None
-    def is_valid(self):
-        return self.x != None and self.y != None
-    def __eq__(self, other):
-        return other != None and self.x == other.y and self.x == other.y
-    def __add__(self, other):
-        return coord(self.x+self.x, self.y+self.y)
-    def __sub__(self, other):
-        return coord(self.x-self.x, self.y-self.y)
-    def distance(self, other):
-        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)
-    def sgn(self):
-        s = coord()
-        if self.x == 0:
-            s.x = 0
-        else:
-            s.x = self.x / abs(self.x)
-        if self.y == 0:
-            s.y = 0
-        else:
-            s.y = self.y / abs(self.y)
-        return s
-    def scatter(self):
-        s = coord()
-        s.x = self.x + randrange(-1, 2)
-        s.y = self.y + randrange(-1, 2)
-        return s
-    def __hash__(self):
-        return hash((x, y))
-    def __str__(self):
-        if self.x == None or self.y == None:
-            return &quot;Nowhere&quot;
-        return &quot;%s - %s&quot; % (self.x+1, self.y+1)
-    __repr__ = __str__
-
-class planet:
-    def __init__(self):
-        self.name = None	# string-valued if inhabited
-        self.w = coord()	# quadrant located
-        self.pclass = None	# could be &quot;&quot;M&quot;, &quot;N&quot;, &quot;O&quot;, or &quot;destroyed&quot;
-        self.crystals = &quot;absent&quot;# could be &quot;mined&quot;, &quot;present&quot;, &quot;absent&quot;
-        self.known = &quot;unknown&quot;	# could be &quot;unknown&quot;, &quot;known&quot;, &quot;shuttle_down&quot;
-        self.inhabited = False	# is it inhabites?
-    def __str__(self):
-        return self.name
-
-class quadrant:
-    def __init__(self):
-        self.stars = None
-        self.planet = None
-	self.starbase = None
-	self.klingons = None
-	self.romulans = None
-	self.supernova = None
-	self.charted = None
-        self.status = None	# Could be &quot;secure&quot;, &quot;distressed&quot;, &quot;enslaved&quot;
-
-class page:
-    def __init__(self):
-	self.stars = None
-	self.starbase = None
-	self.klingons = None
-
-def fill2d(size, fillfun):
-    &quot;Fill an empty list in 2D.&quot;
-    lst = []
-    for i in range(size):
-        lst.append([]) 
-        for j in range(size):
-            lst[i].append(fillfun(i, j))
-    return lst
-
-class snapshot:
-    def __init__(self):
-        self.snap = False	# snapshot taken
-        self.crew = 0   	# crew complement
-	self.remkl = 0  	# remaining klingons
-	self.remcom = 0  	# remaining commanders
-	self.nscrem = 0		# remaining super commanders
-	self.rembase = 0	# remaining bases
-	self.starkl = 0 	# destroyed stars
-	self.basekl = 0 	# destroyed bases
-	self.nromrem = 0	# Romulans remaining
-	self.nplankl = 0	# destroyed uninhabited planets
-	self.nworldkl = 0	# destroyed inhabited planets
-        self.planets = []	# Planet information
-        self.date = 0.0   	# stardate
-	self.remres = 0 	# remaining resources
-	self.remtime = 0	# remaining time
-        self.baseq = [] 	# Base quadrant coordinates
-        for i in range(BASEMAX):
-            self.baseq.append(coord())
-        self.kcmdr = [] 	# Commander quadrant coordinates
-        for i in range(QUADSIZE):
-            self.kcmdr.append(coord())
-	self.kscmdr = coord()	# Supercommander quadrant coordinates
-        # the galaxy (subscript 0 not used)
-        self.galaxy = fill2d(GALSIZE, lambda i, j: quadrant())
-        # the starchart (subscript 0 not used)
-    	self.chart = fill2d(GALSIZE, lambda i, j: page())
-
-class event:
-    def __init__(self):
-        self.date = None	# A real number
-        self.quadrant = None	# A coord structure
-
-# game options 
-OPTION_ALL	= 0xffffffff
-OPTION_TTY	= 0x00000001	# old interface 
-OPTION_CURSES	= 0x00000002	# new interface 
-OPTION_IOMODES	= 0x00000003	# cover both interfaces 
-OPTION_PLANETS	= 0x00000004	# planets and mining 
-OPTION_THOLIAN	= 0x00000008	# Tholians and their webs (UT 1979 version)
-OPTION_THINGY	= 0x00000010	# Space Thingy can shoot back (Stas, 2005)
-OPTION_PROBE	= 0x00000020	# deep-space probes (DECUS version, 1980)
-OPTION_SHOWME	= 0x00000040	# bracket Enterprise in chart 
-OPTION_RAMMING	= 0x00000080	# enemies may ram Enterprise (Almy)
-OPTION_MVBADDY	= 0x00000100	# more enemies can move (Almy)
-OPTION_BLKHOLE	= 0x00000200	# black hole may timewarp you (Stas, 2005) 
-OPTION_BASE	= 0x00000400	# bases have good shields (Stas, 2005)
-OPTION_WORLDS	= 0x00000800	# logic for inhabited worlds (ESR, 2006)
-OPTION_AUTOSCAN	= 0x00001000	# automatic LRSCAN before CHART (ESR, 2006)
-OPTION_PLAIN	= 0x01000000	# user chose plain game 
-OPTION_ALMY	= 0x02000000	# user chose Almy variant 
-
-# Define devices 
-DSRSENS	= 0
-DLRSENS	= 1
-DPHASER	= 2
-DPHOTON	= 3
-DLIFSUP	= 4
-DWARPEN	= 5
-DIMPULS	= 6
-DSHIELD	= 7
-DRADIO	= 0
-DSHUTTL = 9
-DCOMPTR = 10
-DNAVSYS	= 11
-DTRANSP = 12
-DSHCTRL	= 13
-DDRAY	= 14
-DDSP	= 15
-NDEVICES= 16	# Number of devices
-
-SKILL_NONE	= 0
-SKILL_NOVICE	= 1
-SKILL_FAIR	= 2
-SKILL_GOOD	= 3
-SKILL_EXPERT	= 4
-SKILL_EMERITUS	= 5
-
-def damaged(dev):	return (game.damage[dev] != 0.0)
-def communicating():	return not damaged(DRADIO) or game.condition==&quot;docked&quot;
-
-# Define future events 
-FSPY	= 0	# Spy event happens always (no future[] entry)
-		# can cause SC to tractor beam Enterprise
-FSNOVA  = 1	# Supernova
-FTBEAM  = 2	# Commander tractor beams Enterprise
-FSNAP   = 3	# Snapshot for time warp
-FBATTAK = 4	# Commander attacks base
-FCDBAS  = 5	# Commander destroys base
-FSCMOVE = 6	# Supercommander moves (might attack base)
-FSCDBAS = 7	# Supercommander destroys base
-FDSPROB = 8	# Move deep space probe
-FDISTR	= 9	# Emit distress call from an inhabited world 
-FENSLV	= 10	# Inhabited word is enslaved */
-FREPRO	= 11	# Klingons build a ship in an enslaved system
-NEVENTS	= 12
-
-#
-# abstract out the event handling -- underlying data structures will change
-# when we implement stateful events
-# 
-def findevent(evtype):	return game.future[evtype]
-
-class enemy:
-    def __init__(self, type=None, loc=None, power=None):
-        self.type = type
-        self.kloc = coord()
-        if loc:
-            self.move(loc)
-        self.kpower = power	# enemy energy level
-        game.enemies.append(self)
-    def move(self, loc):
-        motion = (loc != self.kloc)
-        if self.kloc.x is not None and self.kloc.y is not None:
-            game.quad[self.kloc.x][self.kloc.y] = IHDOT
-        if loc:
-            self.kloc = loc
-            game.quad[self.kloc.x][self.kloc.y] = self.type
-            self.kdist = self.kavgd = distance(game.sector, loc)
-        else:
-            self.kloc = coord()	# enemy sector location
-            self.kdist = self.kavgd = None
-            game.enemies.remove(self)
-        return motion
-    def __repr__(self):
-        return &quot;&lt;%s=%f&gt;&quot; % (self.kloc, self.kpower)	# For debugging
-
-class gamestate:
-    def __init__(self):
-        self.options = None	# Game options
-        self.state = snapshot()	# A snapshot structure
-        self.snapsht = snapshot()	# Last snapshot taken for time-travel purposes
-        self.quad = None	# contents of our quadrant
-        self.damage = [0.0] * NDEVICES	# damage encountered
-        self.future = []		# future events
-        for i in range(NEVENTS):
-            self.future.append(event())
-        self.passwd  = None;		# Self Destruct password
-        self.enemies = []
-        self.quadrant = None	# where we are in the large
-        self.sector = None	# where we are in the small
-        self.tholian = None	# Tholian enemy object
-        self.base = None	# position of base in current quadrant
-        self.battle = None	# base coordinates being attacked
-        self.plnet = None	# location of planet in quadrant
-        self.probec = None	# current probe quadrant
-        self.gamewon = False	# Finished!
-        self.ididit = False	# action taken -- allows enemy to attack
-        self.alive = False	# we are alive (not killed)
-        self.justin = False	# just entered quadrant
-        self.shldup = False	# shields are up
-        self.shldchg = False	# shield is changing (affects efficiency)
-        self.comhere = False	# commander here
-        self.ishere = False	# super-commander in quadrant
-        self.iscate = False	# super commander is here
-        self.ientesc = False	# attempted escape from supercommander
-        self.resting = False	# rest time
-        self.icraft = False	# Kirk in Galileo
-        self.landed = False	# party on planet (true), on ship (false)
-        self.alldone = False	# game is now finished
-        self.neutz = False	# Romulan Neutral Zone
-        self.isarmed = False	# probe is armed
-        self.inorbit = False	# orbiting a planet
-        self.imine = False	# mining
-        self.icrystl = False	# dilithium crystals aboard
-        self.iseenit = False	# seen base attack report
-        self.thawed = False	# thawed game
-        self.condition = None	# &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;docked&quot;, &quot;dead&quot;
-        self.iscraft = None	# &quot;onship&quot;, &quot;offship&quot;, &quot;removed&quot;
-        self.skill = None	# Player skill level
-        self.inkling = 0	# initial number of klingons
-        self.inbase = 0		# initial number of bases
-        self.incom = 0		# initial number of commanders
-        self.inscom = 0		# initial number of commanders
-        self.inrom = 0		# initial number of commanders
-        self.instar = 0		# initial stars
-        self.intorps = 0	# initial/max torpedoes
-        self.torps = 0		# number of torpedoes
-        self.ship = 0		# ship type -- 'E' is Enterprise
-        self.abandoned = 0	# count of crew abandoned in space
-        self.length = 0		# length of game
-        self.klhere = 0		# klingons here
-        self.casual = 0		# causalties
-        self.nhelp = 0		# calls for help
-        self.nkinks = 0		# count of energy-barrier crossings
-        self.iplnet = None	# planet # in quadrant
-        self.inplan = 0		# initial planets
-        self.irhere = 0		# Romulans in quadrant
-        self.isatb = 0		# =1 if super commander is attacking base
-        self.tourn = None	# tournament number
-        self.proben = 0		# number of moves for probe
-        self.nprobes = 0	# number of probes available
-        self.inresor = 0.0	# initial resources
-        self.intime = 0.0	# initial time
-        self.inenrg = 0.0	# initial/max energy
-        self.inshld = 0.0	# initial/max shield
-        self.inlsr = 0.0	# initial life support resources
-        self.indate = 0.0	# initial date
-        self.energy = 0.0	# energy level
-        self.shield = 0.0	# shield level
-        self.warpfac = 0.0	# warp speed
-        self.wfacsq = 0.0	# squared warp factor
-        self.lsupres = 0.0	# life support reserves
-        self.dist = 0.0		# movement distance
-        self.direc = 0.0	# movement direction
-        self.optime = 0.0	# time taken by current operation
-        self.docfac = 0.0	# repair factor when docking (constant?)
-        self.damfac = 0.0	# damage factor
-        self.lastchart = 0.0	# time star chart was last updated
-        self.cryprob = 0.0	# probability that crystal will work
-        self.probex = 0.0	# location of probe
-        self.probey = 0.0	#
-        self.probeinx = 0.0	# probe x,y increment
-        self.probeiny = 0.0	#
-        self.height = 0.0	# height of orbit around planet
-    def recompute(self):
-        # Stas thinks this should be (C expression): 
-        # game.state.remkl + game.state.remcom &gt; 0 ?
-	#	game.state.remres/(game.state.remkl + 4*game.state.remcom) : 99
-        # He says the existing expression is prone to divide-by-zero errors
-        # after killing the last klingon when score is shown -- perhaps also
-        # if the only remaining klingon is SCOM.
-        game.state.remtime = game.state.remres/(game.state.remkl + 4*game.state.remcom)
-# From enumerated type 'feature'
-IHR = 'R'
-IHK = 'K'
-IHC = 'C'
-IHS = 'S'
-IHSTAR = '*'
-IHP = 'P'
-IHW = '@'
-IHB = 'B'
-IHBLANK = ' '
-IHDOT = '.'
-IHQUEST = '?'
-IHE = 'E'
-IHF = 'F'
-IHT = 'T'
-IHWEB = '#'
-IHMATER0 = '-'
-IHMATER1 = 'o'
-IHMATER2 = '0'
-
-
-# From enumerated type 'FINTYPE'
-FWON = 0
-FDEPLETE = 1
-FLIFESUP = 2
-FNRG = 3
-FBATTLE = 4
-FNEG3 = 5
-FNOVA = 6
-FSNOVAED = 7
-FABANDN = 8
-FDILITHIUM = 9
-FMATERIALIZE = 10
-FPHASER = 11
-FLOST = 12
-FMINING = 13
-FDPLANET = 14
-FPNOVA = 15
-FSSC = 16
-FSTRACTOR = 17
-FDRAY = 18
-FTRIBBLE = 19
-FHOLE = 20
-FCREW = 21
-
-# Log the results of pulling random numbers so we can check determinism.
-
-import traceback
-
-def withprob(p):
-    v = random.random()
-    #logfp.write(&quot;# withprob(%s) -&gt; %f (%s) at %s\n&quot; % (p, v, v&lt;p, traceback.extract_stack()[-2][1:]))
-    return v &lt; p
-
-def randrange(*args):
-    v = random.randrange(*args)
-    #logfp.write(&quot;# randrange%s -&gt; %s at %s\n&quot; % (args, v, traceback.extract_stack()[-2][1:]))
-    return v
-
-def randreal(*args):
-    v = random.random()
-    if len(args) == 1:
-        v *= args[0] 		# returns from [0, a1)
-    elif len(args) == 2:
-        v = args[0] + v*args[1]	# returns from [a1, a2)
-    #logfp.write(&quot;# randreal%s -&gt; %s at %s\n&quot; % (args, v, traceback.extract_stack()[-2][1:]))
-    return v
-
-# Code from ai.c begins here
-
-def tryexit(enemy, look, irun):
-    # a bad guy attempts to bug out 
-    iq = coord()
-    iq.x = game.quadrant.x+(look.x+(QUADSIZE-1))/QUADSIZE - 1
-    iq.y = game.quadrant.y+(look.y+(QUADSIZE-1))/QUADSIZE - 1
-    if not VALID_QUADRANT(iq.x,iq.y) or \
-	game.state.galaxy[iq.x][iq.y].supernova or \
-	game.state.galaxy[iq.x][iq.y].klingons &gt; MAXKLQUAD-1:
-	return False; # no can do -- neg energy, supernovae, or &gt;MAXKLQUAD-1 Klingons 
-    if enemy.type == IHR:
-	return False; # Romulans cannot escape! 
-    if not irun:
-	# avoid intruding on another commander's territory 
-	if enemy.type == IHC:
-	    for n in range(game.state.remcom):
-		if game.state.kcmdr[n] == iq:
-		    return False
-	    # refuse to leave if currently attacking starbase 
-	    if game.battle == game.quadrant:
-		return False
-	# don't leave if over 1000 units of energy 
-	if enemy.kpower &gt; 1000.0:
-	    return False
-    # print escape message and move out of quadrant.
-    # we know this if either short or long range sensors are working
-    if not damaged(DSRSENS) or not damaged(DLRSENS) or \
-	game.condition == &quot;docked&quot;:
-	crmena(True, enemy.type, &quot;sector&quot;, enemy.kloc)
-	prout(_(&quot; escapes to Quadrant %s (and regains strength).&quot;) % q)
-    # handle local matters related to escape
-    enemy.move(None)
-    game.klhere -= 1
-    if game.condition != &quot;docked&quot;:
-	newcnd()
-    # Handle global matters related to escape 
-    game.state.galaxy[game.quadrant.x][game.quadrant.y].klingons -= 1
-    game.state.galaxy[iq.x][iq.y].klingons += 1
-    if enemy.type==IHS:
-	game.ishere = False
-	game.iscate = False
-	game.ientesc = False
-	game.isatb = 0
-	schedule(FSCMOVE, 0.2777)
-	unschedule(FSCDBAS)
-	game.state.kscmdr=iq
-    else:
-	for n in range(game.state.remcom):
-	    if game.state.kcmdr[n] == game.quadrant:
-		game.state.kcmdr[n]=iq
-		break
-	game.comhere = False
-    return True; # success 
-
-#
-# The bad-guy movement algorithm:
-# 
-# 1. Enterprise has &quot;force&quot; based on condition of phaser and photon torpedoes.
-# If both are operating full strength, force is 1000. If both are damaged,
-# force is -1000. Having shields down subtracts an additional 1000.
-# 
-# 2. Enemy has forces equal to the energy of the attacker plus
-# 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
-# 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
-# 
-# Attacker Initial energy levels (nominal):
-# Klingon   Romulan   Commander   Super-Commander
-# Novice    400        700        1200        
-# Fair      425        750        1250
-# Good      450        800        1300        1750
-# Expert    475        850        1350        1875
-# Emeritus  500        900        1400        2000
-# VARIANCE   75        200         200         200
-# 
-# Enemy vessels only move prior to their attack. In Novice - Good games
-# only commanders move. In Expert games, all enemy vessels move if there
-# is a commander present. In Emeritus games all enemy vessels move.
-# 
-# 3. If Enterprise is not docked, an aggressive action is taken if enemy
-# forces are 1000 greater than Enterprise.
-# 
-# Agressive action on average cuts the distance between the ship and
-# the enemy to 1/4 the original.
-# 
-# 4.  At lower energy advantage, movement units are proportional to the
-# advantage with a 650 advantage being to hold ground, 800 to move forward
-# 1, 950 for two, 150 for back 4, etc. Variance of 100.
-# 
-# If docked, is reduced by roughly 1.75*game.skill, generally forcing a
-# retreat, especially at high skill levels.
-# 
-# 5.  Motion is limited to skill level, except for SC hi-tailing it out.
-# 
-
-def movebaddy(enemy):
-    # tactical movement for the bad guys 
-    next = coord(); look = coord()
-    irun = False
-    # This should probably be just game.comhere + game.ishere 
-    if game.skill &gt;= SKILL_EXPERT:
-	nbaddys = ((game.comhere*2 + game.ishere*2+game.klhere*1.23+game.irhere*1.5)/2.0)
-    else:
-	nbaddys = game.comhere + game.ishere
-    dist1 = enemy.kdist
-    mdist = int(dist1 + 0.5); # Nearest integer distance 
-    # If SC, check with spy to see if should hi-tail it 
-    if enemy.type==IHS and \
-	(enemy.kpower &lt;= 500.0 or (game.condition==&quot;docked&quot; and not damaged(DPHOTON))):
-	irun = True
-	motion = -QUADSIZE
-    else:
-	# decide whether to advance, retreat, or hold position 
-	forces = enemy.kpower+100.0*len(game.enemies)+400*(nbaddys-1)
-	if not game.shldup:
-	    forces += 1000; # Good for enemy if shield is down! 
-	if not damaged(DPHASER) or not damaged(DPHOTON):
-            if damaged(DPHASER): # phasers damaged 
-		forces += 300.0
-	    else:
-		forces -= 0.2*(game.energy - 2500.0)
-	    if damaged(DPHOTON): # photon torpedoes damaged 
-		forces += 300.0
-	    else:
-		forces -= 50.0*game.torps
-	else:
-	    # phasers and photon tubes both out! 
-	    forces += 1000.0
-	motion = 0
-        if forces &lt;= 1000.0 and game.condition != &quot;docked&quot;: # Typical situation 
-	    motion = ((forces + randreal(200))/150.0) - 5.0
-	else:
-            if forces &gt; 1000.0: # Very strong -- move in for kill 
-		motion = (1.0-square(randreal()))*dist1 + 1.0
-	    if game.condition==&quot;docked&quot; and (game.options &amp; OPTION_BASE): # protected by base -- back off ! 
-		motion -= game.skill*(2.0-square(randreal()))
-	if idebug:
-	    proutn(&quot;=== MOTION = %d, FORCES = %1.2f, &quot; % (motion, forces))
-	# don't move if no motion 
-	if motion==0:
-	    return
-	# Limit motion according to skill 
-	if abs(motion) &gt; game.skill:
-            if motion &lt; 0:
-                motion = -game.skill
-            else:
-                motion = game.skill
-    # calculate preferred number of steps 
-    if motion &lt; 0:
-        nsteps = -motion
-    else:
-        nsteps = motion
-    if motion &gt; 0 and nsteps &gt; mdist:
-	nsteps = mdist; # don't overshoot 
-    if nsteps &gt; QUADSIZE:
-	nsteps = QUADSIZE; # This shouldn't be necessary 
-    if nsteps &lt; 1:
-	nsteps = 1; # This shouldn't be necessary 
-    if idebug:
-	proutn(&quot;NSTEPS = %d:&quot; % nsteps)
-    # Compute preferred values of delta X and Y 
-    m = game.sector - enemy.kloc
-    if 2.0 * abs(m.x) &lt; abs(m.y):
-	m.x = 0
-    if 2.0 * abs(m.y) &lt; abs(game.sector.x-enemy.kloc.x):
-	m.y = 0
-    if m.x != 0:
-        if m.x*motion &lt; 0:
-            m.x = -1
-        else:
-            m.x = 1
-    if m.y != 0:
-        if m.y*motion &lt; 0:
-            m.y = -1
-        else:
-            m.y = 1
-    next = enemy.kloc
-    # main move loop 
-    for ll in range(nsteps):
-	if idebug:
-	    proutn(&quot; %d&quot; % (ll+1))
-	# Check if preferred position available 
-	look = next + m
-        if m.x &lt; 0:
-            krawlx = 1
-        else:
-            krawlx = -1
-        if m.y &lt; 0:
-            krawly = 1
-        else:
-            krawly = -1
-	success = False
-	attempts = 0; # Settle mysterious hang problem 
-	while attempts &lt; 20 and not success:
-            attempts += 1
-	    if look.x &lt; 0 or look.x &gt;= QUADSIZE:
-		if motion &lt; 0 and tryexit(enemy, look, irun):
-		    return
-		if krawlx == m.x or m.y == 0:
-		    break
-		look.x = next.x + krawlx
-		krawlx = -krawlx
-	    elif look.y &lt; 0 or look.y &gt;= QUADSIZE:
-		if motion &lt; 0 and tryexit(enemy, look, irun):
-		    return
-		if krawly == m.y or m.x == 0:
-		    break
-		look.y = next.y + krawly
-		krawly = -krawly
-	    elif (game.options &amp; OPTION_RAMMING) and game.quad[look.x][look.y] != IHDOT:
-		# See if enemy should ram ship 
-		if game.quad[look.x][look.y] == game.ship and \
-		    (enemy.type == IHC or enemy.type == IHS):
-		    collision(rammed=True, enemy=enemy)
-		    return
-		if krawlx != m.x and m.y != 0:
-		    look.x = next.x + krawlx
-		    krawlx = -krawlx
-		elif krawly != m.y and m.x != 0:
-		    look.y = next.y + krawly
-		    krawly = -krawly
-		else:
-		    break; # we have failed 
-	    else:
-		success = True
-	if success:
-	    next = look
-	    if idebug:
-		proutn(`next`)
-	else:
-	    break; # done early 
-    if idebug:
-	skip(1)
-    if enemy.move(next):
-	if not damaged(DSRSENS) or game.condition == &quot;docked&quot;:
-	    proutn(&quot;***&quot;)
-	    cramen(enemy.type)
-	    proutn(_(&quot; from Sector %s&quot;) % enemy.kloc)
-	    if enemy.kdist &lt; dist1:
-		proutn(_(&quot; advances to &quot;))
-	    else:
-		proutn(_(&quot; retreats to &quot;))
-	    prout(&quot;Sector %s.&quot; % next)
-
-def moveklings():
-    # Klingon tactical movement 
-    if idebug:
-	prout(&quot;== MOVCOM&quot;)
-    # Figure out which Klingon is the commander (or Supercommander)
-    # and do move
-    if game.comhere:
-        for enemy in game.enemies:
-	    if enemy.type == IHC:
-		movebaddy(enemy)
-    if game.ishere:
-        for enemy in game.enemies:
-	    if enemy.type == IHS:
-		movebaddy(enemy)
-		break
-    # If skill level is high, move other Klingons and Romulans too!
-    # Move these last so they can base their actions on what the
-    # commander(s) do.
-    if game.skill &gt;= SKILL_EXPERT and (game.options &amp; OPTION_MVBADDY):
-        for enemy in game.enemies:
-            if enemy.type in (IHK, IHR):
-		movebaddy(enemy)
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-
-def movescom(iq, avoid):
-    # commander movement helper 
-    if iq == game.quadrant or not VALID_QUADRANT(iq.x, iq.y) or \
-	game.state.galaxy[iq.x][iq.y].supernova or \
-	game.state.galaxy[iq.x][iq.y].klingons &gt; MAXKLQUAD-1:
-	return 1
-    if avoid:
-	# Avoid quadrants with bases if we want to avoid Enterprise 
-	for i in range(game.state.rembase):
-	    if game.state.baseq[i] == iq:
-		return True
-    if game.justin and not game.iscate:
-	return True
-    # do the move 
-    game.state.galaxy[game.state.kscmdr.x][game.state.kscmdr.y].klingons -= 1
-    game.state.kscmdr = iq
-    game.state.galaxy[game.state.kscmdr.x][game.state.kscmdr.y].klingons += 1
-    if game.ishere:
-	# SC has scooted, Remove him from current quadrant 
-	game.iscate=False
-	game.isatb=0
-	game.ishere = False
-	game.ientesc = False
-	unschedule(FSCDBAS)
-	for enemy in game.enemies:
-	    if enemy.type == IHS:
-		break
-	enemy.move(None)
-	game.klhere -= 1
-	if game.condition != &quot;docked&quot;:
-	    newcnd()
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # check for a helpful planet 
-    for i in range(game.inplan):
-	if game.state.planets[i].w == game.state.kscmdr and \
-	    game.state.planets[i].crystals == &quot;present&quot;:
-	    # destroy the planet 
-	    game.state.planets[i].pclass = &quot;destroyed&quot;
-	    game.state.galaxy[game.state.kscmdr.x][game.state.kscmdr.y].planet = None
-	    if communicating():
-		announce()
-		prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
-		proutn(_(&quot;   a planet in Quadrant %s has been destroyed&quot;) % game.state.kscmdr)
-		prout(_(&quot;   by the Super-commander.\&quot;&quot;))
-	    break
-    return False; # looks good! 
-			
-def supercommander():
-    # move the Super Commander 
-    iq = coord(); sc = coord(); ibq = coord(); idelta = coord()
-    basetbl = []
-    if idebug:
-	prout(&quot;== SUPERCOMMANDER&quot;)
-    # Decide on being active or passive 
-    avoid = ((game.incom - game.state.remcom + game.inkling - game.state.remkl)/(game.state.date+0.01-game.indate) &lt; 0.1*game.skill*(game.skill+1.0) or \
-	    (game.state.date-game.indate) &lt; 3.0)
-    if not game.iscate and avoid:
-	# compute move away from Enterprise 
-	idelta = game.state.kscmdr-game.quadrant
-	if math.sqrt(idelta.x*idelta.x+idelta.y*idelta.y) &gt; 2.0:
-	    # circulate in space 
-	    idelta.x = game.state.kscmdr.y-game.quadrant.y
-	    idelta.y = game.quadrant.x-game.state.kscmdr.x
-    else:
-	# compute distances to starbases 
-	if game.state.rembase &lt;= 0:
-	    # nothing left to do 
-	    unschedule(FSCMOVE)
-	    return
-	sc = game.state.kscmdr
-	for i in range(game.state.rembase):
-	    basetbl.append((i, distance(game.state.baseq[i], sc)))
-	if game.state.rembase &gt; 1:
-            basetbl.sort(lambda x, y: cmp(x[1]. y[1]))
-	# look for nearest base without a commander, no Enterprise, and
-        # without too many Klingons, and not already under attack. 
-	ifindit = iwhichb = 0
-	for i2 in range(game.state.rembase):
-	    i = basetbl[i2][0];	# bug in original had it not finding nearest
-	    ibq = game.state.baseq[i]
-	    if ibq == game.quadrant or ibq == game.battle or \
-		game.state.galaxy[ibq.x][ibq.y].supernova or \
-		game.state.galaxy[ibq.x][ibq.y].klingons &gt; MAXKLQUAD-1:
-		continue
-	    # if there is a commander, and no other base is appropriate,
-	    #   we will take the one with the commander
-	    for j in range(game.state.remcom):
-		if ibq == game.state.kcmdr[j] and ifindit!= 2:
-		    ifindit = 2
-		    iwhichb = i
-		    break
-	    if j &gt; game.state.remcom: # no commander -- use this one 
-		ifindit = 1
-		iwhichb = i
-		break
-	if ifindit==0:
-	    return # Nothing suitable -- wait until next time
-	ibq = game.state.baseq[iwhichb]
-	# decide how to move toward base 
-	idelta = ibq - game.state.kscmdr
-    # Maximum movement is 1 quadrant in either or both axes 
-    idelta = idelta.sgn()
-    # try moving in both x and y directions
-    # there was what looked like a bug in the Almy C code here,
-    # but it might be this translation is just wrong.
-    iq = game.state.kscmdr + idelta
-    if movescom(iq, avoid):
-	# failed -- try some other maneuvers 
-	if idelta.x==0 or idelta.y==0:
-	    # attempt angle move 
-	    if idelta.x != 0:
-		iq.y = game.state.kscmdr.y + 1
-		if movescom(iq, avoid):
-		    iq.y = game.state.kscmdr.y - 1
-		    movescom(iq, avoid)
-	    else:
-		iq.x = game.state.kscmdr.x + 1
-		if movescom(iq, avoid):
-		    iq.x = game.state.kscmdr.x - 1
-		    movescom(iq, avoid)
-	else:
-	    # try moving just in x or y 
-	    iq.y = game.state.kscmdr.y
-	    if movescom(iq, avoid):
-		iq.y = game.state.kscmdr.y + idelta.y
-		iq.x = game.state.kscmdr.x
-		movescom(iq, avoid)
-    # check for a base 
-    if game.state.rembase == 0:
-	unschedule(FSCMOVE)
-    else:
-	for i in range(game.state.rembase):
-	    ibq = game.state.baseq[i]
-	    if ibq == game.state.kscmdr and game.state.kscmdr == game.battle:
-		# attack the base 
-		if avoid:
-		    return # no, don't attack base! 
-		game.iseenit = False
-		game.isatb = 1
-		schedule(FSCDBAS, randreal(1.0, 3.0))
-		if is_scheduled(FCDBAS):
-		    postpone(FSCDBAS, scheduled(FCDBAS)-game.state.date)
-		if not communicating():
-		    return # no warning 
-		game.iseenit = True
-		announce()
-		prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) \
-                      % game.state.kscmdr)
-		prout(_(&quot;   reports that it is under attack from the Klingon Super-commander.&quot;))
-		proutn(_(&quot;   It can survive until stardate %d.\&quot;&quot;) \
-                       % int(scheduled(FSCDBAS)))
-		if not game.resting:
-		    return
-		prout(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
-		if ja() == False:
-		    return
-		game.resting = False
-		game.optime = 0.0; # actually finished 
-		return
-    # Check for intelligence report 
-    if not idebug and \
-	(withprob(0.8) or \
-	 (not communicating()) or \
-	 not game.state.galaxy[game.state.kscmdr.x][game.state.kscmdr.y].charted):
-	return
-    announce()
-    prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
-    proutn(_(&quot;   the Super-commander is in Quadrant %s,&quot;) % game.state.kscmdr)
-    return
-
-def movetholian():
-    # move the Tholian 
-    if not game.tholian or game.justin:
-	return
-    if game.tholian.kloc.x == 0 and game.tholian.kloc.y == 0:
-	idx = 0; idy = QUADSIZE-1
-    elif game.tholian.kloc.x == 0 and game.tholian.kloc.y == QUADSIZE-1:
-	idx = QUADSIZE-1; idy = QUADSIZE-1
-    elif game.tholian.kloc.x == QUADSIZE-1 and game.tholian.kloc.y == QUADSIZE-1:
-	idx = QUADSIZE-1; idy = 0
-    elif game.tholian.kloc.x == QUADSIZE-1 and game.tholian.kloc.y == 0:
-	idx = 0; idy = 0
-    else:
-	# something is wrong! 
-	game.tholian = None
-	return
-    # do nothing if we are blocked 
-    if game.quad[idx][idy]!= IHDOT and game.quad[idx][idy]!= IHWEB:
-	return
-    game.quad[game.tholian.kloc.x][game.tholian.kloc.y] = IHWEB
-    if game.tholian.kloc.x != idx:
-	# move in x axis 
-	im = math.fabs(idx - game.tholian.kloc.x)*1.0/(idx - game.tholian.kloc.x)
-	while game.tholian.kloc.x != idx:
-	    game.tholian.kloc.x += im
-	    if game.quad[game.tholian.kloc.x][game.tholian.kloc.y]==IHDOT:
-		game.quad[game.tholian.kloc.x][game.tholian.kloc.y] = IHWEB
-    elif game.tholian.kloc.y != idy:
-	# move in y axis 
-	im = math.fabs(idy - game.tholian.kloc.y)*1.0/(idy - game.tholian.kloc.y)
-	while game.tholian.kloc.y != idy:
-	    game.tholian.kloc.y += im
-	    if game.quad[game.tholian.kloc.x][game.tholian.kloc.y]==IHDOT:
-		game.quad[game.tholian.kloc.x][game.tholian.kloc.y] = IHWEB
-    game.quad[game.tholian.kloc.x][game.tholian.kloc.y] = IHT
-    #game.enemies[-1].kloc = game.tholian	#FIXME
-    # check to see if all holes plugged 
-    for i in range(QUADSIZE):
-	if game.quad[0][i]!=IHWEB and game.quad[0][i]!=IHT:
-	    return
-	if game.quad[QUADSIZE][i]!=IHWEB and game.quad[QUADSIZE][i]!=IHT:
-	    return
-	if game.quad[i][0]!=IHWEB and game.quad[i][0]!=IHT:
-	    return
-	if game.quad[i][QUADSIZE]!=IHWEB and game.quad[i][QUADSIZE]!=IHT:
-	    return
-    # All plugged up -- Tholian splits 
-    game.quad[game.tholian.kloc.x][game.tholian.kloc.y]=IHWEB
-    dropin(IHBLANK)
-    crmena(True, IHT, &quot;sector&quot;, game.tholian)
-    prout(_(&quot; completes web.&quot;))
-    game.tholian.move(None)
-    return
-
-# Code from battle.c begins here
-
-def doshield(shraise):
-    # change shield status 
-    action = &quot;NONE&quot;
-    game.ididit = False
-    if shraise:
-	action = &quot;SHUP&quot;
-    else:
-	key = scan()
-	if key == IHALPHA:
-	    if isit(&quot;transfer&quot;):
-		action = &quot;NRG&quot;
-	    else:
-		chew()
-		if damaged(DSHIELD):
-		    prout(_(&quot;Shields damaged and down.&quot;))
-		    return
-		if isit(&quot;up&quot;):
-		    action = &quot;SHUP&quot;
-		elif isit(&quot;down&quot;):
-		    action = &quot;SHDN&quot;
-	if action==&quot;NONE&quot;:
-	    proutn(_(&quot;Do you wish to change shield energy? &quot;))
-	    if ja() == True:
-		proutn(_(&quot;Energy to transfer to shields- &quot;))
-		action = &quot;NRG&quot;
-	    elif damaged(DSHIELD):
-		prout(_(&quot;Shields damaged and down.&quot;))
-		return
-	    elif game.shldup:
-		proutn(_(&quot;Shields are up. Do you want them down? &quot;))
-		if ja() == True:
-		    action = &quot;SHDN&quot;
-		else:
-		    chew()
-		    return
-	    else:
-		proutn(_(&quot;Shields are down. Do you want them up? &quot;))
-		if ja() == True:
-		    action = &quot;SHUP&quot;
-		else:
-		    chew()
-		    return    
-    if action == &quot;SHUP&quot;: # raise shields 
-	if game.shldup:
-	    prout(_(&quot;Shields already up.&quot;))
-	    return
-	game.shldup = True
-	game.shldchg = True
-	if game.condition != &quot;docked&quot;:
-	    game.energy -= 50.0
-	prout(_(&quot;Shields raised.&quot;))
-	if game.energy &lt;= 0:
-	    skip(1)
-	    prout(_(&quot;Shields raising uses up last of energy.&quot;))
-	    finish(FNRG)
-	    return
-	game.ididit=True
-	return
-    elif action == &quot;SHDN&quot;:
-	if not game.shldup:
-	    prout(_(&quot;Shields already down.&quot;))
-	    return
-	game.shldup=False
-	game.shldchg=True
-	prout(_(&quot;Shields lowered.&quot;))
-	game.ididit = True
-	return
-    elif action == &quot;NRG&quot;:
-	while scan() != IHREAL:
-	    chew()
-	    proutn(_(&quot;Energy to transfer to shields- &quot;))
-	chew()
-	if aaitem == 0:
-	    return
-	if aaitem &gt; game.energy:
-	    prout(_(&quot;Insufficient ship energy.&quot;))
-	    return
-	game.ididit = True
-	if game.shield+aaitem &gt;= game.inshld:
-	    prout(_(&quot;Shield energy maximized.&quot;))
-	    if game.shield+aaitem &gt; game.inshld:
-		prout(_(&quot;Excess energy requested returned to ship energy&quot;))
-	    game.energy -= game.inshld-game.shield
-	    game.shield = game.inshld
-	    return
-	if aaitem &lt; 0.0 and game.energy-aaitem &gt; game.inenrg:
-	    # Prevent shield drain loophole 
-	    skip(1)
-	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Scott here. Power circuit problem, Captain.&quot;))
-	    prout(_(&quot;  I can't drain the shields.&quot;))
-	    game.ididit = False
-	    return
-	if game.shield+aaitem &lt; 0:
-	    prout(_(&quot;All shield energy transferred to ship.&quot;))
-	    game.energy += game.shield
-	    game.shield = 0.0
-	    return
-	proutn(_(&quot;Scotty- \&quot;&quot;))
-	if aaitem &gt; 0:
-	    prout(_(&quot;Transferring energy to shields.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Draining energy from shields.\&quot;&quot;))
-	game.shield += aaitem
-	game.energy -= aaitem
-	return
-
-def randdevice():
-    # choose a device to damage, at random. 
-    #
-    # Quoth Eric Allman in the code of BSD-Trek:
-    # &quot;Under certain conditions you can get a critical hit.  This
-    # sort of hit damages devices.  The probability that a given
-    # device is damaged depends on the device.  Well protected
-    # devices (such as the computer, which is in the core of the
-    # ship and has considerable redundancy) almost never get
-    # damaged, whereas devices which are exposed (such as the
-    # warp engines) or which are particularly delicate (such as
-    # the transporter) have a much higher probability of being
-    # damaged.&quot;
-    # 
-    # This is one place where OPTION_PLAIN does not restore the
-    # original behavior, which was equiprobable damage across
-    # all devices.  If we wanted that, we'd return randrange(NDEVICES)
-    # and have done with it.  Also, in the original game, DNAVYS
-    # and DCOMPTR were the same device. 
-    # 
-    # Instead, we use a table of weights similar to the one from BSD Trek.
-    # BSD doesn't have the shuttle, shield controller, death ray, or probes. 
-    # We don't have a cloaking device.  The shuttle got the allocation
-    # for the cloaking device, then we shaved a half-percent off
-    # everything to have some weight to give DSHCTRL/DDRAY/DDSP.
-    # 
-    weights = (
-	105,	# DSRSENS: short range scanners	10.5% 
-	105,	# DLRSENS: long range scanners		10.5% 
-	120,	# DPHASER: phasers			12.0% 
-	120,	# DPHOTON: photon torpedoes		12.0% 
-	25,	# DLIFSUP: life support		 2.5% 
-	65,	# DWARPEN: warp drive			 6.5% 
-	70,	# DIMPULS: impulse engines		 6.5% 
-	145,	# DSHIELD: deflector shields		14.5% 
-	30,	# DRADIO:  subspace radio		 3.0% 
-	45,	# DSHUTTL: shuttle			 4.5% 
-	15,	# DCOMPTR: computer			 1.5% 
-	20,	# NAVCOMP: navigation system		 2.0% 
-	75,	# DTRANSP: transporter			 7.5% 
-	20,	# DSHCTRL: high-speed shield controller 2.0% 
-	10,	# DDRAY: death ray			 1.0% 
-	30,	# DDSP: deep-space probes		 3.0% 
-    )
-    idx = randrange(1000)	# weights must sum to 1000 
-    sum = 0
-    for (i, w) in enumerate(weights):
-	sum += w
-	if idx &lt; sum:
-	    return i
-    return None;	# we should never get here
-
-def collision(rammed, enemy):
-    # collision handling
-    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-    skip(1)
-    prout(_(&quot;***COLLISION IMMINENT.&quot;))
-    skip(2)
-    proutn(&quot;***&quot;)
-    crmshp()
-    hardness = {IHR:1.5, IHC:2.0, IHS:2.5, IHT:0.5, IHQUEST:4.0}.get(enemy.type, 1.0)
-    if rammed:
-        proutn(_(&quot; rammed by &quot;))
-    else:
-        proutn(_(&quot; rams &quot;))
-    crmena(False, enemy.type, &quot;sector&quot;, enemy.kloc)
-    if rammed:
-	proutn(_(&quot; (original position)&quot;))
-    skip(1)
-    deadkl(enemy.kloc, enemy.type, game.sector)
-    proutn(&quot;***&quot;)
-    crmshp()
-    prout(_(&quot; heavily damaged.&quot;))
-    icas = randrange(10, 30)
-    prout(_(&quot;***Sickbay reports %d casualties&quot;), icas)
-    game.casual += icas
-    game.state.crew -= icas
-    #
-    # In the pre-SST2K version, all devices got equiprobably damaged,
-    # which was silly.  Instead, pick up to half the devices at
-    # random according to our weighting table,
-    # 
-    ncrits = randrange(NDEVICES/2)
-    for m in range(ncrits):
-	dev = randdevice()
-	if game.damage[dev] &lt; 0:
-	    continue
-	extradm = (10.0*hardness*randreal()+1.0)*game.damfac
-	# Damage for at least time of travel! 
-	game.damage[dev] += game.optime + extradm
-    game.shldup = False
-    prout(_(&quot;***Shields are down.&quot;))
-    if game.state.remkl + game.state.remcom + game.state.nscrem:
-	announce()
-	damagereport()
-    else:
-	finish(FWON)
-    return
-
-def torpedo(course, dispersion, origin, number, nburst):
-    # let a photon torpedo fly 
-    iquad = 0
-    shoved = False
-    ac = course + 0.25*dispersion
-    angle = (15.0-ac)*0.5235988
-    bullseye = (15.0 - course)*0.5235988
-    deltax = -math.sin(angle);
-    deltay = math.cos(angle);
-    x = origin.x; y = origin.y
-    w = coord(); jw = coord()
-    w.x = w.y = jw.x = jw.y = 0
-    bigger = max(math.fabs(deltax), math.fabs(deltay))
-    deltax /= bigger
-    deltay /= bigger
-    if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
-	setwnd(srscan_window)
-    else: 
-	setwnd(message_window)
-    # Loop to move a single torpedo 
-    for step in range(1, 15+1):
-	x += deltax
-	w.x = int(x + 0.5)
-	y += deltay
-	w.y = int(y + 0.5)
-	if not VALID_SECTOR(w.x, w.y):
-	    break
-	iquad=game.quad[w.x][w.y]
-	tracktorpedo(w, step, number, nburst, iquad)
-	if iquad==IHDOT:
-	    continue
-	# hit something 
-	setwnd(message_window)
-	if damaged(DSRSENS) and not game.condition==&quot;docked&quot;:
-	    skip(1);	# start new line after text track 
-	if iquad in (IHE, IHF): # Hit our ship 
-	    skip(1)
-	    proutn(_(&quot;Torpedo hits &quot;))
-	    crmshp()
-	    prout(&quot;.&quot;)
-	    hit = 700.0 + randreal(100) - \
-		1000.0 * distance(w, origin) * math.fabs(math.sin(bullseye-angle))
-	    newcnd(); # we're blown out of dock 
-	    # We may be displaced. 
-	    if game.landed or game.condition==&quot;docked&quot;:
-		return hit # Cheat if on a planet 
-	    ang = angle + 2.5*(randreal()-0.5)
-	    temp = math.fabs(math.sin(ang))
-	    if math.fabs(math.cos(ang)) &gt; temp:
-		temp = math.fabs(math.cos(ang))
-	    xx = -math.sin(ang)/temp
-	    yy = math.cos(ang)/temp
-	    jw.x = int(w.x+xx+0.5)
-	    jw.y = int(w.y+yy+0.5)
-	    if not VALID_SECTOR(jw.x, jw.y):
-		return hit
-	    if game.quad[jw.x][jw.y]==IHBLANK:
-		finish(FHOLE)
-		return hit
-	    if game.quad[jw.x][jw.y]!=IHDOT:
-		# can't move into object 
-		return hit
-	    game.sector = jw
-	    crmshp()
-	    shoved = True
-	elif iquad in (IHC, IHS): # Hit a commander 
-	    if withprob(0.05):
-		crmena(True, iquad, &quot;sector&quot;, w)
-		prout(_(&quot; uses anti-photon device;&quot;))
-		prout(_(&quot;   torpedo neutralized.&quot;))
-		return None
-	elif iquad in (IHR, IHK): # Hit a regular enemy 
-	    # find the enemy 
-            for enemy in game.enemies:
-		if w == game.enemies[ll].kloc:
-		    break
-	    kp = math.fabs(e.kpower)
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * distance(w, origin) * math.fabs(math.sin(bullseye-angle))
-	    h1 = math.fabs(h1)
-	    if kp &lt; h1:
-		h1 = kp
-            if enemy.kpower &lt; 0:
-                enemy.kpower -= -h1
-            else:
-                enemy.kpower -= h1
-	    if enemy.kpower == 0:
-		deadkl(w, iquad, w)
-		return None
-	    crmena(True, iquad, &quot;sector&quot;, w)
-	    # If enemy damaged but not destroyed, try to displace 
-	    ang = angle + 2.5*(randreal()-0.5)
-	    temp = math.fabs(math.sin(ang))
-	    if math.fabs(math.cos(ang)) &gt; temp:
-		temp = math.fabs(math.cos(ang))
-	    xx = -math.sin(ang)/temp
-	    yy = math.cos(ang)/temp
-	    jw.x = int(w.x+xx+0.5)
-	    jw.y = int(w.y+yy+0.5)
-	    if not VALID_SECTOR(jw.x, jw.y):
-		prout(_(&quot; damaged but not destroyed.&quot;))
-		return
-	    if game.quad[jw.x][jw.y]==IHBLANK:
-		prout(_(&quot; buffeted into black hole.&quot;))
-		deadkl(w, iquad, jw)
-		return None
-	    if game.quad[jw.x][jw.y]!=IHDOT:
-		# can't move into object 
-		prout(_(&quot; damaged but not destroyed.&quot;))
-		return None
-	    proutn(_(&quot; damaged--&quot;))
-	    enemy.kloc = jw
-	    shoved = True
-	    break
-	elif iquad == IHB: # Hit a base 
-	    skip(1)
-	    prout(_(&quot;***STARBASE DESTROYED..&quot;))
-	    for ll in range(game.state.rembase):
-		if game.state.baseq[ll] == game.quadrant:
-		    game.state.baseq[ll]=game.state.baseq[game.state.rembase]
-		    break
-	    game.quad[w.x][w.y]=IHDOT
-	    game.state.rembase -= 1
-	    game.base.x=game.base.y=0
-	    game.state.galaxy[game.quadrant.x][game.quadrant.y].starbase -= 1
-	    game.state.chart[game.quadrant.x][game.quadrant.y].starbase -= 1
-	    game.state.basekl += 1
-	    newcnd()
-	    return None
-	elif iquad == IHP: # Hit a planet 
-	    crmena(True, iquad, &quot;sector&quot;, w)
-	    prout(_(&quot; destroyed.&quot;))
-	    game.state.nplankl += 1
-	    game.state.galaxy[game.quadrant.x][game.quadrant.y].planet = None
-	    game.iplnet.pclass = &quot;destroyed&quot;
-	    game.iplnet = None
-	    invalidate(game.plnet)
-	    game.quad[w.x][w.y] = IHDOT
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    return None
-	elif iquad == IHW: # Hit an inhabited world -- very bad! 
-	    crmena(True, iquad, &quot;sector&quot;, w)
-	    prout(_(&quot; destroyed.&quot;))
-	    game.state.nworldkl += 1
-	    game.state.galaxy[game.quadrant.x][game.quadrant.y].planet = None
-	    game.iplnet.pclass = &quot;destroyed&quot;
-	    game.iplnet = None
-	    invalidate(game.plnet)
-	    game.quad[w.x][w.y] = IHDOT
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    prout(_(&quot;You have just destroyed an inhabited planet.&quot;))
-	    prout(_(&quot;Celebratory rallies are being held on the Klingon homeworld.&quot;))
-	    return None
-	elif iquad == IHSTAR: # Hit a star 
-	    if withprob(0.9):
-		nova(w)
-            else:
-                crmena(True, IHSTAR, &quot;sector&quot;, w)
-                prout(_(&quot; unaffected by photon blast.&quot;))
-	    return None
-	elif iquad == IHQUEST: # Hit a thingy 
-	    if not (game.options &amp; OPTION_THINGY) or withprob(0.3):
-		skip(1)
-		prouts(_(&quot;AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!&quot;))
-		skip(1)
-		prouts(_(&quot;    HACK!     HACK!    HACK!        *CHOKE!*  &quot;))
-		skip(1)
-		proutn(_(&quot;Mr. Spock-&quot;))
-		prouts(_(&quot;  \&quot;Fascinating!\&quot;&quot;))
-		skip(1)
-		deadkl(w, iquad, w)
-	    else:
-		#
-		# Stas Sergeev added the possibility that
-		# you can shove the Thingy and piss it off.
-		# It then becomes an enemy and may fire at you.
-		#
-		thing.angry = True
-		shoved = True
-	    return None
-	elif iquad == IHBLANK: # Black hole 
-	    skip(1)
-	    crmena(True, IHBLANK, &quot;sector&quot;, w)
-	    prout(_(&quot; swallows torpedo.&quot;))
-	    return None
-	elif iquad == IHWEB: # hit the web 
-	    skip(1)
-	    prout(_(&quot;***Torpedo absorbed by Tholian web.&quot;))
-	    return None
-	elif iquad == IHT:  # Hit a Tholian 
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * distance(w, origin) * math.fabs(math.sin(bullseye-angle))
-	    h1 = math.fabs(h1)
-	    if h1 &gt;= 600:
-		game.quad[w.x][w.y] = IHDOT
-		deadkl(w, iquad, w)
-		game.tholian = None
-		return None
-	    skip(1)
-	    crmena(True, IHT, &quot;sector&quot;, w)
-	    if withprob(0.05):
-		prout(_(&quot; survives photon blast.&quot;))
-		return None
-	    prout(_(&quot; disappears.&quot;))
-	    game.tholian.move(None)
-	    game.quad[w.x][w.y] = IHWEB
-	    dropin(IHBLANK)
-	    return None
-        else: # Problem!
-	    skip(1)
-	    proutn(&quot;Don't know how to handle torpedo collision with &quot;)
-	    crmena(True, iquad, &quot;sector&quot;, w)
-	    skip(1)
-	    return None
-	break
-    if curwnd!=message_window:
-	setwnd(message_window)
-    if shoved:
-	game.quad[w.x][w.y]=IHDOT
-	game.quad[jw.x][jw.y]=iquad
-	prout(_(&quot; displaced by blast to Sector %s &quot;) % jw)
-	for ll in range(len(game.enemies)):
-	    game.enemies[ll].kdist = game.enemies[ll].kavgd = distance(game.sector,game.enemies[ll].kloc)
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-	return None
-    skip(1)
-    prout(_(&quot;Torpedo missed.&quot;))
-    return None;
-
-def fry(hit):
-    # critical-hit resolution 
-    if hit &lt; (275.0-25.0*game.skill)*randreal(1.0, 1.5):
-	return
-    ncrit = int(1.0 + hit/(500.0+randreal(100)))
-    proutn(_(&quot;***CRITICAL HIT--&quot;))
-    # Select devices and cause damage
-    cdam = []
-    for loop1 in range(ncrit):
-        while True:
-	    j = randdevice()
-	    # Cheat to prevent shuttle damage unless on ship 
-            if not (game.damage[j]&lt;0.0 or (j==DSHUTTL and game.iscraft != &quot;onship&quot;)):
-                break
-	cdam.append(j)
-	extradm = (hit*game.damfac)/(ncrit*randreal(75, 100))
-	game.damage[j] += extradm
-    skipcount = 0
-    for (i, j) in enumerate(cdam):
-	proutn(device[j])
-        if skipcount % 3 == 2 and i &lt; len(cdam)-1:
-            skip()
-        skipcount += 1
-        if i &lt; len(cdam)-1:
-            proutn(_(&quot; and &quot;))
-    prout(_(&quot; damaged.&quot;))
-    if damaged(DSHIELD) and game.shldup:
-	prout(_(&quot;***Shields knocked down.&quot;))
-	game.shldup=False
-
-def attack(torps_ok):
-    # bad guy attacks us 
-    # torps_ok == False forces use of phasers in an attack 
-    attempt = False; ihurt = False;
-    hitmax=0.0; hittot=0.0; chgfac=1.0
-    where = &quot;neither&quot;
-    # game could be over at this point, check 
-    if game.alldone:
-	return
-    if idebug:
-	prout(&quot;=== ATTACK!&quot;)
-    # Tholian gets to move before attacking 
-    if game.tholian:
-	movetholian()
-    # if you have just entered the RNZ, you'll get a warning 
-    if game.neutz: # The one chance not to be attacked 
-	game.neutz = False
-	return
-    # commanders get a chance to tac-move towards you 
-    if (((game.comhere or game.ishere) and not game.justin) or game.skill == SKILL_EMERITUS) and torps_ok:
-	moveklings()
-    # if no enemies remain after movement, we're done 
-    if len(game.enemies)==0 or (len(game.enemies)==1 and thing == game.quadrant and not thing.angry):
-	return
-    # set up partial hits if attack happens during shield status change 
-    pfac = 1.0/game.inshld
-    if game.shldchg:
-	chgfac = 0.25 + randreal(0.5)
-    skip(1)
-    # message verbosity control 
-    if game.skill &lt;= SKILL_FAIR:
-	where = &quot;sector&quot;
-    for enemy in game.enemies:
-	if enemy.kpower &lt; 0:
-	    continue;	# too weak to attack 
-	# compute hit strength and diminish shield power 
-	r = randreal()
-	# Increase chance of photon torpedos if docked or enemy energy is low 
-	if game.condition == &quot;docked&quot;:
-	    r *= 0.25
-	if enemy.kpower &lt; 500:
-	    r *= 0.25; 
-	if enemy.type==IHT or (enemy.type==IHQUEST and not thing.angry):
-	    continue
-	# different enemies have different probabilities of throwing a torp 
-	usephasers = not torps_ok or \
-	    (enemy.type == IHK and r &gt; 0.0005) or \
-	    (enemy.type==IHC and r &gt; 0.015) or \
-	    (enemy.type==IHR and r &gt; 0.3) or \
-	    (enemy.type==IHS and r &gt; 0.07) or \
-	    (enemy.type==IHQUEST and r &gt; 0.05)
-	if usephasers:	    # Enemy uses phasers 
-	    if game.condition == &quot;docked&quot;:
-		continue; # Don't waste the effort! 
-	    attempt = True; # Attempt to attack 
-	    dustfac = 0.8 + randreal(0.5)
-	    hit = enemy.kpower*math.pow(dustfac,enemy.kavgd)
-	    enemy.kpower *= 0.75
-	else: # Enemy uses photon torpedo 
-	    course = 1.90985*math.atan2(game.sector.y-enemy.kloc.y, enemy.kloc.x-game.sector.x)
-	    hit = 0
-	    proutn(_(&quot;***TORPEDO INCOMING&quot;))
-	    if not damaged(DSRSENS):
-		proutn(_(&quot; From &quot;))
-		crmena(False, enemy.type, where, enemy.kloc)
-	    attempt = True
-	    prout(&quot;  &quot;)
-	    dispersion = (randreal()+randreal())*0.5 - 0.5
-	    dispersion += 0.002*enemy.kpower*dispersion
-	    hit = torpedo(course, dispersion, origin=enemy.kloc, number=1, nburst=1)
-	    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0:
-		finish(FWON); # Klingons did themselves in! 
-	    if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova or game.alldone:
-		return # Supernova or finished 
-	    if hit == None:
-		continue
-	# incoming phaser or torpedo, shields may dissipate it 
-	if game.shldup or game.shldchg or game.condition==&quot;docked&quot;:
-	    # shields will take hits 
-	    propor = pfac * game.shield
-            if game.condition ==&quot;docked&quot;:
-                propr *= 2.1
-	    if propor &lt; 0.1:
-		propor = 0.1
-	    hitsh = propor*chgfac*hit+1.0
-	    absorb = 0.8*hitsh
-	    if absorb &gt; game.shield:
-		absorb = game.shield
-	    game.shield -= absorb
-	    hit -= hitsh
-	    # taking a hit blasts us out of a starbase dock 
-	    if game.condition == &quot;docked&quot;:
-		dock(False)
-	    # but the shields may take care of it 
-	    if propor &gt; 0.1 and hit &lt; 0.005*game.energy:
-		continue
-	# hit from this opponent got through shields, so take damage 
-	ihurt = True
-	proutn(_(&quot;%d unit hit&quot;) % int(hit))
-	if (damaged(DSRSENS) and usephasers) or game.skill&lt;=SKILL_FAIR:
-	    proutn(_(&quot; on the &quot;))
-	    crmshp()
-	if not damaged(DSRSENS) and usephasers:
-	    proutn(_(&quot; from &quot;))
-	    crmena(False, enemy.type, where, enemy.kloc)
-	skip(1)
-	# Decide if hit is critical 
-	if hit &gt; hitmax:
-	    hitmax = hit
-	hittot += hit
-	fry(hit)
-	game.energy -= hit
-    if game.energy &lt;= 0:
-	# Returning home upon your shield, not with it... 
-	finish(FBATTLE)
-	return
-    if not attempt and game.condition == &quot;docked&quot;:
-	prout(_(&quot;***Enemies decide against attacking your ship.&quot;))
-    percent = 100.0*pfac*game.shield+0.5
-    if not ihurt:
-	# Shields fully protect ship 
-	proutn(_(&quot;Enemy attack reduces shield strength to &quot;))
-    else:
-	# Print message if starship suffered hit(s) 
-	skip(1)
-	proutn(_(&quot;Energy left %2d    shields &quot;) % int(game.energy))
-	if game.shldup:
-	    proutn(_(&quot;up &quot;))
-	elif not damaged(DSHIELD):
-	    proutn(_(&quot;down &quot;))
-	else:
-	    proutn(_(&quot;damaged, &quot;))
-    prout(_(&quot;%d%%,   torpedoes left %d&quot;) % (percent, game.torps))
-    # Check if anyone was hurt 
-    if hitmax &gt;= 200 or hittot &gt;= 500:
-	icas = randrange(int(hittot * 0.015))
-	if icas &gt;= 2:
-	    skip(1)
-	    prout(_(&quot;Mc Coy-  \&quot;Sickbay to bridge.  We suffered %d casualties&quot;) % icas)
-	    prout(_(&quot;   in that last attack.\&quot;&quot;))
-	    game.casual += icas
-	    game.state.crew -= icas
-    # After attack, reset average distance to enemies 
-    for enemy in game.enemies:
-	enemy.kavgd = enemy.kdist
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    return
-		
-def deadkl(w, type, mv):
-    # kill a Klingon, Tholian, Romulan, or Thingy 
-    # Added mv to allow enemy to &quot;move&quot; before dying 
-    crmena(True, type, &quot;sector&quot;, mv)
-    # Decide what kind of enemy it is and update appropriately 
-    if type == IHR:
-        # chalk up a Romulan 
-        game.state.galaxy[game.quadrant.x][game.quadrant.y].romulans -= 1
-        game.irhere -= 1
-        game.state.nromrem -= 1
-    elif type == IHT:
-        # Killed a Tholian 
-        game.tholian = None
-    elif type == IHQUEST:
-        # Killed a Thingy
-        global thing
-        thing = None
-    else:
-        # Some type of a Klingon 
-        game.state.galaxy[game.quadrant.x][game.quadrant.y].klingons -= 1
-        game.klhere -= 1
-        if type == IHC:
-            game.comhere = False
-            for i in range(game.state.remcom):
-                if game.state.kcmdr[i] == game.quadrant:
-                    break
-            game.state.kcmdr[i] = game.state.kcmdr[game.state.remcom]
-            game.state.kcmdr[game.state.remcom].x = 0
-            game.state.kcmdr[game.state.remcom].y = 0
-            game.state.remcom -= 1
-            unschedule(FTBEAM)
-            if game.state.remcom != 0:
-                schedule(FTBEAM, expran(1.0*game.incom/game.state.remcom))
-            if is_scheduled(FCDBAS) and game.battle == game.quadrant:
-                unschedule(FCDBAS)    
-        elif type ==  IHK:
-            game.state.remkl -= 1
-        elif type ==  IHS:
-            game.state.nscrem -= 1
-            game.ishere = False
-            game.state.kscmdr.x = game.state.kscmdr.y = game.isatb = 0
-            game.iscate = False
-            unschedule(FSCMOVE)
-            unschedule(FSCDBAS)
-    # For each kind of enemy, finish message to player 
-    prout(_(&quot; destroyed.&quot;))
-    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0:
-	return
-    game.recompute()
-    # Remove enemy ship from arrays describing local conditions
-    for e in game.enemies:
-	if e.kloc == w:
-            e.move(None)
-	    break
-    return
-
-def targetcheck(w):
-    # Return None if target is invalid 
-    if not VALID_SECTOR(w.x, w.y):
-	huh()
-	return None
-    deltx = 0.1*(w.y - game.sector.y)
-    delty = 0.1*(w.x - game.sector.x)
-    if deltx==0 and delty== 0:
-	skip(1)
-	prout(_(&quot;Spock-  \&quot;Bridge to sickbay.  Dr. McCoy,&quot;))
-	prout(_(&quot;  I recommend an immediate review of&quot;))
-	prout(_(&quot;  the Captain's psychological profile.\&quot;&quot;))
-	chew()
-	return None
-    return 1.90985932*math.atan2(deltx, delty)
-
-def photon():
-    # launch photon torpedo
-    course = [0.0] * MAXBURST
-    game.ididit = False
-    if damaged(DPHOTON):
-	prout(_(&quot;Photon tubes damaged.&quot;))
-	chew()
-	return
-    if game.torps == 0:
-	prout(_(&quot;No torpedoes left.&quot;))
-	chew()
-	return
-    key = scan()
-    while True:
-	if key == IHALPHA:
-	    huh()
-	    return
-	elif key == IHEOL:
-	    prout(_(&quot;%d torpedoes left.&quot;) % game.torps)
-            chew()
-	    proutn(_(&quot;Number of torpedoes to fire- &quot;))
-	    key = scan()
-	else: # key == IHREAL  {
-	    n = int(round(aaitem + 0.5))
-	    if n &lt;= 0: # abort command 
-		chew()
-		return
-	    if n &gt; MAXBURST:
-		chew()
-		prout(_(&quot;Maximum of %d torpedoes per burst.&quot;) % MAXBURST)
-		key = IHEOL
-		return
-	    if n &lt;= game.torps:
-		break
-	    chew()
-	    key = IHEOL
-    targ = []
-    for i in range(MAXBURST):
-        targ.append(coord())
-    for i in range(n):
-	key = scan()
-	if i==0 and key == IHEOL:
-	    break;	# we will try prompting 
-	if i==1 and key == IHEOL:
-	    # direct all torpedoes at one target 
-	    while i &lt;= n:
-		targ[i] = targ[0]
-		course[i] = course[0]
-		i += 1
-	    break
-	if key != IHREAL:
-	    huh()
-	    return
-	targ[i].x = aaitem
-	key = scan()
-	if key != IHREAL:
-	    huh()
-	    return
-	targ[i].y = aaitem
-	course[i] = targetcheck(targ[i])
-        if course[i] == None:
-	    return
-    chew()
-    if i == 1 and key == IHEOL:
-	# prompt for each one 
-	for i in range(n):
-	    proutn(_(&quot;Target sector for torpedo number %d- &quot;) % (i+1))
-	    key = scan()
-	    if key != IHREAL:
-		huh()
-		return
-	    targ[i].x = int(aaitem-0.5)
-	    key = scan()
-	    if key != IHREAL:
-		huh()
-		return
-	    targ[i].y = int(aaitem-0.5)
-	    chew()
-            course[i] = targetcheck(targ[i])
-            if course[i] == None:
-                return
-    game.ididit = True
-    # Loop for moving &lt;n&gt; torpedoes 
-    for i in range(n):
-	if game.condition != &quot;docked&quot;:
-	    game.torps -= 1
-	dispersion = (randreal()+randreal())*0.5 -0.5
-	if math.fabs(dispersion) &gt;= 0.47:
-	    # misfire! 
-	    dispersion *= randreal(1.2, 2.2)
-	    if n &gt; 0:
-		prouts(_(&quot;***TORPEDO NUMBER %d MISFIRES&quot;) % (i+1))
-	    else:
-		prouts(_(&quot;***TORPEDO MISFIRES.&quot;))
-	    skip(1)
-	    if i &lt; n:
-		prout(_(&quot;  Remainder of burst aborted.&quot;))
-	    if withprob(0.2):
-		prout(_(&quot;***Photon tubes damaged by misfire.&quot;))
-		game.damage[DPHOTON] = game.damfac * randreal(1.0, 3.0)
-	    break
-	if game.shldup or game.condition == &quot;docked&quot;:
-	    dispersion *= 1.0 + 0.0001*game.shield
-	torpedo(course[i], dispersion, origin=game.sector, number=i, nburst=n)
-	if game.alldone or game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-	    return
-    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0:
-	finish(FWON);
-
-def overheat(rpow):
-    # check for phasers overheating 
-    if rpow &gt; 1500:
-        checkburn = (rpow-1500.0)*0.00038
-        if withprob(checkburn):
-	    prout(_(&quot;Weapons officer Sulu-  \&quot;Phasers overheated, sir.\&quot;&quot;))
-	    game.damage[DPHASER] = game.damfac* randreal(1.0, 2.0) * (1.0+checkburn)
-
-def checkshctrl(rpow):
-    # check shield control 
-    skip(1)
-    if withprob(0.998):
-	prout(_(&quot;Shields lowered.&quot;))
-	return False
-    # Something bad has happened 
-    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-    skip(2)
-    hit = rpow*game.shield/game.inshld
-    game.energy -= rpow+hit*0.8
-    game.shield -= hit*0.2
-    if game.energy &lt;= 0.0:
-	prouts(_(&quot;Sulu-  \&quot;Captain! Shield malf***********************\&quot;&quot;))
-	skip(1)
-	stars()
-	finish(FPHASER)
-	return True
-    prouts(_(&quot;Sulu-  \&quot;Captain! Shield malfunction! Phaser fire contained!\&quot;&quot;))
-    skip(2)
-    prout(_(&quot;Lt. Uhura-  \&quot;Sir, all decks reporting damage.\&quot;&quot;))
-    icas = randrange(int(hit*0.012))
-    skip(1)
-    fry(0.8*hit)
-    if icas:
-	skip(1)
-	prout(_(&quot;McCoy to bridge- \&quot;Severe radiation burns, Jim.&quot;))
-	prout(_(&quot;  %d casualties so far.\&quot;&quot;) % icas)
-	game.casual += icas
-	game.state.crew -= icas
-    skip(1)
-    prout(_(&quot;Phaser energy dispersed by shields.&quot;))
-    prout(_(&quot;Enemy unaffected.&quot;))
-    overheat(rpow)
-    return True;
-
-def hittem(hits):
-    # register a phaser hit on Klingons and Romulans
-    nenhr2 = len(game.enemies); kk=0
-    w = coord()
-    skip(1)
-    for (k, wham) in enumerate(hits):
-	if wham==0:
-	    continue
-	dustfac = randreal(0.9, 1.0)
-	hit = wham*math.pow(dustfac,game.enemies[kk].kdist)
-	kpini = game.enemies[kk].kpower
-	kp = math.fabs(kpini)
-	if PHASEFAC*hit &lt; kp:
-	    kp = PHASEFAC*hit
-        if game.enemies[kk].kpower &lt; 0:
-            game.enemies[kk].kpower -= -kp
-        else:
-            game.enemies[kk].kpower -= kp
-	kpow = game.enemies[kk].kpower
-	w = game.enemies[kk].kloc
-	if hit &gt; 0.005:
-	    if not damaged(DSRSENS):
-		boom(w)
-	    proutn(_(&quot;%d unit hit on &quot;) % int(hit))
-	else:
-	    proutn(_(&quot;Very small hit on &quot;))
-	ienm = game.quad[w.x][w.y]
-	if ienm==IHQUEST:
-	    thing.angry = True
-	crmena(False, ienm, &quot;sector&quot;, w)
-	skip(1)
-	if kpow == 0:
-	    deadkl(w, ienm, w)
-	    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0:
-		finish(FWON);		
-	    if game.alldone:
-		return
-	    kk -= 1	# don't do the increment
-            continue
-	else: # decide whether or not to emasculate klingon 
-	    if kpow&gt;0 and withprob(0.9) and kpow &lt;= randreal(0.4, 0.8)*kpini:
-		prout(_(&quot;***Mr. Spock-  \&quot;Captain, the vessel at Sector %s&quot;)%w)
-		prout(_(&quot;   has just lost its firepower.\&quot;&quot;))
-		game.enemies[kk].kpower = -kpow
-        kk += 1
-    return
-
-def phasers():
-    # fire phasers 
-    hits = []
-    kz = 0; k = 1; irec=0 # Cheating inhibitor 
-    ifast = False; no = False; itarg = True; msgflag = True; rpow=0
-    automode = &quot;NOTSET&quot;
-    key=0
-    skip(1)
-    # SR sensors and Computer are needed fopr automode 
-    if damaged(DSRSENS) or damaged(DCOMPTR):
-	itarg = False
-    if game.condition == &quot;docked&quot;:
-	prout(_(&quot;Phasers can't be fired through base shields.&quot;))
-	chew()
-	return
-    if damaged(DPHASER):
-	prout(_(&quot;Phaser control damaged.&quot;))
-	chew()
-	return
-    if game.shldup:
-	if damaged(DSHCTRL):
-	    prout(_(&quot;High speed shield control damaged.&quot;))
-	    chew()
-	    return
-	if game.energy &lt;= 200.0:
-	    prout(_(&quot;Insufficient energy to activate high-speed shield control.&quot;))
-	    chew()
-	    return
-	prout(_(&quot;Weapons Officer Sulu-  \&quot;High-speed shield control enabled, sir.\&quot;&quot;))
-	ifast = True
-    # Original code so convoluted, I re-did it all
-    # (That was Tom Almy talking about the C code, I think -- ESR)
-    while automode==&quot;NOTSET&quot;:
-	key=scan()
-	if key == IHALPHA:
-	    if isit(&quot;manual&quot;):
-		if len(game.enemies)==0:
-		    prout(_(&quot;There is no enemy present to select.&quot;))
-		    chew()
-		    key = IHEOL
-		    automode=&quot;AUTOMATIC&quot;
-		else:
-		    automode = &quot;MANUAL&quot;
-		    key = scan()
-	    elif isit(&quot;automatic&quot;):
-		if (not itarg) and len(game.enemies) != 0:
-		    automode = &quot;FORCEMAN&quot;
-		else:
-		    if len(game.enemies)==0:
-			prout(_(&quot;Energy will be expended into space.&quot;))
-		    automode = &quot;AUTOMATIC&quot;
-		    key = scan()
-	    elif isit(&quot;no&quot;):
-		no = True
-	    else:
-		huh()
-		return
-	elif key == IHREAL:
-	    if len(game.enemies)==0:
-		prout(_(&quot;Energy will be expended into space.&quot;))
-		automode = &quot;AUTOMATIC&quot;
-	    elif not itarg:
-		automode = &quot;FORCEMAN&quot;
-	    else:
-		automode = &quot;AUTOMATIC&quot;
-	else:
-	    # IHEOL 
-	    if len(game.enemies)==0:
-		prout(_(&quot;Energy will be expended into space.&quot;))
-		automode = &quot;AUTOMATIC&quot;
-	    elif not itarg:
-		automode = &quot;FORCEMAN&quot;
-	    else: 
-		proutn(_(&quot;Manual or automatic? &quot;))
-                chew()
-    avail = game.energy
-    if ifast:
-        avail -= 200.0
-    if automode == &quot;AUTOMATIC&quot;:
-	if key == IHALPHA and isit(&quot;no&quot;):
-	    no = True
-	    key = scan()
-	if key != IHREAL and len(game.enemies) != 0:
-	    prout(_(&quot;Phasers locked on target. Energy available: %.2f&quot;)%avail)
-	irec=0
-        while True:
-	    chew()
-	    if not kz:
-		for i in range(len(game.enemies)):
-		    irec += math.fabs(game.enemies[i].kpower)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))*randreal(1.01, 1.06) + 1.0
-	    kz=1
-	    proutn(_(&quot;%d units required. &quot;) % irec)
-	    chew()
-	    proutn(_(&quot;Units to fire= &quot;))
-	    key = scan()
-	    if key!=IHREAL:
-		return
-	    rpow = aaitem
-	    if rpow &gt; avail:
-		proutn(_(&quot;Energy available= %.2f&quot;) % avail)
-		skip(1)
-		key = IHEOL
-            if not rpow &gt; avail:
-                break
-	if rpow&lt;=0:
-	    # chicken out 
-	    chew()
-	    return
-        key=scan()
-	if key == IHALPHA and isit(&quot;no&quot;):
-	    no = True
-	if ifast:
-	    game.energy -= 200; # Go and do it! 
-	    if checkshctrl(rpow):
-		return
-	chew()
-	game.energy -= rpow
-	extra = rpow
-	if len(game.enemies):
-	    extra = 0.0
-	    powrem = rpow
-	    for i in range(len(game.enemies)):
-		hits.append(0.0)
-		if powrem &lt;= 0:
-		    continue
-		hits[i] = math.fabs(game.enemies[i].kpower)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))
-		over = randreal(1.01, 1.06) * hits[i]
-		temp = powrem
-		powrem -= hits[i] + over
-		if powrem &lt;= 0 and temp &lt; hits[i]:
-		    hits[i] = temp
-		if powrem &lt;= 0:
-		    over = 0.0
-		extra += over
-	    if powrem &gt; 0.0:
-		extra += powrem
-	    hittem(hits)
-	    game.ididit = True
-	if extra &gt; 0 and not game.alldone:
-	    if game.tholian:
-		proutn(_(&quot;*** Tholian web absorbs &quot;))
-		if len(game.enemies)&gt;0:
-		    proutn(_(&quot;excess &quot;))
-		prout(_(&quot;phaser energy.&quot;))
-	    else:
-		prout(_(&quot;%d expended on empty space.&quot;) % int(extra))
-    elif automode == &quot;FORCEMAN&quot;:
-	chew()
-	key = IHEOL
-	if damaged(DCOMPTR):
-	    prout(_(&quot;Battle computer damaged, manual fire only.&quot;))
-	else:
-	    skip(1)
-	    prouts(_(&quot;---WORKING---&quot;))
-	    skip(1)
-	    prout(_(&quot;Short-range-sensors-damaged&quot;))
-	    prout(_(&quot;Insufficient-data-for-automatic-phaser-fire&quot;))
-	    prout(_(&quot;Manual-fire-must-be-used&quot;))
-	    skip(1)
-    elif automode == &quot;MANUAL&quot;:
-	rpow = 0.0
-        for k in range(len(game.enemies)):
-	    aim = game.enemies[k].kloc
-	    ienm = game.quad[aim.x][aim.y]
-	    if msgflag:
-		proutn(_(&quot;Energy available= %.2f&quot;) % (avail-0.006))
-		skip(1)
-		msgflag = False
-		rpow = 0.0
-	    if damaged(DSRSENS) and not (abs(game.sector.x-aim.x) &lt; 2 and abs(game.sector.y-aim.y) &lt; 2) and \
-		(ienm == IHC or ienm == IHS):
-		cramen(ienm)
-		prout(_(&quot; can't be located without short range scan.&quot;))
-		chew()
-		key = IHEOL
-		hits[k] = 0; # prevent overflow -- thanks to Alexei Voitenko 
-		k += 1
-		continue
-	    if key == IHEOL:
-		chew()
-		if itarg and k &gt; kz:
-		    irec=(abs(game.enemies[k].kpower)/(PHASEFAC*math.pow(0.9,game.enemies[k].kdist))) *	randreal(1.01, 1.06) + 1.0
-		kz = k
-		proutn(&quot;(&quot;)
-		if not damaged(DCOMPTR):
-		    proutn(&quot;%d&quot; % irec)
-		else:
-		    proutn(&quot;??&quot;)
-		proutn(&quot;)  &quot;)
-		proutn(_(&quot;units to fire at &quot;))
-		crmena(False, ienm, &quot;sector&quot;, aim)
-		proutn(&quot;-  &quot;)
-		key = scan()
-	    if key == IHALPHA and isit(&quot;no&quot;):
-		no = True
-		key = scan()
-		continue
-	    if key == IHALPHA:
-		huh()
-		return
-	    if key == IHEOL:
-		if k==1: # Let me say I'm baffled by this 
-		    msgflag = True
-		continue
-	    if aaitem &lt; 0:
-		# abort out 
-		chew()
-		return
-	    hits[k] = aaitem
-	    rpow += aaitem
-	    # If total requested is too much, inform and start over 
-            if rpow &gt; avail:
-		prout(_(&quot;Available energy exceeded -- try again.&quot;))
-		chew()
-		return
-	    key = scan(); # scan for next value 
-	    k += 1
-	if rpow == 0.0:
-	    # zero energy -- abort 
-	    chew()
-	    return
-	if key == IHALPHA and isit(&quot;no&quot;):
-	    no = True
-	game.energy -= rpow
-	chew()
-	if ifast:
-	    game.energy -= 200.0
-	    if checkshctrl(rpow):
-		return
-	hittem(hits)
-	game.ididit = True
-     # Say shield raised or malfunction, if necessary 
-    if game.alldone:
-	return
-    if ifast:
-	skip(1)
-	if no == 0:
-	    if withprob(0.99):
-		prout(_(&quot;Sulu-  \&quot;Sir, the high-speed shield control has malfunctioned . . .&quot;))
-		prouts(_(&quot;         CLICK   CLICK   POP  . . .&quot;))
-		prout(_(&quot; No response, sir!&quot;))
-		game.shldup = False
-	    else:
-		prout(_(&quot;Shields raised.&quot;))
-	else:
-	    game.shldup = False
-    overheat(rpow);
-
-# Code from events,c begins here.
-
-# This isn't a real event queue a la BSD Trek yet -- you can only have one 
-# event of each type active at any given time.  Mostly these means we can 
-# only have one FDISTR/FENSLV/FREPRO sequence going at any given time
-# BSD Trek, from which we swiped the idea, can have up to 5.
-
-def unschedule(evtype):
-    # remove an event from the schedule 
-    game.future[evtype].date = FOREVER
-    return game.future[evtype]
-
-def is_scheduled(evtype):
-    # is an event of specified type scheduled 
-    return game.future[evtype].date != FOREVER
-
-def scheduled(evtype):
-    # when will this event happen? 
-    return game.future[evtype].date
-
-def schedule(evtype, offset):
-    # schedule an event of specified type
-    game.future[evtype].date = game.state.date + offset
-    return game.future[evtype]
-
-def postpone(evtype, offset):
-    # postpone a scheduled event 
-    game.future[evtype].date += offset
-
-def cancelrest():
-    # rest period is interrupted by event 
-    if game.resting:
-	skip(1)
-	proutn(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
-	if ja() == True:
-	    game.resting = False
-	    game.optime = 0.0
-	    return True
-    return False
-
-def events():
-    # run through the event queue looking for things to do 
-    i=0
-    fintim = game.state.date + game.optime; yank=0
-    ictbeam = False; istract = False
-    w = coord(); hold = coord()
-    ev = event(); ev2 = event()
-
-    def tractorbeam(yank):
-        # tractor beaming cases merge here 
-        announce()
-        game.optime = (10.0/(7.5*7.5))*yank # 7.5 is yank rate (warp 7.5) 
-        skip(1)
-        proutn(&quot;***&quot;)
-        crmshp()
-        prout(_(&quot; caught in long range tractor beam--&quot;))
-        # If Kirk &amp; Co. screwing around on planet, handle 
-        atover(True) # atover(true) is Grab 
-        if game.alldone:
-            return
-        if game.icraft: # Caught in Galileo? 
-            finish(FSTRACTOR)
-            return
-        # Check to see if shuttle is aboard 
-        if game.iscraft == &quot;offship&quot;:
-            skip(1)
-            if withprob(0.5):
-                prout(_(&quot;Galileo, left on the planet surface, is captured&quot;))
-                prout(_(&quot;by aliens and made into a flying McDonald's.&quot;))
-                game.damage[DSHUTTL] = -10
-                game.iscraft = &quot;removed&quot;
-            else:
-                prout(_(&quot;Galileo, left on the planet surface, is well hidden.&quot;))
-        if evcode == FSPY:
-            game.quadrant = game.state.kscmdr
-        else:
-            game.quadrant = game.state.kcmdr[i]
-        game.sector = randplace(QUADSIZE)
-        crmshp()
-        prout(_(&quot; is pulled to Quadrant %s, Sector %s&quot;) \
-               % (game.quadrant, game.sector))
-        if game.resting:
-            prout(_(&quot;(Remainder of rest/repair period cancelled.)&quot;))
-            game.resting = False
-        if not game.shldup:
-            if not damaged(DSHIELD) and game.shield &gt; 0:
-                doshield(shraise=True) # raise shields 
-                game.shldchg = False
-            else:
-                prout(_(&quot;(Shields not currently useable.)&quot;))
-        newqad(False)
-        # Adjust finish time to time of tractor beaming 
-        fintim = game.state.date+game.optime
-        attack(torps_ok=False)
-        if game.state.remcom &lt;= 0:
-            unschedule(FTBEAM)
-        else: 
-            schedule(FTBEAM, game.optime+expran(1.5*game.intime/game.state.remcom))
-
-    def destroybase():
-        # Code merges here for any commander destroying base 
-        # Not perfect, but will have to do 
-        # Handle case where base is in same quadrant as starship 
-        if game.battle == game.quadrant:
-            game.state.chart[game.battle.x][game.battle.y].starbase = False
-            game.quad[game.base.x][game.base.y] = IHDOT
-            game.base.x=game.base.y=0
-            newcnd()
-            skip(1)
-            prout(_(&quot;Spock-  \&quot;Captain, I believe the starbase has been destroyed.\&quot;&quot;))
-        elif game.state.rembase != 1 and communicating():
-            # Get word via subspace radio 
-            announce()
-            skip(1)
-            prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Command reports that&quot;))
-            proutn(_(&quot;   the starbase in Quadrant %s has been destroyed by&quot;) % game.battle)
-            if game.isatb == 2: 
-                prout(_(&quot;the Klingon Super-Commander&quot;))
-            else:
-                prout(_(&quot;a Klingon Commander&quot;))
-            game.state.chart[game.battle.x][game.battle.y].starbase = False
-        # Remove Starbase from galaxy 
-        game.state.galaxy[game.battle.x][game.battle.y].starbase = False
-        for i in range(1, game.state.rembase+1):
-            if game.state.baseq[i] == game.battle:
-                game.state.baseq[i] = game.state.baseq[game.state.rembase]
-        game.state.rembase -= 1
-        if game.isatb == 2:
-            # reinstate a commander's base attack 
-            game.battle = hold
-            game.isatb = 0
-        else:
-            invalidate(game.battle)
-
-    if idebug:
-	prout(&quot;=== EVENTS from %.2f to %.2f:&quot; % (game.state.date, fintim))
-	for i in range(1, NEVENTS):
-	    if   i == FSNOVA:  proutn(&quot;=== Supernova       &quot;)
-	    elif i == FTBEAM:  proutn(&quot;=== T Beam          &quot;)
-	    elif i == FSNAP:   proutn(&quot;=== Snapshot        &quot;)
-	    elif i == FBATTAK: proutn(&quot;=== Base Attack     &quot;)
-	    elif i == FCDBAS:  proutn(&quot;=== Base Destroy    &quot;)
-	    elif i == FSCMOVE: proutn(&quot;=== SC Move         &quot;)
-	    elif i == FSCDBAS: proutn(&quot;=== SC Base Destroy &quot;)
-	    elif i == FDSPROB: proutn(&quot;=== Probe Move      &quot;)
-	    elif i == FDISTR:  proutn(&quot;=== Distress Call   &quot;)
-	    elif i == FENSLV:  proutn(&quot;=== Enslavement     &quot;)
-	    elif i == FREPRO:  proutn(&quot;=== Klingon Build   &quot;)
-	    if is_scheduled(i):
-		prout(&quot;%.2f&quot; % (scheduled(i)))
-	    else:
-		prout(&quot;never&quot;)
-    radio_was_broken = damaged(DRADIO)
-    hold.x = hold.y = 0
-    while True:
-	# Select earliest extraneous event, evcode==0 if no events 
-	evcode = FSPY
-	if game.alldone:
-	    return
-	datemin = fintim
-	for l in range(1, NEVENTS):
-	    if game.future[l].date &lt; datemin:
-		evcode = l
-		if idebug:
-		    prout(&quot;== Event %d fires&quot; % evcode)
-		datemin = game.future[l].date
-	xtime = datemin-game.state.date
-	game.state.date = datemin
-	# Decrement Federation resources and recompute remaining time 
-	game.state.remres -= (game.state.remkl+4*game.state.remcom)*xtime
-        game.recompute()
-	if game.state.remtime &lt;=0:
-	    finish(FDEPLETE)
-	    return
-	# Any crew left alive? 
-	if game.state.crew &lt;=0:
-	    finish(FCREW)
-	    return
-	# Is life support adequate? 
-	if damaged(DLIFSUP) and game.condition != &quot;docked&quot;:
-	    if game.lsupres &lt; xtime and game.damage[DLIFSUP] &gt; game.lsupres:
-		finish(FLIFESUP)
-		return
-	    game.lsupres -= xtime
-	    if game.damage[DLIFSUP] &lt;= xtime:
-		game.lsupres = game.inlsr
-	# Fix devices 
-	repair = xtime
-	if game.condition == &quot;docked&quot;:
-	    repair /= game.docfac
-	# Don't fix Deathray here 
-	for l in range(NDEVICES):
-	    if game.damage[l] &gt; 0.0 and l != DDRAY:
-                if game.damage[l]-repair &gt; 0.0:
-                    game.damage[l] -= repair
-                else:
-                    game.damage[l] = 0.0
-	# If radio repaired, update star chart and attack reports 
-	if radio_was_broken and not damaged(DRADIO):
-	    prout(_(&quot;Lt. Uhura- \&quot;Captain, the sub-space radio is working and&quot;))
-	    prout(_(&quot;   surveillance reports are coming in.&quot;))
-	    skip(1)
-	    if not game.iseenit:
-		attackreport(False)
-		game.iseenit = True
-	    rechart()
-	    prout(_(&quot;   The star chart is now up to date.\&quot;&quot;))
-	    skip(1)
-	# Cause extraneous event EVCODE to occur 
-	game.optime -= xtime
-	if evcode == FSNOVA: # Supernova 
-	    announce()
-	    supernova(False)
-	    schedule(FSNOVA, expran(0.5*game.intime))
-	    if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-		return
-	elif evcode == FSPY: # Check with spy to see if SC should tractor beam 
-	    if game.state.nscrem == 0 or \
-		ictbeam or istract or \
-                game.condition==&quot;docked&quot; or game.isatb==1 or game.iscate:
-		return
-	    if game.ientesc or \
-		(game.energy&lt;2000 and game.torps&lt;4 and game.shield &lt; 1250) or \
-		(damaged(DPHASER) and (damaged(DPHOTON) or game.torps&lt;4)) or \
-		(damaged(DSHIELD) and \
-		 (game.energy &lt; 2500 or damaged(DPHASER)) and \
-                 (game.torps &lt; 5 or damaged(DPHOTON))):
-		# Tractor-beam her! 
-		istract = ictbeam = True
-                tractorbeam(distance(game.state.kscmdr, game.quadrant))
-	    else:
-		return
-	elif evcode == FTBEAM: # Tractor beam 
-            if game.state.remcom == 0:
-                unschedule(FTBEAM)
-                continue
-            i = randrange(game.state.remcom)
-            yank = distance(game.state.kcmdr[i], game.quadrant)
-            if istract or game.condition == &quot;docked&quot; or yank == 0:
-                # Drats! Have to reschedule 
-                schedule(FTBEAM, 
-                         game.optime + expran(1.5*game.intime/game.state.remcom))
-                continue
-            ictbeam = True
-            tractorbeam(yank)
-	elif evcode == FSNAP: # Snapshot of the universe (for time warp) 
-	    game.snapsht = copy.deepcopy(game.state)
-	    game.state.snap = True
-	    schedule(FSNAP, expran(0.5 * game.intime))
-	elif evcode == FBATTAK: # Commander attacks starbase 
-	    if game.state.remcom==0 or game.state.rembase==0:
-		# no can do 
-		unschedule(FBATTAK)
-		unschedule(FCDBAS)
-                continue
-	    i = 0
-	    for j in range(game.state.rembase):
-		for k in range(game.state.remcom):
-		    if game.state.baseq[j] == game.state.kcmdr[k] and \
-			not game.state.baseq[j] == game.quadrant and \
-                        not game.state.baseq[j] == game.state.kscmdr:
-			i = 1
-		if i == 1:
-		    continue
-	    if j&gt;game.state.rembase:
-		# no match found -- try later 
-		schedule(FBATTAK, expran(0.3*game.intime))
-		unschedule(FCDBAS)
-		continue
-	    # commander + starbase combination found -- launch attack 
-	    game.battle = game.state.baseq[j]
-	    schedule(FCDBAS, randreal(1.0, 4.0))
-	    if game.isatb: # extra time if SC already attacking 
-		postpone(FCDBAS, scheduled(FSCDBAS)-game.state.date)
-	    game.future[FBATTAK].date = game.future[FCDBAS].date + expran(0.3*game.intime)
-	    game.iseenit = False
-            if not communicating():
-		continue # No warning :-( 
-	    game.iseenit = True
-	    announce()
-	    skip(1)
-	    prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) % game.battle)
-	    prout(_(&quot;   reports that it is under attack and that it can&quot;))
-	    prout(_(&quot;   hold out only until stardate %d.\&quot;&quot;) % (int(scheduled(FCDBAS))))
-	    if cancelrest():
-                return
-	elif evcode == FSCDBAS: # Supercommander destroys base 
-	    unschedule(FSCDBAS)
-	    game.isatb = 2
-	    if not game.state.galaxy[game.state.kscmdr.x][game.state.kscmdr.y].starbase: 
-		continue # WAS RETURN! 
-	    hold = game.battle
-	    game.battle = game.state.kscmdr
-	    destroybase()
-	elif evcode == FCDBAS: # Commander succeeds in destroying base 
-	    if evcode==FCDBAS:
-		unschedule(FCDBAS)
-		# find the lucky pair 
-		for i in range(game.state.remcom):
-		    if game.state.kcmdr[i] == game.battle: 
-			break
-		if i &gt; game.state.remcom or game.state.rembase == 0 or \
-		    not game.state.galaxy[game.battle.x][game.battle.y].starbase:
-		    # No action to take after all 
-		    invalidate(game.battle)
-		    continue
-            destroybase()
-	elif evcode == FSCMOVE: # Supercommander moves 
-	    schedule(FSCMOVE, 0.2777)
-	    if not game.ientesc and not istract and game.isatb != 1 and \
-                   (not game.iscate or not game.justin): 
-		supercommander()
-	elif evcode == FDSPROB: # Move deep space probe 
-	    schedule(FDSPROB, 0.01)
-	    game.probex += game.probeinx
-	    game.probey += game.probeiny
-	    i = (int)(game.probex/QUADSIZE +0.05)
-	    j = (int)(game.probey/QUADSIZE + 0.05)
-	    if game.probec.x != i or game.probec.y != j:
-		game.probec.x = i
-		game.probec.y = j
-		if not VALID_QUADRANT(i, j) or \
-		    game.state.galaxy[game.probec.x][game.probec.y].supernova:
-		    # Left galaxy or ran into supernova
-                    if comunicating():
-			announce()
-			skip(1)
-			proutn(_(&quot;Lt. Uhura-  \&quot;The deep space probe &quot;))
-			if not VALID_QUADRANT(j, i):
-			    proutn(_(&quot;has left the galaxy&quot;))
-			else:
-			    proutn(_(&quot;is no longer transmitting&quot;))
-			prout(&quot;.\&quot;&quot;)
-		    unschedule(FDSPROB)
-		    continue
-                if not communicating():
-		    announce()
-		    skip(1)
-		    proutn(_(&quot;Lt. Uhura-  \&quot;The deep space probe is now in Quadrant %s.\&quot;&quot;) % game.probec)
-	    pdest = game.state.galaxy[game.probec.x][game.probec.y]
-	    # Update star chart if Radio is working or have access to radio
-	    if communicating():
-		chp = game.state.chart[game.probec.x][game.probec.y]
-		chp.klingons = pdest.klingons
-		chp.starbase = pdest.starbase
-		chp.stars = pdest.stars
-		pdest.charted = True
-	    game.proben -= 1 # One less to travel
-	    if game.proben == 0 and game.isarmed and pdest.stars:
-		# lets blow the sucker! 
-		supernova(True, game.probec)
-		unschedule(FDSPROB)
-		if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova: 
-		    return
-	elif evcode == FDISTR: # inhabited system issues distress call 
-	    unschedule(FDISTR)
-	    # try a whole bunch of times to find something suitable 
-            for i in range(100):
-		# need a quadrant which is not the current one,
-		# which has some stars which are inhabited and
-		# not already under attack, which is not
-		# supernova'ed, and which has some Klingons in it
-		w = randplace(GALSIZE)
-		q = game.state.galaxy[w.x][w.y]
-                if not (game.quadrant == w or q.planet == None or \
-		      not q.planet.inhabited or \
-		      q.supernova or q.status!=&quot;secure&quot; or q.klingons&lt;=0):
-                    break
-            else:
-		# can't seem to find one; ignore this call 
-		if idebug:
-		    prout(&quot;=== Couldn't find location for distress event.&quot;)
-		continue
-	    # got one!!  Schedule its enslavement 
-	    ev = schedule(FENSLV, expran(game.intime))
-	    ev.quadrant = w
-	    q.status = distressed
-
-	    # tell the captain about it if we can 
-	    if communicating():
-		prout(_(&quot;Uhura- Captain, %s in Quadrant %s reports it is under attack&quot;) \
-                        % (q.planet, `w`))
-		prout(_(&quot;by a Klingon invasion fleet.&quot;))
-		if cancelrest():
-		    return
-	elif evcode == FENSLV:		# starsystem is enslaved 
-	    ev = unschedule(FENSLV)
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.x][ev.quadrant.y]
-	    if q.klingons &lt;= 0:
-		q.status = &quot;secure&quot;
-		continue
-	    q.status = &quot;enslaved&quot;
-
-	    # play stork and schedule the first baby 
-	    ev2 = schedule(FREPRO, expran(2.0 * game.intime))
-	    ev2.quadrant = ev.quadrant
-
-	    # report the disaster if we can 
-	    if communicating():
-		prout(_(&quot;Uhura- We've lost contact with starsystem %s&quot;) % \
-                        q.planet)
-		prout(_(&quot;in Quadrant %s.\n&quot;) % ev.quadrant)
-	elif evcode == FREPRO:		# Klingon reproduces 
-	    # If we ever switch to a real event queue, we'll need to
-	    # explicitly retrieve and restore the x and y.
-	    ev = schedule(FREPRO, expran(1.0 * game.intime))
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.x][ev.quadrant.y]
-	    if q.klingons &lt;= 0:
-		q.status = &quot;secure&quot;
-		continue
-	    if game.state.remkl &gt;=MAXKLGAME:
-		continue		# full right now 
-	    # reproduce one Klingon 
-	    w = ev.quadrant
-	    if game.klhere &gt;= MAXKLQUAD:
-                try:
-                    # this quadrant not ok, pick an adjacent one 
-                    for i in range(w.x - 1, w.x + 2):
-                        for j in range(w.y - 1, w.y + 2):
-                            if not VALID_QUADRANT(i, j):
-                                continue
-                            q = game.state.galaxy[w.x][w.y]
-                            # check for this quad ok (not full &amp; no snova) 
-                            if q.klingons &gt;= MAXKLQUAD or q.supernova:
-                                continue
-                            raise &quot;FOUNDIT&quot;
-                    else:
-                        continue	# search for eligible quadrant failed
-                except &quot;FOUNDIT&quot;:
-                    w.x = i
-                    w.y = j
-	    # deliver the child 
-	    game.state.remkl += 1
-	    q.klingons += 1
-	    if game.quadrant == w:
-                game.klhere += 1
-		game.enemies.append(newkling())
-	    # recompute time left
-            game.recompute()
-	    # report the disaster if we can 
-	    if communicating():
-		if game.quadrant == w:
-		    prout(_(&quot;Spock- sensors indicate the Klingons have&quot;))
-		    prout(_(&quot;launched a warship from %s.&quot;) % q.planet)
-		else:
-		    prout(_(&quot;Uhura- Starfleet reports increased Klingon activity&quot;))
-		    if q.planet != None:
-			proutn(_(&quot;near %s&quot;) % q.planet)
-		    prout(_(&quot;in Quadrant %s.&quot;) % w)
-				
-def wait():
-    # wait on events 
-    game.ididit = False
-    while True:
-	key = scan()
-	if key  != IHEOL:
-	    break
-	proutn(_(&quot;How long? &quot;))
-    chew()
-    if key != IHREAL:
-	huh()
-	return
-    origTime = delay = aaitem
-    if delay &lt;= 0.0:
-	return
-    if delay &gt;= game.state.remtime or len(game.enemies) != 0:
-	proutn(_(&quot;Are you sure? &quot;))
-	if ja() == False:
-	    return
-    # Alternate resting periods (events) with attacks 
-    game.resting = True
-    while True:
-	if delay &lt;= 0:
-	    game.resting = False
-	if not game.resting:
-	    prout(_(&quot;%d stardates left.&quot;) % int(game.state.remtime))
-	    return
-	temp = game.optime = delay
-	if len(game.enemies):
-	    rtime = randreal(1.0, 2.0)
-	    if rtime &lt; temp:
-		temp = rtime
-	    game.optime = temp
-	if game.optime &lt; delay:
-	    attack(torps_ok=False)
-	if game.alldone:
-	    return
-	events()
-	game.ididit = True
-	if game.alldone:
-	    return
-	delay -= temp
-	# Repair Deathray if long rest at starbase 
-	if origTime-delay &gt;= 9.99 and game.condition == &quot;docked&quot;:
-	    game.damage[DDRAY] = 0.0
-	# leave if quadrant supernovas
-        if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-            break
-    game.resting = False
-    game.optime = 0
-
-# A nova occurs.  It is the result of having a star hit with a
-# photon torpedo, or possibly of a probe warhead going off.
-# Stars that go nova cause stars which surround them to undergo
-# the same probabilistic process.  Klingons next to them are
-# destroyed.  And if the starship is next to it, it gets zapped.
-# If the zap is too much, it gets destroyed.
-        
-def nova(nov):
-    # star goes nova 
-    course = (0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5)
-    newc = coord(); neighbor = coord(); bump = coord(0, 0)
-    if withprob(0.05):
-	# Wow! We've supernova'ed 
-	supernova(False, nov)
-	return
-    # handle initial nova 
-    game.quad[nov.x][nov.y] = IHDOT
-    crmena(False, IHSTAR, &quot;sector&quot;, nov)
-    prout(_(&quot; novas.&quot;))
-    game.state.galaxy[game.quadrant.x][game.quadrant.y].stars -= 1
-    game.state.starkl += 1
-    # Set up queue to recursively trigger adjacent stars 
-    hits = [nov]
-    kount = 0
-    while hits:
-        offset = coord()
-        start = hits.pop()
-        for offset.x in range(-1, 1+1):
-            for offset.y in range(-1, 1+1):
-                if offset.y==0 and offset.x==0:
-                    continue
-                neighbor = start + offset
-                if not VALID_SECTOR(neighbor.y, neighbor.x):
-                    continue
-                iquad = game.quad[neighbor.x][neighbor.y]
-                # Empty space ends reaction
-                if iquad in (IHDOT, IHQUEST, IHBLANK, IHT, IHWEB):
-                    pass
-                elif iquad == IHSTAR: # Affect another star 
-                    if withprob(0.05):
-                        # This star supernovas 
-                        supernova(False)
-                        return
-                    else:
-                        hits.append(neighbor)
-			game.state.galaxy[game.quadrant.x][game.quadrant.y].stars -= 1
-			game.state.starkl += 1
-			crmena(True, IHSTAR, &quot;sector&quot;, neighbor)
-			prout(_(&quot; novas.&quot;))
-                        game.quad[neighbor.x][neighbor.y] = IHDOT
-                        kount += 1
-                elif iquad in (IHP, IHW): # Destroy planet 
-                    game.state.galaxy[game.quadrant.x][game.quadrant.y].planet = None
-                    if iquad == IHP:
-                        game.state.nplankl += 1
-                    else:
-                        game.state.worldkl += 1
-                    crmena(True, iquad, &quot;sector&quot;, neighbor)
-                    prout(_(&quot; destroyed.&quot;))
-                    game.iplnet.pclass = &quot;destroyed&quot;
-                    game.iplnet = None
-                    invalidate(game.plnet)
-                    if game.landed:
-                        finish(FPNOVA)
-                        return
-                    game.quad[neighbor.x][neighbor.y] = IHDOT
-                elif iquad == IHB: # Destroy base 
-                    game.state.galaxy[game.quadrant.x][game.quadrant.y].starbase = False
-                    for i in range(game.state.rembase):
-                        if game.state.baseq[i] == game.quadrant: 
-                            break
-                    game.state.baseq[i] = game.state.baseq[game.state.rembase]
-                    game.state.rembase -= 1
-                    invalidate(game.base)
-                    game.state.basekl += 1
-                    newcnd()
-                    crmena(True, IHB, &quot;sector&quot;, neighbor)
-                    prout(_(&quot; destroyed.&quot;))
-                    game.quad[neighbor.x][neighbor.y] = IHDOT
-                elif iquad in (IHE, IHF): # Buffet ship 
-                    prout(_(&quot;***Starship buffeted by nova.&quot;))
-                    if game.shldup:
-                        if game.shield &gt;= 2000.0:
-                            game.shield -= 2000.0
-                        else:
-                            diff = 2000.0 - game.shield
-                            game.energy -= diff
-                            game.shield = 0.0
-                            game.shldup = False
-                            prout(_(&quot;***Shields knocked out.&quot;))
-                            game.damage[DSHIELD] += 0.005*game.damfac*randreal()*diff
-                    else:
-                        game.energy -= 2000.0
-                    if game.energy &lt;= 0:
-                        finish(FNOVA)
-                        return
-                    # add in course nova contributes to kicking starship
-                    bump += (game.sector-hits[mm]).sgn()
-                elif iquad == IHK: # kill klingon 
-                    deadkl(neighbor, iquad, neighbor)
-                elif iquad in (IHC,IHS,IHR): # Damage/destroy big enemies 
-                    for ll in range(len(game.enemies)):
-                        if game.enemies[ll].kloc == neighbor:
-                            break
-                    game.enemies[ll].kpower -= 800.0 # If firepower is lost, die 
-                    if game.enemies[ll].kpower &lt;= 0.0:
-                        deadkl(neighbor, iquad, neighbor)
-                        break
-                    newc = neighbor + neighbor - hits[mm]
-                    crmena(True, iquad, &quot;sector&quot;, neighbor)
-                    proutn(_(&quot; damaged&quot;))
-                    if not VALID_SECTOR(newc.x, newc.y):
-                        # can't leave quadrant 
-                        skip(1)
-                        break
-                    iquad1 = game.quad[newc.x][newc.y]
-                    if iquad1 == IHBLANK:
-                        proutn(_(&quot;, blasted into &quot;))
-                        crmena(False, IHBLANK, &quot;sector&quot;, newc)
-                        skip(1)
-                        deadkl(neighbor, iquad, newc)
-                        break
-                    if iquad1 != IHDOT:
-                        # can't move into something else 
-                        skip(1)
-                        break
-                    proutn(_(&quot;, buffeted to Sector %s&quot;) % newc)
-                    game.quad[neighbor.x][neighbor.y] = IHDOT
-                    game.quad[newc.x][newc.y] = iquad
-                    game.enemies[ll].move(newc)
-    # Starship affected by nova -- kick it away. 
-    game.dist = kount*0.1
-    game.direc = course[3*(bump.x+1)+bump.y+2]
-    if game.direc == 0.0:
-	game.dist = 0.0
-    if game.dist == 0.0:
-	return
-    game.optime = 10.0*game.dist/16.0
-    skip(1)
-    prout(_(&quot;Force of nova displaces starship.&quot;))
-    imove(novapush=True)
-    game.optime = 10.0*game.dist/16.0
-    return
-	
-def supernova(induced, w=None):
-    # star goes supernova 
-    num = 0; npdead = 0
-    nq = coord()
-    if w != None: 
-	nq = w
-    else:
-	stars = 0
-	# Scheduled supernova -- select star 
-	# logic changed here so that we won't favor quadrants in top
-        # left of universe 
-	for nq.x in range(GALSIZE):
-	    for nq.y in range(GALSIZE):
-		stars += game.state.galaxy[nq.x][nq.y].stars
-	if stars == 0:
-	    return # nothing to supernova exists 
-	num = randrange(stars) + 1
-	for nq.x in range(GALSIZE):
-	    for nq.y in range(GALSIZE):
-		num -= game.state.galaxy[nq.x][nq.y].stars
-		if num &lt;= 0:
-		    break
-	    if num &lt;=0:
-		break
-	if idebug:
-	    proutn(&quot;=== Super nova here?&quot;)
-	    if ja() == True:
-		nq = game.quadrant
-    if not nq == game.quadrant or game.justin:
-	# it isn't here, or we just entered (treat as enroute) 
-	if communicating():
-	    skip(1)
-	    prout(_(&quot;Message from Starfleet Command       Stardate %.2f&quot;) % game.state.date)
-	    prout(_(&quot;     Supernova in Quadrant %s; caution advised.&quot;) % nq)
-    else:
-	ns = coord()
-	# we are in the quadrant! 
-	num = randrange(game.state.galaxy[nq.x][nq.y].stars) + 1
-	for ns.x in range(QUADSIZE):
-	    for ns.y in range(QUADSIZE):
-		if game.quad[ns.x][ns.y]==IHSTAR:
-		    num -= 1
-		    if num==0:
-			break
-	    if num==0:
-		break
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	skip(1)
-	prout(_(&quot;***Incipient supernova detected at Sector %s&quot;) % ns)
-	if square(ns.x-game.sector.x) + square(ns.y-game.sector.y) &lt;= 2.1:
-	    proutn(_(&quot;Emergency override attempts t&quot;))
-	    prouts(&quot;***************&quot;)
-	    skip(1)
-	    stars()
-	    game.alldone = True
-
-    # destroy any Klingons in supernovaed quadrant 
-    kldead = game.state.galaxy[nq.x][nq.y].klingons
-    game.state.galaxy[nq.x][nq.y].klingons = 0
-    if nq == game.state.kscmdr:
-	# did in the Supercommander! 
-	game.state.nscrem = game.state.kscmdr.x = game.state.kscmdr.y = game.isatb =  0
-	game.iscate = False
-	unschedule(FSCMOVE)
-	unschedule(FSCDBAS)
-    if game.state.remcom:
-	maxloop = game.state.remcom
-	for l in range(maxloop):
-	    if game.state.kcmdr[l] == nq:
-		game.state.kcmdr[l] = game.state.kcmdr[game.state.remcom]
-		invalidate(game.state.kcmdr[game.state.remcom])
-		game.state.remcom -= 1
-		kldead -= 1
-		if game.state.remcom==0:
-		    unschedule(FTBEAM)
-		break
-    game.state.remkl -= kldead
-    # destroy Romulans and planets in supernovaed quadrant 
-    nrmdead = game.state.galaxy[nq.x][nq.y].romulans
-    game.state.galaxy[nq.x][nq.y].romulans = 0
-    game.state.nromrem -= nrmdead
-    # Destroy planets 
-    for loop in range(game.inplan):
-	if game.state.planets[loop].w == nq:
-	    game.state.planets[loop].pclass = &quot;destroyed&quot;
-	    npdead += 1
-    # Destroy any base in supernovaed quadrant 
-    if game.state.rembase:
-	maxloop = game.state.rembase
-	for loop in range(maxloop):
-	    if game.state.baseq[loop] == nq:
-		game.state.baseq[loop] = game.state.baseq[game.state.rembase]
-		invalidate(game.state.baseq[game.state.rembase])
-		game.state.rembase -= 1
-		break
-    # If starship caused supernova, tally up destruction 
-    if induced:
-	game.state.starkl += game.state.galaxy[nq.x][nq.y].stars
-	game.state.basekl += game.state.galaxy[nq.x][nq.y].starbase
-	game.state.nplankl += npdead
-    # mark supernova in galaxy and in star chart 
-    if game.quadrant == nq or communicating():
-	game.state.galaxy[nq.x][nq.y].supernova = True
-    # If supernova destroys last Klingons give special message 
-    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0 and not nq == game.quadrant:
-	skip(2)
-	if not induced:
-	    prout(_(&quot;Lucky you!&quot;))
-	proutn(_(&quot;A supernova in %s has just destroyed the last Klingons.&quot;) % nq)
-	finish(FWON)
-	return
-    # if some Klingons remain, continue or die in supernova 
-    if game.alldone:
-	finish(FSNOVAED)
-    return
-
-# Code from finish.c ends here.
-
-def selfdestruct():
-    # self-destruct maneuver 
-    # Finish with a BANG! 
-    chew()
-    if damaged(DCOMPTR):
-	prout(_(&quot;Computer damaged; cannot execute destruct sequence.&quot;))
-	return
-    prouts(_(&quot;---WORKING---&quot;)); skip(1)
-    prouts(_(&quot;SELF-DESTRUCT-SEQUENCE-ACTIVATED&quot;)); skip(1)
-    prouts(&quot;   10&quot;); skip(1)
-    prouts(&quot;       9&quot;); skip(1)
-    prouts(&quot;          8&quot;); skip(1)
-    prouts(&quot;             7&quot;); skip(1)
-    prouts(&quot;                6&quot;); skip(1)
-    skip(1)
-    prout(_(&quot;ENTER-CORRECT-PASSWORD-TO-CONTINUE-&quot;))
-    skip(1)
-    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-OTHERWISE-&quot;))
-    skip(1)
-    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED&quot;))
-    skip(1)
-    scan()
-    chew()
-    if game.passwd != citem:
-	prouts(_(&quot;PASSWORD-REJECTED;&quot;))
-	skip(1)
-	prouts(_(&quot;CONTINUITY-EFFECTED&quot;))
-	skip(2)
-	return
-    prouts(_(&quot;PASSWORD-ACCEPTED&quot;)); skip(1)
-    prouts(&quot;                   5&quot;); skip(1)
-    prouts(&quot;                      4&quot;); skip(1)
-    prouts(&quot;                         3&quot;); skip(1)
-    prouts(&quot;                            2&quot;); skip(1)
-    prouts(&quot;                              1&quot;); skip(1)
-    if withprob(0.15):
-	prouts(_(&quot;GOODBYE-CRUEL-WORLD&quot;))
-	skip(1)
-    kaboom()
-
-def kaboom():
-    stars()
-    if game.ship==IHE:
-	prouts(&quot;***&quot;)
-    prouts(_(&quot;********* Entropy of &quot;))
-    crmshp()
-    prouts(_(&quot; maximized *********&quot;))
-    skip(1)
-    stars()
-    skip(1)
-    if len(game.enemies) != 0:
-	whammo = 25.0 * game.energy
-	l=1
-	while l &lt;= len(game.enemies):
-	    if game.enemies[l].kpower*game.enemies[l].kdist &lt;= whammo: 
-		deadkl(game.enemies[l].kloc, game.quad[game.enemies[l].kloc.x][game.enemies[l].kloc.y], game.enemies[l].kloc)
-	    l += 1
-    finish(FDILITHIUM)
-				
-def killrate():
-    &quot;Compute our rate of kils over time.&quot;
-    elapsed = game.state.date - game.indate
-    if elapsed == 0:	# Avoid divide-by-zero error if calculated on turn 0
-        return 0
-    else:
-        starting = (game.inkling + game.incom + game.inscom)
-        remaining = (game.state.remkl + game.state.remcom + game.state.nscrem)
-        return (starting - remaining)/elapsed
-
-def badpoints():
-    &quot;Compute demerits.&quot;
-    badpt = 5.0*game.state.starkl + \
-            game.casual + \
-            10.0*game.state.nplankl + \
-            300*game.state.nworldkl + \
-            45.0*game.nhelp +\
-            100.0*game.state.basekl +\
-            3.0*game.abandoned
-    if game.ship == IHF:
-        badpt += 100.0
-    elif game.ship == None:
-        badpt += 200.0
-    return badpt
-
-def finish(ifin):
-    # end the game, with appropriate notfications 
-    igotit = False
-    game.alldone = True
-    skip(3)
-    prout(_(&quot;It is stardate %.1f.&quot;) % game.state.date)
-    skip(1)
-    if ifin == FWON: # Game has been won
-	if game.state.nromrem != 0:
-	    prout(_(&quot;The remaining %d Romulans surrender to Starfleet Command.&quot;) %
-		  game.state.nromrem)
-
-	prout(_(&quot;You have smashed the Klingon invasion fleet and saved&quot;))
-	prout(_(&quot;the Federation.&quot;))
-	game.gamewon = True
-	if game.alive:
-            badpt = badpoints()
-            if badpt &lt; 100.0:
-                badpt = 0.0	# Close enough!
-            # killsPerDate &gt;= RateMax
-	    if game.state.date-game.indate &lt; 5.0 or \
-                killrate() &gt;= 0.1*game.skill*(game.skill+1.0) + 0.1 + 0.008*badpt:
-		skip(1)
-		prout(_(&quot;In fact, you have done so well that Starfleet Command&quot;))
-		if game.skill == SKILL_NOVICE:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Novice\&quot; to \&quot;Fair\&quot;.&quot;))
-		elif game.skill == SKILL_FAIR:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Fair\&quot; to \&quot;Good\&quot;.&quot;))
-		elif game.skill == SKILL_GOOD:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Good\&quot; to \&quot;Expert\&quot;.&quot;))
-		elif game.skill == SKILL_EXPERT:
-		    prout(_(&quot;promotes you to Commodore Emeritus.&quot;))
-		    skip(1)
-		    prout(_(&quot;Now that you think you're really good, try playing&quot;))
-		    prout(_(&quot;the \&quot;Emeritus\&quot; game. It will splatter your ego.&quot;))
-		elif game.skill == SKILL_EMERITUS:
-		    skip(1)
-		    proutn(_(&quot;Computer-  &quot;))
-		    prouts(_(&quot;ERROR-ERROR-ERROR-ERROR&quot;))
-		    skip(2)
-		    prouts(_(&quot;  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI&quot;))
-		    skip(2)
-		    prout(_(&quot;Now you can retire and write your own Star Trek game!&quot;))
-		    skip(1)
-		elif game.skill &gt;= SKILL_EXPERT:
-		    if game.thawed and not idebug:
-			prout(_(&quot;You cannot get a citation, so...&quot;))
-		    else:
-			proutn(_(&quot;Do you want your Commodore Emeritus Citation printed? &quot;))
-			chew()
-			if ja() == True:
-			    igotit = True
-	    # Only grant long life if alive (original didn't!)
-	    skip(1)
-	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
-	score()
-	if igotit:
-	    plaque()	    
-	return
-    elif ifin == FDEPLETE: # Federation Resources Depleted
-	prout(_(&quot;Your time has run out and the Federation has been&quot;))
-	prout(_(&quot;conquered.  Your starship is now Klingon property,&quot;))
-	prout(_(&quot;and you are put on trial as a war criminal.  On the&quot;))
-	proutn(_(&quot;basis of your record, you are &quot;))
-	if (game.state.remkl + game.state.remcom + game.state.nscrem)*3.0 &gt; (game.inkling + game.incom + game.inscom):
-	    prout(_(&quot;acquitted.&quot;))
-	    skip(1)
-	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
-	else:
-	    prout(_(&quot;found guilty and&quot;))
-	    prout(_(&quot;sentenced to death by slow torture.&quot;))
-	    game.alive = False
-	score()
-	return
-    elif ifin == FLIFESUP:
-	prout(_(&quot;Your life support reserves have run out, and&quot;))
-	prout(_(&quot;you die of thirst, starvation, and asphyxiation.&quot;))
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FNRG:
-	prout(_(&quot;Your energy supply is exhausted.&quot;))
-	skip(1)
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FBATTLE:
-	proutn(_(&quot;The &quot;))
-	crmshp()
-	prout(_(&quot; has been destroyed in battle.&quot;))
-	skip(1)
-	prout(_(&quot;Dulce et decorum est pro patria mori.&quot;))
-    elif ifin == FNEG3:
-	prout(_(&quot;You have made three attempts to cross the negative energy&quot;))
-	prout(_(&quot;barrier which surrounds the galaxy.&quot;))
-	skip(1)
-	prout(_(&quot;Your navigation is abominable.&quot;))
-	score()
-    elif ifin == FNOVA:
-	prout(_(&quot;Your starship has been destroyed by a nova.&quot;))
-	prout(_(&quot;That was a great shot.&quot;))
-	skip(1)
-    elif ifin == FSNOVAED:
-	proutn(_(&quot;The &quot;))
-	crmshp()
-	prout(_(&quot; has been fried by a supernova.&quot;))
-	prout(_(&quot;...Not even cinders remain...&quot;))
-    elif ifin == FABANDN:
-	prout(_(&quot;You have been captured by the Klingons. If you still&quot;))
-	prout(_(&quot;had a starbase to be returned to, you would have been&quot;))
-	prout(_(&quot;repatriated and given another chance. Since you have&quot;))
-	prout(_(&quot;no starbases, you will be mercilessly tortured to death.&quot;))
-    elif ifin == FDILITHIUM:
-	prout(_(&quot;Your starship is now an expanding cloud of subatomic particles&quot;))
-    elif ifin == FMATERIALIZE:
-	prout(_(&quot;Starbase was unable to re-materialize your starship.&quot;))
-	prout(_(&quot;Sic transit gloria mundi&quot;))
-    elif ifin == FPHASER:
-	proutn(_(&quot;The &quot;))
-	crmshp()
-	prout(_(&quot; has been cremated by its own phasers.&quot;))
-    elif ifin == FLOST:
-	prout(_(&quot;You and your landing party have been&quot;))
-	prout(_(&quot;converted to energy, disipating through space.&quot;))
-    elif ifin == FMINING:
-	prout(_(&quot;You are left with your landing party on&quot;))
-	prout(_(&quot;a wild jungle planet inhabited by primitive cannibals.&quot;))
-	skip(1)
-	prout(_(&quot;They are very fond of \&quot;Captain Kirk\&quot; soup.&quot;))
-	skip(1)
-	proutn(_(&quot;Without your leadership, the &quot;))
-	crmshp()
-	prout(_(&quot; is destroyed.&quot;))
-    elif ifin == FDPLANET:
-	prout(_(&quot;You and your mining party perish.&quot;))
-	skip(1)
-	prout(_(&quot;That was a great shot.&quot;))
-	skip(1)
-    elif ifin == FSSC:
-	prout(_(&quot;The Galileo is instantly annihilated by the supernova.&quot;))
-	prout(_(&quot;You and your mining party are atomized.&quot;))
-	skip(1)
-	proutn(_(&quot;Mr. Spock takes command of the &quot;))
-	crmshp()
-	prout(_(&quot; and&quot;))
-	prout(_(&quot;joins the Romulans, reigning terror on the Federation.&quot;))
-    elif ifin == FPNOVA:
-	prout(_(&quot;You and your mining party are atomized.&quot;))
-	skip(1)
-	proutn(_(&quot;Mr. Spock takes command of the &quot;))
-	crmshp()
-	prout(_(&quot; and&quot;))
-	prout(_(&quot;joins the Romulans, reigning terror on the Federation.&quot;))
-    elif ifin == FSTRACTOR:
-	prout(_(&quot;The shuttle craft Galileo is also caught,&quot;))
-	prout(_(&quot;and breaks up under the strain.&quot;))
-	skip(1)
-	prout(_(&quot;Your debris is scattered for millions of miles.&quot;))
-	proutn(_(&quot;Without your leadership, the &quot;))
-	crmshp()
-	prout(_(&quot; is destroyed.&quot;))
-    elif ifin == FDRAY:
-	prout(_(&quot;The mutants attack and kill Spock.&quot;))
-	prout(_(&quot;Your ship is captured by Klingons, and&quot;))
-	prout(_(&quot;your crew is put on display in a Klingon zoo.&quot;))
-    elif ifin == FTRIBBLE:
-	prout(_(&quot;Tribbles consume all remaining water,&quot;))
-	prout(_(&quot;food, and oxygen on your ship.&quot;))
-	skip(1)
-	prout(_(&quot;You die of thirst, starvation, and asphyxiation.&quot;))
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FHOLE:
-	prout(_(&quot;Your ship is drawn to the center of the black hole.&quot;))
-	prout(_(&quot;You are crushed into extremely dense matter.&quot;))
-    elif ifin == FCREW:
-	prout(_(&quot;Your last crew member has died.&quot;))
-    if game.ship == IHF:
-	game.ship = None
-    elif game.ship == IHE:
-	game.ship = IHF
-    game.alive = False
-    if (game.state.remkl + game.state.remcom + game.state.nscrem) != 0:
-	goodies = game.state.remres/game.inresor
-	baddies = (game.state.remkl + 2.0*game.state.remcom)/(game.inkling+2.0*game.incom)
-	if goodies/baddies &gt;= randreal(1.0, 1.5):
-	    prout(_(&quot;As a result of your actions, a treaty with the Klingon&quot;))
-	    prout(_(&quot;Empire has been signed. The terms of the treaty are&quot;))
-	    if goodies/baddies &gt;= randreal(3.0):
-		prout(_(&quot;favorable to the Federation.&quot;))
-		skip(1)
-		prout(_(&quot;Congratulations!&quot;))
-	    else:
-		prout(_(&quot;highly unfavorable to the Federation.&quot;))
-	else:
-	    prout(_(&quot;The Federation will be destroyed.&quot;))
-    else:
-	prout(_(&quot;Since you took the last Klingon with you, you are a&quot;))
-	prout(_(&quot;martyr and a hero. Someday maybe they'll erect a&quot;))
-	prout(_(&quot;statue in your memory. Rest in peace, and try not&quot;))
-	prout(_(&quot;to think about pigeons.&quot;))
-	game.gamewon = True
-    score()
-
-def score():
-    # compute player's score 
-    timused = game.state.date - game.indate
-    iskill = game.skill
-    if (timused == 0 or (game.state.remkl + game.state.remcom + game.state.nscrem) != 0) and timused &lt; 5.0:
-	timused = 5.0
-    perdate = killrate()
-    ithperd = 500*perdate + 0.5
-    iwon = 0
-    if game.gamewon:
-	iwon = 100*game.skill
-    if game.ship == IHE: 
-	klship = 0
-    elif game.ship == IHF: 
-	klship = 1
-    else:
-	klship = 2
-    if not game.gamewon:
-	game.state.nromrem = 0 # None captured if no win
-    iscore = 10*(game.inkling - game.state.remkl) \
-             + 50*(game.incom - game.state.remcom) \
-             + ithperd + iwon \
-             + 20*(game.inrom - game.state.nromrem) \
-             + 200*(game.inscom - game.state.nscrem) \
-    	     - game.state.nromrem \
-             - badpoints()
-    if not game.alive:
-	iscore -= 200
-    skip(2)
-    prout(_(&quot;Your score --&quot;))
-    if game.inrom - game.state.nromrem:
-	prout(_(&quot;%6d Romulans destroyed                 %5d&quot;) %
-	      (game.inrom - game.state.nromrem, 20*(game.inrom - game.state.nromrem)))
-    if game.state.nromrem:
-	prout(_(&quot;%6d Romulans captured                  %5d&quot;) %
-	      (game.state.nromrem, game.state.nromrem))
-    if game.inkling - game.state.remkl:
-	prout(_(&quot;%6d ordinary Klingons destroyed        %5d&quot;) %
-	      (game.inkling - game.state.remkl, 10*(game.inkling - game.state.remkl)))
-    if game.incom - game.state.remcom:
-	prout(_(&quot;%6d Klingon commanders destroyed       %5d&quot;) %
-	      (game.incom - game.state.remcom, 50*(game.incom - game.state.remcom)))
-    if game.inscom - game.state.nscrem:
-	prout(_(&quot;%6d Super-Commander destroyed          %5d&quot;) %
-	      (game.inscom - game.state.nscrem, 200*(game.inscom - game.state.nscrem)))
-    if ithperd:
-	prout(_(&quot;%6.2f Klingons per stardate              %5d&quot;) %
-	      (perdate, ithperd))
-    if game.state.starkl:
-	prout(_(&quot;%6d stars destroyed by your action     %5d&quot;) %
-	      (game.state.starkl, -5*game.state.starkl))
-    if game.state.nplankl:
-	prout(_(&quot;%6d planets destroyed by your action   %5d&quot;) %
-	      (game.state.nplankl, -10*game.state.nplankl))
-    if (game.options &amp; OPTION_WORLDS) and game.state.nworldkl:
-	prout(_(&quot;%6d inhabited planets destroyed by your action   %5d&quot;) %
-	      (game.state.nplankl, -300*game.state.nworldkl))
-    if game.state.basekl:
-	prout(_(&quot;%6d bases destroyed by your action     %5d&quot;) %
-	      (game.state.basekl, -100*game.state.basekl))
-    if game.nhelp:
-	prout(_(&quot;%6d calls for help from starbase       %5d&quot;) %
-	      (game.nhelp, -45*game.nhelp))
-    if game.casual:
-	prout(_(&quot;%6d casualties incurred                %5d&quot;) %
-	      (game.casual, -game.casual))
-    if game.abandoned:
-	prout(_(&quot;%6d crew abandoned in space            %5d&quot;) %
-	      (game.abandoned, -3*game.abandoned))
-    if klship:
-	prout(_(&quot;%6d ship(s) lost or destroyed          %5d&quot;) %
-	      (klship, -100*klship))
-    if not game.alive:
-	prout(_(&quot;Penalty for getting yourself killed        -200&quot;))
-    if game.gamewon:
-	proutn(_(&quot;Bonus for winning &quot;))
-	if game.skill   == SKILL_NOVICE:	proutn(_(&quot;Novice game  &quot;))
-	elif game.skill == SKILL_FAIR:  	proutn(_(&quot;Fair game    &quot;))
-	elif game.skill ==  SKILL_GOOD: 	proutn(_(&quot;Good game    &quot;))
-	elif game.skill ==  SKILL_EXPERT:	proutn(_(&quot;Expert game  &quot;))
-	elif game.skill ==  SKILL_EMERITUS:	proutn(_(&quot;Emeritus game&quot;))
-	prout(&quot;           %5d&quot; % iwon)
-    skip(1)
-    prout(_(&quot;TOTAL SCORE                               %5d&quot;) % iscore)
-
-def plaque():
-    # emit winner's commemmorative plaque 
-    skip(2)
-    while True:
-        proutn(_(&quot;File or device name for your plaque: &quot;))
-        winner = cgetline()
-        try:
-            fp = open(winner, &quot;w&quot;)
-            break
-        except IOError:
-            prout(_(&quot;Invalid name.&quot;))
-
-    proutn(_(&quot;Enter name to go on plaque (up to 30 characters): &quot;))
-    winner = cgetline()
-    # The 38 below must be 64 for 132-column paper 
-    nskip = 38 - len(winner)/2
-    fp.write(&quot;\n\n\n\n&quot;)
-    # --------DRAW ENTERPRISE PICTURE. 
-    fp.write(&quot;                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot; )
-    fp.write(&quot;                                      EEE                      E  : :                                         :  E\n&quot; )
-    fp.write(&quot;                                    EE   EEE                   E  : :                   NCC-1701              :  E\n&quot;)
-    fp.write(&quot;EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n&quot;)
-    fp.write(&quot; E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
-    fp.write(&quot;                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n&quot;)
-    fp.write(&quot;                               EEEEEEE   EEEEE    E          E              E  E\n&quot;)
-    fp.write(&quot;                                      EEE           E          E            E  E\n&quot;)
-    fp.write(&quot;                                                       E         E          E  E\n&quot;)
-    fp.write(&quot;                                                         EEEEEEEEEEEEE      E  E\n&quot;)
-    fp.write(&quot;                                                      EEE :           EEEEEEE  EEEEEEEE\n&quot;)
-    fp.write(&quot;                                                    :E    :                 EEEE       E\n&quot;)
-    fp.write(&quot;                                                   .-E   -:-----                       E\n&quot;)
-    fp.write(&quot;                                                    :E    :                            E\n&quot;)
-    fp.write(&quot;                                                      EE  :                    EEEEEEEE\n&quot;)
-    fp.write(&quot;                                                       EEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
-    fp.write(&quot;\n\n\n&quot;)
-    fp.write(_(&quot;                                                       U. S. S. ENTERPRISE\n&quot;))
-    fp.write(&quot;\n\n\n\n&quot;)
-    fp.write(_(&quot;                                  For demonstrating outstanding ability as a starship captain\n&quot;))
-    fp.write(&quot;\n&quot;)
-    fp.write(_(&quot;                                                Starfleet Command bestows to you\n&quot;))
-    fp.write(&quot;\n&quot;)
-    fp.write(&quot;%*s%s\n\n&quot; % (nskip, &quot;&quot;, winner))
-    fp.write(_(&quot;                                                           the rank of\n\n&quot;))
-    fp.write(_(&quot;                                                       \&quot;Commodore Emeritus\&quot;\n\n&quot;))
-    fp.write(&quot;                                                          &quot;)
-    if game.skill ==  SKILL_EXPERT:
-        fp.write(_(&quot; Expert level\n\n&quot;))
-    elif game.skill == SKILL_EMERITUS:
-        fp.write(_(&quot;Emeritus level\n\n&quot;))
-    else:
-        fp.write(_(&quot; Cheat level\n\n&quot;))
-    timestring = ctime()
-    fp.write(_(&quot;                                                 This day of %.6s %.4s, %.8s\n\n&quot;) %
-                    (timestring+4, timestring+20, timestring+11))
-    fp.write(_(&quot;                                                        Your score:  %d\n\n&quot;) % iscore)
-    fp.write(_(&quot;                                                    Klingons per stardate:  %.2f\n&quot;) % perdate)
-    fp.close()
-
-# Code from io.c begins here
-
-rows = linecount = 0	# for paging 
-stdscr = None
-replayfp = None
-fullscreen_window = None
-srscan_window     = None
-report_window     = None
-status_window     = None
-lrscan_window     = None
-message_window    = None
-prompt_window     = None
-curwnd = None
-
-def outro():
-    &quot;wrap up, either normally or due to signal&quot;
-    if game.options &amp; OPTION_CURSES:
-	#clear()
-	#curs_set(1)
-	#refresh()
-	#resetterm()
-	#echo()
-	curses.endwin()
-	sys.stdout.write('\n')
-    if logfp:
-	logfp.close()
-
-def iostart():
-    global stdscr, rows
-    #setlocale(LC_ALL, &quot;&quot;)
-    #bindtextdomain(PACKAGE, LOCALEDIR)
-    #textdomain(PACKAGE)
-    if atexit.register(outro):
-	sys.stderr.write(&quot;Unable to register outro(), exiting...\n&quot;)
-	raise SysExit,1
-    if not (game.options &amp; OPTION_CURSES):
-	ln_env = os.getenv(&quot;LINES&quot;)
-        if ln_env:
-            rows = ln_env
-        else:
-            rows = 25
-    else:
-	stdscr = curses.initscr()
-	stdscr.keypad(True)
-	#saveterm()
-	curses.nonl()
-	curses.cbreak()
-        curses.start_color()
-        curses.init_pair(curses.COLOR_BLACK, curses.COLOR_BLACK, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_GREEN, curses.COLOR_GREEN, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_RED, curses.COLOR_RED, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_CYAN, curses.COLOR_CYAN, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_WHITE, curses.COLOR_WHITE, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_BLUE, curses.COLOR_BLUE, curses.COLOR_BLACK)
-        curses.init_pair(curses.COLOR_YELLOW, curses.COLOR_YELLOW, curses.COLOR_BLACK)
-	#noecho()
-        global fullscreen_window, srscan_window, report_window, status_window
-        global lrscan_window, message_window, prompt_window
-        (rows, columns)   = stdscr.getmaxyx()
-	fullscreen_window = stdscr
-	srscan_window     = curses.newwin(12, 25, 0,       0)
-	report_window     = curses.newwin(11, 0,  1,       25)
-	status_window     = curses.newwin(10, 0,  1,       39)
-	lrscan_window     = curses.newwin(5,  0,  0,       64) 
-	message_window    = curses.newwin(0,  0,  12,      0)
-	prompt_window     = curses.newwin(1,  0,  rows-2,  0) 
-	message_window.scrollok(True)
-	setwnd(fullscreen_window)
-	textcolor(DEFAULT)
-
-def textcolor(color):
-    &quot;Set text foreground color.  Presently a stub.&quot;
-    pass	# FIXME
-
-def ioend():
-    &quot;Wrap up I/O.  Presently a stub.&quot;
-    pass
-
-def waitfor():
-    &quot;Wait for user action -- OK to do nothing if on a TTY&quot;
-    if game.options &amp; OPTION_CURSES:
-	stsdcr.getch()
-
-def announce():
-    skip(1)
-    if game.skill &gt; SKILL_FAIR:
-	prouts(_(&quot;[ANOUNCEMENT ARRIVING...]&quot;))
-    else:
-	prouts(_(&quot;[IMPORTANT ANNOUNCEMENT ARRIVING -- PRESS ENTER TO CONTINUE]&quot;))
-    skip(1)
-
-def pause_game():
-    if game.skill &gt; SKILL_FAIR:
-        prompt = _(&quot;[CONTINUE?]&quot;)
-    else:
-        prompt = _(&quot;[PRESS ENTER TO CONTINUE]&quot;)
-
-    if game.options &amp; OPTION_CURSES:
-        drawmaps(0)
-        setwnd(prompt_window)
-        prompt_window.wclear()
-        prompt_window.addstr(prompt)
-        prompt_window.getstr()
-        prompt_window.clear()
-        prompt_window.refresh()
-        setwnd(message_window)
-    else:
-        global linecount
-        sys.stdout.write('\n')
-        proutn(prompt)
-        raw_input()
-        for j in range(rows):
-            sys.stdout.write('\n')
-        linecount = 0
-
-def skip(i):
-    &quot;Skip i lines.  Pause game if this would cause a scrolling event.&quot;
-    for dummy in range(i):
-	if game.options &amp; OPTION_CURSES:
-            (y, x) = curwnd.getyx()
-            (my, mx) = curwnd.getmaxyx()
-	    if curwnd == message_window and y &gt;= my - 3:
-		pause_game()
-		clrscr()
-	    else:
-		proutn(&quot;\n&quot;)
-	else:
-            global linecount
-	    linecount += 1
-	    if rows and linecount &gt;= rows:
-		pause_game()
-	    else:
-		sys.stdout.write('\n')
-
-def proutn(line):
-    &quot;Utter a line with no following line feed.&quot;
-    if game.options &amp; OPTION_CURSES:
-	curwnd.addstr(line)
-	curwnd.refresh()
-    else:
-	sys.stdout.write(line)
-        sys.stdout.flush()
-
-def prout(line):
-    proutn(line)
-    skip(1)
-
-def prouts(line):
-    &quot;print slowly!&quot; 
-    for c in line:
-        if not replayfp or replayfp.closed:	# Don't slow down replays
-            time.sleep(0.03)
-	proutn(c)
-	if game.options &amp; OPTION_CURSES:
-	    wrefresh(curwnd)
-	else:
-	    sys.stdout.flush()
-    if not replayfp or replayfp.closed:
-        time.sleep(0.03)
-
-def cgetline():
-    &quot;Get a line of input.&quot;
-    if game.options &amp; OPTION_CURSES:
-	line = curwnd.getstr() + &quot;\n&quot;
-	curwnd.refresh()
-    else:
-	if replayfp and not replayfp.closed:
-            while True:
-                line = replayfp.readline()
-                proutn(line)
-                if line == '':
-                    prout(&quot;*** Replay finished&quot;)
-                    replayfp.close()
-                    break
-                elif line[0] != &quot;#&quot;:
-                    break
-	else:
-	    line = raw_input() + &quot;\n&quot;
-    if logfp:
-	logfp.write(line)
-    return line
-
-def setwnd(wnd):
-    &quot;Change windows -- OK for this to be a no-op in tty mode.&quot;
-    global curwnd
-    if game.options &amp; OPTION_CURSES:
-        curwnd = wnd
-        curses.curs_set(wnd == fullscreen_window or wnd == message_window or wnd == prompt_window)
-
-def clreol():
-    &quot;Clear to end of line -- can be a no-op in tty mode&quot; 
-    if game.options &amp; OPTION_CURSES:
-        wclrtoeol(curwnd)
-        wrefresh(curwnd)
-
-def clrscr():
-    &quot;Clear screen -- can be a no-op in tty mode.&quot;
-    global linecount
-    if game.options &amp; OPTION_CURSES:
-       curwnd.clear()
-       curwnd.move(0, 0)
-       curwnd.refresh()
-    linecount = 0
-    
-def highvideo():
-    &quot;Set highlight video, if this is reasonable.&quot;
-    if game.options &amp; OPTION_CURSES:
-	curwnd.attron(curses.A_REVERSE)
- 
-#
-# Things past this point have policy implications.
-# 
-
-def drawmaps(mode):
-    &quot;Hook to be called after moving to redraw maps.&quot;
-    if game.options &amp; OPTION_CURSES:
-	if mode == 1:
-	    sensor()
-        setwnd(srscan_window)
-        curwnd.move(0, 0)
-        srscan()
-	if mode != 2:
-	    setwnd(status_window)
-	    status_window.clear()
-	    status_window.move(0, 0)
-	    setwnd(report_window)
-	    report_window.clear()
-	    report_window.move(0, 0)
-	    status()
-	    setwnd(lrscan_window)
-	    lrscan_window.clear()
-	    lrscan_window.move(0, 0)
-	    lrscan(silent=False)
-
-def put_srscan_sym(w, sym):
-    &quot;Emit symbol for short-range scan.&quot;
-    srscan_window.move(w.x+1, w.y*2+2)
-    srscan_window.addch(sym)
-    srscan_window.refresh()
-
-def boom(w):
-    &quot;Enemy fall down, go boom.&quot;  
-    if game.options &amp; OPTION_CURSES:
-	drawmaps(2)
-	setwnd(srscan_window)
-	srscan_window.attron(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.x][w.y])
-	#sound(500)
-	#time.sleep(1.0)
-	#nosound()
-	srscan_window.attroff(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.x][w.y])
-	curses.delay_output(500)
-	setwnd(message_window) 
-
-def warble():
-    &quot;Sound and visual effects for teleportation.&quot;
-    if game.options &amp; OPTION_CURSES:
-	drawmaps(2)
-	setwnd(message_window)
-	#sound(50)
-    prouts(&quot;     . . . . .     &quot;)
-    if game.options &amp; OPTION_CURSES:
-	#curses.delay_output(1000)
-	#nosound()
-        pass
-
-def tracktorpedo(w, step, i, n, iquad):
-    &quot;Torpedo-track animation.&quot; 
-    if not game.options &amp; OPTION_CURSES:
-	if step == 1:
-	    if n != 1:
-		skip(1)
-		proutn(_(&quot;Track for torpedo number %d-  &quot;) % i)
-	    else:
-		skip(1)
-		proutn(_(&quot;Torpedo track- &quot;))
-	elif step==4 or step==9: 
-	    skip(1)
-	proutn(&quot;%s   &quot; % w)
-    else:
-	if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
-	    if i != 0 and step == 1:
-		drawmaps(2)
-		time.sleep(0.4)
-	    if (iquad==IHDOT) or (iquad==IHBLANK):
-		put_srscan_sym(w, '+')
-		#sound(step*10)
-		#time.sleep(0.1)
-		#nosound()
-		put_srscan_sym(w, iquad)
-	    else:
-		curwnd.attron(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-		#sound(500)
-		#time.sleep(1.0)
-		#nosound()
-		curwnd.attroff(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-	else:
-	    proutn(&quot;%s   &quot; % w)
-
-def makechart():
-    &quot;Display the current galaxy chart.&quot;
-    if game.options &amp; OPTION_CURSES:
-	setwnd(message_window)
-	message_window.clear()
-    chart()
-    if game.options &amp; OPTION_TTY:
-	skip(1)
-
-NSYM	= 14
-
-def prstat(txt, data):
-    proutn(txt)
-    if game.options &amp; OPTION_CURSES:
-	skip(1)
-	setwnd(status_window)
-    else:
-        proutn(&quot; &quot; * (NSYM - len(txt)))
-    proutn(data)
-    skip(1)
-    if game.options &amp; OPTION_CURSES:
-	setwnd(report_window)
-
-# Code from moving.c begins here
-
-def imove(novapush):
-    # movement execution for warp, impulse, supernova, and tractor-beam events 
-    w = coord(); final = coord()
-    trbeam = False
-
-    def no_quad_change():
-        # No quadrant change -- compute new average enemy distances 
-        game.quad[game.sector.x][game.sector.y] = game.ship
-        if len(game.enemies):
-            for m in range(len(game.enemies)):
-                finald = distance(w, game.enemies[m].kloc)
-                game.enemies[m].kavgd = 0.5 * (finald+game.enemies[m].kdist)
-                game.enemies[m].kdist = finald
-            game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-            if not game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-                attack(torps_ok=False)
-            for m in range(len(game.enemies)):
-                game.enemies[m].kavgd = game.enemies[m].kdist
-        newcnd()
-        drawmaps(0)
-        setwnd(message_window)
-    w.x = w.y = 0
-    if game.inorbit:
-	prout(_(&quot;Helmsman Sulu- \&quot;Leaving standard orbit.\&quot;&quot;))
-	game.inorbit = False
-    angle = ((15.0 - game.direc) * 0.5235988)
-    deltax = -math.sin(angle)
-    deltay = math.cos(angle)
-    if math.fabs(deltax) &gt; math.fabs(deltay):
-	bigger = math.fabs(deltax)
-    else:
-	bigger = math.fabs(deltay)
-    deltay /= bigger
-    deltax /= bigger
-    # If tractor beam is to occur, don't move full distance 
-    if game.state.date+game.optime &gt;= scheduled(FTBEAM):
-	trbeam = True
-	game.condition = &quot;red&quot;
-	game.dist = game.dist*(scheduled(FTBEAM)-game.state.date)/game.optime + 0.1
-	game.optime = scheduled(FTBEAM) - game.state.date + 1e-5
-    # Move within the quadrant 
-    game.quad[game.sector.x][game.sector.y] = IHDOT
-    x = game.sector.x
-    y = game.sector.y
-    n = int(10.0*game.dist*bigger+0.5)
-    if n &gt; 0:
-	for m in range(1, n+1):
-            x += deltax
-            y += deltay
-	    w.x = int(round(x))
-	    w.y = int(round(y))
-	    if not VALID_SECTOR(w.x, w.y):
-		# Leaving quadrant -- allow final enemy attack 
-		# Don't do it if being pushed by Nova 
-		if len(game.enemies) != 0 and not novapush:
-		    newcnd()
-		    for m in range(len(game.enemies)):
-			finald = distance(w, game.enemies[m].kloc)
-			game.enemies[m].kavgd = 0.5 * (finald + game.enemies[m].kdist)
-		    #
-		    # Stas Sergeev added the condition
-		    # that attacks only happen if Klingons
-		    # are present and your skill is good.
-		    # 
-		    if game.skill &gt; SKILL_GOOD and game.klhere &gt; 0 and not game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-			attack(torps_ok=False)
-		    if game.alldone:
-			return
-		# compute final position -- new quadrant and sector 
-		x = (QUADSIZE*game.quadrant.x)+game.sector.x
-		y = (QUADSIZE*game.quadrant.y)+game.sector.y
-		w.x = int(round(x+10.0*game.dist*bigger*deltax))
-		w.y = int(round(y+10.0*game.dist*bigger*deltay))
-		# check for edge of galaxy 
-		kinks = 0
-                while True:
-		    kink = False
-		    if w.x &lt; 0:
-			w.x = -w.x
-			kink = True
-		    if w.y &lt; 0:
-			w.y = -w.y
-			kink = True
-		    if w.x &gt;= GALSIZE*QUADSIZE:
-			w.x = (GALSIZE*QUADSIZE*2) - w.x
-			kink = True
-		    if w.y &gt;= GALSIZE*QUADSIZE:
-			w.y = (GALSIZE*QUADSIZE*2) - w.y
-			kink = True
-		    if kink:
-			kinks += 1
-                    else:
-                        break
-		if kinks:
-		    game.nkinks += 1
-		    if game.nkinks == 3:
-			# Three strikes -- you're out! 
-			finish(FNEG3)
-			return
-		    skip(1)
-		    prout(_(&quot;YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER&quot;))
-		    prout(_(&quot;AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,&quot;))
-		    prout(_(&quot;YOU WILL BE DESTROYED.&quot;))
-		# Compute final position in new quadrant 
-		if trbeam: # Don't bother if we are to be beamed 
-		    return
-		game.quadrant.x = w.x/QUADSIZE
-		game.quadrant.y = w.y/QUADSIZE
-		game.sector.x = w.x - (QUADSIZE*game.quadrant.x)
-		game.sector.y = w.y - (QUADSIZE*game.quadrant.y)
-		skip(1)
-		prout(_(&quot;Entering Quadrant %s.&quot;) % game.quadrant)
-		game.quad[game.sector.x][game.sector.y] = game.ship
-		newqad(False)
-		if game.skill&gt;SKILL_NOVICE:
-		    attack(torps_ok=False)  
-		return
-	    iquad = game.quad[w.x][w.y]
-	    if iquad != IHDOT:
-		# object encountered in flight path 
-		stopegy = 50.0*game.dist/game.optime
-		game.dist = distance(game.sector, w) / (QUADSIZE * 1.0)
-                if iquad in (IHT, IHK, IHC, IHS, IHR, IHQUEST):
-		    game.sector = w
-                    for enemy in game.enemies:
-                        if enemy.kloc == game.sector:
-                            break
-		    collision(rammed=False, enemy=enemy)
-		    final = game.sector
-		elif iquad == IHBLANK:
-		    skip(1)
-		    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-		    skip(1)
-		    proutn(&quot;***&quot;)
-		    crmshp()
-		    proutn(_(&quot; pulled into black hole at Sector %s&quot;) % w)
-		    #
-		    # Getting pulled into a black hole was certain
-		    # death in Almy's original.  Stas Sergeev added a
-		    # possibility that you'll get timewarped instead.
-		    # 
-		    n=0
-		    for m in range(NDEVICES):
-			if game.damage[m]&gt;0: 
-			    n += 1
-		    probf=math.pow(1.4,(game.energy+game.shield)/5000.0-1.0)*math.pow(1.3,1.0/(n+1)-1.0)
-		    if (game.options &amp; OPTION_BLKHOLE) and withprob(1-probf): 
-			timwrp()
-		    else: 
-			finish(FHOLE)
-		    return
-		else:
-		    # something else 
-		    skip(1)
-		    crmshp()
-		    if iquad == IHWEB:
-			proutn(_(&quot; encounters Tholian web at %s;&quot;) % w)
-		    else:
-			proutn(_(&quot; blocked by object at %s;&quot;) % w)
-		    proutn(_(&quot;Emergency stop required &quot;))
-		    prout(_(&quot;%2d units of energy.&quot;) % int(stopegy))
-		    game.energy -= stopegy
-		    final.x = x-deltax+0.5
-		    final.y = y-deltay+0.5
-		    game.sector = final
-		    if game.energy &lt;= 0:
-			finish(FNRG)
-			return
-                # We're here!
-		no_quad_change()
-                return
-	game.dist = distance(game.sector, w) / (QUADSIZE * 1.0)
-	game.sector = w
-    final = game.sector
-    no_quad_change()
-    return
-
-def dock(verbose):
-    # dock our ship at a starbase 
-    chew()
-    if game.condition == &quot;docked&quot; and verbose:
-	prout(_(&quot;Already docked.&quot;))
-	return
-    if game.inorbit:
-	prout(_(&quot;You must first leave standard orbit.&quot;))
-	return
-    if not is_valid(game.base) or abs(game.sector.x-game.base.x) &gt; 1 or abs(game.sector.y-game.base.y) &gt; 1:
-	crmshp()
-	prout(_(&quot; not adjacent to base.&quot;))
-	return
-    game.condition = &quot;docked&quot;
-    if &quot;verbose&quot;:
-	prout(_(&quot;Docked.&quot;))
-    game.ididit = True
-    if game.energy &lt; game.inenrg:
-	game.energy = game.inenrg
-    game.shield = game.inshld
-    game.torps = game.intorps
-    game.lsupres = game.inlsr
-    game.state.crew = FULLCREW
-    if not damaged(DRADIO) and \
-	((is_scheduled(FCDBAS) or game.isatb == 1) and not game.iseenit):
-	# get attack report from base 
-	prout(_(&quot;Lt. Uhura- \&quot;Captain, an important message from the starbase:\&quot;&quot;))
-	attackreport(False)
-	game.iseenit = True
- 
-# This program originally required input in terms of a (clock)
-# direction and distance. Somewhere in history, it was changed to
-# cartesian coordinates. So we need to convert.  Probably
-# &quot;manual&quot; input should still be done this way -- it's a real
-# pain if the computer isn't working! Manual mode is still confusing
-# because it involves giving x and y motions, yet the coordinates
-# are always displayed y - x, where +y is downward!
-
-def getcourse(isprobe, akey):
-    # get course and distance
-    key = 0
-    dquad = copy.copy(game.quadrant)
-    navmode = &quot;unspecified&quot;
-    itemp = &quot;curt&quot;
-    dsect = coord()
-    iprompt = False
-    if game.landed and not isprobe:
-	prout(_(&quot;Dummy! You can't leave standard orbit until you&quot;))
-	proutn(_(&quot;are back aboard the ship.&quot;))
-	chew()
-	return False
-    while navmode == &quot;unspecified&quot;:
-	if damaged(DNAVSYS):
-	    if isprobe:
-		prout(_(&quot;Computer damaged; manual navigation only&quot;))
-	    else:
-		prout(_(&quot;Computer damaged; manual movement only&quot;))
-	    chew()
-	    navmode = &quot;manual&quot;
-	    key = IHEOL
-	    break
-	if isprobe and akey != -1:
-	    # For probe launch, use pre-scanned value first time 
-	    key = akey
-	    akey = -1
-	else: 
-	    key = scan()
-	if key == IHEOL:
-	    proutn(_(&quot;Manual or automatic- &quot;))
-	    iprompt = True
-	    chew()
-	elif key == IHALPHA:
-            if isit(&quot;manual&quot;):
-		navmode = &quot;manual&quot;
-		key = scan()
-		break
-            elif isit(&quot;automatic&quot;):
-		navmode = &quot;automatic&quot;
-		key = scan()
-		break
-	    else:
-		huh()
-		chew()
-		return False
-	else: # numeric 
-	    if isprobe:
-		prout(_(&quot;(Manual navigation assumed.)&quot;))
-	    else:
-		prout(_(&quot;(Manual movement assumed.)&quot;))
-	    navmode = &quot;manual&quot;
-	    break
-    if navmode == &quot;automatic&quot;:
-	while key == IHEOL:
-	    if isprobe:
-		proutn(_(&quot;Target quadrant or quadrant&amp;sector- &quot;))
-	    else:
-		proutn(_(&quot;Destination sector or quadrant&amp;sector- &quot;))
-	    chew()
-	    iprompt = True
-	    key = scan()
-	if key != IHREAL:
-	    huh()
-	    return False
-	xi = int(round(aaitem))-1
-	key = scan()
-	if key != IHREAL:
-	    huh()
-	    return False
-	xj = int(round(aaitem))-1
-	key = scan()
-	if key == IHREAL:
-	    # both quadrant and sector specified 
-	    xk = int(round(aaitem))-1
-	    key = scan()
-	    if key != IHREAL:
-		huh()
-		return False
-	    xl = int(round(aaitem))-1
-	    dquad.x = xi
-	    dquad.y = xj
-	    dsect.y = xk
-	    dsect.x = xl
-	else:
-            # only one pair of numbers was specified
-	    if isprobe:
-		# only quadrant specified -- go to center of dest quad 
-		dquad.x = xi
-		dquad.y = xj
-		dsect.y = dsect.x = 4	# preserves 1-origin behavior
-	    else:
-                # only sector specified
-		dsect.y = xi
-		dsect.x = xj
-	    itemp = &quot;normal&quot;
-	if not VALID_QUADRANT(dquad.y,dquad.x) or not VALID_SECTOR(dsect.x,dsect.y):
-	    huh()
-	    return False
-	skip(1)
-	if not isprobe:
-	    if itemp &gt; &quot;curt&quot;:
-		if iprompt:
-		    prout(_(&quot;Helmsman Sulu- \&quot;Course locked in for Sector %s.\&quot;&quot;) % dsect)
-	    else:
-		prout(_(&quot;Ensign Chekov- \&quot;Course laid in, Captain.\&quot;&quot;))
-        # the actual deltas get computed here
-	deltax = dquad.y-game.quadrant.y + 0.1*(dsect.x-game.sector.y)
-	deltay = game.quadrant.x-dquad.x + 0.1*(game.sector.x-dsect.y)
-    else: # manual 
-	while key == IHEOL:
-	    proutn(_(&quot;X and Y displacements- &quot;))
-	    chew()
-	    iprompt = True
-	    key = scan()
-	itemp = &quot;verbose&quot;
-	if key != IHREAL:
-	    huh()
-	    return False
-	deltax = aaitem
-	key = scan()
-	if key != IHREAL:
-	    huh()
-	    return False
-	deltay = aaitem
-    # Check for zero movement 
-    if deltax == 0 and deltay == 0:
-	chew()
-	return False
-    if itemp == &quot;verbose&quot; and not isprobe:
-	skip(1)
-	prout(_(&quot;Helmsman Sulu- \&quot;Aye, Sir.\&quot;&quot;))
-    # Course actually laid in.
-    game.dist = math.sqrt(deltax*deltax + deltay*deltay)
-    game.direc = math.atan2(deltax, deltay)*1.90985932
-    if game.direc &lt; 0.0:
-	game.direc += 12.0
-    chew()
-    return True
-
-def impulse():
-    # move under impulse power 
-    game.ididit = False
-    if damaged(DIMPULS):
-	chew()
-	skip(1)
-	prout(_(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;))
-	return
-    if game.energy &gt; 30.0:
-        if not getcourse(isprobe=False, akey=0):
-	    return
-	power = 20.0 + 100.0*game.dist
-    else:
-	power = 30.0
-    if power &gt;= game.energy:
-	# Insufficient power for trip 
-	skip(1)
-	prout(_(&quot;First Officer Spock- \&quot;Captain, the impulse engines&quot;))
-	prout(_(&quot;require 20.0 units to engage, plus 100.0 units per&quot;))
-	if game.energy &gt; 30:
-	    proutn(_(&quot;quadrant.  We can go, therefore, a maximum of %d&quot;) %
-                     int(0.01 * (game.energy-20.0)-0.05))
-	    prout(_(&quot; quadrants.\&quot;&quot;))
-	else:
-	    prout(_(&quot;quadrant.  They are, therefore, useless.\&quot;&quot;))
-	chew()
-	return
-    # Make sure enough time is left for the trip 
-    game.optime = game.dist/0.095
-    if game.optime &gt;= game.state.remtime:
-	prout(_(&quot;First Officer Spock- \&quot;Captain, our speed under impulse&quot;))
-	prout(_(&quot;power is only 0.95 sectors per stardate. Are you sure&quot;))
-	proutn(_(&quot;we dare spend the time?\&quot; &quot;))
-	if ja() == False:
-	    return
-    # Activate impulse engines and pay the cost 
-    imove(novapush=False)
-    game.ididit = True
-    if game.alldone:
-	return
-    power = 20.0 + 100.0*game.dist
-    game.energy -= power
-    game.optime = game.dist/0.095
-    if game.energy &lt;= 0:
-	finish(FNRG)
-    return
-
-def warp(timewarp):
-    # move under warp drive 
-    blooey = False; twarp = False
-    if not timewarp: # Not WARPX entry 
-	game.ididit = False
-	if game.damage[DWARPEN] &gt; 10.0:
-	    chew()
-	    skip(1)
-	    prout(_(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;))
-	    return
-	if damaged(DWARPEN) and game.warpfac &gt; 4.0:
-	    chew()
-	    skip(1)
-	    prout(_(&quot;Engineer Scott- \&quot;Sorry, Captain. Until this damage&quot;))
-	    prout(_(&quot;  is repaired, I can only give you warp 4.\&quot;&quot;))
-	    return
-       	# Read in course and distance 
-        if not getcourse(isprobe=False, akey=0):
-	    return
-	# Make sure starship has enough energy for the trip 
-	power = (game.dist+0.05)*game.warpfac*game.warpfac*game.warpfac*(game.shldup+1)
-	if power &gt;= game.energy:
-	    # Insufficient power for trip 
-	    game.ididit = False
-	    skip(1)
-	    prout(_(&quot;Engineering to bridge--&quot;))
-	    if not game.shldup or 0.5*power &gt; game.energy:
-		iwarp = math.pow((game.energy/(game.dist+0.05)), 0.333333333)
-		if iwarp &lt;= 0:
-		    prout(_(&quot;We can't do it, Captain. We don't have enough energy.&quot;))
-		else:
-		    proutn(_(&quot;We don't have enough energy, but we could do it at warp %d&quot;) % iwarp)
-		    if game.shldup:
-			prout(&quot;,&quot;)
-			prout(_(&quot;if you'll lower the shields.&quot;))
-		    else:
-			prout(&quot;.&quot;)
-	    else:
-		prout(_(&quot;We haven't the energy to go that far with the shields up.&quot;))
-	    return
-						
-	# Make sure enough time is left for the trip 
-	game.optime = 10.0*game.dist/game.wfacsq
-	if game.optime &gt;= 0.8*game.state.remtime:
-	    skip(1)
-	    prout(_(&quot;First Officer Spock- \&quot;Captain, I compute that such&quot;))
-	    proutn(_(&quot;  a trip would require approximately %2.0f&quot;) %
-		   (100.0*game.optime/game.state.remtime))
-	    prout(_(&quot; percent of our&quot;))
-	    proutn(_(&quot;  remaining time.  Are you sure this is wise?\&quot; &quot;))
-	    if ja() == False:
-		game.ididit = False
-		game.optime=0 
-		return
-    # Entry WARPX 
-    if game.warpfac &gt; 6.0:
-	# Decide if engine damage will occur
-        # ESR: Seems wrong. Probability of damage goes *down* with distance? 
-	prob = game.dist*square(6.0-game.warpfac)/66.666666666
-	if prob &gt; randreal():
-	    blooey = True
-	    game.dist = randreal(game.dist)
-	# Decide if time warp will occur 
-	if 0.5*game.dist*math.pow(7.0,game.warpfac-10.0) &gt; randreal():
-	    twarp = True
-	if idebug and game.warpfac==10 and not twarp:
-	    blooey = False
-	    proutn(&quot;=== Force time warp? &quot;)
-	    if ja() == True:
-		twarp = True
-	if blooey or twarp:
-	    # If time warp or engine damage, check path 
-	    # If it is obstructed, don't do warp or damage 
-	    angle = ((15.0-game.direc)*0.5235998)
-	    deltax = -math.sin(angle)
-	    deltay = math.cos(angle)
-	    if math.fabs(deltax) &gt; math.fabs(deltay):
-		bigger = math.fabs(deltax)
-	    else:
-		bigger = math.fabs(deltay)
-			
-	    deltax /= bigger
-	    deltay /= bigger
-	    n = 10.0 * game.dist * bigger +0.5
-	    x = game.sector.x
-	    y = game.sector.y
-	    for l in range(1, n+1):
-		x += deltax
-		ix = x + 0.5
-		y += deltay
-		iy = y +0.5
-		if not VALID_SECTOR(ix, iy):
-		    break
-		if game.quad[ix][iy] != IHDOT:
-		    blooey = False
-		    twarp = False
-    # Activate Warp Engines and pay the cost 
-    imove(novapush=False)
-    if game.alldone:
-	return
-    game.energy -= game.dist*game.warpfac*game.warpfac*game.warpfac*(game.shldup+1)
-    if game.energy &lt;= 0:
-	finish(FNRG)
-    game.optime = 10.0*game.dist/game.wfacsq
-    if twarp:
-	timwrp()
-    if blooey:
-	game.damage[DWARPEN] = game.damfac * randreal(1.0, 4.0)
-	skip(1)
-	prout(_(&quot;Engineering to bridge--&quot;))
-	prout(_(&quot;  Scott here.  The warp engines are damaged.&quot;))
-	prout(_(&quot;  We'll have to reduce speed to warp 4.&quot;))
-    game.ididit = True
-    return
-
-def setwarp():
-    # change the warp factor 	
-    while True:
-        key=scan()
-        if key != IHEOL:
-            break
-	chew()
-	proutn(_(&quot;Warp factor- &quot;))
-    chew()
-    if key != IHREAL:
-	huh()
-	return
-    if game.damage[DWARPEN] &gt; 10.0:
-	prout(_(&quot;Warp engines inoperative.&quot;))
-	return
-    if damaged(DWARPEN) and aaitem &gt; 4.0:
-	prout(_(&quot;Engineer Scott- \&quot;I'm doing my best, Captain,&quot;))
-	prout(_(&quot;  but right now we can only go warp 4.\&quot;&quot;))
-	return
-    if aaitem &gt; 10.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;Our top speed is warp 10, Captain.\&quot;&quot;))
-	return
-    if aaitem &lt; 1.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;We can't go below warp 1, Captain.\&quot;&quot;))
-	return
-    oldfac = game.warpfac
-    game.warpfac = aaitem
-    game.wfacsq=game.warpfac*game.warpfac
-    if game.warpfac &lt;= oldfac or game.warpfac &lt;= 6.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;Warp factor %d, Captain.\&quot;&quot;) %
-	       int(game.warpfac))
-	return
-    if game.warpfac &lt; 8.00:
-	prout(_(&quot;Engineer Scott- \&quot;Aye, but our maximum safe speed is warp 6.\&quot;&quot;))
-	return
-    if game.warpfac == 10.0:
-	prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, we'll try it.\&quot;&quot;))
-	return
-    prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, but our engines may not take it.\&quot;&quot;))
-    return
-
-def atover(igrab):
-    # cope with being tossed out of quadrant by supernova or yanked by beam 
-    chew()
-    # is captain on planet? 
-    if game.landed:
-	if damaged(DTRANSP):
-	    finish(FPNOVA)
-	    return
-	prout(_(&quot;Scotty rushes to the transporter controls.&quot;))
-	if game.shldup:
-	    prout(_(&quot;But with the shields up it's hopeless.&quot;))
-	    finish(FPNOVA)
-	prouts(_(&quot;His desperate attempt to rescue you . . .&quot;))
-	if withprob(0.5):
-	    prout(_(&quot;fails.&quot;))
-	    finish(FPNOVA)
-	    return
-	prout(_(&quot;SUCCEEDS!&quot;))
-	if game.imine:
-	    game.imine = False
-	    proutn(_(&quot;The crystals mined were &quot;))
-	    if withprob(0.25):
-		prout(_(&quot;lost.&quot;))
-	    else:
-		prout(_(&quot;saved.&quot;))
-		game.icrystl = True
-    if igrab:
-	return
-    # Check to see if captain in shuttle craft 
-    if game.icraft:
-	finish(FSTRACTOR)
-    if game.alldone:
-	return
-    # Inform captain of attempt to reach safety 
-    skip(1)
-    while True:
-	if game.justin:
-	    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	    skip(1)
-	    proutn(_(&quot;The &quot;))
-	    crmshp()
-	    prout(_(&quot; has stopped in a quadrant containing&quot;))
-	    prouts(_(&quot;   a supernova.&quot;))
-	    skip(2)
-	proutn(_(&quot;***Emergency automatic override attempts to hurl &quot;))
-	crmshp()
-	skip(1)
-	prout(_(&quot;safely out of quadrant.&quot;))
-	if not damaged(DRADIO):
-	    game.state.galaxy[game.quadrant.x][game.quadrant.y].charted = True
-	# Try to use warp engines 
-	if damaged(DWARPEN):
-	    skip(1)
-	    prout(_(&quot;Warp engines damaged.&quot;))
-	    finish(FSNOVAED)
-	    return
-	game.warpfac = randreal(6.0, 8.0)
-	game.wfacsq = game.warpfac * game.warpfac
-	prout(_(&quot;Warp factor set to %d&quot;) % int(game.warpfac))
-	power = 0.75*game.energy
-	game.dist = power/(game.warpfac*game.warpfac*game.warpfac*(game.shldup+1))
-	distreq = randreal(math.sqrt(2))
-	if distreq &lt; game.dist:
-	    game.dist = distreq
-	game.optime = 10.0*game.dist/game.wfacsq
-	game.direc = randreal(12)	# How dumb! 
-	game.justin = False
-	game.inorbit = False
-	warp(True)
-	if not game.justin:
-	    # This is bad news, we didn't leave quadrant. 
-	    if game.alldone:
-		return
-	    skip(1)
-	    prout(_(&quot;Insufficient energy to leave quadrant.&quot;))
-	    finish(FSNOVAED)
-	    return
-	# Repeat if another snova
-        if not game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-            break
-    if (game.state.remkl + game.state.remcom + game.state.nscrem)==0: 
-	finish(FWON) # Snova killed remaining enemy. 
-
-def timwrp():
-    # let's do the time warp again 
-    prout(_(&quot;***TIME WARP ENTERED.&quot;))
-    if game.state.snap and withprob(0.5):
-	# Go back in time 
-	prout(_(&quot;You are traveling backwards in time %d stardates.&quot;) %
-	      int(game.state.date-game.snapsht.date))
-	game.state = game.snapsht
-	game.state.snap = False
-	if game.state.remcom:
-	    schedule(FTBEAM, expran(game.intime/game.state.remcom))
-	    schedule(FBATTAK, expran(0.3*game.intime))
-	schedule(FSNOVA, expran(0.5*game.intime))
-	# next snapshot will be sooner 
-	schedule(FSNAP, expran(0.25*game.state.remtime))
-				
-	if game.state.nscrem:
-	    schedule(FSCMOVE, 0.2777)	    
-	game.isatb = 0
-	unschedule(FCDBAS)
-	unschedule(FSCDBAS)
-	invalidate(game.battle)
-
-	# Make sure Galileo is consistant -- Snapshot may have been taken
-        # when on planet, which would give us two Galileos! 
-	gotit = False
-	for l in range(game.inplan):
-	    if game.state.planets[l].known == &quot;shuttle_down&quot;:
-		gotit = True
-		if game.iscraft == &quot;onship&quot; and game.ship==IHE:
-		    prout(_(&quot;Chekov-  \&quot;Security reports the Galileo has disappeared, Sir!&quot;))
-		    game.iscraft = &quot;offship&quot;
-	# Likewise, if in the original time the Galileo was abandoned, but
-	# was on ship earlier, it would have vanished -- let's restore it.
-	if game.iscraft == &quot;offship&quot; and not gotit and game.damage[DSHUTTL] &gt;= 0.0:
-	    prout(_(&quot;Checkov-  \&quot;Security reports the Galileo has reappeared in the dock!\&quot;&quot;))
-	    game.iscraft = &quot;onship&quot;
-	# 
-#	 * There used to be code to do the actual reconstrction here,
-#	 * but the starchart is now part of the snapshotted galaxy state.
-#	 
-	prout(_(&quot;Spock has reconstructed a correct star chart from memory&quot;))
-    else:
-	# Go forward in time 
-	game.optime = -0.5*game.intime*math.log(randreal())
-	prout(_(&quot;You are traveling forward in time %d stardates.&quot;) % int(game.optime))
-	# cheat to make sure no tractor beams occur during time warp 
-	postpone(FTBEAM, game.optime)
-	game.damage[DRADIO] += game.optime
-    newqad(False)
-    events()	# Stas Sergeev added this -- do pending events 
-
-def probe():
-    # launch deep-space probe 
-    # New code to launch a deep space probe 
-    if game.nprobes == 0:
-	chew()
-	skip(1)
-	if game.ship == IHE: 
-	    prout(_(&quot;Engineer Scott- \&quot;We have no more deep space probes, Sir.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Ye Faerie Queene has no deep space probes.&quot;))
-	return
-    if damaged(DDSP):
-	chew()
-	skip(1)
-	prout(_(&quot;Engineer Scott- \&quot;The probe launcher is damaged, Sir.\&quot;&quot;))
-	return
-    if is_scheduled(FDSPROB):
-	chew()
-	skip(1)
-	if damaged(DRADIO) and game.condition != &quot;docked&quot;:
-	    prout(_(&quot;Spock-  \&quot;Records show the previous probe has not yet&quot;))
-	    prout(_(&quot;   reached its destination.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Uhura- \&quot;The previous probe is still reporting data, Sir.\&quot;&quot;))
-	return
-    key = scan()
-    if key == IHEOL:
-	# slow mode, so let Kirk know how many probes there are left
-        if game.nprobes == 1:
-            prout(_(&quot;1 probe left.&quot;))
-        else:
-            prout(_(&quot;%d probes left&quot;) % game.nprobes)
-	proutn(_(&quot;Are you sure you want to fire a probe? &quot;))
-	if ja() == False:
-	    return
-    game.isarmed = False
-    if key == IHALPHA and citem == &quot;armed&quot;:
-	game.isarmed = True
-	key = scan()
-    elif key == IHEOL:
-	proutn(_(&quot;Arm NOVAMAX warhead? &quot;))
-	game.isarmed = ja()
-    if not getcourse(isprobe=True, akey=key):
-	return
-    game.nprobes -= 1
-    angle = ((15.0 - game.direc) * 0.5235988)
-    game.probeinx = -math.sin(angle)
-    game.probeiny = math.cos(angle)
-    if math.fabs(game.probeinx) &gt; math.fabs(game.probeiny):
-	bigger = math.fabs(game.probeinx)
-    else:
-	bigger = math.fabs(game.probeiny)
-    game.probeiny /= bigger
-    game.probeinx /= bigger
-    game.proben = 10.0*game.dist*bigger +0.5
-    game.probex = game.quadrant.x*QUADSIZE + game.sector.x - 1	# We will use better packing than original
-    game.probey = game.quadrant.y*QUADSIZE + game.sector.y - 1
-    game.probec = game.quadrant
-    schedule(FDSPROB, 0.01) # Time to move one sector
-    prout(_(&quot;Ensign Chekov-  \&quot;The deep space probe is launched, Captain.\&quot;&quot;))
-    game.ididit = True
-    return
-
-# Here's how the mayday code works:
-# 
-# First, the closest starbase is selected.  If there is a a starbase
-# in your own quadrant, you are in good shape.  This distance takes
-# quadrant distances into account only.
-#
-# A magic number is computed based on the distance which acts as the
-# probability that you will be rematerialized.  You get three tries.
-#
-# When it is determined that you should be able to be rematerialized
-# (i.e., when the probability thing mentioned above comes up
-# positive), you are put into that quadrant (anywhere).  Then, we try
-# to see if there is a spot adjacent to the star- base.  If not, you
-# can't be rematerialized!!!  Otherwise, it drops you there.  It only
-# tries five times to find a spot to drop you.  After that, it's your
-# problem.
-
-def mayday():
-    # yell for help from nearest starbase 
-    # There's more than one way to move in this game! 
-    line = 0
-    chew()
-    # Test for conditions which prevent calling for help 
-    if game.condition == &quot;docked&quot;:
-	prout(_(&quot;Lt. Uhura-  \&quot;But Captain, we're already docked.\&quot;&quot;))
-	return
-    if damaged(DRADIO):
-	prout(_(&quot;Subspace radio damaged.&quot;))
-	return
-    if game.state.rembase==0:
-	prout(_(&quot;Lt. Uhura-  \&quot;Captain, I'm not getting any response from Starbase.\&quot;&quot;))
-	return
-    if game.landed:
-	proutn(_(&quot;You must be aboard the &quot;))
-	crmshp()
-	prout(&quot;.&quot;)
-	return
-    # OK -- call for help from nearest starbase 
-    game.nhelp += 1
-    if game.base.x!=0:
-	# There's one in this quadrant 
-	ddist = distance(game.base, game.sector)
-    else:
-	ddist = FOREVER
-	for m in range(game.state.rembase):
-	    xdist = QUADSIZE * distance(game.state.baseq[m], game.quadrant)
-	    if xdist &lt; ddist:
-		ddist = xdist
-		line = m
-	# Since starbase not in quadrant, set up new quadrant 
-	game.quadrant = game.state.baseq[line]
-	newqad(True)
-    # dematerialize starship 
-    game.quad[game.sector.x][game.sector.y]=IHDOT
-    proutn(_(&quot;Starbase in Quadrant %s responds--&quot;) % game.quadrant)
-    crmshp()
-    prout(_(&quot; dematerializes.&quot;))
-    game.sector.x=0
-    for m in range(1, 5+1):
-        w = game.base.scatter() 
-	if VALID_SECTOR(ix,iy) and game.quad[ix][iy]==IHDOT:
-	    # found one -- finish up 
-            game.sector = w
-	    break
-    if not is_valid(game.sector):
-	prout(_(&quot;You have been lost in space...&quot;))
-	finish(FMATERIALIZE)
-	return
-    # Give starbase three chances to rematerialize starship 
-    probf = math.pow((1.0 - math.pow(0.98,ddist)), 0.33333333)
-    for m in range(1, 3+1):
-	if m == 1: proutn(_(&quot;1st&quot;))
-	elif m == 2: proutn(_(&quot;2nd&quot;))
-	elif m == 3: proutn(_(&quot;3rd&quot;))
-	proutn(_(&quot; attempt to re-materialize &quot;))
-	crmshp()
-	game.quad[ix][iy]=(IHMATER0,IHMATER1,IHMATER2)[m-1]
-	textcolor(&quot;red&quot;)
-	warble()
-	if randreal() &gt; probf:
-	    break
-	prout(_(&quot;fails.&quot;))
-	curses.delay_output(500)
-	textcolor(None)
-    if m &gt; 3:
-	game.quad[ix][iy]=IHQUEST
-	game.alive = False
-	drawmaps(1)
-	setwnd(message_window)
-	finish(FMATERIALIZE)
-	return
-    game.quad[ix][iy]=game.ship
-    textcolor(&quot;green&quot;)
-    prout(_(&quot;succeeds.&quot;))
-    textcolor(None)
-    dock(False)
-    skip(1)
-    prout(_(&quot;Lt. Uhura-  \&quot;Captain, we made it!\&quot;&quot;))
-
-# Abandon Ship (the BSD-Trek description)
-# 
-# The ship is abandoned.  If your current ship is the Faire
-# Queene, or if your shuttlecraft is dead, you're out of
-# luck.  You need the shuttlecraft in order for the captain
-# (that's you!!) to escape.
-# 
-# Your crew can beam to an inhabited starsystem in the
-# quadrant, if there is one and if the transporter is working.
-# If there is no inhabited starsystem, or if the transporter
-# is out, they are left to die in outer space.
-# 
-# If there are no starbases left, you are captured by the
-# Klingons, who torture you mercilessly.  However, if there
-# is at least one starbase, you are returned to the
-# Federation in a prisoner of war exchange.  Of course, this
-# can't happen unless you have taken some prisoners.
-
-def abandon():
-    # abandon ship 
-    chew()
-    if game.condition==&quot;docked&quot;:
-	if game.ship!=IHE:
-	    prout(_(&quot;You cannot abandon Ye Faerie Queene.&quot;))
-	    return
-    else:
-	# Must take shuttle craft to exit 
-	if game.damage[DSHUTTL]==-1:
-	    prout(_(&quot;Ye Faerie Queene has no shuttle craft.&quot;))
-	    return
-	if game.damage[DSHUTTL]&lt;0:
-	    prout(_(&quot;Shuttle craft now serving Big Macs.&quot;))
-	    return
-	if game.damage[DSHUTTL]&gt;0:
-	    prout(_(&quot;Shuttle craft damaged.&quot;))
-	    return
-	if game.landed:
-	    prout(_(&quot;You must be aboard the ship.&quot;))
-	    return
-	if game.iscraft != &quot;onship&quot;:
-	    prout(_(&quot;Shuttle craft not currently available.&quot;))
-	    return
-	# Print abandon ship messages 
-	skip(1)
-	prouts(_(&quot;***ABANDON SHIP!  ABANDON SHIP!&quot;))
-	skip(1)
-	prouts(_(&quot;***ALL HANDS ABANDON SHIP!&quot;))
-	skip(2)
-	prout(_(&quot;Captain and crew escape in shuttle craft.&quot;))
-	if game.state.rembase==0:
-	    # Oops! no place to go... 
-	    finish(FABANDN)
-	    return
-	q = game.state.galaxy[game.quadrant.x][game.quadrant.y]
-	# Dispose of crew 
-	if not (game.options &amp; OPTION_WORLDS) and not damaged(DTRANSP):
-	    prout(_(&quot;Remainder of ship's complement beam down&quot;))
-	    prout(_(&quot;to nearest habitable planet.&quot;))
-	elif q.planet != None and not damaged(DTRANSP):
-	    prout(_(&quot;Remainder of ship's complement beam down to %s.&quot;) %
-		    q.planet)
-	else:
-	    prout(_(&quot;Entire crew of %d left to die in outer space.&quot;) %
-		    game.state.crew)
-	    game.casual += game.state.crew
-	    game.abandoned += game.state.crew
-
-	# If at least one base left, give 'em the Faerie Queene 
-	skip(1)
-	game.icrystl = False # crystals are lost 
-	game.nprobes = 0 # No probes 
-	prout(_(&quot;You are captured by Klingons and released to&quot;))
-	prout(_(&quot;the Federation in a prisoner-of-war exchange.&quot;))
-	nb = randrange(game.state.rembase)
-	# Set up quadrant and position FQ adjacient to base 
-	if not game.quadrant == game.state.baseq[nb]:
-	    game.quadrant = game.state.baseq[nb]
-	    game.sector.x = game.sector.y = 5
-	    newqad(True)
-	while True:
-	    # position next to base by trial and error 
-	    game.quad[game.sector.x][game.sector.y] = IHDOT
-	    for l in range(QUADSIZE):
-		game.sector = game.base.scatter()
-		if VALID_SECTOR(game.sector.x, game.sector.y) and \
-                       game.quad[game.sector.x][game.sector.y] == IHDOT:
-                    break
-	    if l &lt; QUADSIZE+1:
-		break # found a spot 
-	    game.sector.x=QUADSIZE/2
-	    game.sector.y=QUADSIZE/2
-	    newqad(True)
-    # Get new commission 
-    game.quad[game.sector.x][game.sector.y] = game.ship = IHF
-    game.state.crew = FULLCREW
-    prout(_(&quot;Starfleet puts you in command of another ship,&quot;))
-    prout(_(&quot;the Faerie Queene, which is antiquated but,&quot;))
-    prout(_(&quot;still useable.&quot;))
-    if game.icrystl:
-	prout(_(&quot;The dilithium crystals have been moved.&quot;))
-    game.imine = False
-    game.iscraft = &quot;offship&quot; # Galileo disappears 
-    # Resupply ship 
-    game.condition=&quot;docked&quot;
-    for l in range(NDEVICES): 
-	game.damage[l] = 0.0
-    game.damage[DSHUTTL] = -1
-    game.energy = game.inenrg = 3000.0
-    game.shield = game.inshld = 1250.0
-    game.torps = game.intorps = 6
-    game.lsupres=game.inlsr=3.0
-    game.shldup=False
-    game.warpfac=5.0
-    game.wfacsq=25.0
-    return
-
-# Code from planets.c begins here.
-
-def consumeTime():
-    # abort a lengthy operation if an event interrupts it 
-    game.ididit = True
-    events()
-    if game.alldone or game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova or game.justin: 
-	return True
-    return False
-
-def survey():
-    # report on (uninhabited) planets in the galaxy 
-    iknow = False
-    skip(1)
-    chew()
-    prout(_(&quot;Spock-  \&quot;Planet report follows, Captain.\&quot;&quot;))
-    skip(1)
-    for i in range(game.inplan):
-	if game.state.planets[i].pclass == &quot;destroyed&quot;:
-	    continue
-	if (game.state.planets[i].known != &quot;unknown&quot; \
-            and not game.state.planets[i].inhabited) \
-            or idebug:
-	    iknow = True
-	    if idebug and game.state.planets[i].known==&quot;unknown&quot;:
-		proutn(&quot;(Unknown) &quot;)
-	    proutn(_(&quot;Quadrant %s&quot;) % game.state.planets[i].w)
-	    proutn(_(&quot;   class &quot;))
-	    proutn(game.state.planets[i].pclass)
-	    proutn(&quot;   &quot;)
-	    if game.state.planets[i].crystals != present:
-		proutn(_(&quot;no &quot;))
-	    prout(_(&quot;dilithium crystals present.&quot;))
-	    if game.state.planets[i].known==&quot;shuttle_down&quot;: 
-		prout(_(&quot;    Shuttle Craft Galileo on surface.&quot;))
-    if not iknow:
-	prout(_(&quot;No information available.&quot;))
-
-def orbit():
-    # enter standard orbit 
-    skip(1)
-    chew()
-    if game.inorbit:
-	prout(_(&quot;Already in standard orbit.&quot;))
-	return
-    if damaged(DWARPEN) and damaged(DIMPULS):
-	prout(_(&quot;Both warp and impulse engines damaged.&quot;))
-	return
-    if not is_valid(game.plnet) or abs(game.sector.x-game.plnet.x) &gt; 1 or abs(game.sector.y-game.plnet.y) &gt; 1:
-	crmshp()
-	prout(_(&quot; not adjacent to planet.&quot;))
-	skip(1)
-	return
-    game.optime = randreal(0.02, 0.05)
-    prout(_(&quot;Helmsman Sulu-  \&quot;Entering standard orbit, Sir.\&quot;&quot;))
-    newcnd()
-    if consumeTime():
-	return
-    game.height = randreal(1400, 8600)
-    prout(_(&quot;Sulu-  \&quot;Entered orbit at altitude %.2f kilometers.\&quot;&quot;) % game.height)
-    game.inorbit = True
-    game.ididit = True
-
-def sensor():
-    # examine planets in this quadrant 
-    if damaged(DSRSENS):
-	if game.options &amp; OPTION_TTY:
-	    prout(_(&quot;Short range sensors damaged.&quot;))
-	return
-    if game.iplnet == None:
-	if game.options &amp; OPTION_TTY:
-	    prout(_(&quot;Spock- \&quot;No planet in this quadrant, Captain.\&quot;&quot;))
-	return
-    if game.iplnet.known == &quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Sensor scan for Quadrant %s-&quot;) % game.quadrant)
-	skip(1)
-	prout(_(&quot;         Planet at Sector %s is of class %s.&quot;) %
-	      (game.plnet, game.iplnet.pclass))
-	if game.iplnet.known==&quot;shuttle_down&quot;: 
-	    prout(_(&quot;         Sensors show Galileo still on surface.&quot;))
-	proutn(_(&quot;         Readings indicate&quot;))
-	if game.iplnet.crystals != &quot;present&quot;:
-	    proutn(_(&quot; no&quot;))
-	prout(_(&quot; dilithium crystals present.\&quot;&quot;))
-	if game.iplnet.known == &quot;unknown&quot;:
-	    game.iplnet.known = &quot;known&quot;
-    elif game.iplnet.inhabited:
-        prout(_(&quot;Spock-  \&quot;The inhabited planet %s &quot;) % game.iplnet.name)
-        prout(_(&quot;        is located at Sector %s, Captain.\&quot;&quot;) % game.plnet)
-
-def beam():
-    # use the transporter 
-    nrgneed = 0
-    chew()
-    skip(1)
-    if damaged(DTRANSP):
-	prout(_(&quot;Transporter damaged.&quot;))
-	if not damaged(DSHUTTL) and (game.iplnet.known==&quot;shuttle_down&quot; or game.iscraft == &quot;onship&quot;):
-	    skip(1)
-	    proutn(_(&quot;Spock-  \&quot;May I suggest the shuttle craft, Sir?\&quot; &quot;))
-	    if ja() == True:
-		shuttle()
-	return
-    if not game.inorbit:
-	crmshp()
-	prout(_(&quot; not in standard orbit.&quot;))
-	return
-    if game.shldup:
-	prout(_(&quot;Impossible to transport through shields.&quot;))
-	return
-    if game.iplnet.known==&quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
-	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
-	prout(_(&quot;  you may not go down.\&quot;&quot;))
-	return
-    if not game.landed and game.iplnet.crystals==&quot;absent&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, I fail to see the logic in&quot;))
-	prout(_(&quot;  exploring a planet with no dilithium crystals.&quot;))
-	proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-	if ja() == False:
-	    chew()
-	    return
-    if not (game.options &amp; OPTION_PLAIN):
-	nrgneed = 50 * game.skill + game.height / 100.0
-	if nrgneed &gt; game.energy:
-    	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Captain, we don't have enough energy for transportation.&quot;))
-	    return
-	if not game.landed and nrgneed * 2 &gt; game.energy:
-    	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Captain, we have enough energy only to transport you down to&quot;))
-	    prout(_(&quot;  the planet, but there wouldn't be an energy for the trip back.&quot;))
-	    if game.iplnet.known == &quot;shuttle_down&quot;:
-		prout(_(&quot;  Although the Galileo shuttle craft may still be on a surface.&quot;))
-	    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-	    if ja() == False:
-		chew()
-		return
-    if game.landed:
-	# Coming from planet 
-	if game.iplnet.known==&quot;shuttle_down&quot;:
-	    proutn(_(&quot;Spock-  \&quot;Wouldn't you rather take the Galileo?\&quot; &quot;))
-	    if ja() == True:
-		chew()
-		return
-	    prout(_(&quot;Your crew hides the Galileo to prevent capture by aliens.&quot;))
-	prout(_(&quot;Landing party assembled, ready to beam up.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk whips out communicator...&quot;))
-	prouts(_(&quot;BEEP  BEEP  BEEP&quot;))
-	skip(2)
-	prout(_(&quot;\&quot;Kirk to enterprise-  Lock on coordinates...energize.\&quot;&quot;))
-    else:
-	# Going to planet 
-	prout(_(&quot;Scotty-  \&quot;Transporter room ready, Sir.\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Kirk and landing party prepare to beam down to planet surface.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk-  \&quot;Energize.\&quot;&quot;))
-    game.ididit = True
-    skip(1)
-    prouts(&quot;WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .&quot;)
-    skip(2)
-    if withprob(0.98):
-	prouts(&quot;BOOOIIIOOOIIOOOOIIIOIING . . .&quot;)
-	skip(2)
-	prout(_(&quot;Scotty-  \&quot;Oh my God!  I've lost them.\&quot;&quot;))
-	finish(FLOST)
-	return
-    prouts(&quot;.    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW&quot;)
-    game.landed = not game.landed
-    game.energy -= nrgneed
-    skip(2)
-    prout(_(&quot;Transport complete.&quot;))
-    if game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
-	prout(_(&quot;The shuttle craft Galileo is here!&quot;))
-    if not game.landed and game.imine:
-	game.icrystl = True
-	game.cryprob = 0.05
-    game.imine = False
-    return
-
-def mine():
-    # strip-mine a world for dilithium 
-    skip(1)
-    chew()
-    if not game.landed:
-	prout(_(&quot;Mining party not on planet.&quot;))
-	return
-    if game.iplnet.crystals == &quot;mined&quot;:
-	prout(_(&quot;This planet has already been strip-mined for dilithium.&quot;))
-	return
-    elif game.iplnet.crystals == &quot;absent&quot;:
-	prout(_(&quot;No dilithium crystals on this planet.&quot;))
-	return
-    if game.imine:
-	prout(_(&quot;You've already mined enough crystals for this trip.&quot;))
-	return
-    if game.icrystl and game.cryprob == 0.05:
-	proutn(_(&quot;With all those fresh crystals aboard the &quot;))
-	crmshp()
-	skip(1)
-	prout(_(&quot;there's no reason to mine more at this time.&quot;))
-	return
-    game.optime = randreal(0.1, 0.3)*(ord(game.iplnet.pclass)-ord(&quot;L&quot;))
-    if consumeTime():
-	return
-    prout(_(&quot;Mining operation complete.&quot;))
-    game.iplnet.crystals = &quot;mined&quot;
-    game.imine = game.ididit = True
-
-def usecrystals():
-    # use dilithium crystals 
-    game.ididit = False
-    skip(1)
-    chew()
-    if not game.icrystl:
-	prout(_(&quot;No dilithium crystals available.&quot;))
-	return
-    if game.energy &gt;= 1000:
-	prout(_(&quot;Spock-  \&quot;Captain, Starfleet Regulations prohibit such an operation&quot;))
-	prout(_(&quot;  except when Condition Yellow exists.&quot;))
-	return
-    prout(_(&quot;Spock- \&quot;Captain, I must warn you that loading&quot;))
-    prout(_(&quot;  raw dilithium crystals into the ship's power&quot;))
-    prout(_(&quot;  system may risk a severe explosion.&quot;))
-    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-    if ja() == False:
-	chew()
-	return
-    skip(1)
-    prout(_(&quot;Engineering Officer Scott-  \&quot;(GULP) Aye Sir.&quot;))
-    prout(_(&quot;  Mr. Spock and I will try it.\&quot;&quot;))
-    skip(1)
-    prout(_(&quot;Spock-  \&quot;Crystals in place, Sir.&quot;))
-    prout(_(&quot;  Ready to activate circuit.\&quot;&quot;))
-    skip(1)
-    prouts(_(&quot;Scotty-  \&quot;Keep your fingers crossed, Sir!\&quot;&quot;))
-    skip(1)
-    if with(game.cryprob):
-	prouts(_(&quot;  \&quot;Activating now! - - No good!  It's***&quot;))
-	skip(2)
-	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
-	skip(1)
-	stars()
-	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
-	skip(1)
-	kaboom()
-	return
-    game.energy += randreal(5000.0, 5500.0)
-    prouts(_(&quot;  \&quot;Activating now! - - &quot;))
-    prout(_(&quot;The instruments&quot;))
-    prout(_(&quot;   are going crazy, but I think it's&quot;))
-    prout(_(&quot;   going to work!!  Congratulations, Sir!\&quot;&quot;))
-    game.cryprob *= 2.0
-    game.ididit = True
-
-def shuttle():
-    # use shuttlecraft for planetary jaunt 
-    chew()
-    skip(1)
-    if damaged(DSHUTTL):
-	if game.damage[DSHUTTL] == -1.0:
-	    if game.inorbit and game.iplnet.known == &quot;shuttle_down&quot;:
-		prout(_(&quot;Ye Faerie Queene has no shuttle craft bay to dock it at.&quot;))
-	    else:
-		prout(_(&quot;Ye Faerie Queene had no shuttle craft.&quot;))
-	elif game.damage[DSHUTTL] &gt; 0:
-	    prout(_(&quot;The Galileo is damaged.&quot;))
-	else: # game.damage[DSHUTTL] &lt; 0  
-	    prout(_(&quot;Shuttle craft is now serving Big Macs.&quot;))
-	return
-    if not game.inorbit:
-	crmshp()
-	prout(_(&quot; not in standard orbit.&quot;))
-	return
-    if (game.iplnet.known != &quot;shuttle_down&quot;) and game.iscraft != &quot;onship&quot;:
-	prout(_(&quot;Shuttle craft not currently available.&quot;))
-	return
-    if not game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
-	prout(_(&quot;You will have to beam down to retrieve the shuttle craft.&quot;))
-	return
-    if game.shldup or game.condition == &quot;docked&quot;:
-	prout(_(&quot;Shuttle craft cannot pass through shields.&quot;))
-	return
-    if game.iplnet.known==&quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
-	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
-	prout(_(&quot;  you may not fly down.\&quot;&quot;))
-	return
-    game.optime = 3.0e-5*game.height
-    if game.optime &gt;= 0.8*game.state.remtime:
-	prout(_(&quot;First Officer Spock-  \&quot;Captain, I compute that such&quot;))
-	proutn(_(&quot;  a maneuver would require approximately %2d%% of our&quot;) % \
-	       int(100*game.optime/game.state.remtime))
-	prout(_(&quot;remaining time.&quot;))
-	proutn(_(&quot;Are you sure this is wise?\&quot; &quot;))
-	if ja() == False:
-	    game.optime = 0.0
-	    return
-    if game.landed:
-	# Kirk on planet 
-	if game.iscraft == &quot;onship&quot;:
-	    # Galileo on ship! 
-	    if not damaged(DTRANSP):
-		proutn(_(&quot;Spock-  \&quot;Would you rather use the transporter?\&quot; &quot;))
-		if ja() == True:
-		    beam()
-		    return
-		proutn(_(&quot;Shuttle crew&quot;))
-	    else:
-		proutn(_(&quot;Rescue party&quot;))
-	    prout(_(&quot; boards Galileo and swoops toward planet surface.&quot;))
-	    game.iscraft = &quot;offship&quot;
-	    skip(1)
-	    if consumeTime():
-		return
-	    game.iplnet.known=&quot;shuttle_down&quot;
-	    prout(_(&quot;Trip complete.&quot;))
-	    return
-	else:
-	    # Ready to go back to ship 
-	    prout(_(&quot;You and your mining party board the&quot;))
-	    prout(_(&quot;shuttle craft for the trip back to the Enterprise.&quot;))
-	    skip(1)
-	    prouts(_(&quot;The short hop begins . . .&quot;))
-	    skip(1)
-	    game.iplnet.known=&quot;known&quot;
-	    game.icraft = True
-	    skip(1)
-	    game.landed = False
-	    if consumeTime():
-		return
-	    game.iscraft = &quot;onship&quot;
-	    game.icraft = False
-	    if game.imine:
-		game.icrystl = True
-		game.cryprob = 0.05
-	    game.imine = False
-	    prout(_(&quot;Trip complete.&quot;))
-	    return
-    else:
-	# Kirk on ship 
-	# and so is Galileo 
-	prout(_(&quot;Mining party assembles in the hangar deck,&quot;))
-	prout(_(&quot;ready to board the shuttle craft \&quot;Galileo\&quot;.&quot;))
-	skip(1)
-	prouts(_(&quot;The hangar doors open; the trip begins.&quot;))
-	skip(1)
-	game.icraft = True
-	game.iscraft = &quot;offship&quot;
-	if consumeTime():
-	    return
-	game.iplnet.known = &quot;shuttle_down&quot;
-	game.landed = True
-	game.icraft = False
-	prout(_(&quot;Trip complete.&quot;))
-	return
-
-def deathray():
-    # use the big zapper 
-    game.ididit = False
-    skip(1)
-    chew()
-    if game.ship != IHE:
-	prout(_(&quot;Ye Faerie Queene has no death ray.&quot;))
-	return
-    if len(game.enemies)==0:
-	prout(_(&quot;Sulu-  \&quot;But Sir, there are no enemies in this quadrant.\&quot;&quot;))
-	return
-    if damaged(DDRAY):
-	prout(_(&quot;Death Ray is damaged.&quot;))
-	return
-    prout(_(&quot;Spock-  \&quot;Captain, the 'Experimental Death Ray'&quot;))
-    prout(_(&quot;  is highly unpredictible.  Considering the alternatives,&quot;))
-    proutn(_(&quot;  are you sure this is wise?\&quot; &quot;))
-    if ja() == False:
-	return
-    prout(_(&quot;Spock-  \&quot;Acknowledged.\&quot;&quot;))
-    skip(1)
-    game.ididit = True
-    prouts(_(&quot;WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE&quot;))
-    skip(1)
-    prout(_(&quot;Crew scrambles in emergency preparation.&quot;))
-    prout(_(&quot;Spock and Scotty ready the death ray and&quot;))
-    prout(_(&quot;prepare to channel all ship's power to the device.&quot;))
-    skip(1)
-    prout(_(&quot;Spock-  \&quot;Preparations complete, sir.\&quot;&quot;))
-    prout(_(&quot;Kirk-  \&quot;Engage!\&quot;&quot;))
-    skip(1)
-    prouts(_(&quot;WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&quot;))
-    skip(1)
-    dprob = 0.30
-    if game.options &amp; OPTION_PLAIN:
-	dprob = 0.5
-    r = randreal()
-    if r &gt; dprob:
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
-	skip(2)
-	while len(game.enemies) &gt; 0:
-	    deadkl(game.enemies[1].kloc, game.quad[game.enemies[1].kloc.x][game.enemies[1].kloc.y],game.enemies[1].kloc)
-	prout(_(&quot;Ensign Chekov-  \&quot;Congratulations, Captain!\&quot;&quot;))
-	if (game.state.remkl + game.state.remcom + game.state.nscrem) == 0:
-	    finish(FWON)    
-	if (game.options &amp; OPTION_PLAIN) == 0:
-	    prout(_(&quot;Spock-  \&quot;Captain, I believe the `Experimental Death Ray'&quot;))
-	    if withprob(0.05):
-		prout(_(&quot;   is still operational.\&quot;&quot;))
-	    else:
-		prout(_(&quot;   has been rendered nonfunctional.\&quot;&quot;))
-		game.damage[DDRAY] = 39.95
-	return
-    r = randreal()	# Pick failure method 
-    if r &lt;= 0.30:
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	skip(1)
-	prout(_(&quot;***MATTER-ANTIMATTER IMPLOSION IMMINENT!&quot;))
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
-	skip(1)
-	stars()
-	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
-	skip(1)
-	kaboom()
-	return
-    if r &lt;= 0.55:
-	prouts(_(&quot;Sulu- \&quot;Captain!  Yagabandaghangrapl, brachriigringlanbla!\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Lt. Uhura-  \&quot;Graaeek!  Graaeek!\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Spock-  \&quot;Fascinating!  . . . All humans aboard&quot;))
-	prout(_(&quot;  have apparently been transformed into strange mutations.&quot;))
-	prout(_(&quot;  Vulcans do not seem to be affected.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk-  \&quot;Raauch!  Raauch!\&quot;&quot;))
-	finish(FDRAY)
-	return
-    if r &lt;= 0.75:
-	intj
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's   --WHAT?!?!\&quot;&quot;))
-	skip(2)
-	proutn(_(&quot;Spock-  \&quot;I believe the word is&quot;))
-	prouts(_(&quot; *ASTONISHING*&quot;))
-	prout(_(&quot; Mr. Sulu.&quot;))
-	for i in range(QUADSIZE):
-	    for j in range(QUADSIZE):
-		if game.quad[i][j] == IHDOT:
-		    game.quad[i][j] = IHQUEST
-	prout(_(&quot;  Captain, our quadrant is now infested with&quot;))
-	prouts(_(&quot; - - - - - -  *THINGS*.&quot;))
-	skip(1)
-	prout(_(&quot;  I have no logical explanation.\&quot;&quot;))
-	return
-    prouts(_(&quot;Sulu- \&quot;Captain!  The Death Ray is creating tribbles!\&quot;&quot;))
-    skip(1)
-    prout(_(&quot;Scotty-  \&quot;There are so many tribbles down here&quot;))
-    prout(_(&quot;  in Engineering, we can't move for 'em, Captain.\&quot;&quot;))
-    finish(FTRIBBLE)
-    return
-
-# Code from reports.c begins here
-
-def attackreport(curt):
-    # report status of bases under attack 
-    if not curt:
-	if is_scheduled(FCDBAS):
-	    prout(_(&quot;Starbase in Quadrant %s is currently under Commander attack.&quot;) % game.battle)
-	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FCDBAS)))
-	elif game.isatb == 1:
-	    prout(_(&quot;Starbase in Quadrant %s is under Super-commander attack.&quot;) % game.state.kscmdr)
-	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FSCDBAS)))
-	else:
-	    prout(_(&quot;No Starbase is currently under attack.&quot;))
-    else:
-        if is_scheduled(FCDBAS):
-	    proutn(_(&quot;Base in %s attacked by C. Alive until %.1f&quot;) % (game.battle, scheduled(FCDBAS)))
-        if game.isatb:
-	    proutn(_(&quot;Base in %s attacked by S. Alive until %.1f&quot;) % (game.state.kscmdr, scheduled(FSCDBAS)))
-	clreol()
-
-def report():
-    # report on general game status 
-    chew()
-    s1 = &quot;&quot; and game.thawed and _(&quot;thawed &quot;)
-    s2 = {1:&quot;short&quot;, 2:&quot;medium&quot;, 4:&quot;long&quot;}[game.length]
-    s3 = (None, _(&quot;novice&quot;). _(&quot;fair&quot;),
-          _(&quot;good&quot;), _(&quot;expert&quot;), _(&quot;emeritus&quot;))[game.skill]
-    prout(_(&quot;You %s a %s%s %s game.&quot;) % ((_(&quot;were playing&quot;), _(&quot;are playing&quot;))[game.alldone], s1, s2, s3))
-    if game.skill&gt;SKILL_GOOD and game.thawed and not game.alldone:
-	prout(_(&quot;No plaque is allowed.&quot;))
-    if game.tourn:
-	prout(_(&quot;This is tournament game %d.&quot;) % game.tourn)
-    prout(_(&quot;Your secret password is \&quot;%s\&quot;&quot;) % game.passwd)
-    proutn(_(&quot;%d of %d Klingons have been killed&quot;) % (((game.inkling + game.incom + game.inscom) - (game.state.remkl + game.state.remcom + game.state.nscrem)), 
-	   (game.inkling + game.incom + game.inscom)))
-    if game.incom - game.state.remcom:
-	prout(_(&quot;, including %d Commander%s.&quot;) % (game.incom - game.state.remcom, (_(&quot;s&quot;), &quot;&quot;)[(game.incom - game.state.remcom)==1]))
-    elif game.inkling - game.state.remkl + (game.inscom - game.state.nscrem) &gt; 0:
-	prout(_(&quot;, but no Commanders.&quot;))
-    else:
-	prout(&quot;.&quot;)
-    if game.skill &gt; SKILL_FAIR:
-	prout(_(&quot;The Super Commander has %sbeen destroyed.&quot;) % (&quot;&quot;, _(&quot;not &quot;))[game.state.nscrem])
-    if game.state.rembase != game.inbase:
-	proutn(_(&quot;There &quot;))
-	if game.inbase-game.state.rembase==1:
-	    proutn(_(&quot;has been 1 base&quot;))
-	else:
-	    proutn(_(&quot;have been %d bases&quot;) % (game.inbase-game.state.rembase))
-	prout(_(&quot; destroyed, %d remaining.&quot;) % game.state.rembase)
-    else:
-	prout(_(&quot;There are %d bases.&quot;) % game.inbase)
-    if communicating() or game.iseenit:
-	# Don't report this if not seen and
-	# either the radio is dead or not at base!
-	attackreport(False)
-	game.iseenit = True
-    if game.casual: 
-	prout(_(&quot;%d casualt%s suffered so far.&quot;) % (game.casual, (&quot;y&quot;, &quot;ies&quot;)[game.casual!=1]))
-    if game.nhelp:
-	prout(_(&quot;There were %d call%s for help.&quot;) % (game.nhelp,  (&quot;&quot; , _(&quot;s&quot;))[game.nhelp!=1]))
-    if game.ship == IHE:
-	proutn(_(&quot;You have &quot;))
-	if game.nprobes:
-	    proutn(&quot;%d&quot; % (game.nprobes))
-	else:
-	    proutn(_(&quot;no&quot;))
-	proutn(_(&quot; deep space probe&quot;))
-	if game.nprobes!=1:
-	    proutn(_(&quot;s&quot;))
-	prout(&quot;.&quot;)
-    if communicating() and is_scheduled(FDSPROB):
-	if game.isarmed: 
-	    proutn(_(&quot;An armed deep space probe is in &quot;))
-	else:
-	    proutn(_(&quot;A deep space probe is in &quot;))
-	prout(&quot;Quadrant %s.&quot; % game.probec)
-    if game.icrystl:
-	if game.cryprob &lt;= .05:
-	    prout(_(&quot;Dilithium crystals aboard ship... not yet used.&quot;))
-	else:
-	    i=0
-	    ai = 0.05
-	    while game.cryprob &gt; ai:
-		ai *= 2.0
-		i += 1
-	    prout(_(&quot;Dilithium crystals have been used %d time%s.&quot;) % \
-                  (i, (_(&quot;s&quot;), &quot;&quot;)[i==1]))
-    skip(1)
-	
-def lrscan(silent):
-    # long-range sensor scan 
-    if damaged(DLRSENS):
-	# Now allow base's sensors if docked 
-	if game.condition != &quot;docked&quot;:
-            if not silent:
-                prout(_(&quot;LONG-RANGE SENSORS DAMAGED.&quot;))
-	    return
-        if not silent:
-            prout(_(&quot;Starbase's long-range scan&quot;))
-    elif not silent:
-	prout(_(&quot;Long-range scan&quot;))
-    for x in range(game.quadrant.x-1, game.quadrant.x+2):
-        if not silent:
-            proutn(&quot; &quot;)
-        for y in range(game.quadrant.y-1, game.quadrant.y+2):
-	    if not VALID_QUADRANT(x, y):
-                if not silent:
-                    proutn(&quot;  -1&quot;)
-	    else:
-		if not damaged(DRADIO):
-		    game.state.galaxy[x][y].charted = True
-		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons
-		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase
-		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars
-		if not silent and game.state.galaxy[x][y].supernova: 
-		    proutn(&quot; ***&quot;)
-		elif not silent:
-		    proutn(&quot; %3d&quot; % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
-	prout(&quot; &quot;)
-
-def damagereport():
-    # damage report 
-    jdam = False
-    chew()
-
-    for i in range(NDEVICES):
-	if damaged(i):
-	    if not jdam:
-		prout(_(&quot;\tDEVICE\t\t\t-REPAIR TIMES-&quot;))
-		prout(_(&quot;\t\t\tIN FLIGHT\t\tDOCKED&quot;))
-		jdam = True
-	    prout(&quot;  %-26s\t%8.2f\t\t%8.2f&quot; % (device[i],
-                                               game.damage[i]+0.05,
-                                               game.docfac*game.damage[i]+0.005))
-    if not jdam:
-	prout(_(&quot;All devices functional.&quot;))
-
-def rechart():
-    # update the chart in the Enterprise's computer from galaxy data 
-    game.lastchart = game.state.date
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    if game.state.galaxy[i][j].charted:
-		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons
-		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase
-		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars
-
-def chart():
-    # display the star chart  
-    chew()
-    if (game.options &amp; OPTION_AUTOSCAN):
-        lrscan(silent=True)
-    if not damaged(DRADIO):
-	rechart()
-    if game.lastchart &lt; game.state.date and game.condition == &quot;docked&quot;:
-	prout(_(&quot;Spock-  \&quot;I revised the Star Chart from the starbase's records.\&quot;&quot;))
-	rechart()
-
-    prout(_(&quot;       STAR CHART FOR THE KNOWN GALAXY&quot;))
-    if game.state.date &gt; game.lastchart:
-	prout(_(&quot;(Last surveillance update %d stardates ago).&quot;) % ((int)(game.state.date-game.lastchart)))
-    prout(&quot;      1    2    3    4    5    6    7    8&quot;)
-    for i in range(GALSIZE):
-	proutn(&quot;%d |&quot; % (i+1))
-	for j in range(GALSIZE):
-	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.x and j == game.quadrant.y:
-		proutn(&quot;&lt;&quot;)
-	    else:
-		proutn(&quot; &quot;)
-	    if game.state.galaxy[i][j].supernova:
-		show = &quot;***&quot;
-	    elif not game.state.galaxy[i][j].charted and game.state.galaxy[i][j].starbase:
-		show = &quot;.1.&quot;
-	    elif game.state.galaxy[i][j].charted:
-		show = &quot;%3d&quot; % (game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars)
-	    else:
-		show = &quot;...&quot;
-	    proutn(show)
-	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.x and j == game.quadrant.y:
-		proutn(&quot;&gt;&quot;)
-	    else:
-		proutn(&quot; &quot;)
-	proutn(&quot;  |&quot;)
-	if i&lt;GALSIZE:
-	    skip(1)
-
-def sectscan(goodScan, i, j):
-    # light up an individual dot in a sector 
-    if goodScan or (abs(i-game.sector.x)&lt;= 1 and abs(j-game.sector.y) &lt;= 1):
-	if (game.quad[i][j]==IHMATER0) or (game.quad[i][j]==IHMATER1) or (game.quad[i][j]==IHMATER2) or (game.quad[i][j]==IHE) or (game.quad[i][j]==IHF):
-	    if game.condition   == &quot;red&quot;: textcolor(&quot;red&quot;)
-	    elif game.condition == &quot;green&quot;: textcolor(&quot;green&quot;)
-	    elif game.condition == &quot;yellow&quot;: textcolor(&quot;yellow&quot;)
-	    elif game.condition == &quot;docked&quot;: textcolor(&quot;cyan&quot;)
-	    elif game.condition == &quot;dead&quot;: textcolor(&quot;brown&quot;)
-	    if game.quad[i][j] != game.ship: 
-		highvideo()
-	proutn(&quot;%c &quot; % game.quad[i][j])
-	textcolor(None)
-    else:
-	proutn(&quot;- &quot;)
-
-def status(req=0):
-    # print status report lines 
-
-    if not req or req == 1:
-	prstat(_(&quot;Stardate&quot;), _(&quot;%.1f, Time Left %.2f&quot;) \
-               % (game.state.date, game.state.remtime))
-    if not req or req == 2:
-	if game.condition != &quot;docked&quot;:
-	    newcnd()
-        dam = 0
-	for t in range(NDEVICES):
-	    if game.damage[t]&gt;0: 
-		dam += 1
-	prstat(_(&quot;Condition&quot;), _(&quot;%s, %i DAMAGES&quot;) % (game.condition.upper(), dam))
-    if not req or req == 3:
-	prstat(_(&quot;Position&quot;), &quot;%s , %s&quot; % (game.quadrant, game.sector))
-    if not req or req == 4:
-	if damaged(DLIFSUP):
-	    if game.condition == &quot;docked&quot;:
-		s = _(&quot;DAMAGED, Base provides&quot;)
-	    else:
-		s = _(&quot;DAMAGED, reserves=%4.2f&quot;) % game.lsupres
-	else:
-	    s = _(&quot;ACTIVE&quot;)
-	prstat(_(&quot;Life Support&quot;), s)
-    if not req or req == 5:
-	prstat(_(&quot;Warp Factor&quot;), &quot;%.1f&quot; % game.warpfac)
-    if not req or req == 6:
-        extra = &quot;&quot;
-        if game.icrystl and (game.options &amp; OPTION_SHOWME):
-            extra = _(&quot; (have crystals)&quot;)
-	prstat(_(&quot;Energy&quot;), &quot;%.2f%s&quot; % (game.energy, extra))
-    if not req or req == 7:
-	prstat(_(&quot;Torpedoes&quot;), &quot;%d&quot; % (game.torps))
-    if not req or req == 8:
-	if damaged(DSHIELD):
-	    s = _(&quot;DAMAGED,&quot;)
-	elif game.shldup:
-	    s = _(&quot;UP,&quot;)
-	else:
-	    s = _(&quot;DOWN,&quot;)
-	data = _(&quot; %d%% %.1f units&quot;) \
-               % (int((100.0*game.shield)/game.inshld + 0.5), game.shield)
-	prstat(_(&quot;Shields&quot;), s+data)
-    if not req or req == 9:
-        prstat(_(&quot;Klingons Left&quot;), &quot;%d&quot; \
-               % (game.state.remkl + game.state.remcom + game.state.nscrem))
-    if not req or req == 10:
-	if game.options &amp; OPTION_WORLDS:
-	    plnet = game.state.galaxy[game.quadrant.x][game.quadrant.y].planet
-	    if plnet and plnet.inhabited:
-		prstat(_(&quot;Major system&quot;), plnet.name)
-	    else:
-		prout(_(&quot;Sector is uninhabited&quot;))
-    elif not req or req == 11:
-	attackreport(not req)
-
-def request():
-    requests = (&quot;da&quot;,&quot;co&quot;,&quot;po&quot;,&quot;ls&quot;,&quot;wa&quot;,&quot;en&quot;,&quot;to&quot;,&quot;sh&quot;,&quot;kl&quot;,&quot;sy&quot;, &quot;ti&quot;)
-    while scan() == IHEOL:
-	proutn(_(&quot;Information desired? &quot;))
-    chew()
-    if citem in requests:
-        status(requests.index(citem))
-    else:
-	prout(_(&quot;UNRECOGNIZED REQUEST. Legal requests are:&quot;))
-	prout((&quot;  date, condition, position, lsupport, warpfactor,&quot;))
-	prout((&quot;  energy, torpedoes, shields, klingons, system, time.&quot;))
-		
-def srscan():
-    # short-range scan 
-    goodScan=True
-    if damaged(DSRSENS):
-	# Allow base's sensors if docked 
-	if game.condition != &quot;docked&quot;:
-	    prout(_(&quot;   S.R. SENSORS DAMAGED!&quot;))
-	    goodScan=False
-	else:
-	    prout(_(&quot;  [Using Base's sensors]&quot;))
-    else:
-	prout(_(&quot;     Short-range scan&quot;))
-    if goodScan and not damaged(DRADIO): 
-	game.state.chart[game.quadrant.x][game.quadrant.y].klingons = game.state.galaxy[game.quadrant.x][game.quadrant.y].klingons
-	game.state.chart[game.quadrant.x][game.quadrant.y].starbase = game.state.galaxy[game.quadrant.x][game.quadrant.y].starbase
-	game.state.chart[game.quadrant.x][game.quadrant.y].stars = game.state.galaxy[game.quadrant.x][game.quadrant.y].stars
-	game.state.galaxy[game.quadrant.x][game.quadrant.y].charted = True
-    prout(&quot;    1 2 3 4 5 6 7 8 9 10&quot;)
-    if game.condition != &quot;docked&quot;:
-	newcnd()
-    for i in range(QUADSIZE):
-	proutn(&quot;%2d  &quot; % (i+1))
-	for j in range(QUADSIZE):
-	    sectscan(goodScan, i, j)
-	skip(1)
-			
-def eta():
-    # use computer to get estimated time of arrival for a warp jump 
-    w1 = coord(); w2 = coord()
-    prompt = False
-    if damaged(DCOMPTR):
-	prout(_(&quot;COMPUTER DAMAGED, USE A POCKET CALCULATOR.&quot;))
-	skip(1)
-	return
-    if scan() != IHREAL:
-	prompt = True
-	chew()
-	proutn(_(&quot;Destination quadrant and/or sector? &quot;))
-	if scan()!=IHREAL:
-	    huh()
-	    return
-    w1.y = int(aaitem-0.5)
-    if scan() != IHREAL:
-	huh()
-	return
-    w1.x = int(aaitem-0.5)
-    if scan() == IHREAL:
-	w2.y = int(aaitem-0.5)
-	if scan() != IHREAL:
-	    huh()
-	    return
-	w2.x = int(aaitem-0.5)
-    else:
-	if game.quadrant.y&gt;w1.x:
-	    w2.x = 0
-	else:
-	    w2.x=QUADSIZE-1
-	if game.quadrant.x&gt;w1.y:
-	    w2.y = 0
-	else:
-	    w2.y=QUADSIZE-1
-    if not VALID_QUADRANT(w1.x, w1.y) or not VALID_SECTOR(w2.x, w2.y):
-	huh()
-	return
-    game.dist = math.sqrt(square(w1.y-game.quadrant.y+0.1*(w2.y-game.sector.y))+
-		square(w1.x-game.quadrant.x+0.1*(w2.x-game.sector.x)))
-    wfl = False
-    if prompt:
-	prout(_(&quot;Answer \&quot;no\&quot; if you don't know the value:&quot;))
-    while True:
-	chew()
-	proutn(_(&quot;Time or arrival date? &quot;))
-	if scan()==IHREAL:
-	    ttime = aaitem
-	    if ttime &gt; game.state.date:
-		ttime -= game.state.date # Actually a star date
-            twarp=(math.floor(math.sqrt((10.0*game.dist)/ttime)*10.0)+1.0)/10.0
-            if ttime &lt;= 1e-10 or twarp &gt; 10:
-		prout(_(&quot;We'll never make it, sir.&quot;))
-		chew()
-		return
-	    if twarp &lt; 1.0:
-		twarp = 1.0
-	    break
-	chew()
-	proutn(_(&quot;Warp factor? &quot;))
-	if scan()== IHREAL:
-	    wfl = True
-	    twarp = aaitem
-	    if twarp&lt;1.0 or twarp &gt; 10.0:
-		huh()
-		return
-	    break
-	prout(_(&quot;Captain, certainly you can give me one of these.&quot;))
-    while True:
-	chew()
-	ttime = (10.0*game.dist)/square(twarp)
-	tpower = game.dist*twarp*twarp*twarp*(game.shldup+1)
-	if tpower &gt;= game.energy:
-	    prout(_(&quot;Insufficient energy, sir.&quot;))
-	    if not game.shldup or tpower &gt; game.energy*2.0:
-		if not wfl:
-		    return
-		proutn(_(&quot;New warp factor to try? &quot;))
-		if scan() == IHREAL:
-		    wfl = True
-		    twarp = aaitem
-		    if twarp&lt;1.0 or twarp &gt; 10.0:
-			huh()
-			return
-		    continue
-		else:
-		    chew()
-		    skip(1)
-		    return
-	    prout(_(&quot;But if you lower your shields,&quot;))
-	    proutn(_(&quot;remaining&quot;))
-	    tpower /= 2
-	else:
-	    proutn(_(&quot;Remaining&quot;))
-	prout(_(&quot; energy will be %.2f.&quot;) % (game.energy-tpower))
-	if wfl:
-	    prout(_(&quot;And we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
-	elif twarp==1.0:
-	    prout(_(&quot;Any warp speed is adequate.&quot;))
-	else:
-	    prout(_(&quot;Minimum warp needed is %.2f,&quot;) % (twarp))
-	    prout(_(&quot;and we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
-	if game.state.remtime &lt; ttime:
-	    prout(_(&quot;Unfortunately, the Federation will be destroyed by then.&quot;))
-	if twarp &gt; 6.0:
-	    prout(_(&quot;You'll be taking risks at that speed, Captain&quot;))
-	if (game.isatb==1 and game.state.kscmdr == w1 and \
-	     scheduled(FSCDBAS)&lt; ttime+game.state.date) or \
-	    (scheduled(FCDBAS)&lt;ttime+game.state.date and game.battle == w1):
-	    prout(_(&quot;The starbase there will be destroyed by then.&quot;))
-	proutn(_(&quot;New warp factor to try? &quot;))
-	if scan() == IHREAL:
-	    wfl = True
-	    twarp = aaitem
-	    if twarp&lt;1.0 or twarp &gt; 10.0:
-		huh()
-		return
-	else:
-	    chew()
-	    skip(1)
-	    return
-			
-
-# Code from setup.c begins here
-
-def prelim():
-    # issue a historically correct banner 
-    skip(2)
-    prout(_(&quot;-SUPER- STAR TREK&quot;))
-    skip(1)
-# From the FORTRAN original
-#    prout(_(&quot;Latest update-21 Sept 78&quot;))
-#    skip(1)
-
-def freeze(boss):
-    # save game 
-    if boss:
-	citem = &quot;emsave.trk&quot;
-    else:
-        key = scan()
-	if key == IHEOL:
-	    proutn(_(&quot;File name: &quot;))
-	    key = scan()
-	if key != IHALPHA:
-	    huh()
-	    return
-	chew()
-        if '.' not in citem:
-	    citem += &quot;.trk&quot;
-    try:
-        fp = open(citem, &quot;wb&quot;)
-    except IOError:
-	prout(_(&quot;Can't freeze game as file %s&quot;) % citem)
-	return
-    cPickle.dump(game, fp)
-    fp.close()
-
-def thaw():
-    # retrieve saved game 
-    game.passwd[0] = '\0'
-    key = scan()
-    if key == IHEOL:
-	proutn(_(&quot;File name: &quot;))
-	key = scan()
-    if key != IHALPHA:
-	huh()
-	return True
-    chew()
-    if '.' not in citem:
-        citem += &quot;.trk&quot;
-    try:
-        fp = open(citem, &quot;rb&quot;)
-    except IOError:
-	prout(_(&quot;Can't thaw game in %s&quot;) % citem)
-	return
-    game = cPickle.load(fp)
-    fp.close()
-    return False
-
-# I used &lt;<A HREF="http://www.memory-alpha.org">http://www.memory-alpha.org</A>&gt; to find planets
-# with references in ST:TOS.  Eath and the Alpha Centauri
-# Colony have been omitted.
-# 
-# Some planets marked Class G and P here will be displayed as class M
-# because of the way planets are generated. This is a known bug.
-systnames = (
-    # Federation Worlds 
-    _(&quot;Andoria (Fesoan)&quot;),	# several episodes 
-    _(&quot;Tellar Prime (Miracht)&quot;),	# TOS: &quot;Journey to Babel&quot; 
-    _(&quot;Vulcan (T'Khasi)&quot;),	# many episodes 
-    _(&quot;Medusa&quot;),		# TOS: &quot;Is There in Truth No Beauty?&quot; 
-    _(&quot;Argelius II (Nelphia)&quot;),# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
-    _(&quot;Ardana&quot;),		# TOS: &quot;The Cloud Minders&quot; 
-    _(&quot;Catulla (Cendo-Prae)&quot;),	# TOS: &quot;The Way to Eden&quot; 
-    _(&quot;Gideon&quot;),		# TOS: &quot;The Mark of Gideon&quot; 
-    _(&quot;Aldebaran III&quot;),	# TOS: &quot;The Deadly Years&quot; 
-    _(&quot;Alpha Majoris I&quot;),	# TOS: &quot;Wolf in the Fold&quot; 
-    _(&quot;Altair IV&quot;),		# TOS: &quot;Amok Time 
-    _(&quot;Ariannus&quot;),		# TOS: &quot;Let That Be Your Last Battlefield&quot; 
-    _(&quot;Benecia&quot;),		# TOS: &quot;The Conscience of the King&quot; 
-    _(&quot;Beta Niobe I (Sarpeidon)&quot;),	# TOS: &quot;All Our Yesterdays&quot; 
-    _(&quot;Alpha Carinae II&quot;),	# TOS: &quot;The Ultimate Computer&quot; 
-    _(&quot;Capella IV (Kohath)&quot;),	# TOS: &quot;Friday's Child&quot; (Class G) 
-    _(&quot;Daran V&quot;),		# TOS: &quot;For the World is Hollow and I Have Touched the Sky&quot; 
-    _(&quot;Deneb II&quot;),		# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
-    _(&quot;Eminiar VII&quot;),		# TOS: &quot;A Taste of Armageddon&quot; 
-    _(&quot;Gamma Canaris IV&quot;),	# TOS: &quot;Metamorphosis&quot; 
-    _(&quot;Gamma Tranguli VI (Vaalel)&quot;),	# TOS: &quot;The Apple&quot; 
-    _(&quot;Ingraham B&quot;),		# TOS: &quot;Operation: Annihilate&quot; 
-    _(&quot;Janus IV&quot;),		# TOS: &quot;The Devil in the Dark&quot; 
-    _(&quot;Makus III&quot;),		# TOS: &quot;The Galileo Seven&quot; 
-    _(&quot;Marcos XII&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
-    _(&quot;Omega IV&quot;),		# TOS: &quot;The Omega Glory&quot; 
-    _(&quot;Regulus V&quot;),		# TOS: &quot;Amok Time 
-    _(&quot;Deneva&quot;),		# TOS: &quot;Operation -- Annihilate!&quot; 
-    # Worlds from BSD Trek 
-    _(&quot;Rigel II&quot;),		# TOS: &quot;Shore Leave&quot; (&quot;III&quot; in BSD) 
-    _(&quot;Beta III&quot;),		# TOS: &quot;The Return of the Archons&quot; 
-    _(&quot;Triacus&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
-    _(&quot;Exo III&quot;),		# TOS: &quot;What Are Little Girls Made Of?&quot; (Class P) 
-#	# Others 
-#    _(&quot;Hansen's Planet&quot;),	# TOS: &quot;The Galileo Seven&quot; 
-#    _(&quot;Taurus IV&quot;),		# TOS: &quot;The Galileo Seven&quot; (class G) 
-#    _(&quot;Antos IV (Doraphane)&quot;),	# TOS: &quot;Whom Gods Destroy&quot;, &quot;Who Mourns for Adonais?&quot; 
-#    _(&quot;Izar&quot;),			# TOS: &quot;Whom Gods Destroy&quot; 
-#    _(&quot;Tiburon&quot;),		# TOS: &quot;The Way to Eden&quot; 
-#    _(&quot;Merak II&quot;),		# TOS: &quot;The Cloud Minders&quot; 
-#    _(&quot;Coridan (Desotriana)&quot;),	# TOS: &quot;Journey to Babel&quot; 
-#    _(&quot;Iotia&quot;),		# TOS: &quot;A Piece of the Action&quot; 
-)
-
-device = (
-	_(&quot;S. R. Sensors&quot;), \
-	_(&quot;L. R. Sensors&quot;), \
-	_(&quot;Phasers&quot;), \
-	_(&quot;Photon Tubes&quot;), \
-	_(&quot;Life Support&quot;), \
-	_(&quot;Warp Engines&quot;), \
-	_(&quot;Impulse Engines&quot;), \
-	_(&quot;Shields&quot;), \
-	_(&quot;Subspace Radio&quot;), \
-	_(&quot;Shuttle Craft&quot;), \
-	_(&quot;Computer&quot;), \
-	_(&quot;Navigation System&quot;), \
-	_(&quot;Transporter&quot;), \
-	_(&quot;Shield Control&quot;), \
-	_(&quot;Death Ray&quot;), \
-	_(&quot;D. S. Probe&quot;), \
-)
-
-def setup(needprompt):
-    # prepare to play, set up cosmos 
-    w = coord()
-    #  Decide how many of everything
-    if choose(needprompt):
-	return # frozen game
-    # Prepare the Enterprise
-    game.alldone = game.gamewon = False
-    game.ship = IHE
-    game.state.crew = FULLCREW
-    game.energy = game.inenrg = 5000.0
-    game.shield = game.inshld = 2500.0
-    game.shldchg = False
-    game.shldup = False
-    game.inlsr = 4.0
-    game.lsupres = 4.0
-    game.quadrant = randplace(GALSIZE)
-    game.sector = randplace(QUADSIZE)
-    game.torps = game.intorps = 10
-    game.nprobes = randrange(2, 5)
-    game.warpfac = 5.0
-    game.wfacsq = game.warpfac * game.warpfac
-    for i in range(NDEVICES): 
-	game.damage[i] = 0.0
-    # Set up assorted game parameters
-    game.battle = coord()
-    game.state.date = game.indate = 100.0 * randreal(20, 51)
-    game.nkinks = game.nhelp = game.casual = game.abandoned = 0
-    game.iscate = game.resting = game.imine = game.icrystl = game.icraft = False
-    game.isatb = game.state.nplankl = 0
-    game.state.starkl = game.state.basekl = 0
-    game.iscraft = &quot;onship&quot;
-    game.landed = False
-    game.alive = True
-    game.docfac = 0.25
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    quad = game.state.galaxy[i][j]
-	    quad.charted = 0
-	    quad.planet = None
-	    quad.romulans = 0
-	    quad.klingons = 0
-	    quad.starbase = False
-	    quad.supernova = False
-	    quad.status = &quot;secure&quot;
-    # Initialize times for extraneous events
-    schedule(FSNOVA, expran(0.5 * game.intime))
-    schedule(FTBEAM, expran(1.5 * (game.intime / game.state.remcom)))
-    schedule(FSNAP, randreal(1.0, 2.0)) # Force an early snapshot
-    schedule(FBATTAK, expran(0.3*game.intime))
-    unschedule(FCDBAS)
-    if game.state.nscrem:
-	schedule(FSCMOVE, 0.2777)
-    else:
-	unschedule(FSCMOVE)
-    unschedule(FSCDBAS)
-    unschedule(FDSPROB)
-    if (game.options &amp; OPTION_WORLDS) and game.skill &gt;= SKILL_GOOD:
-	schedule(FDISTR, expran(1.0 + game.intime))
-    else:
-	unschedule(FDISTR)
-    unschedule(FENSLV)
-    unschedule(FREPRO)
-    # Starchart is functional but we've never seen it
-    game.lastchart = FOREVER
-    # Put stars in the galaxy
-    game.instar = 0
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    k = randrange(1, QUADSIZE**2/10+1)
-	    game.instar += k
-	    game.state.galaxy[i][j].stars = k
-    # Locate star bases in galaxy
-    for i in range(game.inbase):
-        while True:
-            while True:
-                w = randplace(GALSIZE)
-                if not game.state.galaxy[w.x][w.y].starbase:
-                    break
-	    contflag = False
-            # C version: for (j = i-1; j &gt; 0; j--)
-            # so it did them in the opposite order.
-            for j in range(1, i):
-		# Improved placement algorithm to spread out bases
-		distq = w.distance(game.state.baseq[j])
-		if distq &lt; 6.0*(BASEMAX+1-game.inbase) and withprob(0.75):
-		    contflag = True
-		    if idebug:
-			prout(&quot;=== Abandoning base #%d at %s&quot; % (i, w))
-		    break
-		elif distq &lt; 6.0 * (BASEMAX+1-game.inbase):
-		    if idebug:
-			prout(&quot;=== Saving base #%d, close to #%d&quot; % (i, j))
-            if not contflag:
-                break
-	game.state.baseq[i] = w
-	game.state.galaxy[w.x][w.y].starbase = True
-	game.state.chart[w.x][w.y].starbase = True
-    # Position ordinary Klingon Battle Cruisers
-    krem = game.inkling
-    klumper = 0.25*game.skill*(9.0-game.length)+1.0
-    if klumper &gt; MAXKLQUAD: 
-	klumper = MAXKLQUAD
-    while True:
-	r = randreal()
-	klump = (1.0 - r*r)*klumper
-	if klump &gt; krem:
-	    klump = krem
-	krem -= klump
-        while True:
-            w = randplace(GALSIZE)
-            if not game.state.galaxy[w.x][w.y].supernova and \
-               game.state.galaxy[w.x][w.y].klingons + klump &lt;= MAXKLQUAD:
-                break
-	game.state.galaxy[w.x][w.y].klingons += int(klump)
-        if krem &lt;= 0:
-            break
-    # Position Klingon Commander Ships
-    for i in range(1, game.incom+1):
-        while True:
-            w = randplace(GALSIZE)
-	    if (game.state.galaxy[w.x][w.y].klingons or withprob(0.25)) and \
-		   not game.state.galaxy[w.x][w.y].supernova and \
-		   game.state.galaxy[w.x][w.y].klingons &lt;= MAXKLQUAD-1 and \
-                   not w in game.state.kcmdr[:i]:
-                break
-	game.state.galaxy[w.x][w.y].klingons += 1
-	game.state.kcmdr[i] = w
-    # Locate planets in galaxy
-    for i in range(game.inplan):
-        while True:
-            w = randplace(GALSIZE) 
-            if game.state.galaxy[w.x][w.y].planet == None:
-                break
-        new = planet()
-	new.w = w
-        new.crystals = &quot;absent&quot;
-	if (game.options &amp; OPTION_WORLDS) and i &lt; NINHAB:
-	    new.pclass = &quot;M&quot;	# All inhabited planets are class M
-	    new.crystals = &quot;absent&quot;
-	    new.known = &quot;known&quot;
-            new.name = systnames[i]
-	    new.inhabited = True
-	else:
-	    new.pclass = (&quot;M&quot;, &quot;N&quot;, &quot;O&quot;)[randrange(0, 3)]
-            if withprob(0.33):
-                new.crystals = &quot;present&quot;
-	    new.known = &quot;unknown&quot;
-	    new.inhabited = False
-	game.state.galaxy[w.x][w.y].planet = new
-        game.state.planets.append(new)
-    # Locate Romulans
-    for i in range(game.state.nromrem):
-	w = randplace(GALSIZE)
-	game.state.galaxy[w.x][w.y].romulans += 1
-    # Locate the Super Commander
-    if game.state.nscrem &gt; 0:
-        while True:
-            w = randplace(GALSIZE)
-            if not game.state.galaxy[w.x][w.y].supernova and game.state.galaxy[w.x][w.y].klingons &lt;= MAXKLQUAD:
-                break
-	game.state.kscmdr = w
-	game.state.galaxy[w.x][w.y].klingons += 1
-    # Place thing (in tournament game, we don't want one!)
-    global thing
-    if game.tourn is None:
-        thing = randplace(GALSIZE)
-    skip(2)
-    game.state.snap = False
-    if game.skill == SKILL_NOVICE:
-	prout(_(&quot;It is stardate %d. The Federation is being attacked by&quot;) % int(game.state.date))
-	prout(_(&quot;a deadly Klingon invasion force. As captain of the United&quot;))
-	prout(_(&quot;Starship U.S.S. Enterprise, it is your mission to seek out&quot;))
-	prout(_(&quot;and destroy this invasion force of %d battle cruisers.&quot;) % ((game.inkling + game.incom + game.inscom)))
-	prout(_(&quot;You have an initial allotment of %d stardates to complete&quot;) % int(game.intime))
-	prout(_(&quot;your mission.  As you proceed you may be given more time.&quot;))
-	skip(1)
-	prout(_(&quot;You will have %d supporting starbases.&quot;) % (game.inbase))
-	proutn(_(&quot;Starbase locations-  &quot;))
-    else:
-	prout(_(&quot;Stardate %d.&quot;) % int(game.state.date))
-	skip(1)
-	prout(_(&quot;%d Klingons.&quot;) % (game.inkling + game.incom + game.inscom))
-	prout(_(&quot;An unknown number of Romulans.&quot;))
-	if game.state.nscrem:
-	    prout(_(&quot;And one (GULP) Super-Commander.&quot;))
-	prout(_(&quot;%d stardates.&quot;) % int(game.intime))
-	proutn(_(&quot;%d starbases in &quot;) % game.inbase)
-    for i in range(game.inbase):
-	proutn(`game.state.baseq[i]`)
-	proutn(&quot;  &quot;)
-    skip(2)
-    proutn(_(&quot;The Enterprise is currently in Quadrant %s&quot;) % game.quadrant)
-    proutn(_(&quot; Sector %s&quot;) % game.sector)
-    skip(2)
-    prout(_(&quot;Good Luck!&quot;))
-    if game.state.nscrem:
-	prout(_(&quot;  YOU'LL NEED IT.&quot;))
-    waitfor()
-    newqad(False)
-    if len(game.enemies) - (thing == game.quadrant) - (game.tholian != None):
-	game.shldup = True
-    if game.neutz:	# bad luck to start in a Romulan Neutral Zone
-	attack(torps_ok=False)
-
-def choose(needprompt):
-    # choose your game type
-    global thing
-    while True:
-	game.tourn = 0
-	game.thawed = False
-	game.skill = SKILL_NONE
-	game.length = 0
-	if needprompt: # Can start with command line options 
-	    proutn(_(&quot;Would you like a regular, tournament, or saved game? &quot;))
-	scan()
-	if len(citem)==0: # Try again
-	    continue
-        if isit(&quot;tournament&quot;):
-	    while scan() == IHEOL:
-		proutn(_(&quot;Type in tournament number-&quot;))
-	    if aaitem == 0:
-		chew()
-		continue # We don't want a blank entry
-	    game.tourn = int(round(aaitem))
-	    random.seed(aaitem)
-            if logfp:
-                logfp.write(&quot;# random.seed(%d)\n&quot; % aaitem)
-	    break
-        if isit(&quot;saved&quot;) or isit(&quot;frozen&quot;):
-	    if thaw():
-		continue
-	    chew()
-	    if game.passwd == None:
-		continue
-	    if not game.alldone:
-		game.thawed = True # No plaque if not finished
-	    report()
-	    waitfor()
-	    return True
-        if isit(&quot;regular&quot;):
-	    break
-	proutn(_(&quot;What is \&quot;%s\&quot;?&quot;), citem)
-	chew()
-    while game.length==0 or game.skill==SKILL_NONE:
-	if scan() == IHALPHA:
-            if isit(&quot;short&quot;):
-		game.length = 1
-	    elif isit(&quot;medium&quot;):
-		game.length = 2
-	    elif isit(&quot;long&quot;):
-		game.length = 4
-	    elif isit(&quot;novice&quot;):
-		game.skill = SKILL_NOVICE
-	    elif isit(&quot;fair&quot;):
-		game.skill = SKILL_FAIR
-	    elif isit(&quot;good&quot;):
-		game.skill = SKILL_GOOD
-	    elif isit(&quot;expert&quot;):
-		game.skill = SKILL_EXPERT
-	    elif isit(&quot;emeritus&quot;):
-		game.skill = SKILL_EMERITUS
-	    else:
-		proutn(_(&quot;What is \&quot;&quot;))
-		proutn(citem)
-		prout(&quot;\&quot;?&quot;)
-	else:
-	    chew()
-	    if game.length==0:
-		proutn(_(&quot;Would you like a Short, Medium, or Long game? &quot;))
-	    elif game.skill == SKILL_NONE:
-		proutn(_(&quot;Are you a Novice, Fair, Good, Expert, or Emeritus player? &quot;))
-    # Choose game options -- added by ESR for SST2K
-    if scan() != IHALPHA:
-	chew()
-	proutn(_(&quot;Choose your game style (or just press enter): &quot;))
-	scan()
-    if isit(&quot;plain&quot;):
-	# Approximates the UT FORTRAN version.
-	game.options &amp;=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_PLAIN
-    elif isit(&quot;almy&quot;):
-	# Approximates Tom Almy's version.
-	game.options &amp;=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_ALMY
-    elif isit(&quot;fancy&quot;):
-	pass
-    elif len(citem):
-        proutn(_(&quot;What is \&quot;%s\&quot;?&quot;) % citem)
-    setpassword()
-    if game.passwd == &quot;debug&quot;:
-	idebug = True
-	fputs(&quot;=== Debug mode enabled\n&quot;, sys.stdout)
-
-    # Use parameters to generate initial values of things
-    game.damfac = 0.5 * game.skill
-    game.state.rembase = randrange(BASEMIN, BASEMAX+1)
-    game.inbase = game.state.rembase
-    game.inplan = 0
-    if game.options &amp; OPTION_PLANETS:
-	game.inplan += randrange(MAXUNINHAB/2, MAXUNINHAB+1)
-    if game.options &amp; OPTION_WORLDS:
-	game.inplan += int(NINHAB)
-    game.state.nromrem = game.inrom = randrange(2 *game.skill)
-    game.state.nscrem = game.inscom = (game.skill &gt; SKILL_FAIR)
-    game.state.remtime = 7.0 * game.length
-    game.intime = game.state.remtime
-    game.state.remkl = game.inkling = 2.0*game.intime*((game.skill+1 - 2*randreal())*game.skill*0.1+.15)
-    game.incom = int(game.skill + 0.0625*game.inkling*randreal())
-    game.state.remcom = min(10, game.incom)
-    game.incom = game.state.remcom
-    game.state.remres = (game.inkling+4*game.incom)*game.intime
-    game.inresor = game.state.remres
-    if game.inkling &gt; 50:
-        game.state.rembase += 1
-	game.inbase = game.state.rembase
-    return False
-
-def dropin(iquad=None):
-    # drop a feature on a random dot in the current quadrant 
-    w = coord()
-    while True:
-        w = randplace(QUADSIZE)
-        if game.quad[w.x][w.y] == IHDOT:
-            break
-    if iquad is not None:
-        game.quad[w.x][w.y] = iquad
-    return w
-
-def newcnd():
-    # update our alert status 
-    game.condition = &quot;green&quot;
-    if game.energy &lt; 1000.0:
-	game.condition = &quot;yellow&quot;
-    if game.state.galaxy[game.quadrant.x][game.quadrant.y].klingons or game.state.galaxy[game.quadrant.x][game.quadrant.y].romulans:
-	game.condition = &quot;red&quot;
-    if not game.alive:
-	game.condition=&quot;dead&quot;
-
-def newkling():
-    # drop new Klingon into current quadrant
-    return enemy(IHK, loc=dropin(), power=randreal(300,450)+25.0*game.skill)
-
-def newqad(shutup):
-    # set up a new state of quadrant, for when we enter or re-enter it 
-    w = coord()
-    game.justin = True
-    game.klhere = 0
-    game.comhere = False
-    game.ishere = False
-    game.irhere = 0
-    game.iplnet = 0
-    game.neutz = False
-    game.inorbit = False
-    game.landed = False
-    game.ientesc = False
-    game.iseenit = False
-    # Create a blank quadrant
-    game.quad = fill2d(QUADSIZE, lambda i, j: IHDOT)
-    if game.iscate:
-	# Attempt to escape Super-commander, so tbeam back!
-	game.iscate = False
-	game.ientesc = True
-    q = game.state.galaxy[game.quadrant.x][game.quadrant.y]
-    # cope with supernova
-    if q.supernova:
-	return
-    game.klhere = q.klingons
-    game.irhere = q.romulans
-    # Position Starship
-    game.quad[game.sector.x][game.sector.y] = game.ship
-    game.enemies = []
-    if q.klingons:
-	# Position ordinary Klingons
-	for i in range(game.klhere):
-            newkling()
-	# If we need a commander, promote a Klingon
-	for i in range(game.state.remcom):
-	    if game.state.kcmdr[i] == game.quadrant:
-                e = game.enemies[game.klhere-1]
-                game.quad[e.kloc.x][e.kloc.y] = IHC
-                e.kpower = randreal(950,1350) + 50.0*game.skill
-                game.comhere = True
-		break	
-	# If we need a super-commander, promote a Klingon
-	if game.quadrant == game.state.kscmdr:
-            e = game.enemies[0]
-	    game.quad[e.kloc.x][e.kloc.y] = IHS
-	    e.kpower = randreal(1175.0,  1575.0) + 125.0*game.skill
-	    game.iscate = (game.state.remkl &gt; 1)
-	    game.ishere = True
-    # Put in Romulans if needed
-    for i in range(game.klhere, len(game.enemies)):
-        enemy(IHR, loc=dropin(), power=randreal(400.0,850.0)+50.0*game.skill)
-    # If quadrant needs a starbase, put it in
-    if q.starbase:
-	game.base = dropin(IHB)
-    # If quadrant needs a planet, put it in
-    if q.planet:
-	game.iplnet = q.planet
-	if not q.planet.inhabited:
-	    game.plnet = dropin(IHP)
-	else:
-	    game.plnet = dropin(IHW)
-    # Check for condition
-    newcnd()
-    # Check for RNZ
-    if game.irhere &gt; 0 and game.klhere == 0:
-	game.neutz = True
-	if not damaged(DRADIO):
-	    skip(1)
-	    prout(_(&quot;LT. Uhura- \&quot;Captain, an urgent message.&quot;))
-	    prout(_(&quot;  I'll put it on audio.\&quot;  CLICK&quot;))
-	    skip(1)
-	    prout(_(&quot;INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE.&quot;))
-	    prout(_(&quot;LEAVE AT ONCE, OR YOU WILL BE DESTROYED!&quot;))
-    if shutup==0:
-	# Put in THING if needed
-	if thing == game.quadrant:
-	    enemy(type=IHQUEST, loc=dropin(),
-                      power=randreal(6000,6500.0)+250.0*game.skill)
-	    if not damaged(DSRSENS):
-		skip(1)
-		prout(_(&quot;Mr. Spock- \&quot;Captain, this is most unusual.&quot;))
-		prout(_(&quot;    Please examine your short-range scan.\&quot;&quot;))
-    # Decide if quadrant needs a Tholian; lighten up if skill is low 
-    if game.options &amp; OPTION_THOLIAN:
-	if (game.skill &lt; SKILL_GOOD and withprob(0.02)) or \
-	    (game.skill == SKILL_GOOD and withprob(0.05)) or \
-            (game.skill &gt; SKILL_GOOD and withprob(0.08)):
-            w = coord()
-            while True:
-		w.x = withprob(0.5) * (QUADSIZE-1)
-		w.y = withprob(0.5) * (QUADSIZE-1)
-                if game.quad[w.x][w.y] == IHDOT:
-                    break
-            game.tholian = enemy(type=IHT, loc=w,
-                                 power=randrange(100, 500) + 25.0*game.skill)
-	    # Reserve unoccupied corners 
-	    if game.quad[0][0]==IHDOT:
-		game.quad[0][0] = 'X'
-	    if game.quad[0][QUADSIZE-1]==IHDOT:
-		game.quad[0][QUADSIZE-1] = 'X'
-	    if game.quad[QUADSIZE-1][0]==IHDOT:
-		game.quad[QUADSIZE-1][0] = 'X'
-	    if game.quad[QUADSIZE-1][QUADSIZE-1]==IHDOT:
-		game.quad[QUADSIZE-1][QUADSIZE-1] = 'X'
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # And finally the stars
-    for i in range(q.stars):
-	dropin(IHSTAR)
-    # Put in a few black holes
-    for i in range(1, 3+1):
-	if withprob(0.5): 
-	    dropin(IHBLANK)
-    # Take out X's in corners if Tholian present
-    if game.tholian:
-	if game.quad[0][0]=='X':
-	    game.quad[0][0] = IHDOT
-	if game.quad[0][QUADSIZE-1]=='X':
-	    game.quad[0][QUADSIZE-1] = IHDOT
-	if game.quad[QUADSIZE-1][0]=='X':
-	    game.quad[QUADSIZE-1][0] = IHDOT
-	if game.quad[QUADSIZE-1][QUADSIZE-1]=='X':
-	    game.quad[QUADSIZE-1][QUADSIZE-1] = IHDOT
-
-def setpassword():
-    # set the self-destruct password 
-    if game.options &amp; OPTION_PLAIN:
-	while True:
-	    chew()
-	    proutn(_(&quot;Please type in a secret password- &quot;))
-	    scan()
-	    game.passwd = citem
-	    if game.passwd != None:
-		break
-    else:
-        game.passwd = &quot;&quot;
-        for i in range(3):
-	    game.passwd += chr(ord('a')+randrange(26))
-
-# Code from sst.c begins here
-
-commands = {
-    &quot;SRSCAN&quot;:   	OPTION_TTY,
-    &quot;STATUS&quot;:   	OPTION_TTY,
-    &quot;REQUEST&quot;:  	OPTION_TTY,
-    &quot;LRSCAN&quot;:   	OPTION_TTY,
-    &quot;PHASERS&quot;:  	0,
-    &quot;TORPEDO&quot;:  	0,
-    &quot;PHOTONS&quot;:  	0,
-    &quot;MOVE&quot;:     	0,
-    &quot;SHIELDS&quot;:   	0,
-    &quot;DOCK&quot;:     	0,
-    &quot;DAMAGES&quot;:   	0,
-    &quot;CHART&quot;:    	0,
-    &quot;IMPULSE&quot;:  	0,
-    &quot;REST&quot;:     	0,
-    &quot;WARP&quot;:     	0,
-    &quot;SCORE&quot;:    	0,
-    &quot;SENSORS&quot;:  	OPTION_PLANETS,
-    &quot;ORBIT&quot;:		OPTION_PLANETS,
-    &quot;TRANSPORT&quot;:	OPTION_PLANETS,
-    &quot;MINE&quot;:		OPTION_PLANETS,
-    &quot;CRYSTALS&quot;:  	OPTION_PLANETS,
-    &quot;SHUTTLE&quot;:  	OPTION_PLANETS,
-    &quot;PLANETS&quot;:  	OPTION_PLANETS,
-    &quot;REPORT&quot;:   	0,
-    &quot;COMPUTER&quot;: 	0,
-    &quot;COMMANDS&quot;: 	0,
-    &quot;EMEXIT&quot;:		0,
-    &quot;PROBE&quot;:		OPTION_PROBE,
-    &quot;SAVE&quot;:		0,
-    &quot;FREEZE&quot;:		0,	# Synonym for SAVE
-    &quot;ABANDON&quot;:  	0,
-    &quot;DESTRUCT&quot;: 	0,
-    &quot;DEATHRAY&quot;: 	0,
-    &quot;DEBUG&quot;:    	0,
-    &quot;MAYDAY&quot;:		0,
-    &quot;SOS&quot;:		0,	# Synonym for MAYDAY
-    &quot;CALL&quot;:		0,	# Synonym for MAYDAY
-    &quot;QUIT&quot;:		0,
-    &quot;HELP&quot;:		0,
-    &quot;SEED&quot;:		0,
-    &quot;VISUAL&quot;:		0,
-}
-
-def ACCEPT(cmd):	return (not commands[cmd] or (commands[cmd] &amp; game.options))
-
-def listCommands():
-    # generate a list of legal commands 
-    k = 0
-    proutn(_(&quot;LEGAL COMMANDS ARE:&quot;))
-    for key in commands:
-	if ACCEPT(key):
-            if k % 5 == 0:
-                skip(1)
-            proutn(&quot;%-12s &quot; % key) 
-            k += 1
-    skip(1)
-
-def helpme():
-    # browse on-line help 
-    # Give help on commands 
-    key = scan()
-    while True:
-	if key == IHEOL:
-	    setwnd(prompt_window)
-	    proutn(_(&quot;Help on what command? &quot;))
-	    key = scan()
-	setwnd(message_window)
-	if key == IHEOL:
-	    return
-        if citem in commands or citem == &quot;ABBREV&quot;:
-	    break
-	skip(1)
-	listCommands()
-	key = IHEOL
-	chew()
-	skip(1)
-    cmd = citem.upper()
-    try:
-        fp = open(SSTDOC, &quot;r&quot;)
-    except IOError:
-        try:
-            fp = open(DOC_NAME, &quot;r&quot;)
-        except IOError:
-            prout(_(&quot;Spock-  \&quot;Captain, that information is missing from the&quot;))
-            proutn(_(&quot;   computer. You need to find &quot;))
-            proutn(DOC_NAME)
-            prout(_(&quot; and put it in the&quot;))
-            proutn(_(&quot;   current directory or to &quot;))
-            proutn(SSTDOC)
-            prout(&quot;.\&quot;&quot;)
-            #
-            # This used to continue: &quot;You need to find SST.DOC and put 
-            # it in the current directory.&quot;
-            # 
-            return
-    while True:
-        linebuf = fp.readline()
-	if linebuf == '':
-	    prout(_(&quot;Spock- \&quot;Captain, there is no information on that command.\&quot;&quot;))
-	    fp.close()
-	    return
-	if linebuf[0] == '%' and linebuf[1] == '%' and linebuf[2] == ' ':
-            linebuf = linebuf[3:].strip()
-            if cmd == linebuf:
-		break
-    skip(1)
-    prout(_(&quot;Spock- \&quot;Captain, I've found the following information:\&quot;&quot;))
-    skip(1)
-    while linebuf in fp:
-        if &quot;******&quot; in linebuf:
-	    break
-	proutn(linebuf)
-    fp.close()
-
-def makemoves():
-    # command-interpretation loop 
-    v = 0
-    clrscr()
-    setwnd(message_window)
-    while True: 	# command loop 
-	drawmaps(1)
-        while True:	# get a command 
-	    hitme = False
-	    game.justin = False
-	    game.optime = 0.0
-	    chew()
-	    setwnd(prompt_window)
-	    clrscr()
-	    proutn(&quot;COMMAND&gt; &quot;)
-	    if scan() == IHEOL:
-		if game.options &amp; OPTION_CURSES:
-		    makechart()
-		continue
-	    game.ididit = False
-	    clrscr()
-	    setwnd(message_window)
-	    clrscr()
-            candidates = filter(lambda x: x.startswith(citem.upper()),
-                                commands)
-            if len(candidates) == 1:
-                cmd = candidates[0]
-                break
-            elif candidates and not (game.options &amp; OPTION_PLAIN):
-                prout(&quot;Commands with that prefix: &quot; + &quot; &quot;.join(candidates))
-            else:
-                listCommands()
-                continue
-	if cmd == &quot;SRSCAN&quot;:		# srscan
-	    srscan()
-	elif cmd == &quot;STATUS&quot;:		# status
-	    status()
-	elif cmd == &quot;REQUEST&quot;:		# status request 
-	    request()
-	elif cmd == &quot;LRSCAN&quot;:		# long range scan
-	    lrscan(silent=False)
-	elif cmd == &quot;PHASERS&quot;:		# phasers
-	    phasers()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;TORPEDO&quot;:		# photon torpedos
-	    photon()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;MOVE&quot;:		# move under warp
-	    warp(False)
-	elif cmd == &quot;SHIELDS&quot;:		# shields
-	    doshield(shraise=False)
-	    if game.ididit:
-		hitme = True
-		game.shldchg = False
-	elif cmd == &quot;DOCK&quot;:		# dock at starbase
-	    dock(True)
-	    if game.ididit:
-		attack(torps_ok=False)		
-	elif cmd == &quot;DAMAGES&quot;:		# damage reports
-	    damagereport()
-	elif cmd == &quot;CHART&quot;:		# chart
-	    makechart()
-	elif cmd == &quot;IMPULSE&quot;:		# impulse
-	    impulse()
-	elif cmd == &quot;REST&quot;:		# rest
-	    os.wait()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;WARP&quot;:		# warp
-	    setwarp()
-	elif cmd == &quot;SCORE&quot;:		# score
-	    score()
-	elif cmd == &quot;SENSORS&quot;:		# sensors
-	    sensor()
-	elif cmd == &quot;ORBIT&quot;:		# orbit
-	    orbit()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;TRANSPORT&quot;:		# transport &quot;beam&quot;
-	    beam()
-	elif cmd == &quot;MINE&quot;:		# mine
-	    mine()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;CRYSTALS&quot;:		# crystals
-	    usecrystals()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;SHUTTLE&quot;:		# shuttle
-	    shuttle()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;PLANETS&quot;:		# Planet list
-	    survey()
-	elif cmd == &quot;REPORT&quot;:		# Game Report 
-	    report()
-	elif cmd == &quot;COMPUTER&quot;:		# use COMPUTER!
-	    eta()
-	elif cmd == &quot;COMMANDS&quot;:
-	    listCommands()
-	elif cmd == &quot;EMEXIT&quot;:		# Emergency exit
-	    clrscr()			# Hide screen
-	    freeze(True)		# forced save
-	    raise SysExit,1			# And quick exit
-	elif cmd == &quot;PROBE&quot;:
-	    probe()			# Launch probe
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;ABANDON&quot;:		# Abandon Ship
-	    abandon()
-	elif cmd == &quot;DESTRUCT&quot;:		# Self Destruct
-	    selfdestruct()
-	elif cmd == &quot;SAVE&quot;:		# Save Game
-	    freeze(False)
-	    clrscr()
-	    if game.skill &gt; SKILL_GOOD:
-		prout(_(&quot;WARNING--Saved games produce no plaques!&quot;))
-	elif cmd == &quot;DEATHRAY&quot;:		# Try a desparation measure
-	    deathray()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;DEBUGCMD&quot;:		# What do we want for debug???
-	    debugme()
-	elif cmd == &quot;MAYDAY&quot;:		# Call for help
-	    mayday()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;QUIT&quot;:
-	    game.alldone = True		# quit the game
-	elif cmd == &quot;HELP&quot;:
-	    helpme()			# get help
-	while True:
-	    if game.alldone:
-		break		# Game has ended
-	    if game.optime != 0.0:
-		events()
-		if game.alldone:
-		    break	# Events did us in
-	    if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-		atover(False)
-		continue
-	    if hitme and not game.justin:
-		attack(torps_ok=True)
-		if game.alldone:
-		    break
-		if game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova:
-		    atover(False)
-		    hitme = True
-		    continue
-	    break
-	if game.alldone:
-	    break
-    if idebug:
-	prout(&quot;=== Ending&quot;)
-
-def cramen(cmd):
-    # return an enemy 
-    if   cmd == IHR: s = _(&quot;Romulan&quot;)
-    elif cmd == IHK: s = _(&quot;Klingon&quot;)
-    elif cmd == IHC: s = _(&quot;Commander&quot;)
-    elif cmd == IHS: s = _(&quot;Super-commander&quot;)
-    elif cmd == IHSTAR: s = _(&quot;Star&quot;)
-    elif cmd == IHP: s = _(&quot;Planet&quot;)
-    elif cmd == IHB: s = _(&quot;Starbase&quot;)
-    elif cmd == IHBLANK: s = _(&quot;Black hole&quot;)
-    elif cmd == IHT: s = _(&quot;Tholian&quot;)
-    elif cmd == IHWEB: s = _(&quot;Tholian web&quot;)
-    elif cmd == IHQUEST: s = _(&quot;Stranger&quot;)
-    elif cmd == IHW: s = _(&quot;Inhabited World&quot;)
-    else: s = &quot;Unknown??&quot;
-    proutn(s)
-
-def crmena(stars, enemy, loctype, w):
-    # print an enemy and his location 
-    if stars:
-	proutn(&quot;***&quot;)
-    cramen(enemy)
-    proutn(_(&quot; at &quot;))
-    buf = &quot;&quot;
-    if loctype == &quot;quadrant&quot;:
-	buf = _(&quot;Quadrant &quot;)
-    elif loctype == &quot;sector&quot;:
-	buf = _(&quot;Sector &quot;)
-    proutn(buf + `w`)
-
-def crmshp():
-    # print our ship name 
-    if game.ship == IHE:
-        s = _(&quot;Enterprise&quot;)
-    elif game.ship == IHF:
-        s = _(&quot;Faerie Queene&quot;)
-    else:
-        s = &quot;Ship???&quot;
-    proutn(s)
-
-def stars():
-    # print a line of stars 
-    prouts(&quot;******************************************************&quot;)
-    skip(1)
-
-def expran(avrage):
-    return -avrage*math.log(1e-7 + randreal())
-
-def randplace(size):
-    # choose a random location  
-    w = coord()
-    w.x = randrange(size) 
-    w.y = randrange(size)
-    return w
-
-def chew():
-    # Demand input for next scan
-    global inqueue
-    inqueue = None
-
-def chew2():
-    # return IHEOL next time 
-    global inqueue
-    inqueue = []
-
-def scan():
-    # Get a token from the user
-    global inqueue, line, citem, aaitem
-    aaitem = 0.0
-    citem = ''
-
-    # Read a line if nothing here
-    if inqueue == None:
-	line = cgetline()
-	if curwnd==prompt_window:
-	    clrscr()
-	    setwnd(message_window)
-	    clrscr()
-        # Skip leading white space
-        line = line.lstrip()
-        if line:
-            inqueue = line.split()
-        else:
-            inqueue = []
-            return IHEOL
-    elif not inqueue:
-        return IHEOL
-    # From here on in it's all looking at the queue
-    citem = inqueue.pop(0)
-    if citem == IHEOL:
-        return IHEOL
-    try:
-        aaitem = float(citem)
-        return IHREAL
-    except ValueError:
-        pass
-    # Treat as alpha
-    citem = citem.lower()
-    return IHALPHA
-
-def ja():
-    # yes-or-no confirmation 
-    chew()
-    while True:
-	scan()
-	chew()
-	if citem == 'y':
-	    return True
-	if citem == 'n':
-	    return False
-	proutn(_(&quot;Please answer with \&quot;y\&quot; or \&quot;n\&quot;: &quot;))
-
-def huh():
-    # complain about unparseable input 
-    chew()
-    skip(1)
-    prout(_(&quot;Beg your pardon, Captain?&quot;))
-
-def isit(s):
-    # compares s to citem and returns true if it matches to the length of s
-    return s.startswith(citem)
-
-def debugme():
-    # access to the internals for debugging 
-    proutn(&quot;Reset levels? &quot;)
-    if ja() == True:
-	if game.energy &lt; game.inenrg:
-	    game.energy = game.inenrg
-	game.shield = game.inshld
-	game.torps = game.intorps
-	game.lsupres = game.inlsr
-    proutn(&quot;Reset damage? &quot;)
-    if ja() == True:
-	for i in range(NDEVICES): 
-	    if game.damage[i] &gt; 0.0: 
-		game.damage[i] = 0.0
-    proutn(&quot;Toggle debug flag? &quot;)
-    if ja() == True:
-	idebug = not idebug
-	if idebug:
-	    prout(&quot;Debug output ON&quot;)	    
-	else:
-	    prout(&quot;Debug output OFF&quot;)
-    proutn(&quot;Cause selective damage? &quot;)
-    if ja() == True:
-	for i in range(NDEVICES):
-	    proutn(&quot;Kill &quot;)
-	    proutn(device[i])
-	    proutn(&quot;? &quot;)
-	    chew()
-	    key = scan()
-            if key == IHALPHA and isit(&quot;y&quot;):
-		game.damage[i] = 10.0
-    proutn(&quot;Examine/change events? &quot;)
-    if ja() == True:
-	ev = event()
-	w = coord()
-        legends = {
-            FSNOVA:  &quot;Supernova       &quot;,
-            FTBEAM:  &quot;T Beam          &quot;,
-            FSNAP:   &quot;Snapshot        &quot;,
-            FBATTAK: &quot;Base Attack     &quot;,
-            FCDBAS:  &quot;Base Destroy    &quot;,
-            FSCMOVE: &quot;SC Move         &quot;,
-            FSCDBAS: &quot;SC Base Destroy &quot;,
-            FDSPROB: &quot;Probe Move      &quot;,
-            FDISTR:  &quot;Distress Call   &quot;,
-            FENSLV:  &quot;Enslavement     &quot;,
-            FREPRO:  &quot;Klingon Build   &quot;,
-        }
-	for i in range(1, NEVENTS):
-            proutn(legends[i])
-	    if is_scheduled(i):
-		proutn(&quot;%.2f&quot; % (scheduled(i)-game.state.date))
-		if i == FENSLV or i == FREPRO:
-		    ev = findevent(i)
-		    proutn(&quot; in %s&quot; % ev.quadrant)
-	    else:
-		proutn(&quot;never&quot;)
-	    proutn(&quot;? &quot;)
-	    chew()
-	    key = scan()
-	    if key == 'n':
-		unschedule(i)
-		chew()
-	    elif key == IHREAL:
-		ev = schedule(i, aaitem)
-		if i == FENSLV or i == FREPRO:
-		    chew()
-		    proutn(&quot;In quadrant- &quot;)
-		    key = scan()
-		    # IHEOL says to leave coordinates as they are 
-		    if key != IHEOL:
-			if key != IHREAL:
-			    prout(&quot;Event %d canceled, no x coordinate.&quot; % (i))
-			    unschedule(i)
-			    continue
-			w.x = int(round(aaitem))
-			key = scan()
-			if key != IHREAL:
-			    prout(&quot;Event %d canceled, no y coordinate.&quot; % (i))
-			    unschedule(i)
-			    continue
-			w.y = int(round(aaitem))
-			ev.quadrant = w
-	chew()
-    proutn(&quot;Induce supernova here? &quot;)
-    if ja() == True:
-	game.state.galaxy[game.quadrant.x][game.quadrant.y].supernova = True
-	atover(True)
-
-if __name__ == '__main__':
-    try:
-        global line, thing, game, idebug
-        game = citem = aaitem = inqueue = None
-        line = ''
-        thing = coord()
-        thing.angry = False
-        game = gamestate()
-        idebug = 0
-        game.options = OPTION_ALL &amp;~ (OPTION_IOMODES | OPTION_PLAIN | OPTION_ALMY)
-        # Disable curses mode until the game logic is working.
-        #    if os.getenv(&quot;TERM&quot;):
-        #	game.options |= OPTION_CURSES | OPTION_SHOWME
-        #    else:
-        game.options |= OPTION_TTY
-        seed = int(time.time())
-        (options, arguments) = getopt.getopt(sys.argv[1:], &quot;r:tx&quot;)
-        for (switch, val) in options:
-            if switch == '-r':
-                try:
-                    replayfp = open(val, &quot;r&quot;)
-                except IOError:
-                    sys.stderr.write(&quot;sst: can't open replay file %s\n&quot; % val)
-                    raise SystemExit, 1
-                try:
-                    line = replayfp.readline().strip()
-                    (leader, key, seed) = line.split()
-                    seed = eval(seed)
-                    sys.stderr.write(&quot;sst2k: seed set to %s\n&quot; % seed)
-                    line = replayfp.readline().strip()
-                    arguments += line.split()[2:]
-                except ValueError:
-                    sys.stderr.write(&quot;sst: replay file %s is ill-formed\n&quot;% val)
-                    raise SystemExit(1)
-                game.options |= OPTION_TTY
-                game.options &amp;=~ OPTION_CURSES
-            elif switch == '-t':
-                game.options |= OPTION_TTY
-                game.options &amp;=~ OPTION_CURSES
-            elif switch == '-x':
-                idebug = True
-            else:
-                sys.stderr.write(&quot;usage: sst [-t] [-x] [startcommand...].\n&quot;)
-                raise SystemExit, 1
-        # where to save the input in case of bugs
-        try:
-            logfp = open(&quot;/usr/tmp/sst-input.log&quot;, &quot;w&quot;)
-        except IOError:
-            sys.stderr.write(&quot;sst: warning, can't open logfile\n&quot;)
-        if logfp:
-            logfp.write(&quot;# seed %s\n&quot; % seed)
-            logfp.write(&quot;# options %s\n&quot; % &quot; &quot;.join(arguments))
-        random.seed(seed)
-        if arguments:
-            inqueue = arguments
-        else:
-            inqueue = None
-        try:
-            iostart()
-            while True: # Play a game 
-                setwnd(fullscreen_window)
-                clrscr()
-                prelim()
-                setup(needprompt=not inqueue)
-                if game.alldone:
-                    score()
-                    game.alldone = False
-                else:
-                    makemoves()
-                skip(1)
-                stars()
-                skip(1)
-                if game.tourn and game.alldone:
-                    proutn(_(&quot;Do you want your score recorded?&quot;))
-                    if ja() == True:
-                        chew2()
-                        freeze(False)
-                chew()
-                proutn(_(&quot;Do you want to play again? &quot;))
-                if not ja():
-                    break
-            skip(1)
-            prout(_(&quot;May the Great Bird of the Galaxy roost upon your home planet.&quot;))
-        finally:
-            ioend()
-        raise SystemExit, 0
-    except KeyboardInterrupt:
-        print&quot;&quot;
-        pass


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000168.html">[Sst-commit-watch] r701 - branches
</A></li>
	<LI>Next message: <A HREF="000170.html">[Sst-commit-watch] r703 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#169">[ date ]</a>
              <a href="thread.html#169">[ thread ]</a>
              <a href="subject.html#169">[ subject ]</a>
              <a href="author.html#169">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">More information about the Sst-commit-watch
mailing list</a><br>
</body></html>
