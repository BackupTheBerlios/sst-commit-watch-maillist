<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Sst-commit-watch] r810 - in trunk: . c-version c-version/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/sst-commit-watch/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r810%20-%20in%20trunk%3A%20.%20c-version%20c-version/src&In-Reply-To=%3C20101130081536.A6EF9480149%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000278.html">
   <LINK REL="Next"  HREF="000280.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Sst-commit-watch] r810 - in trunk: . c-version c-version/src</H1>
    <B>esr at mail.berlios.de</B> 
    <A HREF="mailto:sst-commit-watch%40lists.berlios.de?Subject=Re%3A%20%5BSst-commit-watch%5D%20r810%20-%20in%20trunk%3A%20.%20c-version%20c-version/src&In-Reply-To=%3C20101130081536.A6EF9480149%40sheep.berlios.de%3E"
       TITLE="[Sst-commit-watch] r810 - in trunk: . c-version c-version/src">esr at mail.berlios.de
       </A><BR>
    <I>Tue Nov 30 09:15:36 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000278.html">[Sst-commit-watch] r809 - branches
</A></li>
        <LI>Next message: <A HREF="000280.html">[Sst-commit-watch] r811 - in trunk: . c-version
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#279">[ date ]</a>
              <a href="thread.html#279">[ thread ]</a>
              <a href="subject.html#279">[ subject ]</a>
              <a href="author.html#279">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: esr
Date: 2010-11-30 09:15:36 +0100 (Tue, 30 Nov 2010)
New Revision: 810

Added:
   trunk/c-version/
   trunk/c-version/ABOUT-NLS
   trunk/c-version/Makefile.am
   trunk/c-version/autogen.sh
   trunk/c-version/compile
   trunk/c-version/config.guess
   trunk/c-version/config.rpath
   trunk/c-version/config.sub
   trunk/c-version/configure.ac
   trunk/c-version/depcomp
   trunk/c-version/install-sh
   trunk/c-version/m4/
   trunk/c-version/missing
   trunk/c-version/mkinstalldirs
   trunk/c-version/src/
   trunk/c-version/sst.spec
   trunk/sst.py
Removed:
   trunk/ABOUT-NLS
   trunk/Makefile.am
   trunk/autogen.sh
   trunk/c-version/src/sst.py
   trunk/compile
   trunk/config.guess
   trunk/config.rpath
   trunk/config.sub
   trunk/configure.ac
   trunk/depcomp
   trunk/install-sh
   trunk/m4/
   trunk/missing
   trunk/mkinstalldirs
   trunk/src/
   trunk/sst.spec
Log:
C files and associated autotools stuff moved to the c-version subdirectory.


Deleted: trunk/ABOUT-NLS
===================================================================
--- trunk/ABOUT-NLS	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/ABOUT-NLS	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,996 +0,0 @@
-1 Notes on the Free Translation Project
-***************************************
-
-Free software is going international!  The Free Translation Project is
-a way to get maintainers of free software, translators, and users all
-together, so that free software will gradually become able to speak many
-languages.  A few packages already provide translations for their
-messages.
-
-   If you found this `ABOUT-NLS' file inside a distribution, you may
-assume that the distributed package does use GNU `gettext' internally,
-itself available at your nearest GNU archive site.  But you do _not_
-need to install GNU `gettext' prior to configuring, installing or using
-this package with messages translated.
-
-   Installers will find here some useful hints.  These notes also
-explain how users should proceed for getting the programs to use the
-available translations.  They tell how people wanting to contribute and
-work on translations can contact the appropriate team.
-
-   When reporting bugs in the `intl/' directory or bugs which may be
-related to internationalization, you should tell about the version of
-`gettext' which is used.  The information can be found in the
-`intl/VERSION' file, in internationalized packages.
-
-1.1 Quick configuration advice
-==============================
-
-If you want to exploit the full power of internationalization, you
-should configure it using
-
-     ./configure --with-included-gettext
-
-to force usage of internationalizing routines provided within this
-package, despite the existence of internationalizing capabilities in the
-operating system where this package is being installed.  So far, only
-the `gettext' implementation in the GNU C library version 2 provides as
-many features (such as locale alias, message inheritance, automatic
-charset conversion or plural form handling) as the implementation here.
-It is also not possible to offer this additional functionality on top
-of a `catgets' implementation.  Future versions of GNU `gettext' will
-very likely convey even more functionality.  So it might be a good idea
-to change to GNU `gettext' as soon as possible.
-
-   So you need _not_ provide this option if you are using GNU libc 2 or
-you have installed a recent copy of the GNU gettext package with the
-included `libintl'.
-
-1.2 INSTALL Matters
-===================
-
-Some packages are &quot;localizable&quot; when properly installed; the programs
-they contain can be made to speak your own native language.  Most such
-packages use GNU `gettext'.  Other packages have their own ways to
-internationalization, predating GNU `gettext'.
-
-   By default, this package will be installed to allow translation of
-messages.  It will automatically detect whether the system already
-provides the GNU `gettext' functions.  If not, the included GNU
-`gettext' library will be used.  This library is wholly contained
-within this package, usually in the `intl/' subdirectory, so prior
-installation of the GNU `gettext' package is _not_ required.
-Installers may use special options at configuration time for changing
-the default behaviour.  The commands:
-
-     ./configure --with-included-gettext
-     ./configure --disable-nls
-
-will, respectively, bypass any pre-existing `gettext' to use the
-internationalizing routines provided within this package, or else,
-_totally_ disable translation of messages.
-
-   When you already have GNU `gettext' installed on your system and run
-configure without an option for your new package, `configure' will
-probably detect the previously built and installed `libintl.a' file and
-will decide to use this.  This might not be desirable.  You should use
-the more recent version of the GNU `gettext' library.  I.e. if the file
-`intl/VERSION' shows that the library which comes with this package is
-more recent, you should use
-
-     ./configure --with-included-gettext
-
-to prevent auto-detection.
-
-   The configuration process will not test for the `catgets' function
-and therefore it will not be used.  The reason is that even an
-emulation of `gettext' on top of `catgets' could not provide all the
-extensions of the GNU `gettext' library.
-
-   Internationalized packages usually have many `po/LL.po' files, where
-LL gives an ISO 639 two-letter code identifying the language.  Unless
-translations have been forbidden at `configure' time by using the
-`--disable-nls' switch, all available translations are installed
-together with the package.  However, the environment variable `LINGUAS'
-may be set, prior to configuration, to limit the installed set.
-`LINGUAS' should then contain a space separated list of two-letter
-codes, stating which languages are allowed.
-
-1.3 Using This Package
-======================
-
-As a user, if your language has been installed for this package, you
-only have to set the `LANG' environment variable to the appropriate
-`LL_CC' combination.  Here `LL' is an ISO 639 two-letter language code,
-and `CC' is an ISO 3166 two-letter country code.  For example, let's
-suppose that you speak German and live in Germany.  At the shell
-prompt, merely execute `setenv LANG de_DE' (in `csh'),
-`export LANG; LANG=de_DE' (in `sh') or `export LANG=de_DE' (in `bash').
-This can be done from your `.login' or `.profile' file, once and for
-all.
-
-   You might think that the country code specification is redundant.
-But in fact, some languages have dialects in different countries.  For
-example, `de_AT' is used for Austria, and `pt_BR' for Brazil.  The
-country code serves to distinguish the dialects.
-
-   The locale naming convention of `LL_CC', with `LL' denoting the
-language and `CC' denoting the country, is the one use on systems based
-on GNU libc.  On other systems, some variations of this scheme are
-used, such as `LL' or `LL_CC.ENCODING'.  You can get the list of
-locales supported by your system for your country by running the command
-`locale -a | grep '^LL''.
-
-   Not all programs have translations for all languages.  By default, an
-English message is shown in place of a nonexistent translation.  If you
-understand other languages, you can set up a priority list of languages.
-This is done through a different environment variable, called
-`LANGUAGE'.  GNU `gettext' gives preference to `LANGUAGE' over `LANG'
-for the purpose of message handling, but you still need to have `LANG'
-set to the primary language; this is required by other parts of the
-system libraries.  For example, some Swedish users who would rather
-read translations in German than English for when Swedish is not
-available, set `LANGUAGE' to `sv:de' while leaving `LANG' to `sv_SE'.
-
-   Special advice for Norwegian users: The language code for Norwegian
-bokma*l changed from `no' to `nb' recently (in 2003).  During the
-transition period, while some message catalogs for this language are
-installed under `nb' and some older ones under `no', it's recommended
-for Norwegian users to set `LANGUAGE' to `nb:no' so that both newer and
-older translations are used.
-
-   In the `LANGUAGE' environment variable, but not in the `LANG'
-environment variable, `LL_CC' combinations can be abbreviated as `LL'
-to denote the language's main dialect.  For example, `de' is equivalent
-to `de_DE' (German as spoken in Germany), and `pt' to `pt_PT'
-(Portuguese as spoken in Portugal) in this context.
-
-1.4 Translating Teams
-=====================
-
-For the Free Translation Project to be a success, we need interested
-people who like their own language and write it well, and who are also
-able to synergize with other translators speaking the same language.
-Each translation team has its own mailing list.  The up-to-date list of
-teams can be found at the Free Translation Project's homepage,
-`<A HREF="http://www.iro.umontreal.ca/contrib/po/HTML/">http://www.iro.umontreal.ca/contrib/po/HTML/</A>', in the &quot;National teams&quot;
-area.
-
-   If you'd like to volunteer to _work_ at translating messages, you
-should become a member of the translating team for your own language.
-The subscribing address is _not_ the same as the list itself, it has
-`-request' appended.  For example, speakers of Swedish can send a
-message to `<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">sv-request at li.org</A>', having this message body:
-
-     subscribe
-
-   Keep in mind that team members are expected to participate
-_actively_ in translations, or at solving translational difficulties,
-rather than merely lurking around.  If your team does not exist yet and
-you want to start one, or if you are unsure about what to do or how to
-get started, please write to `<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">translation at iro.umontreal.ca</A>' to reach the
-coordinator for all translator teams.
-
-   The English team is special.  It works at improving and uniformizing
-the terminology in use.  Proven linguistic skill are praised more than
-programming skill, here.
-
-1.5 Available Packages
-======================
-
-Languages are not equally supported in all packages.  The following
-matrix shows the current state of internationalization, as of May 2005.
-The matrix shows, in regard of each package, for which languages PO
-files have been submitted to translation coordination, with a
-translation percentage of at least 50%.
-
-     Ready PO files       af am ar az be bg bs ca cs cy da de el en en_GB
-                        +-------------------------------------------------+
-     GNUnet             |                                                 |
-     a2ps               |             []                [] [] []     []   |
-     aegis              |                                  ()             |
-     ant-phone          |                                  ()             |
-     anubis             |                                  []             |
-     ap-utils           |                                                 |
-     aspell             |                         []    [] []        []   |
-     bash               |                      []          []             |
-     batchelor          |                                  []             |
-     bfd                |                                                 |
-     bibshelf           |                                  []             |
-     binutils           |                               []                |
-     bison              |                               [] []             |
-     bluez-pin          | []                      []       [] []          |
-     clisp              |                                  []    []       |
-     console-tools      |                         []       []             |
-     coreutils          |                []    []       [] []             |
-     cpio               |                                                 |
-     cpplib             |                      []       [] []             |
-     darkstat           |                []             () []             |
-     dialog             |                      [] [] [] [] [] []          |
-     diffutils          |                      [] []    [] [] []          |
-     doodle             |                                  []             |
-     e2fsprogs          |                         []       []             |
-     enscript           |                      []       [] []        []   |
-     error              |                      []       [] []        []   |
-     fetchmail          |                      []       [] () []          |
-     fileutils          |                               [] []             |
-     findutils          |                      []       []    []          |
-     flex               |                      []       [] []             |
-     fslint             |                                  []             |
-     gas                |                                                 |
-     gawk               |                      []       [] []             |
-     gbiff              |                                  []             |
-     gcal               |                      []                         |
-     gcc                |                                  []             |
-     gettext-examples   | []                   []          [] []          |
-     gettext-runtime    |             []       []       [] []             |
-     gettext-tools      |                      []          []             |
-     gimp-print         |                         []    [] []        []   |
-     gip                |                                                 |
-     gliv               |                                  []             |
-     glunarclock        |                                                 |
-     gmult              | []                               []             |
-     gnubiff            |                                  ()             |
-     gnucash            |                         []       () ()     []   |
-     gnucash-glossary   |                               [] ()             |
-     gpe-aerial         |                         []       []             |
-     gpe-beam           |                         []       []             |
-     gpe-calendar       |                         []       []             |
-     gpe-clock          |                         []       []             |
-     gpe-conf           |                         []       []             |
-     gpe-contacts       |                                                 |
-     gpe-edit           |                         []                      |
-     gpe-go             |                         []                      |
-     gpe-login          |                         []       []             |
-     gpe-ownerinfo      |                         []       []             |
-     gpe-sketchbook     |                         []       []             |
-     gpe-su             |                         []       []             |
-     gpe-taskmanager    |                         []       []             |
-     gpe-timesheet      |                         []                      |
-     gpe-today          |                         []       []             |
-     gpe-todo           |                         []       []             |
-     gphoto2            |                         []    [] []        []   |
-     gprof              |                               [] []             |
-     gpsdrive           |                                  ()    ()       |
-     gramadoir          | []                               []             |
-     grep               | []          [] []    []          [] []          |
-     gretl              |                                                 |
-     gsasl              |                                  []             |
-     gss                |                                                 |
-     gst-plugins        | []       []          [] []       []        []   |
-     gstreamer          | []                   [] []       []        []   |
-     gtick              | []                               ()             |
-     gtkspell           |             []                   [] []          |
-     hello              |                      []       [] [] []          |
-     id-utils           |                               [] []             |
-     impost             |                                                 |
-     indent             |                      []          []             |
-     iso_3166           |                                                 |
-     iso_3166_1         |                      [] []    [] [] []          |
-     iso_3166_2         |                                                 |
-     iso_3166_3         |                                  []             |
-     iso_4217           |                                                 |
-     iso_639            |                                                 |
-     jpilot             |                         []                      |
-     jtag               |                                                 |
-     jwhois             |                                                 |
-     kbd                |                         []    [] [] []          |
-     latrine            |                                  ()             |
-     ld                 |                               []                |
-     libc               |                      [] []    [] [] []          |
-     libextractor       |                                                 |
-     libgpewidget       |                         []    [] []             |
-     libgphoto2         |                                  []             |
-     libgphoto2_port    |                                  []             |
-     libgsasl           |                                                 |
-     libiconv           | []                   []       [] [] []          |
-     libidn             |                                                 |
-     lifelines          |                               [] ()             |
-     lilypond           |                                  []             |
-     lingoteach         |                                                 |
-     lynx               |                      [] []    [] []             |
-     m4                 |                         []    [] [] []          |
-     mailutils          |                      []                         |
-     make               |                               [] []             |
-     man-db             |                      [] ()    [] []             |
-     minicom            |                         []       []             |
-     mysecretdiary      |                               [] []             |
-     nano               |                      [] ()       []             |
-     nano_1_0           |                      [] ()    [] []             |
-     opcodes            |                                  []             |
-     parted             |                      [] []    [] []             |
-     psmisc             |                                                 |
-     ptx                |                      []       [] []             |
-     pwdutils           |                                                 |
-     python             |                                                 |
-     radius             |                      []                         |
-     recode             |             []       []       [] [] []          |
-     rpm                |                         []    []                |
-     screem             |                                                 |
-     scrollkeeper       |          [] []       [] [] [] [] []        []   |
-     sed                |                      []          []             |
-     sh-utils           |                               [] []             |
-     shared-mime-info   |                []       []                      |
-     sharutils          |                      [] []    [] [] []          |
-     silky              |                                                 |
-     skencil            |                               [] ()             |
-     sketch             |                               [] ()             |
-     solfege            |                                  []             |
-     soundtracker       |                               [] []             |
-     sp                 |                                  []             |
-     stardict           |                         []                      |
-     tar                |                                                 |
-     texinfo            |                               [] []             |
-     textutils          |                      []       [] []             |
-     tin                |                                  ()        ()   |
-     tp-robot           |                                  []             |
-     tuxpaint           | []                   [] []    [] [] []     []   |
-     unicode-han-tra... |                                                 |
-     unicode-transla... |                                                 |
-     util-linux         |                      [] []    [] []             |
-     vorbis-tools       |             []          []    []           []   |
-     wastesedge         |                                  ()             |
-     wdiff              |                      []       [] []        []   |
-     wget               |                                                 |
-     xchat              |                []    []          [] []     []   |
-     xkeyboard-config   |                                                 |
-     xpad               |                                                 |
-                        +-------------------------------------------------+
-                          af am ar az be bg bs ca cs cy da de el en en_GB
-                          10  0  0  2  7  5  0 40 43  2 51 91 19  1  14
-
-                          eo es et eu fa fi fr  ga gl he hi hr hu id is
-                        +-----------------------------------------------+
-     GNUnet             |                                               |
-     a2ps               |       []       [] []                          |
-     aegis              |                                               |
-     ant-phone          |                   []                          |
-     anubis             |                   []                          |
-     ap-utils           |                   []                          |
-     aspell             |                   []  []                      |
-     bash               | [] []             []                 []       |
-     batchelor          |                   []  []                      |
-     bfd                |    []                                         |
-     bibshelf           |    []                 []                      |
-     binutils           |    []             []                          |
-     bison              |    [] []          []  []                []    |
-     bluez-pin          | []             [] []  []             [] []    |
-     clisp              |    []             []                          |
-     console-tools      |                                               |
-     coreutils          |    [] []       [] []  []                      |
-     cpio               |    []             []                          |
-     cpplib             |    []             []                          |
-     darkstat           |    []             ()  []             [] []    |
-     dialog             |    [] [] []    [] []  []             []       |
-     diffutils          | [] []          [] []  [] [] []       [] []    |
-     doodle             |                       []                      |
-     e2fsprogs          |    []             []                          |
-     enscript           |                   []              []          |
-     error              |    []          [] []  []             []       |
-     fetchmail          |    []                                         |
-     fileutils          |    [] []          []  []             []       |
-     findutils          |    [] []          []  []                      |
-     flex               |    []             []  []                      |
-     fslint             |                   []                          |
-     gas                |    []             []                          |
-     gawk               |    []             []  []    []                |
-     gbiff              |                   []                          |
-     gcal               |    []             []                          |
-     gcc                |    []                                         |
-     gettext-examples   |    []             []  []                      |
-     gettext-runtime    |    []          [] []  []                []    |
-     gettext-tools      |    []             []                          |
-     gimp-print         |    []             []                          |
-     gip                |    []    []       []                          |
-     gliv               |                   ()                          |
-     glunarclock        |                []     []             []       |
-     gmult              |          []       []                          |
-     gnubiff            |                   ()                          |
-     gnucash            |    []                                ()       |
-     gnucash-glossary   |    []                                         |
-     gpe-aerial         |    []             []                          |
-     gpe-beam           |    []             []                          |
-     gpe-calendar       |    []             []                 [] []    |
-     gpe-clock          |    []          [] []                          |
-     gpe-conf           |                   []                          |
-     gpe-contacts       |                   []                          |
-     gpe-edit           |                   []                    []    |
-     gpe-go             |    []             []                          |
-     gpe-login          |    []             []                 []       |
-     gpe-ownerinfo      |    []          [] []                 [] []    |
-     gpe-sketchbook     |    []             []                          |
-     gpe-su             |    []          [] []                          |
-     gpe-taskmanager    |    []          [] []                          |
-     gpe-timesheet      |    []             []  []                []    |
-     gpe-today          |    []          [] []  []                      |
-     gpe-todo           |    []             []                    []    |
-     gphoto2            |    []          [] []                 []       |
-     gprof              |    []             []                    []    |
-     gpsdrive           |    ()             ()                 []       |
-     gramadoir          |                   []  []                      |
-     grep               |    [] [] []    [] []  [] [] []    [] [] []    |
-     gretl              |    []             []                          |
-     gsasl              |          []       []  []                      |
-     gss                |                   []                          |
-     gst-plugins        |                   []                 []       |
-     gstreamer          |                                               |
-     gtick              |          []    [] []  []                      |
-     gtkspell           | [] []    []       []  []                      |
-     hello              | [] [] [] [] [] [] []  [] [] []    [] [] []    |
-     id-utils           |                   []                 [] []    |
-     impost             |                   []  []                      |
-     indent             | [] [] [] []    [] []  [] []          [] []    |
-     iso_3166           | []             [] []                          |
-     iso_3166_1         |    []    []    [] []  []             [] []    |
-     iso_3166_2         |                   []                          |
-     iso_3166_3         |                   []                          |
-     iso_4217           |       []       []        []                   |
-     iso_639            | []          [] [] []                          |
-     jpilot             |    []             []                          |
-     jtag               |                   []                          |
-     jwhois             |    []             []                 [] []    |
-     kbd                |    []             []                          |
-     latrine            |                   []  []                      |
-     ld                 |    []             []                          |
-     libc               |    []          [] []     []          []       |
-     libextractor       |                                               |
-     libgpewidget       |    []             []  []             [] []    |
-     libgphoto2         |    []             []                 []       |
-     libgphoto2_port    |                   []                          |
-     libgsasl           |                   []  []                      |
-     libiconv           | [] [] []       [] []  [] []       [] [] []    |
-     libidn             | []                []                          |
-     lifelines          |                   ()                          |
-     lilypond           |                                               |
-     lingoteach         |                   []                    []    |
-     lynx               |       []                             []       |
-     m4                 |                   []  [] []             []    |
-     mailutils          |    []             []                          |
-     make               |    []          [] []  [] [] []    []          |
-     man-db             |    ()                                         |
-     minicom            |    []          [] []                 []       |
-     mysecretdiary      |    []             []                    []    |
-     nano               |    []    []    () []                          |
-     nano_1_0           |    []             []     []             []    |
-     opcodes            |    []          [] []                          |
-     parted             |    []             []     []                   |
-     psmisc             |          []                                   |
-     ptx                | [] [] []       [] []  [] []          [] []    |
-     pwdutils           |                                               |
-     python             |                                               |
-     radius             |    []             []                          |
-     recode             | [] []             []     [] []       [] []    |
-     rpm                |                   []                          |
-     screem             |                                               |
-     scrollkeeper       |    []          []                    []       |
-     sed                | [] [] []          []  []             []       |
-     sh-utils           |    [] []       [] []  []             []       |
-     shared-mime-info   | [] []    []    [] []                 []       |
-     sharutils          |    [] []       [] []     []          []       |
-     silky              |                   []                          |
-     skencil            |    []             []                          |
-     sketch             |    []             []                          |
-     solfege            |                                               |
-     soundtracker       |    []             []                          |
-     sp                 |                   []                          |
-     stardict           |                                      []       |
-     tar                |    [] []          []  []                      |
-     texinfo            | []                []        []                |
-     textutils          |    []             []  [] []          []       |
-     tin                |       []          ()                          |
-     tp-robot           |                   []                 []       |
-     tuxpaint           |    []          [] []  []    []       [] [] [] |
-     unicode-han-tra... |                                               |
-     unicode-transla... |                   []  []                      |
-     util-linux         |    [] []       [] []                 []       |
-     vorbis-tools       |    []             []                          |
-     wastesedge         |                   ()                          |
-     wdiff              |    [] []          []  [] []          [] []    |
-     wget               |       [] []           []          []          |
-     xchat              |    []    []    [] []           []             |
-     xkeyboard-config   |                                               |
-     xpad               |    []                 []             []       |
-                        +-----------------------------------------------+
-                          eo es et eu fa fi fr  ga gl he hi hr hu id is
-                          15 85 21 15  2 35 115 45 16  8  1  6 40 27  1
-
-                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
-                        +--------------------------------------------------+
-     GNUnet             |                                                  |
-     a2ps               | ()    ()                   []       []    ()     |
-     aegis              |                                     ()           |
-     ant-phone          |                                     []           |
-     anubis             |                            []    [] []           |
-     ap-utils           |                                                  |
-     aspell             |                         []          []           |
-     bash               |                                     []           |
-     batchelor          |                                     []           |
-     bfd                |                                                  |
-     bibshelf           | []                                               |
-     binutils           |                                                  |
-     bison              | []                         []    [] []           |
-     bluez-pin          |          []                         []           |
-     clisp              |                                     []           |
-     console-tools      |                                                  |
-     coreutils          |    []                               []           |
-     cpio               |                                                  |
-     cpplib             |                                     []           |
-     darkstat           |                            []       []           |
-     dialog             | []                                  []           |
-     diffutils          | [] []                      []       []           |
-     doodle             | []                                               |
-     e2fsprogs          | []                                               |
-     enscript           |                                     []           |
-     error              |                                     []           |
-     fetchmail          |    []                               []           |
-     fileutils          | [] []       []                                   |
-     findutils          | []                                  []           |
-     flex               |       []                            []           |
-     fslint             |                                     []           |
-     gas                |                                                  |
-     gawk               |    []                               []           |
-     gbiff              |                                     []           |
-     gcal               |                                                  |
-     gcc                |                                                  |
-     gettext-examples   | [] []                               []           |
-     gettext-runtime    | [] [] []                            []           |
-     gettext-tools      | [] [] []                                         |
-     gimp-print         |    []                               []           |
-     gip                |                                     []           |
-     gliv               |                                     []           |
-     glunarclock        |                            []       []           |
-     gmult              | [] []                                            |
-     gnubiff            | ()                                               |
-     gnucash            | [] ()                            () []           |
-     gnucash-glossary   | []                                  []           |
-     gpe-aerial         |                                     []           |
-     gpe-beam           |                                     []           |
-     gpe-calendar       |                                     []           |
-     gpe-clock          |                                     []           |
-     gpe-conf           |                                     []           |
-     gpe-contacts       |                                                  |
-     gpe-edit           |                                     []           |
-     gpe-go             |                                     []           |
-     gpe-login          |                                     []           |
-     gpe-ownerinfo      |                                     []           |
-     gpe-sketchbook     |                                     []           |
-     gpe-su             |                                     []           |
-     gpe-taskmanager    |          []                         []           |
-     gpe-timesheet      |                                     []           |
-     gpe-today          |                                     []           |
-     gpe-todo           |                                     []           |
-     gphoto2            | [] []                               []           |
-     gprof              |                                                  |
-     gpsdrive           | () ()                               ()    ()     |
-     gramadoir          |                                     ()           |
-     grep               | [] []                            [] []           |
-     gretl              | []                                               |
-     gsasl              |                                     []           |
-     gss                |                                                  |
-     gst-plugins        | []                                  []           |
-     gstreamer          | []                                  []           |
-     gtick              | []                                  []           |
-     gtkspell           | []                      []          []           |
-     hello              | [] [] []          []       []    [] [] [] []     |
-     id-utils           | []                                  []           |
-     impost             |                                                  |
-     indent             | [] []                               []           |
-     iso_3166           |                                     []           |
-     iso_3166_1         |                                     []    []     |
-     iso_3166_2         |                                     []           |
-     iso_3166_3         |                                     []           |
-     iso_4217           |    []                   []          []           |
-     iso_639            |    []                               [] []        |
-     jpilot             |    ()                               ()    ()     |
-     jtag               |                                                  |
-     jwhois             | []                                  []           |
-     kbd                |                                     []           |
-     latrine            | []                                  []           |
-     ld                 |                                                  |
-     libc               |    [] []                         [] []    []     |
-     libextractor       |                                                  |
-     libgpewidget       |                                     []           |
-     libgphoto2         | [] []                                            |
-     libgphoto2_port    | [] []                                            |
-     libgsasl           |                                     []           |
-     libiconv           | []                                  []           |
-     libidn             | []                                               |
-     lifelines          |                                     []           |
-     lilypond           |                                                  |
-     lingoteach         | []                                  []           |
-     lynx               | [] []                               []           |
-     m4                 |    []                               []           |
-     mailutils          |                                                  |
-     make               |    [] []                            []           |
-     man-db             |    ()                                            |
-     minicom            |    []                                            |
-     mysecretdiary      |                                     []           |
-     nano               | []                         []    []              |
-     nano_1_0           | []                         []    []    []        |
-     opcodes            |                                     []           |
-     parted             | [] []                               [] []        |
-     psmisc             | []                               [] []           |
-     ptx                |                                  [] []    []     |
-     pwdutils           |                                                  |
-     python             |                                                  |
-     radius             |                                                  |
-     recode             | []                                  []           |
-     rpm                |    [] []                                         |
-     screem             |    []                                            |
-     scrollkeeper       |                                  [] [] []        |
-     sed                |    []                               []           |
-     sh-utils           | [] []                            []              |
-     shared-mime-info   |       []                         [] [] []        |
-     sharutils          | [] []                               []           |
-     silky              |                                     []           |
-     skencil            |                                                  |
-     sketch             |                                                  |
-     solfege            | []                                  []    []     |
-     soundtracker       | []                                               |
-     sp                 |    ()                                            |
-     stardict           |                      []             []           |
-     tar                | [] []                               []           |
-     texinfo            |    []                            [] []           |
-     textutils          |    [] []                         []              |
-     tin                |                                                  |
-     tp-robot           |                                     []           |
-     tuxpaint           | [] [] []       []          []       [] []        |
-     unicode-han-tra... |                                                  |
-     unicode-transla... |                                                  |
-     util-linux         | [] []                               []           |
-     vorbis-tools       |                                     []           |
-     wastesedge         |                                     []           |
-     wdiff              | []                         []    []              |
-     wget               |    []                                            |
-     xchat              | []    []          [] []             []           |
-     xkeyboard-config   |                                     []           |
-     xpad               |                                     []           |
-                        +--------------------------------------------------+
-                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
-                          46 35 11  2  1  1  2  2  3 11  0 15 96  7  5  0
-
-                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
-                        +----------------------------------------------+
-     GNUnet             |                                              |
-     a2ps               |       ()     []      [] []       []    [] [] |
-     aegis              |                      () ()                   |
-     ant-phone          |                      []                      |
-     anubis             |       []             [] []                   |
-     ap-utils           |       ()                                     |
-     aspell             |                      [] []                   |
-     bash               |              []      [] []                   |
-     batchelor          |                      []                      |
-     bfd                |                                              |
-     bibshelf           |                                              |
-     binutils           |                         []                [] |
-     bison              |       []     []      [] []                [] |
-     bluez-pin          |       []     []   [] [] []    []       [] [] |
-     clisp              |                         []                   |
-     console-tools      |                         []                   |
-     coreutils          |       []                []       []       [] |
-     cpio               |       []                                  [] |
-     cpplib             |                                              |
-     darkstat           |       []     []      []       []       [] [] |
-     dialog             |       [] []  []   [] [] [] []                |
-     diffutils          |       []     []      [] []             [] [] |
-     doodle             |                                     []       |
-     e2fsprogs          |       []                                  [] |
-     enscript           |              []      [] []                [] |
-     error              |              []      []       []             |
-     fetchmail          |       []                []    []    []       |
-     fileutils          |       []             [] []       []       [] |
-     findutils          |       [] []          []       []       [] [] |
-     flex               |       []     []      [] []                [] |
-     fslint             |              []      []                []    |
-     gas                |                                              |
-     gawk               |       []     []      []                   [] |
-     gbiff              |                      []                      |
-     gcal               |                                           [] |
-     gcc                |                                              |
-     gettext-examples   |       []             [] []    []       [] [] |
-     gettext-runtime    |       []             [] []    [] []    [] [] |
-     gettext-tools      |       []             [] []    [] []    [] [] |
-     gimp-print         |                               []          [] |
-     gip                |                   []          []       []    |
-     gliv               |              []      []       []             |
-     glunarclock        |              []      [] []    []       [] [] |
-     gmult              |              []   [] []                []    |
-     gnubiff            |                      ()                   [] |
-     gnucash            |       () []             []    []          [] |
-     gnucash-glossary   |          []                   []          [] |
-     gpe-aerial         |          []  []      [] []             [] [] |
-     gpe-beam           |          []  []      [] []             [] [] |
-     gpe-calendar       |          []  []      [] []    []       [] [] |
-     gpe-clock          |          []  []      [] []    []       [] [] |
-     gpe-conf           |          []  []      [] []    []          [] |
-     gpe-contacts       |                      [] []             [] [] |
-     gpe-edit           |          []  []      [] []    []       [] [] |
-     gpe-go             |              []      [] []             [] [] |
-     gpe-login          |          []  []      [] []    []       [] [] |
-     gpe-ownerinfo      |          []  []      [] []    []       [] [] |
-     gpe-sketchbook     |          []  []      [] []    []       [] [] |
-     gpe-su             |          []  []      [] []    []       [] [] |
-     gpe-taskmanager    |          []  []      [] []    []       [] [] |
-     gpe-timesheet      |          []  []      [] []    []       [] [] |
-     gpe-today          |          []  []      [] []    []       [] [] |
-     gpe-todo           |    []    []  []      [] []    []       [] [] |
-     gphoto2            |                      []       []       [] [] |
-     gprof              |              []      []                   [] |
-     gpsdrive           |    []                []                      |
-     gramadoir          |                               []             |
-     grep               |       [] []  []      [] []       []    []    |
-     gretl              |       []                                     |
-     gsasl              |       []             []             [] [] [] |
-     gss                |       []             []                   [] |
-     gst-plugins        | []                                  [] [] [] |
-     gstreamer          |                         []          [] [] [] |
-     gtick              |                      [] []                [] |
-     gtkspell           |              []   [] [] []    []       []    |
-     hello              |       []     []      [] []    []       [] [] |
-     id-utils           |              []      [] []                [] |
-     impost             |                                              |
-     indent             |              []      [] []    []       [] [] |
-     iso_3166           |          []                []       [] [] [] |
-     iso_3166_1         |                               [] [] [] []    |
-     iso_3166_2         |                                              |
-     iso_3166_3         |                      []    []          []    |
-     iso_4217           |                            []          []    |
-     iso_639            |                            []          [] [] |
-     jpilot             |                                              |
-     jtag               |                               []             |
-     jwhois             |       []     []      [] ()                () |
-     kbd                |       []             []                   [] |
-     latrine            |                      []                   [] |
-     ld                 |                                           [] |
-     libc               |       []     []         []    []          [] |
-     libextractor       |                      []                      |
-     libgpewidget       |          []  []      []       []       [] [] |
-     libgphoto2         |                         []                [] |
-     libgphoto2_port    |                         []                   |
-     libgsasl           |       []             []                []    |
-     libiconv           |       []     []   [] [] []    [] [] [] [] [] |
-     libidn             |       []                                  () |
-     lifelines          |       []                                  [] |
-     lilypond           |                                              |
-     lingoteach         |              []                              |
-     lynx               |              []         []                [] |
-     m4                 |       []     []      [] []                [] |
-     mailutils          |       []             [] []                   |
-     make               |       []     []         []                [] |
-     man-db             |                      []                   [] |
-     minicom            |       []     []      [] []                   |
-     mysecretdiary      |              []      [] []                [] |
-     nano               |              []      []                   [] |
-     nano_1_0           |       []             [] []                [] |
-     opcodes            |                      []                   [] |
-     parted             |       [] []  []                           [] |
-     psmisc             |       []             []                      |
-     ptx                |       [] []  []      [] []                [] |
-     pwdutils           |       []                                     |
-     python             |                                              |
-     radius             |       []                []                   |
-     recode             |       []     []      [] []       []       [] |
-     rpm                |       [] []             []                [] |
-     screem             |                                              |
-     scrollkeeper       |       []             [] []    []    [] [] [] |
-     sed                |       [] []  []      [] []    []       [] [] |
-     sh-utils           |                         []       []    []    |
-     shared-mime-info   |          []  []         []          [] [] [] |
-     sharutils          |                         []             [] [] |
-     silky              |                               []             |
-     skencil            |          []  []                           [] |
-     sketch             |          []  []                           [] |
-     solfege            |                                              |
-     soundtracker       |                               []          [] |
-     sp                 |                                              |
-     stardict           |                         []    []             |
-     tar                |       []             [] []                [] |
-     texinfo            |       []             [] []                [] |
-     textutils          |                         []       []       [] |
-     tin                |                                              |
-     tp-robot           |                         []                   |
-     tuxpaint           |       [] []  []      []       []    [] [] [] |
-     unicode-han-tra... |                                              |
-     unicode-transla... |                                              |
-     util-linux         |              []         []                [] |
-     vorbis-tools       |                      [] []                   |
-     wastesedge         |                                              |
-     wdiff              |       []     []      [] []    []          [] |
-     wget               |                                              |
-     xchat              |    []                   []    [] [] [] [] [] |
-     xkeyboard-config   |                                              |
-     xpad               |                                              |
-                        +----------------------------------------------+
-                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
-                           1  3 47 29  57    6 78 73  5 44 12 12 50 85
-
-                          ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
-                        +-----------------------------------------------+
-     GNUnet             |                                               |  0
-     a2ps               |             [] []     []                      | 19
-     aegis              |                                               |  0
-     ant-phone          |             []        []                      |  5
-     anubis             |             [] []     []                      | 11
-     ap-utils           |                ()     []                      |  2
-     aspell             |                []     [] []                   | 13
-     bash               |                       []                      | 11
-     batchelor          |             []        []                      |  7
-     bfd                |                                               |  1
-     bibshelf           |                       []                      |  5
-     binutils           |             []                                |  6
-     bison              |             []        []                      | 18
-     bluez-pin          |             [] []     [] []     []            | 25
-     clisp              |                                               |  7
-     console-tools      |             []        []                      |  5
-     coreutils          |             []        []                      | 17
-     cpio               |             [] []     []                      |  7
-     cpplib             |             []        []                      |  8
-     darkstat           |                       []        ()    ()      | 15
-     dialog             |             [] []     []                      | 25
-     diffutils          |             []        []        []    []      | 28
-     doodle             |                       []                      |  5
-     e2fsprogs          |             []                                |  8
-     enscript           |             []                                | 12
-     error              |             []        []              []      | 16
-     fetchmail          |             []                                | 12
-     fileutils          |             []                  []    []      | 18
-     findutils          |             []        []                      | 17
-     flex               |             []        []                      | 15
-     fslint             |                       []                      |  7
-     gas                |             []                                |  3
-     gawk               |             []                                | 14
-     gbiff              |                       []                      |  5
-     gcal               |             []                                |  5
-     gcc                |             []                  []            |  4
-     gettext-examples   |             [] []     []        []    []      | 21
-     gettext-runtime    |             [] []     []        []    []      | 25
-     gettext-tools      |             [] []     []        []    []      | 19
-     gimp-print         |                []                             | 11
-     gip                |                       []                      |  8
-     gliv               |             []        []                      |  7
-     glunarclock        |                       [] []                   | 13
-     gmult              |             []        []        []            | 13
-     gnubiff            |                       []                      |  3
-     gnucash            |             ()                        []      | 10
-     gnucash-glossary   |                       []              []      |  9
-     gpe-aerial         |                       []        []            | 13
-     gpe-beam           |                       []        []            | 13
-     gpe-calendar       |                       [] []     []    []      | 18
-     gpe-clock          |             []        [] []     []            | 17
-     gpe-conf           |                       []        []            | 12
-     gpe-contacts       |                       []        []            |  7
-     gpe-edit           |             []        [] []           []      | 15
-     gpe-go             |             []        []                      | 11
-     gpe-login          |             []        [] []     []    []      | 18
-     gpe-ownerinfo      |             []        []        []    []      | 19
-     gpe-sketchbook     |             []        []                      | 14
-     gpe-su             |             []        []        []            | 16
-     gpe-taskmanager    |             []        []        []            | 17
-     gpe-timesheet      |             []        []        []    []      | 17
-     gpe-today          |             []        [] []     []    []      | 19
-     gpe-todo           |                       [] []           []      | 17
-     gphoto2            |                []               []    []      | 18
-     gprof              |             []        []                      | 10
-     gpsdrive           |                                               |  3
-     gramadoir          |                       []                      |  6
-     grep               |             [] []     []              []      | 32
-     gretl              |                                               |  4
-     gsasl              |                       []        []            | 12
-     gss                |                       []                      |  5
-     gst-plugins        |                []     []              []      | 17
-     gstreamer          |             [] []     []              []      | 15
-     gtick              |                       []                      | 11
-     gtkspell           |                       [] []     []    []      | 21
-     hello              |             [] []     []        []            | 37
-     id-utils           |             []        []                      | 13
-     impost             |                       []                      |  3
-     indent             |             []        []        []    []      | 25
-     iso_3166           |          [] []        []                      | 12
-     iso_3166_1         |             []           []                   | 20
-     iso_3166_2         |                                               |  2
-     iso_3166_3         |                          []     []            |  8
-     iso_4217           |             []        []                      | 10
-     iso_639            |                       [] []                   | 12
-     jpilot             |             [] []               []            |  6
-     jtag               |                                               |  2
-     jwhois             |             []        []              []      | 12
-     kbd                |             []        []                      | 12
-     latrine            |             []        []                      |  8
-     ld                 |             []                                |  5
-     libc               |             []                  []            | 22
-     libextractor       |                                               |  1
-     libgpewidget       |                       [] []                   | 17
-     libgphoto2         |                                 []            |  9
-     libgphoto2_port    |                                               |  5
-     libgsasl           |                       []                      |  7
-     libiconv           |             [] []     [] []     []            | 32
-     libidn             |                       []        []            |  6
-     lifelines          |                                               |  4
-     lilypond           |                                               |  1
-     lingoteach         |                       []                      |  6
-     lynx               |             [] []     []                      | 15
-     m4                 |                       []        []            | 17
-     mailutils          |                []                             |  7
-     make               |             []                  []            | 18
-     man-db             |                                               |  5
-     minicom            |                                               | 11
-     mysecretdiary      |             []        []                      | 12
-     nano               |                       []              []      | 13
-     nano_1_0           |             [] []     []                      | 18
-     opcodes            |             []        []                      |  9
-     parted             |             [] []               []            | 18
-     psmisc             |                       []                      |  7
-     ptx                |             []                  []            | 23
-     pwdutils           |                                               |  1
-     python             |                                               |  0
-     radius             |                []                             |  6
-     recode             |             []        []                      | 22
-     rpm                |             [] []                             | 11
-     screem             |                                               |  1
-     scrollkeeper       |             [] []                     []      | 24
-     sed                |             []        []              []      | 21
-     sh-utils           |             []                                | 15
-     shared-mime-info   |                []               []    []      | 21
-     sharutils          |             []        []              []      | 20
-     silky              |                                               |  3
-     skencil            |                                               |  6
-     sketch             |                                               |  6
-     solfege            |                                               |  4
-     soundtracker       |             []                                |  8
-     sp                 |             []                                |  3
-     stardict           |                []     []        []    []      | 10
-     tar                |             [] []     []              []      | 15
-     texinfo            |             []                  []            | 14
-     textutils          |             []                  []    []      | 17
-     tin                |                                               |  1
-     tp-robot           |                       []        []    []      |  8
-     tuxpaint           |             []        [] []     []            | 34
-     unicode-han-tra... |                                               |  0
-     unicode-transla... |                                               |  2
-     util-linux         |             [] []     []                      | 18
-     vorbis-tools       |                []                             | 10
-     wastesedge         |                                               |  1
-     wdiff              |             []        []                      | 22
-     wget               |             []        []                      |  7
-     xchat              |                []     []        []    []      | 26
-     xkeyboard-config   |                       []                      |  2
-     xpad               |                       []                      |  5
-                        +-----------------------------------------------+
-       73 teams           ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
-      149 domains          0  0  0  1 77 30  0  92 16  0  42    32    0  1746
-
-   Some counters in the preceding matrix are higher than the number of
-visible blocks let us expect.  This is because a few extra PO files are
-used for implementing regional variants of languages, or language
-dialects.
-
-   For a PO file in the matrix above to be effective, the package to
-which it applies should also have been internationalized and
-distributed as such by its maintainer.  There might be an observable
-lag between the mere existence a PO file and its wide availability in a
-distribution.
-
-   If May 2005 seems to be old, you may fetch a more recent copy of
-this `ABOUT-NLS' file on most GNU archive sites.  The most up-to-date
-matrix with full percentage details can be found at
-`<A HREF="http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html">http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html</A>'.
-
-1.6 Using `gettext' in new packages
-===================================
-
-If you are writing a freely available program and want to
-internationalize it you are welcome to use GNU `gettext' in your
-package.  Of course you have to respect the GNU Library General Public
-License which covers the use of the GNU `gettext' library.  This means
-in particular that even non-free programs can use `libintl' as a shared
-library, whereas only free software can use `libintl' as a static
-library or use modified versions of `libintl'.
-
-   Once the sources are changed appropriately and the setup can handle
-the use of `gettext' the only thing missing are the translations.  The
-Free Translation Project is also available for packages which are not
-developed inside the GNU project.  Therefore the information given above
-applies also for every other Free Software Project.  Contact
-`<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">translation at iro.umontreal.ca</A>' to make the `.pot' files available to
-the translation teams.
-

Deleted: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/Makefile.am	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,18 +0,0 @@
-## Process this file with automake to produce Makefile.in
-
-SUBDIRS = po src doc
-
-EXTRA_DIST = config.rpath po m4 \
-	autogen.sh sst.spec ChangeLog.old
-
-maintainer-clean-local:
-	rm -f configure
-	rm -f aclocal.m4
-	rm -f `find . -name Makefile.in`
-	rm -f `find . -name *~`
-	rm -f src/include/config.h.in
-
-clean-local:
-	rm -rf autom4te*.cache
-
-ACLOCAL_AMFLAGS = -I m4

Deleted: trunk/autogen.sh
===================================================================
--- trunk/autogen.sh	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/autogen.sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,4 +0,0 @@
-#!/bin/sh
-# Run this to generate all the initial makefiles, etc.
-
-autoreconf -v

Copied: trunk/c-version/ABOUT-NLS (from rev 809, trunk/ABOUT-NLS)
===================================================================
--- trunk/c-version/ABOUT-NLS	                        (rev 0)
+++ trunk/c-version/ABOUT-NLS	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,996 @@
+1 Notes on the Free Translation Project
+***************************************
+
+Free software is going international!  The Free Translation Project is
+a way to get maintainers of free software, translators, and users all
+together, so that free software will gradually become able to speak many
+languages.  A few packages already provide translations for their
+messages.
+
+   If you found this `ABOUT-NLS' file inside a distribution, you may
+assume that the distributed package does use GNU `gettext' internally,
+itself available at your nearest GNU archive site.  But you do _not_
+need to install GNU `gettext' prior to configuring, installing or using
+this package with messages translated.
+
+   Installers will find here some useful hints.  These notes also
+explain how users should proceed for getting the programs to use the
+available translations.  They tell how people wanting to contribute and
+work on translations can contact the appropriate team.
+
+   When reporting bugs in the `intl/' directory or bugs which may be
+related to internationalization, you should tell about the version of
+`gettext' which is used.  The information can be found in the
+`intl/VERSION' file, in internationalized packages.
+
+1.1 Quick configuration advice
+==============================
+
+If you want to exploit the full power of internationalization, you
+should configure it using
+
+     ./configure --with-included-gettext
+
+to force usage of internationalizing routines provided within this
+package, despite the existence of internationalizing capabilities in the
+operating system where this package is being installed.  So far, only
+the `gettext' implementation in the GNU C library version 2 provides as
+many features (such as locale alias, message inheritance, automatic
+charset conversion or plural form handling) as the implementation here.
+It is also not possible to offer this additional functionality on top
+of a `catgets' implementation.  Future versions of GNU `gettext' will
+very likely convey even more functionality.  So it might be a good idea
+to change to GNU `gettext' as soon as possible.
+
+   So you need _not_ provide this option if you are using GNU libc 2 or
+you have installed a recent copy of the GNU gettext package with the
+included `libintl'.
+
+1.2 INSTALL Matters
+===================
+
+Some packages are &quot;localizable&quot; when properly installed; the programs
+they contain can be made to speak your own native language.  Most such
+packages use GNU `gettext'.  Other packages have their own ways to
+internationalization, predating GNU `gettext'.
+
+   By default, this package will be installed to allow translation of
+messages.  It will automatically detect whether the system already
+provides the GNU `gettext' functions.  If not, the included GNU
+`gettext' library will be used.  This library is wholly contained
+within this package, usually in the `intl/' subdirectory, so prior
+installation of the GNU `gettext' package is _not_ required.
+Installers may use special options at configuration time for changing
+the default behaviour.  The commands:
+
+     ./configure --with-included-gettext
+     ./configure --disable-nls
+
+will, respectively, bypass any pre-existing `gettext' to use the
+internationalizing routines provided within this package, or else,
+_totally_ disable translation of messages.
+
+   When you already have GNU `gettext' installed on your system and run
+configure without an option for your new package, `configure' will
+probably detect the previously built and installed `libintl.a' file and
+will decide to use this.  This might not be desirable.  You should use
+the more recent version of the GNU `gettext' library.  I.e. if the file
+`intl/VERSION' shows that the library which comes with this package is
+more recent, you should use
+
+     ./configure --with-included-gettext
+
+to prevent auto-detection.
+
+   The configuration process will not test for the `catgets' function
+and therefore it will not be used.  The reason is that even an
+emulation of `gettext' on top of `catgets' could not provide all the
+extensions of the GNU `gettext' library.
+
+   Internationalized packages usually have many `po/LL.po' files, where
+LL gives an ISO 639 two-letter code identifying the language.  Unless
+translations have been forbidden at `configure' time by using the
+`--disable-nls' switch, all available translations are installed
+together with the package.  However, the environment variable `LINGUAS'
+may be set, prior to configuration, to limit the installed set.
+`LINGUAS' should then contain a space separated list of two-letter
+codes, stating which languages are allowed.
+
+1.3 Using This Package
+======================
+
+As a user, if your language has been installed for this package, you
+only have to set the `LANG' environment variable to the appropriate
+`LL_CC' combination.  Here `LL' is an ISO 639 two-letter language code,
+and `CC' is an ISO 3166 two-letter country code.  For example, let's
+suppose that you speak German and live in Germany.  At the shell
+prompt, merely execute `setenv LANG de_DE' (in `csh'),
+`export LANG; LANG=de_DE' (in `sh') or `export LANG=de_DE' (in `bash').
+This can be done from your `.login' or `.profile' file, once and for
+all.
+
+   You might think that the country code specification is redundant.
+But in fact, some languages have dialects in different countries.  For
+example, `de_AT' is used for Austria, and `pt_BR' for Brazil.  The
+country code serves to distinguish the dialects.
+
+   The locale naming convention of `LL_CC', with `LL' denoting the
+language and `CC' denoting the country, is the one use on systems based
+on GNU libc.  On other systems, some variations of this scheme are
+used, such as `LL' or `LL_CC.ENCODING'.  You can get the list of
+locales supported by your system for your country by running the command
+`locale -a | grep '^LL''.
+
+   Not all programs have translations for all languages.  By default, an
+English message is shown in place of a nonexistent translation.  If you
+understand other languages, you can set up a priority list of languages.
+This is done through a different environment variable, called
+`LANGUAGE'.  GNU `gettext' gives preference to `LANGUAGE' over `LANG'
+for the purpose of message handling, but you still need to have `LANG'
+set to the primary language; this is required by other parts of the
+system libraries.  For example, some Swedish users who would rather
+read translations in German than English for when Swedish is not
+available, set `LANGUAGE' to `sv:de' while leaving `LANG' to `sv_SE'.
+
+   Special advice for Norwegian users: The language code for Norwegian
+bokma*l changed from `no' to `nb' recently (in 2003).  During the
+transition period, while some message catalogs for this language are
+installed under `nb' and some older ones under `no', it's recommended
+for Norwegian users to set `LANGUAGE' to `nb:no' so that both newer and
+older translations are used.
+
+   In the `LANGUAGE' environment variable, but not in the `LANG'
+environment variable, `LL_CC' combinations can be abbreviated as `LL'
+to denote the language's main dialect.  For example, `de' is equivalent
+to `de_DE' (German as spoken in Germany), and `pt' to `pt_PT'
+(Portuguese as spoken in Portugal) in this context.
+
+1.4 Translating Teams
+=====================
+
+For the Free Translation Project to be a success, we need interested
+people who like their own language and write it well, and who are also
+able to synergize with other translators speaking the same language.
+Each translation team has its own mailing list.  The up-to-date list of
+teams can be found at the Free Translation Project's homepage,
+`<A HREF="http://www.iro.umontreal.ca/contrib/po/HTML/">http://www.iro.umontreal.ca/contrib/po/HTML/</A>', in the &quot;National teams&quot;
+area.
+
+   If you'd like to volunteer to _work_ at translating messages, you
+should become a member of the translating team for your own language.
+The subscribing address is _not_ the same as the list itself, it has
+`-request' appended.  For example, speakers of Swedish can send a
+message to `<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">sv-request at li.org</A>', having this message body:
+
+     subscribe
+
+   Keep in mind that team members are expected to participate
+_actively_ in translations, or at solving translational difficulties,
+rather than merely lurking around.  If your team does not exist yet and
+you want to start one, or if you are unsure about what to do or how to
+get started, please write to `<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">translation at iro.umontreal.ca</A>' to reach the
+coordinator for all translator teams.
+
+   The English team is special.  It works at improving and uniformizing
+the terminology in use.  Proven linguistic skill are praised more than
+programming skill, here.
+
+1.5 Available Packages
+======================
+
+Languages are not equally supported in all packages.  The following
+matrix shows the current state of internationalization, as of May 2005.
+The matrix shows, in regard of each package, for which languages PO
+files have been submitted to translation coordination, with a
+translation percentage of at least 50%.
+
+     Ready PO files       af am ar az be bg bs ca cs cy da de el en en_GB
+                        +-------------------------------------------------+
+     GNUnet             |                                                 |
+     a2ps               |             []                [] [] []     []   |
+     aegis              |                                  ()             |
+     ant-phone          |                                  ()             |
+     anubis             |                                  []             |
+     ap-utils           |                                                 |
+     aspell             |                         []    [] []        []   |
+     bash               |                      []          []             |
+     batchelor          |                                  []             |
+     bfd                |                                                 |
+     bibshelf           |                                  []             |
+     binutils           |                               []                |
+     bison              |                               [] []             |
+     bluez-pin          | []                      []       [] []          |
+     clisp              |                                  []    []       |
+     console-tools      |                         []       []             |
+     coreutils          |                []    []       [] []             |
+     cpio               |                                                 |
+     cpplib             |                      []       [] []             |
+     darkstat           |                []             () []             |
+     dialog             |                      [] [] [] [] [] []          |
+     diffutils          |                      [] []    [] [] []          |
+     doodle             |                                  []             |
+     e2fsprogs          |                         []       []             |
+     enscript           |                      []       [] []        []   |
+     error              |                      []       [] []        []   |
+     fetchmail          |                      []       [] () []          |
+     fileutils          |                               [] []             |
+     findutils          |                      []       []    []          |
+     flex               |                      []       [] []             |
+     fslint             |                                  []             |
+     gas                |                                                 |
+     gawk               |                      []       [] []             |
+     gbiff              |                                  []             |
+     gcal               |                      []                         |
+     gcc                |                                  []             |
+     gettext-examples   | []                   []          [] []          |
+     gettext-runtime    |             []       []       [] []             |
+     gettext-tools      |                      []          []             |
+     gimp-print         |                         []    [] []        []   |
+     gip                |                                                 |
+     gliv               |                                  []             |
+     glunarclock        |                                                 |
+     gmult              | []                               []             |
+     gnubiff            |                                  ()             |
+     gnucash            |                         []       () ()     []   |
+     gnucash-glossary   |                               [] ()             |
+     gpe-aerial         |                         []       []             |
+     gpe-beam           |                         []       []             |
+     gpe-calendar       |                         []       []             |
+     gpe-clock          |                         []       []             |
+     gpe-conf           |                         []       []             |
+     gpe-contacts       |                                                 |
+     gpe-edit           |                         []                      |
+     gpe-go             |                         []                      |
+     gpe-login          |                         []       []             |
+     gpe-ownerinfo      |                         []       []             |
+     gpe-sketchbook     |                         []       []             |
+     gpe-su             |                         []       []             |
+     gpe-taskmanager    |                         []       []             |
+     gpe-timesheet      |                         []                      |
+     gpe-today          |                         []       []             |
+     gpe-todo           |                         []       []             |
+     gphoto2            |                         []    [] []        []   |
+     gprof              |                               [] []             |
+     gpsdrive           |                                  ()    ()       |
+     gramadoir          | []                               []             |
+     grep               | []          [] []    []          [] []          |
+     gretl              |                                                 |
+     gsasl              |                                  []             |
+     gss                |                                                 |
+     gst-plugins        | []       []          [] []       []        []   |
+     gstreamer          | []                   [] []       []        []   |
+     gtick              | []                               ()             |
+     gtkspell           |             []                   [] []          |
+     hello              |                      []       [] [] []          |
+     id-utils           |                               [] []             |
+     impost             |                                                 |
+     indent             |                      []          []             |
+     iso_3166           |                                                 |
+     iso_3166_1         |                      [] []    [] [] []          |
+     iso_3166_2         |                                                 |
+     iso_3166_3         |                                  []             |
+     iso_4217           |                                                 |
+     iso_639            |                                                 |
+     jpilot             |                         []                      |
+     jtag               |                                                 |
+     jwhois             |                                                 |
+     kbd                |                         []    [] [] []          |
+     latrine            |                                  ()             |
+     ld                 |                               []                |
+     libc               |                      [] []    [] [] []          |
+     libextractor       |                                                 |
+     libgpewidget       |                         []    [] []             |
+     libgphoto2         |                                  []             |
+     libgphoto2_port    |                                  []             |
+     libgsasl           |                                                 |
+     libiconv           | []                   []       [] [] []          |
+     libidn             |                                                 |
+     lifelines          |                               [] ()             |
+     lilypond           |                                  []             |
+     lingoteach         |                                                 |
+     lynx               |                      [] []    [] []             |
+     m4                 |                         []    [] [] []          |
+     mailutils          |                      []                         |
+     make               |                               [] []             |
+     man-db             |                      [] ()    [] []             |
+     minicom            |                         []       []             |
+     mysecretdiary      |                               [] []             |
+     nano               |                      [] ()       []             |
+     nano_1_0           |                      [] ()    [] []             |
+     opcodes            |                                  []             |
+     parted             |                      [] []    [] []             |
+     psmisc             |                                                 |
+     ptx                |                      []       [] []             |
+     pwdutils           |                                                 |
+     python             |                                                 |
+     radius             |                      []                         |
+     recode             |             []       []       [] [] []          |
+     rpm                |                         []    []                |
+     screem             |                                                 |
+     scrollkeeper       |          [] []       [] [] [] [] []        []   |
+     sed                |                      []          []             |
+     sh-utils           |                               [] []             |
+     shared-mime-info   |                []       []                      |
+     sharutils          |                      [] []    [] [] []          |
+     silky              |                                                 |
+     skencil            |                               [] ()             |
+     sketch             |                               [] ()             |
+     solfege            |                                  []             |
+     soundtracker       |                               [] []             |
+     sp                 |                                  []             |
+     stardict           |                         []                      |
+     tar                |                                                 |
+     texinfo            |                               [] []             |
+     textutils          |                      []       [] []             |
+     tin                |                                  ()        ()   |
+     tp-robot           |                                  []             |
+     tuxpaint           | []                   [] []    [] [] []     []   |
+     unicode-han-tra... |                                                 |
+     unicode-transla... |                                                 |
+     util-linux         |                      [] []    [] []             |
+     vorbis-tools       |             []          []    []           []   |
+     wastesedge         |                                  ()             |
+     wdiff              |                      []       [] []        []   |
+     wget               |                                                 |
+     xchat              |                []    []          [] []     []   |
+     xkeyboard-config   |                                                 |
+     xpad               |                                                 |
+                        +-------------------------------------------------+
+                          af am ar az be bg bs ca cs cy da de el en en_GB
+                          10  0  0  2  7  5  0 40 43  2 51 91 19  1  14
+
+                          eo es et eu fa fi fr  ga gl he hi hr hu id is
+                        +-----------------------------------------------+
+     GNUnet             |                                               |
+     a2ps               |       []       [] []                          |
+     aegis              |                                               |
+     ant-phone          |                   []                          |
+     anubis             |                   []                          |
+     ap-utils           |                   []                          |
+     aspell             |                   []  []                      |
+     bash               | [] []             []                 []       |
+     batchelor          |                   []  []                      |
+     bfd                |    []                                         |
+     bibshelf           |    []                 []                      |
+     binutils           |    []             []                          |
+     bison              |    [] []          []  []                []    |
+     bluez-pin          | []             [] []  []             [] []    |
+     clisp              |    []             []                          |
+     console-tools      |                                               |
+     coreutils          |    [] []       [] []  []                      |
+     cpio               |    []             []                          |
+     cpplib             |    []             []                          |
+     darkstat           |    []             ()  []             [] []    |
+     dialog             |    [] [] []    [] []  []             []       |
+     diffutils          | [] []          [] []  [] [] []       [] []    |
+     doodle             |                       []                      |
+     e2fsprogs          |    []             []                          |
+     enscript           |                   []              []          |
+     error              |    []          [] []  []             []       |
+     fetchmail          |    []                                         |
+     fileutils          |    [] []          []  []             []       |
+     findutils          |    [] []          []  []                      |
+     flex               |    []             []  []                      |
+     fslint             |                   []                          |
+     gas                |    []             []                          |
+     gawk               |    []             []  []    []                |
+     gbiff              |                   []                          |
+     gcal               |    []             []                          |
+     gcc                |    []                                         |
+     gettext-examples   |    []             []  []                      |
+     gettext-runtime    |    []          [] []  []                []    |
+     gettext-tools      |    []             []                          |
+     gimp-print         |    []             []                          |
+     gip                |    []    []       []                          |
+     gliv               |                   ()                          |
+     glunarclock        |                []     []             []       |
+     gmult              |          []       []                          |
+     gnubiff            |                   ()                          |
+     gnucash            |    []                                ()       |
+     gnucash-glossary   |    []                                         |
+     gpe-aerial         |    []             []                          |
+     gpe-beam           |    []             []                          |
+     gpe-calendar       |    []             []                 [] []    |
+     gpe-clock          |    []          [] []                          |
+     gpe-conf           |                   []                          |
+     gpe-contacts       |                   []                          |
+     gpe-edit           |                   []                    []    |
+     gpe-go             |    []             []                          |
+     gpe-login          |    []             []                 []       |
+     gpe-ownerinfo      |    []          [] []                 [] []    |
+     gpe-sketchbook     |    []             []                          |
+     gpe-su             |    []          [] []                          |
+     gpe-taskmanager    |    []          [] []                          |
+     gpe-timesheet      |    []             []  []                []    |
+     gpe-today          |    []          [] []  []                      |
+     gpe-todo           |    []             []                    []    |
+     gphoto2            |    []          [] []                 []       |
+     gprof              |    []             []                    []    |
+     gpsdrive           |    ()             ()                 []       |
+     gramadoir          |                   []  []                      |
+     grep               |    [] [] []    [] []  [] [] []    [] [] []    |
+     gretl              |    []             []                          |
+     gsasl              |          []       []  []                      |
+     gss                |                   []                          |
+     gst-plugins        |                   []                 []       |
+     gstreamer          |                                               |
+     gtick              |          []    [] []  []                      |
+     gtkspell           | [] []    []       []  []                      |
+     hello              | [] [] [] [] [] [] []  [] [] []    [] [] []    |
+     id-utils           |                   []                 [] []    |
+     impost             |                   []  []                      |
+     indent             | [] [] [] []    [] []  [] []          [] []    |
+     iso_3166           | []             [] []                          |
+     iso_3166_1         |    []    []    [] []  []             [] []    |
+     iso_3166_2         |                   []                          |
+     iso_3166_3         |                   []                          |
+     iso_4217           |       []       []        []                   |
+     iso_639            | []          [] [] []                          |
+     jpilot             |    []             []                          |
+     jtag               |                   []                          |
+     jwhois             |    []             []                 [] []    |
+     kbd                |    []             []                          |
+     latrine            |                   []  []                      |
+     ld                 |    []             []                          |
+     libc               |    []          [] []     []          []       |
+     libextractor       |                                               |
+     libgpewidget       |    []             []  []             [] []    |
+     libgphoto2         |    []             []                 []       |
+     libgphoto2_port    |                   []                          |
+     libgsasl           |                   []  []                      |
+     libiconv           | [] [] []       [] []  [] []       [] [] []    |
+     libidn             | []                []                          |
+     lifelines          |                   ()                          |
+     lilypond           |                                               |
+     lingoteach         |                   []                    []    |
+     lynx               |       []                             []       |
+     m4                 |                   []  [] []             []    |
+     mailutils          |    []             []                          |
+     make               |    []          [] []  [] [] []    []          |
+     man-db             |    ()                                         |
+     minicom            |    []          [] []                 []       |
+     mysecretdiary      |    []             []                    []    |
+     nano               |    []    []    () []                          |
+     nano_1_0           |    []             []     []             []    |
+     opcodes            |    []          [] []                          |
+     parted             |    []             []     []                   |
+     psmisc             |          []                                   |
+     ptx                | [] [] []       [] []  [] []          [] []    |
+     pwdutils           |                                               |
+     python             |                                               |
+     radius             |    []             []                          |
+     recode             | [] []             []     [] []       [] []    |
+     rpm                |                   []                          |
+     screem             |                                               |
+     scrollkeeper       |    []          []                    []       |
+     sed                | [] [] []          []  []             []       |
+     sh-utils           |    [] []       [] []  []             []       |
+     shared-mime-info   | [] []    []    [] []                 []       |
+     sharutils          |    [] []       [] []     []          []       |
+     silky              |                   []                          |
+     skencil            |    []             []                          |
+     sketch             |    []             []                          |
+     solfege            |                                               |
+     soundtracker       |    []             []                          |
+     sp                 |                   []                          |
+     stardict           |                                      []       |
+     tar                |    [] []          []  []                      |
+     texinfo            | []                []        []                |
+     textutils          |    []             []  [] []          []       |
+     tin                |       []          ()                          |
+     tp-robot           |                   []                 []       |
+     tuxpaint           |    []          [] []  []    []       [] [] [] |
+     unicode-han-tra... |                                               |
+     unicode-transla... |                   []  []                      |
+     util-linux         |    [] []       [] []                 []       |
+     vorbis-tools       |    []             []                          |
+     wastesedge         |                   ()                          |
+     wdiff              |    [] []          []  [] []          [] []    |
+     wget               |       [] []           []          []          |
+     xchat              |    []    []    [] []           []             |
+     xkeyboard-config   |                                               |
+     xpad               |    []                 []             []       |
+                        +-----------------------------------------------+
+                          eo es et eu fa fi fr  ga gl he hi hr hu id is
+                          15 85 21 15  2 35 115 45 16  8  1  6 40 27  1
+
+                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
+                        +--------------------------------------------------+
+     GNUnet             |                                                  |
+     a2ps               | ()    ()                   []       []    ()     |
+     aegis              |                                     ()           |
+     ant-phone          |                                     []           |
+     anubis             |                            []    [] []           |
+     ap-utils           |                                                  |
+     aspell             |                         []          []           |
+     bash               |                                     []           |
+     batchelor          |                                     []           |
+     bfd                |                                                  |
+     bibshelf           | []                                               |
+     binutils           |                                                  |
+     bison              | []                         []    [] []           |
+     bluez-pin          |          []                         []           |
+     clisp              |                                     []           |
+     console-tools      |                                                  |
+     coreutils          |    []                               []           |
+     cpio               |                                                  |
+     cpplib             |                                     []           |
+     darkstat           |                            []       []           |
+     dialog             | []                                  []           |
+     diffutils          | [] []                      []       []           |
+     doodle             | []                                               |
+     e2fsprogs          | []                                               |
+     enscript           |                                     []           |
+     error              |                                     []           |
+     fetchmail          |    []                               []           |
+     fileutils          | [] []       []                                   |
+     findutils          | []                                  []           |
+     flex               |       []                            []           |
+     fslint             |                                     []           |
+     gas                |                                                  |
+     gawk               |    []                               []           |
+     gbiff              |                                     []           |
+     gcal               |                                                  |
+     gcc                |                                                  |
+     gettext-examples   | [] []                               []           |
+     gettext-runtime    | [] [] []                            []           |
+     gettext-tools      | [] [] []                                         |
+     gimp-print         |    []                               []           |
+     gip                |                                     []           |
+     gliv               |                                     []           |
+     glunarclock        |                            []       []           |
+     gmult              | [] []                                            |
+     gnubiff            | ()                                               |
+     gnucash            | [] ()                            () []           |
+     gnucash-glossary   | []                                  []           |
+     gpe-aerial         |                                     []           |
+     gpe-beam           |                                     []           |
+     gpe-calendar       |                                     []           |
+     gpe-clock          |                                     []           |
+     gpe-conf           |                                     []           |
+     gpe-contacts       |                                                  |
+     gpe-edit           |                                     []           |
+     gpe-go             |                                     []           |
+     gpe-login          |                                     []           |
+     gpe-ownerinfo      |                                     []           |
+     gpe-sketchbook     |                                     []           |
+     gpe-su             |                                     []           |
+     gpe-taskmanager    |          []                         []           |
+     gpe-timesheet      |                                     []           |
+     gpe-today          |                                     []           |
+     gpe-todo           |                                     []           |
+     gphoto2            | [] []                               []           |
+     gprof              |                                                  |
+     gpsdrive           | () ()                               ()    ()     |
+     gramadoir          |                                     ()           |
+     grep               | [] []                            [] []           |
+     gretl              | []                                               |
+     gsasl              |                                     []           |
+     gss                |                                                  |
+     gst-plugins        | []                                  []           |
+     gstreamer          | []                                  []           |
+     gtick              | []                                  []           |
+     gtkspell           | []                      []          []           |
+     hello              | [] [] []          []       []    [] [] [] []     |
+     id-utils           | []                                  []           |
+     impost             |                                                  |
+     indent             | [] []                               []           |
+     iso_3166           |                                     []           |
+     iso_3166_1         |                                     []    []     |
+     iso_3166_2         |                                     []           |
+     iso_3166_3         |                                     []           |
+     iso_4217           |    []                   []          []           |
+     iso_639            |    []                               [] []        |
+     jpilot             |    ()                               ()    ()     |
+     jtag               |                                                  |
+     jwhois             | []                                  []           |
+     kbd                |                                     []           |
+     latrine            | []                                  []           |
+     ld                 |                                                  |
+     libc               |    [] []                         [] []    []     |
+     libextractor       |                                                  |
+     libgpewidget       |                                     []           |
+     libgphoto2         | [] []                                            |
+     libgphoto2_port    | [] []                                            |
+     libgsasl           |                                     []           |
+     libiconv           | []                                  []           |
+     libidn             | []                                               |
+     lifelines          |                                     []           |
+     lilypond           |                                                  |
+     lingoteach         | []                                  []           |
+     lynx               | [] []                               []           |
+     m4                 |    []                               []           |
+     mailutils          |                                                  |
+     make               |    [] []                            []           |
+     man-db             |    ()                                            |
+     minicom            |    []                                            |
+     mysecretdiary      |                                     []           |
+     nano               | []                         []    []              |
+     nano_1_0           | []                         []    []    []        |
+     opcodes            |                                     []           |
+     parted             | [] []                               [] []        |
+     psmisc             | []                               [] []           |
+     ptx                |                                  [] []    []     |
+     pwdutils           |                                                  |
+     python             |                                                  |
+     radius             |                                                  |
+     recode             | []                                  []           |
+     rpm                |    [] []                                         |
+     screem             |    []                                            |
+     scrollkeeper       |                                  [] [] []        |
+     sed                |    []                               []           |
+     sh-utils           | [] []                            []              |
+     shared-mime-info   |       []                         [] [] []        |
+     sharutils          | [] []                               []           |
+     silky              |                                     []           |
+     skencil            |                                                  |
+     sketch             |                                                  |
+     solfege            | []                                  []    []     |
+     soundtracker       | []                                               |
+     sp                 |    ()                                            |
+     stardict           |                      []             []           |
+     tar                | [] []                               []           |
+     texinfo            |    []                            [] []           |
+     textutils          |    [] []                         []              |
+     tin                |                                                  |
+     tp-robot           |                                     []           |
+     tuxpaint           | [] [] []       []          []       [] []        |
+     unicode-han-tra... |                                                  |
+     unicode-transla... |                                                  |
+     util-linux         | [] []                               []           |
+     vorbis-tools       |                                     []           |
+     wastesedge         |                                     []           |
+     wdiff              | []                         []    []              |
+     wget               |    []                                            |
+     xchat              | []    []          [] []             []           |
+     xkeyboard-config   |                                     []           |
+     xpad               |                                     []           |
+                        +--------------------------------------------------+
+                          it ja ko ku lg lt lv mk mn ms mt nb nl nn no nso
+                          46 35 11  2  1  1  2  2  3 11  0 15 96  7  5  0
+
+                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
+                        +----------------------------------------------+
+     GNUnet             |                                              |
+     a2ps               |       ()     []      [] []       []    [] [] |
+     aegis              |                      () ()                   |
+     ant-phone          |                      []                      |
+     anubis             |       []             [] []                   |
+     ap-utils           |       ()                                     |
+     aspell             |                      [] []                   |
+     bash               |              []      [] []                   |
+     batchelor          |                      []                      |
+     bfd                |                                              |
+     bibshelf           |                                              |
+     binutils           |                         []                [] |
+     bison              |       []     []      [] []                [] |
+     bluez-pin          |       []     []   [] [] []    []       [] [] |
+     clisp              |                         []                   |
+     console-tools      |                         []                   |
+     coreutils          |       []                []       []       [] |
+     cpio               |       []                                  [] |
+     cpplib             |                                              |
+     darkstat           |       []     []      []       []       [] [] |
+     dialog             |       [] []  []   [] [] [] []                |
+     diffutils          |       []     []      [] []             [] [] |
+     doodle             |                                     []       |
+     e2fsprogs          |       []                                  [] |
+     enscript           |              []      [] []                [] |
+     error              |              []      []       []             |
+     fetchmail          |       []                []    []    []       |
+     fileutils          |       []             [] []       []       [] |
+     findutils          |       [] []          []       []       [] [] |
+     flex               |       []     []      [] []                [] |
+     fslint             |              []      []                []    |
+     gas                |                                              |
+     gawk               |       []     []      []                   [] |
+     gbiff              |                      []                      |
+     gcal               |                                           [] |
+     gcc                |                                              |
+     gettext-examples   |       []             [] []    []       [] [] |
+     gettext-runtime    |       []             [] []    [] []    [] [] |
+     gettext-tools      |       []             [] []    [] []    [] [] |
+     gimp-print         |                               []          [] |
+     gip                |                   []          []       []    |
+     gliv               |              []      []       []             |
+     glunarclock        |              []      [] []    []       [] [] |
+     gmult              |              []   [] []                []    |
+     gnubiff            |                      ()                   [] |
+     gnucash            |       () []             []    []          [] |
+     gnucash-glossary   |          []                   []          [] |
+     gpe-aerial         |          []  []      [] []             [] [] |
+     gpe-beam           |          []  []      [] []             [] [] |
+     gpe-calendar       |          []  []      [] []    []       [] [] |
+     gpe-clock          |          []  []      [] []    []       [] [] |
+     gpe-conf           |          []  []      [] []    []          [] |
+     gpe-contacts       |                      [] []             [] [] |
+     gpe-edit           |          []  []      [] []    []       [] [] |
+     gpe-go             |              []      [] []             [] [] |
+     gpe-login          |          []  []      [] []    []       [] [] |
+     gpe-ownerinfo      |          []  []      [] []    []       [] [] |
+     gpe-sketchbook     |          []  []      [] []    []       [] [] |
+     gpe-su             |          []  []      [] []    []       [] [] |
+     gpe-taskmanager    |          []  []      [] []    []       [] [] |
+     gpe-timesheet      |          []  []      [] []    []       [] [] |
+     gpe-today          |          []  []      [] []    []       [] [] |
+     gpe-todo           |    []    []  []      [] []    []       [] [] |
+     gphoto2            |                      []       []       [] [] |
+     gprof              |              []      []                   [] |
+     gpsdrive           |    []                []                      |
+     gramadoir          |                               []             |
+     grep               |       [] []  []      [] []       []    []    |
+     gretl              |       []                                     |
+     gsasl              |       []             []             [] [] [] |
+     gss                |       []             []                   [] |
+     gst-plugins        | []                                  [] [] [] |
+     gstreamer          |                         []          [] [] [] |
+     gtick              |                      [] []                [] |
+     gtkspell           |              []   [] [] []    []       []    |
+     hello              |       []     []      [] []    []       [] [] |
+     id-utils           |              []      [] []                [] |
+     impost             |                                              |
+     indent             |              []      [] []    []       [] [] |
+     iso_3166           |          []                []       [] [] [] |
+     iso_3166_1         |                               [] [] [] []    |
+     iso_3166_2         |                                              |
+     iso_3166_3         |                      []    []          []    |
+     iso_4217           |                            []          []    |
+     iso_639            |                            []          [] [] |
+     jpilot             |                                              |
+     jtag               |                               []             |
+     jwhois             |       []     []      [] ()                () |
+     kbd                |       []             []                   [] |
+     latrine            |                      []                   [] |
+     ld                 |                                           [] |
+     libc               |       []     []         []    []          [] |
+     libextractor       |                      []                      |
+     libgpewidget       |          []  []      []       []       [] [] |
+     libgphoto2         |                         []                [] |
+     libgphoto2_port    |                         []                   |
+     libgsasl           |       []             []                []    |
+     libiconv           |       []     []   [] [] []    [] [] [] [] [] |
+     libidn             |       []                                  () |
+     lifelines          |       []                                  [] |
+     lilypond           |                                              |
+     lingoteach         |              []                              |
+     lynx               |              []         []                [] |
+     m4                 |       []     []      [] []                [] |
+     mailutils          |       []             [] []                   |
+     make               |       []     []         []                [] |
+     man-db             |                      []                   [] |
+     minicom            |       []     []      [] []                   |
+     mysecretdiary      |              []      [] []                [] |
+     nano               |              []      []                   [] |
+     nano_1_0           |       []             [] []                [] |
+     opcodes            |                      []                   [] |
+     parted             |       [] []  []                           [] |
+     psmisc             |       []             []                      |
+     ptx                |       [] []  []      [] []                [] |
+     pwdutils           |       []                                     |
+     python             |                                              |
+     radius             |       []                []                   |
+     recode             |       []     []      [] []       []       [] |
+     rpm                |       [] []             []                [] |
+     screem             |                                              |
+     scrollkeeper       |       []             [] []    []    [] [] [] |
+     sed                |       [] []  []      [] []    []       [] [] |
+     sh-utils           |                         []       []    []    |
+     shared-mime-info   |          []  []         []          [] [] [] |
+     sharutils          |                         []             [] [] |
+     silky              |                               []             |
+     skencil            |          []  []                           [] |
+     sketch             |          []  []                           [] |
+     solfege            |                                              |
+     soundtracker       |                               []          [] |
+     sp                 |                                              |
+     stardict           |                         []    []             |
+     tar                |       []             [] []                [] |
+     texinfo            |       []             [] []                [] |
+     textutils          |                         []       []       [] |
+     tin                |                                              |
+     tp-robot           |                         []                   |
+     tuxpaint           |       [] []  []      []       []    [] [] [] |
+     unicode-han-tra... |                                              |
+     unicode-transla... |                                              |
+     util-linux         |              []         []                [] |
+     vorbis-tools       |                      [] []                   |
+     wastesedge         |                                              |
+     wdiff              |       []     []      [] []    []          [] |
+     wget               |                                              |
+     xchat              |    []                   []    [] [] [] [] [] |
+     xkeyboard-config   |                                              |
+     xpad               |                                              |
+                        +----------------------------------------------+
+                          or pa pl pt pt_BR rm ro ru rw sk sl sq sr sv
+                           1  3 47 29  57    6 78 73  5 44 12 12 50 85
+
+                          ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
+                        +-----------------------------------------------+
+     GNUnet             |                                               |  0
+     a2ps               |             [] []     []                      | 19
+     aegis              |                                               |  0
+     ant-phone          |             []        []                      |  5
+     anubis             |             [] []     []                      | 11
+     ap-utils           |                ()     []                      |  2
+     aspell             |                []     [] []                   | 13
+     bash               |                       []                      | 11
+     batchelor          |             []        []                      |  7
+     bfd                |                                               |  1
+     bibshelf           |                       []                      |  5
+     binutils           |             []                                |  6
+     bison              |             []        []                      | 18
+     bluez-pin          |             [] []     [] []     []            | 25
+     clisp              |                                               |  7
+     console-tools      |             []        []                      |  5
+     coreutils          |             []        []                      | 17
+     cpio               |             [] []     []                      |  7
+     cpplib             |             []        []                      |  8
+     darkstat           |                       []        ()    ()      | 15
+     dialog             |             [] []     []                      | 25
+     diffutils          |             []        []        []    []      | 28
+     doodle             |                       []                      |  5
+     e2fsprogs          |             []                                |  8
+     enscript           |             []                                | 12
+     error              |             []        []              []      | 16
+     fetchmail          |             []                                | 12
+     fileutils          |             []                  []    []      | 18
+     findutils          |             []        []                      | 17
+     flex               |             []        []                      | 15
+     fslint             |                       []                      |  7
+     gas                |             []                                |  3
+     gawk               |             []                                | 14
+     gbiff              |                       []                      |  5
+     gcal               |             []                                |  5
+     gcc                |             []                  []            |  4
+     gettext-examples   |             [] []     []        []    []      | 21
+     gettext-runtime    |             [] []     []        []    []      | 25
+     gettext-tools      |             [] []     []        []    []      | 19
+     gimp-print         |                []                             | 11
+     gip                |                       []                      |  8
+     gliv               |             []        []                      |  7
+     glunarclock        |                       [] []                   | 13
+     gmult              |             []        []        []            | 13
+     gnubiff            |                       []                      |  3
+     gnucash            |             ()                        []      | 10
+     gnucash-glossary   |                       []              []      |  9
+     gpe-aerial         |                       []        []            | 13
+     gpe-beam           |                       []        []            | 13
+     gpe-calendar       |                       [] []     []    []      | 18
+     gpe-clock          |             []        [] []     []            | 17
+     gpe-conf           |                       []        []            | 12
+     gpe-contacts       |                       []        []            |  7
+     gpe-edit           |             []        [] []           []      | 15
+     gpe-go             |             []        []                      | 11
+     gpe-login          |             []        [] []     []    []      | 18
+     gpe-ownerinfo      |             []        []        []    []      | 19
+     gpe-sketchbook     |             []        []                      | 14
+     gpe-su             |             []        []        []            | 16
+     gpe-taskmanager    |             []        []        []            | 17
+     gpe-timesheet      |             []        []        []    []      | 17
+     gpe-today          |             []        [] []     []    []      | 19
+     gpe-todo           |                       [] []           []      | 17
+     gphoto2            |                []               []    []      | 18
+     gprof              |             []        []                      | 10
+     gpsdrive           |                                               |  3
+     gramadoir          |                       []                      |  6
+     grep               |             [] []     []              []      | 32
+     gretl              |                                               |  4
+     gsasl              |                       []        []            | 12
+     gss                |                       []                      |  5
+     gst-plugins        |                []     []              []      | 17
+     gstreamer          |             [] []     []              []      | 15
+     gtick              |                       []                      | 11
+     gtkspell           |                       [] []     []    []      | 21
+     hello              |             [] []     []        []            | 37
+     id-utils           |             []        []                      | 13
+     impost             |                       []                      |  3
+     indent             |             []        []        []    []      | 25
+     iso_3166           |          [] []        []                      | 12
+     iso_3166_1         |             []           []                   | 20
+     iso_3166_2         |                                               |  2
+     iso_3166_3         |                          []     []            |  8
+     iso_4217           |             []        []                      | 10
+     iso_639            |                       [] []                   | 12
+     jpilot             |             [] []               []            |  6
+     jtag               |                                               |  2
+     jwhois             |             []        []              []      | 12
+     kbd                |             []        []                      | 12
+     latrine            |             []        []                      |  8
+     ld                 |             []                                |  5
+     libc               |             []                  []            | 22
+     libextractor       |                                               |  1
+     libgpewidget       |                       [] []                   | 17
+     libgphoto2         |                                 []            |  9
+     libgphoto2_port    |                                               |  5
+     libgsasl           |                       []                      |  7
+     libiconv           |             [] []     [] []     []            | 32
+     libidn             |                       []        []            |  6
+     lifelines          |                                               |  4
+     lilypond           |                                               |  1
+     lingoteach         |                       []                      |  6
+     lynx               |             [] []     []                      | 15
+     m4                 |                       []        []            | 17
+     mailutils          |                []                             |  7
+     make               |             []                  []            | 18
+     man-db             |                                               |  5
+     minicom            |                                               | 11
+     mysecretdiary      |             []        []                      | 12
+     nano               |                       []              []      | 13
+     nano_1_0           |             [] []     []                      | 18
+     opcodes            |             []        []                      |  9
+     parted             |             [] []               []            | 18
+     psmisc             |                       []                      |  7
+     ptx                |             []                  []            | 23
+     pwdutils           |                                               |  1
+     python             |                                               |  0
+     radius             |                []                             |  6
+     recode             |             []        []                      | 22
+     rpm                |             [] []                             | 11
+     screem             |                                               |  1
+     scrollkeeper       |             [] []                     []      | 24
+     sed                |             []        []              []      | 21
+     sh-utils           |             []                                | 15
+     shared-mime-info   |                []               []    []      | 21
+     sharutils          |             []        []              []      | 20
+     silky              |                                               |  3
+     skencil            |                                               |  6
+     sketch             |                                               |  6
+     solfege            |                                               |  4
+     soundtracker       |             []                                |  8
+     sp                 |             []                                |  3
+     stardict           |                []     []        []    []      | 10
+     tar                |             [] []     []              []      | 15
+     texinfo            |             []                  []            | 14
+     textutils          |             []                  []    []      | 17
+     tin                |                                               |  1
+     tp-robot           |                       []        []    []      |  8
+     tuxpaint           |             []        [] []     []            | 34
+     unicode-han-tra... |                                               |  0
+     unicode-transla... |                                               |  2
+     util-linux         |             [] []     []                      | 18
+     vorbis-tools       |                []                             | 10
+     wastesedge         |                                               |  1
+     wdiff              |             []        []                      | 22
+     wget               |             []        []                      |  7
+     xchat              |                []     []        []    []      | 26
+     xkeyboard-config   |                       []                      |  2
+     xpad               |                       []                      |  5
+                        +-----------------------------------------------+
+       73 teams           ta tg th tk tr uk ven vi wa xh zh_CN zh_TW zu
+      149 domains          0  0  0  1 77 30  0  92 16  0  42    32    0  1746
+
+   Some counters in the preceding matrix are higher than the number of
+visible blocks let us expect.  This is because a few extra PO files are
+used for implementing regional variants of languages, or language
+dialects.
+
+   For a PO file in the matrix above to be effective, the package to
+which it applies should also have been internationalized and
+distributed as such by its maintainer.  There might be an observable
+lag between the mere existence a PO file and its wide availability in a
+distribution.
+
+   If May 2005 seems to be old, you may fetch a more recent copy of
+this `ABOUT-NLS' file on most GNU archive sites.  The most up-to-date
+matrix with full percentage details can be found at
+`<A HREF="http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html">http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html</A>'.
+
+1.6 Using `gettext' in new packages
+===================================
+
+If you are writing a freely available program and want to
+internationalize it you are welcome to use GNU `gettext' in your
+package.  Of course you have to respect the GNU Library General Public
+License which covers the use of the GNU `gettext' library.  This means
+in particular that even non-free programs can use `libintl' as a shared
+library, whereas only free software can use `libintl' as a static
+library or use modified versions of `libintl'.
+
+   Once the sources are changed appropriately and the setup can handle
+the use of `gettext' the only thing missing are the translations.  The
+Free Translation Project is also available for packages which are not
+developed inside the GNU project.  Therefore the information given above
+applies also for every other Free Software Project.  Contact
+`<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">translation at iro.umontreal.ca</A>' to make the `.pot' files available to
+the translation teams.
+

Copied: trunk/c-version/Makefile.am (from rev 809, trunk/Makefile.am)
===================================================================
--- trunk/c-version/Makefile.am	                        (rev 0)
+++ trunk/c-version/Makefile.am	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,18 @@
+## Process this file with automake to produce Makefile.in
+
+SUBDIRS = po src doc
+
+EXTRA_DIST = config.rpath po m4 \
+	autogen.sh sst.spec ChangeLog.old
+
+maintainer-clean-local:
+	rm -f configure
+	rm -f aclocal.m4
+	rm -f `find . -name Makefile.in`
+	rm -f `find . -name *~`
+	rm -f src/include/config.h.in
+
+clean-local:
+	rm -rf autom4te*.cache
+
+ACLOCAL_AMFLAGS = -I m4

Copied: trunk/c-version/autogen.sh (from rev 809, trunk/autogen.sh)
===================================================================
--- trunk/c-version/autogen.sh	                        (rev 0)
+++ trunk/c-version/autogen.sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,4 @@
+#!/bin/sh
+# Run this to generate all the initial makefiles, etc.
+
+autoreconf -v

Copied: trunk/c-version/compile (from rev 809, trunk/compile)
===================================================================
--- trunk/c-version/compile	                        (rev 0)
+++ trunk/c-version/compile	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,142 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand `-c -o'.
+
+scriptversion=2005-05-14.22
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
+# Written by Tom Tromey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">tromey at cygnus.com</A>&gt;.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt; or send patches to
+# &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">automake-patches at gnu.org</A>&gt;.
+
+case $1 in
+  '')
+     echo &quot;$0: No command.  Try \`$0 --help' for more information.&quot; 1&gt;&amp;2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat &lt;&lt;\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand `-c -o'.
+Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file `INSTALL'.
+
+Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo &quot;compile $scriptversion&quot;
+    exit $?
+    ;;
+esac
+
+ofile=
+cfile=
+eat=
+
+for arg
+do
+  if test -n &quot;$eat&quot;; then
+    eat=
+  else
+    case $1 in
+      -o)
+	# configure might choose to run compile as `compile cc -o foo foo.c'.
+	# So we strip `-o arg' only if arg is an object.
+	eat=1
+	case $2 in
+	  *.o | *.obj)
+	    ofile=$2
+	    ;;
+	  *)
+	    set x &quot;$@&quot; -o &quot;$2&quot;
+	    shift
+	    ;;
+	esac
+	;;
+      *.c)
+	cfile=$1
+	set x &quot;$@&quot; &quot;$1&quot;
+	shift
+	;;
+      *)
+	set x &quot;$@&quot; &quot;$1&quot;
+	shift
+	;;
+    esac
+  fi
+  shift
+done
+
+if test -z &quot;$ofile&quot; || test -z &quot;$cfile&quot;; then
+  # If no `-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # `.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec &quot;$@&quot;
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo &quot;$cfile&quot; | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use `[/.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo &quot;$cofile&quot; | sed -e 's|[/.-]|_|g'`.d
+while true; do
+  if mkdir &quot;$lockdir&quot; &gt;/dev/null 2&gt;&amp;1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap &quot;rmdir '$lockdir'; exit 1&quot; 1 2 15
+
+# Run the compile.
+&quot;$@&quot;
+ret=$?
+
+if test -f &quot;$cofile&quot;; then
+  mv &quot;$cofile&quot; &quot;$ofile&quot;
+elif test -f &quot;${cofile}bj&quot;; then
+  mv &quot;${cofile}bj&quot; &quot;$ofile&quot;
+fi
+
+rmdir &quot;$lockdir&quot;
+exit $ret
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;scriptversion=&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
+# time-stamp-end: &quot;$&quot;
+# End:

Copied: trunk/c-version/config.guess (from rev 809, trunk/config.guess)
===================================================================
--- trunk/c-version/config.guess	                        (rev 0)
+++ trunk/c-version/config.guess	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,1463 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-07-08'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Originally written by Per Bothner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">per at bothner.com</A>&gt;.
+# Please send patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo &quot;$0&quot; | sed -e 's,.*/,,'`
+
+usage=&quot;\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.&quot;
+
+version=&quot;\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&quot;
+
+help=&quot;
+Try \`$me --help' for more information.&quot;
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo &quot;$timestamp&quot; ; exit ;;
+    --version | -v )
+       echo &quot;$version&quot; ; exit ;;
+    --help | --h* | -h )
+       echo &quot;$usage&quot;; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo &quot;$me: invalid option $1$help&quot; &gt;&amp;2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo &quot;$me: too many arguments$help&quot; &gt;&amp;2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap &quot;exitcode=\$?; (rm -f \$tmpfiles 2&gt;/dev/null; rmdir \$tmp 2&gt;/dev/null) &amp;&amp; exit \$exitcode&quot; 0 ;
+trap &quot;rm -f \$tmpfiles 2&gt;/dev/null; rmdir \$tmp 2&gt;/dev/null; exit 1&quot; 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 &amp;&amp; mktemp -d -q &quot;$TMPDIR/cgXXXXXX&quot;) 2&gt;/dev/null` &amp;&amp; test -n &quot;$tmp&quot; &amp;&amp; test -d &quot;$tmp&quot; ; } ||
+ { test -n &quot;$RANDOM&quot; &amp;&amp; tmp=$TMPDIR/cg$$-$RANDOM &amp;&amp; (umask 077 &amp;&amp; mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ &amp;&amp; (umask 077 &amp;&amp; mkdir $tmp) &amp;&amp; echo &quot;Warning: creating insecure temp directory&quot; &gt;&amp;2 ; } ||
+ { echo &quot;$me: cannot create a temporary directory in $TMPDIR&quot; &gt;&amp;2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles=&quot;$dummy.c $dummy.o $dummy.rel $dummy&quot; ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo &quot;int x;&quot; &gt; $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) &gt;/dev/null 2&gt;&amp;1 ; then
+	     CC_FOR_BUILD=&quot;$c&quot;; break ;
+	  fi ;
+	done ;
+	if test x&quot;$CC_FOR_BUILD&quot; = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">ghazi at noc.rutgers.edu</A> 1994-08-24)
+if (test -f /.attbin/uname) &gt;/dev/null 2&gt;&amp;1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2&gt;/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2&gt;/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2&gt;/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2&gt;/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case &quot;${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}&quot; in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to &quot;unknown&quot;.
+	sysctl=&quot;sysctl -n hw.machine_arch&quot;
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2&gt;/dev/null || \
+	    /usr/sbin/$sysctl 2&gt;/dev/null || echo unknown)`
+	case &quot;${UNAME_MACHINE_ARCH}&quot; in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case &quot;${UNAME_MACHINE_ARCH}&quot; in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2&gt;/dev/null \
+			| grep __ELF__ &gt;/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case &quot;${UNAME_VERSION}&quot; in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo &quot;${machine}-${os}${release}&quot;
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case &quot;$ALPHA_CPU_TYPE&quot; in
+	    &quot;EV4 (21064)&quot;)
+		UNAME_MACHINE=&quot;alpha&quot; ;;
+	    &quot;EV4.5 (21064)&quot;)
+		UNAME_MACHINE=&quot;alpha&quot; ;;
+	    &quot;LCA4 (21066/21068)&quot;)
+		UNAME_MACHINE=&quot;alpha&quot; ;;
+	    &quot;EV5 (21164)&quot;)
+		UNAME_MACHINE=&quot;alphaev5&quot; ;;
+	    &quot;EV5.6 (21164A)&quot;)
+		UNAME_MACHINE=&quot;alphaev56&quot; ;;
+	    &quot;EV5.6 (21164PC)&quot;)
+		UNAME_MACHINE=&quot;alphapca56&quot; ;;
+	    &quot;EV5.7 (21164PC)&quot;)
+		UNAME_MACHINE=&quot;alphapca57&quot; ;;
+	    &quot;EV6 (21264)&quot;)
+		UNAME_MACHINE=&quot;alphaev6&quot; ;;
+	    &quot;EV6.7 (21264A)&quot;)
+		UNAME_MACHINE=&quot;alphaev67&quot; ;;
+	    &quot;EV6.8CB (21264C)&quot;)
+		UNAME_MACHINE=&quot;alphaev68&quot; ;;
+	    &quot;EV6.8AL (21264B)&quot;)
+		UNAME_MACHINE=&quot;alphaev68&quot; ;;
+	    &quot;EV6.8CX (21264D)&quot;)
+		UNAME_MACHINE=&quot;alphaev68&quot; ;;
+	    &quot;EV6.9A (21264/EV69A)&quot;)
+		UNAME_MACHINE=&quot;alphaev69&quot; ;;
+	    &quot;EV7 (21364)&quot;)
+		UNAME_MACHINE=&quot;alphaev7&quot; ;;
+	    &quot;EV7.9 (21364A)&quot;)
+		UNAME_MACHINE=&quot;alphaev79&quot; ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses &quot;1.2&quot; for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">akee at wpdis03.wpafb.af.mil</A> (Earle F. Ake) contributed MIS and NILE.
+	if test &quot;`(/bin/universe) 2&gt;/dev/null`&quot; = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case &quot;`/usr/bin/arch -k`&quot; in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2&gt;/dev/null`
+	test &quot;x${UNAME_RELEASE}&quot; = &quot;x&quot; &amp;&amp; UNAME_RELEASE=3
+	case &quot;`/bin/arch`&quot; in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # &quot;atarist&quot; or &quot;atariste&quot; at least should have a processor
+    # &gt; m68000).  The system name ranges from &quot;MiNT&quot; over &quot;FreeMiNT&quot;
+    # to the lowercase version &quot;mint&quot; (or &quot;freemint&quot;).  Finally
+    # the system name &quot;TOS&quot; denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
+#ifdef __cplusplus
+#include &lt;stdio.h&gt;  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) &amp;&amp; defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf (&quot;mips-mips-riscos%ssysv\n&quot;, argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf (&quot;mips-mips-riscos%ssvr4\n&quot;, argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf (&quot;mips-mips-riscos%sbsd\n&quot;, argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp;
+	  dummyarg=`echo &quot;${UNAME_RELEASE}&quot; | sed -n 's/\([0-9]*\).*/\1/p'` &amp;&amp;
+	  SYSTEM_NAME=`$dummy $dummyarg` &amp;&amp;
+	    { echo &quot;$SYSTEM_NAME&quot;; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo &quot;'`uname -s`'&quot; gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h &gt;/dev/null 2&gt;&amp;1; then
+		eval $set_cc_for_build
+		sed 's/^		//' &lt;&lt; EOF &gt;$dummy.c
+		#include &lt;sys/systemcfg.h&gt;
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts(&quot;powerpc-ibm-aix3.2.5&quot;);
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp; SYSTEM_NAME=`$dummy`
+		then
+			echo &quot;$SYSTEM_NAME&quot;
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h &gt;/dev/null 2&gt;&amp;1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' &gt;/dev/null 2&gt;&amp;1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case &quot;${UNAME_MACHINE}&quot; in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2&gt;/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2&gt;/dev/null`
+                    case &quot;${sc_cpu_version}&quot; in
+                      523) HP_ARCH=&quot;hppa1.0&quot; ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH=&quot;hppa1.1&quot; ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case &quot;${sc_kernel_bits}&quot; in
+                          32) HP_ARCH=&quot;hppa2.0n&quot; ;;
+                          64) HP_ARCH=&quot;hppa2.0w&quot; ;;
+			  '') HP_ARCH=&quot;hppa2.0&quot; ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ &quot;${HP_ARCH}&quot; = &quot;&quot; ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' &lt;&lt; EOF &gt;$dummy.c
+
+              #define _HPUX_SOURCE
+              #include &lt;stdlib.h&gt;
+              #include &lt;unistd.h&gt;
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts (&quot;hppa1.0&quot;); break;
+              	case CPU_PA_RISC1_1: puts (&quot;hppa1.1&quot;); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts (&quot;hppa2.0w&quot;); break;
+              		case 32: puts (&quot;hppa2.0n&quot;); break;
+              		default: puts (&quot;hppa2.0&quot;); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts (&quot;hppa2.0&quot;); break;
+              #endif
+              	default: puts (&quot;hppa1.0&quot;); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2&gt;/dev/null) &amp;&amp; HP_ARCH=`$dummy`
+		    test -z &quot;$HP_ARCH&quot; &amp;&amp; HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = &quot;hppa2.0w&quot; ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # =&gt; hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD=&quot;cc +DA2.0w&quot; ./config.guess
+	    # =&gt; hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2&gt;/dev/null) |
+		grep __LP64__ &gt;/dev/null
+	    then
+		HP_ARCH=&quot;hppa2.0w&quot;
+	    else
+		HP_ARCH=&quot;hppa64&quot;
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
+	#include &lt;unistd.h&gt;
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts (&quot;hppa1.0-hitachi-hiuxwe2&quot;); break;
+		  case CPU_PA_RISC1_1: puts (&quot;hppa1.1-hitachi-hiuxwe2&quot;); break;
+		  case CPU_PA_RISC2_0: puts (&quot;hppa2.0-hitachi-hiuxwe2&quot;); break;
+		  default: puts (&quot;hppa-hitachi-hiuxwe2&quot;); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts (&quot;m68k-hitachi-hiuxwe2&quot;);
+	  else puts (&quot;unknown-hitachi-hiuxwe2&quot;);
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp; SYSTEM_NAME=`$dummy` &amp;&amp;
+		{ echo &quot;$SYSTEM_NAME&quot;; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo &quot;${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}&quot;
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo &quot;sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}&quot;
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes &quot;-pc&quot; on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&amp;T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^CPU=`
+	test x&quot;${CPU}&quot; != x &amp;&amp; { echo &quot;${CPU}-unknown-linux-gnu&quot;; exit; }
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^CPU=`
+	test x&quot;${CPU}&quot; != x &amp;&amp; { echo &quot;${CPU}-unknown-linux-gnu&quot;; exit; }
+	;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' &lt; /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 &gt;/dev/null
+	if test &quot;$?&quot; = 0 ; then LIBC=&quot;libc1&quot; ; else LIBC=&quot;&quot; ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2&gt;/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2&gt;&amp;1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case &quot;$ld_supported_targets&quot; in
+	  elf32-i386)
+		TENTATIVE=&quot;${UNAME_MACHINE}-pc-linux-gnu&quot;
+		;;
+	  a.out-i386-linux)
+		echo &quot;${UNAME_MACHINE}-pc-linux-gnuaout&quot;
+		exit ;;
+	  coff-i386)
+		echo &quot;${UNAME_MACHINE}-pc-linux-gnucoff&quot;
+		exit ;;
+	  &quot;&quot;)
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo &quot;${UNAME_MACHINE}-pc-linux-gnuoldld&quot;
+		exit ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
+	#include &lt;features.h&gt;
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ &gt;= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#ifdef __INTEL_COMPILER
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^LIBC=`
+	test x&quot;${LIBC}&quot; != x &amp;&amp; {
+		echo &quot;${UNAME_MACHINE}-pc-linux-${LIBC}&quot;
+		exit
+	}
+	test x&quot;${TENTATIVE}&quot; != x &amp;&amp; { echo &quot;${TENTATIVE}&quot;; exit; }
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h &gt;/dev/null 2&gt;/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep &quot;^Machine&quot;` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' &lt;/usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2&gt;/dev/null &gt;/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 &gt;/dev/null) &amp;&amp; UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' &gt;/dev/null) \
+			&amp;&amp; UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' &gt;/dev/null) \
+			&amp;&amp; UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' &gt;/dev/null) \
+			&amp;&amp; UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h &gt;/dev/null 2&gt;&amp;1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# &quot;miniframe&quot;
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 &amp;&amp; { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&amp;&amp; OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' &lt; /etc/.relid`
+	/bin/uname -p 2&gt;/dev/null | grep 86 &gt;/dev/null \
+	  &amp;&amp; { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2&gt;/dev/null | /bin/grep entium &gt;/dev/null \
+	  &amp;&amp; { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2&gt;/dev/null | grep 86 &gt;/dev/null \
+          &amp;&amp; { echo i486-ncr-sysv4; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2&gt;/dev/null &gt;/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2&gt;/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Richard.M.Bartel at ccMail.Census.GOV</A>&gt;
+        echo i586-unisys-sysv4
+        exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">hewes at openmarket.com</A>&gt;.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">seanf at swdc.stratus.com.</A>
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Paul.Green at stratus.com.</A>
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Paul.Green at stratus.com.</A>
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    *86) UNAME_PROCESSOR=i686 ;;
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test &quot;$UNAME_PROCESSOR&quot; = &quot;x86&quot;; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# &quot;uname -m&quot; is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test &quot;$cputype&quot; = &quot;386&quot;; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE=&quot;$cputype&quot;
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2&gt;/dev/null`
+	case &quot;${UNAME_MACHINE}&quot; in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1&gt;&amp;2
+#echo &quot;${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}&quot; 1&gt;&amp;2
+
+eval $set_cc_for_build
+cat &gt;$dummy.c &lt;&lt;EOF
+#ifdef _SEQUENT_
+# include &lt;sys/types.h&gt;
+# include &lt;sys/utsname.h&gt;
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants &quot;bsd&quot; instead of &quot;newsos&quot;.  Perhaps BFD should be changed,
+     I don't know....  */
+  printf (&quot;mips-sony-bsd\n&quot;); exit (0);
+#else
+#include &lt;sys/param.h&gt;
+  printf (&quot;m68k-sony-newsos%s\n&quot;,
+#ifdef NEWSOS4
+          &quot;4&quot;
+#else
+	  &quot;&quot;
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) &amp;&amp; defined (__acorn) &amp;&amp; defined (__unix)
+  printf (&quot;arm-acorn-riscix\n&quot;); exit (0);
+#endif
+
+#if defined (hp300) &amp;&amp; !defined (hpux)
+  printf (&quot;m68k-hp-bsd\n&quot;); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ &quot;m68k&quot;
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2&gt;/dev/null`;
+  if (version &lt; 4)
+    printf (&quot;%s-next-nextstep%d\n&quot;, __ARCHITECTURE__, version);
+  else
+    printf (&quot;%s-next-openstep%d\n&quot;, __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf (&quot;ns32k-encore-sysv\n&quot;); exit (0);
+#else
+#if defined (CMU)
+  printf (&quot;ns32k-encore-mach\n&quot;); exit (0);
+#else
+  printf (&quot;ns32k-encore-bsd\n&quot;); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf (&quot;i386-pc-bsd\n&quot;); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf (&quot;i386-sequent-dynix\n&quot;); exit (0);
+#endif
+#if defined (ns32000)
+  printf (&quot;ns32k-sequent-dynix\n&quot;); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&amp;un);
+
+    if (strncmp(un.version, &quot;V2&quot;, 2) == 0) {
+	printf (&quot;i386-sequent-ptx2\n&quot;); exit (0);
+    }
+    if (strncmp(un.version, &quot;V1&quot;, 2) == 0) { /* XXX is V1 correct? */
+	printf (&quot;i386-sequent-ptx1\n&quot;); exit (0);
+    }
+    printf (&quot;i386-sequent-ptx\n&quot;); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include &lt;sys/param.h&gt;
+#  if defined (BSD)
+#   if BSD == 43
+      printf (&quot;vax-dec-bsd4.3\n&quot;); exit (0);
+#   else
+#    if BSD == 199006
+      printf (&quot;vax-dec-bsd4.3reno\n&quot;); exit (0);
+#    else
+      printf (&quot;vax-dec-bsd\n&quot;); exit (0);
+#    endif
+#   endif
+#  else
+    printf (&quot;vax-dec-bsd\n&quot;); exit (0);
+#  endif
+# else
+    printf (&quot;vax-dec-ultrix\n&quot;); exit (0);
+# endif
+#endif
+
+#if defined (alliant) &amp;&amp; defined (i860)
+  printf (&quot;i860-alliant-bsd\n&quot;); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2&gt;/dev/null &amp;&amp; SYSTEM_NAME=`$dummy` &amp;&amp;
+	{ echo &quot;$SYSTEM_NAME&quot;; exit; }
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo &amp;&amp; { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    c34*)
+	echo c34-convex-bsd
+	exit ;;
+    c38*)
+	echo c38-convex-bsd
+	exit ;;
+    c4*)
+	echo c4-convex-bsd
+	exit ;;
+    esac
+fi
+
+cat &gt;&amp;2 &lt;&lt;EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  <A HREF="http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess">http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess</A>
+and
+  <A HREF="http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub">http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub</A>
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt; in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2&gt;/dev/null || echo unknown`
+uname -r = `(uname -r) 2&gt;/dev/null || echo unknown`
+uname -s = `(uname -s) 2&gt;/dev/null || echo unknown`
+uname -v = `(uname -v) 2&gt;/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2&gt;/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2&gt;/dev/null`
+
+hostinfo               = `(hostinfo) 2&gt;/dev/null`
+/bin/universe          = `(/bin/universe) 2&gt;/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2&gt;/dev/null`
+/bin/arch              = `(/bin/arch) 2&gt;/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2&gt;/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2&gt;/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;timestamp='&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d&quot;
+# time-stamp-end: &quot;'&quot;
+# End:

Copied: trunk/c-version/config.rpath (from rev 809, trunk/config.rpath)
===================================================================
--- trunk/c-version/config.rpath	                        (rev 0)
+++ trunk/c-version/config.rpath	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,571 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2005 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">gord at gnu.ai.mit.edu</A>&gt;, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC=&quot;cc&quot;, the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except M$VC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host=&quot;$1&quot;
+host_cpu=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+cc_basename=`echo &quot;$CC&quot; | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test &quot;$GCC&quot; = yes; then
+  wl='-Wl,'
+else
+  case &quot;$host_os&quot; in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case &quot;$cc_basename&quot; in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux*)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    sco3.2v5*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case &quot;$host_os&quot; in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test &quot;$GCC&quot; != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test &quot;$with_gnu_ld&quot; = yes; then
+  case &quot;$host_os&quot; in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test &quot;$host_cpu&quot; != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">kc5tja at dolphin.openprojects.net</A>&gt; reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2&gt;&amp;1 | grep 'auto-import' &gt; /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris* | sysv5*)
+      if $LD -v 2&gt;&amp;1 | grep 'BFD 2\.8' &gt; /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    linux*)
+      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    *)
+      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test &quot;$ld_shlibs&quot; = yes; then
+    # Unlike libtool, we use -rpath here, not --rpath, since the documented
+    # option of GNU ld is called -rpath, not --rpath.
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  fi
+else
+  case &quot;$host_os&quot; in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test &quot;$GCC&quot; = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test &quot;$host_cpu&quot; = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = &quot;-brtl&quot; || test $ld_flag = &quot;-Wl,-brtl&quot;); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test &quot;$GCC&quot; = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f &quot;$collect2name&quot; &amp;&amp; \
+            strings &quot;$collect2name&quot; | grep resolve_lib_name &gt;/dev/null
+          then
+            # We have reworked collect2
+            hardcode_direct=yes
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' &gt; conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2&gt;/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z &quot;$aix_libpath&quot;; then
+        aix_libpath=`dump -HX64 conftest 2&gt;/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z &quot;$aix_libpath&quot;; then
+        aix_libpath=&quot;/usr/lib:/lib&quot;
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test &quot;$aix_use_runtimelinking&quot; = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'&quot;$aix_libpath&quot;
+      else
+        if test &quot;$host_cpu&quot; = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'&quot;$aix_libpath&quot;
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test &quot;$GCC&quot; = yes ; then
+        :
+      else
+        case &quot;$cc_basename&quot; in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | kfreebsd*-gnu | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10* | hpux11*)
+      if test &quot;$with_gnu_ld&quot; = no; then
+        case &quot;$host_cpu&quot; in
+          hppa*64*)
+            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+            hardcode_libdir_separator=:
+            hardcode_direct=no
+            ;;
+          ia64*)
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_direct=no
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+          *)
+            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+            hardcode_libdir_separator=:
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      hardcode_direct=yes
+      if test -z &quot;`echo __ELF__ | $CC -E - | grep __ELF__`&quot; || test &quot;$host_os-$host_cpu&quot; = &quot;openbsd2.8-powerpc&quot;; then
+        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      else
+        case &quot;$host_os&quot; in
+          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+            hardcode_libdir_flag_spec='-R$libdir'
+            ;;
+          *)
+            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+            ;;
+        esac
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test &quot;$GCC&quot; = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    sco3.2v5*)
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4.2uw2*)
+      hardcode_direct=yes
+      hardcode_minus_L=no
+      ;;
+    sysv5OpenUNIX8* | sysv5UnixWare7* |  sysv5uw[78]* | unixware7*)
+      ;;
+    sysv5*)
+      hardcode_libdir_flag_spec=
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+libname_spec='lib$name'
+case &quot;$host_os&quot; in
+  aix3*)
+    ;;
+  aix4* | aix5*)
+    ;;
+  amigaos*)
+    ;;
+  beos*)
+    ;;
+  bsdi[45]*)
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    ;;
+  dgux*)
+    ;;
+  freebsd1*)
+    ;;
+  kfreebsd*-gnu)
+    ;;
+  freebsd*)
+    ;;
+  gnu*)
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case &quot;$host_cpu&quot; in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    ;;
+  irix5* | irix6* | nonstopux*)
+    case &quot;$host_os&quot; in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*&quot;-32 &quot;|*-melf32bsmip|*&quot;-melf32bsmip &quot;) libsuff= shlibsuff= ;;
+          *-n32|*&quot;-n32 &quot;|*-melf32bmipn32|*&quot;-melf32bmipn32 &quot;) libsuff=32 shlibsuff=N32 ;;
+          *-64|*&quot;-64 &quot;|*-melf64bmip|*&quot;-melf64bmip &quot;) libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux*)
+    ;;
+  knetbsd*-gnu)
+    ;;
+  netbsd*)
+    ;;
+  newsos6)
+    ;;
+  nto-qnx*)
+    ;;
+  openbsd*)
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    ;;
+  osf3* | osf4* | osf5*)
+    ;;
+  sco3.2v5*)
+    ;;
+  solaris*)
+    ;;
+  sunos4*)
+    ;;
+  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+    ;;
+  sysv4*MP*)
+    ;;
+  uts4*)
+    ;;
+esac
+
+sed_quote_subst='s/\([&quot;`$\\]\)/\\\1/g'
+escaped_wl=`echo &quot;X$wl&quot; | sed -e 's/^X//' -e &quot;$sed_quote_subst&quot;`
+shlibext=`echo &quot;$shrext&quot; | sed -e 's,^\.,,'`
+escaped_hardcode_libdir_flag_spec=`echo &quot;X$hardcode_libdir_flag_spec&quot; | sed -e 's/^X//' -e &quot;$sed_quote_subst&quot;`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' &lt;&lt;EOF
+
+# How to pass a linker flag through the compiler.
+wl=&quot;$escaped_wl&quot;
+
+# Static library suffix (normally &quot;a&quot;).
+libext=&quot;$libext&quot;
+
+# Shared library suffix (normally &quot;so&quot;).
+shlibext=&quot;$shlibext&quot;
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=&quot;$escaped_hardcode_libdir_flag_spec&quot;
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=&quot;$hardcode_libdir_separator&quot;
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=&quot;$hardcode_direct&quot;
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=&quot;$hardcode_minus_L&quot;
+
+EOF

Copied: trunk/c-version/config.sub (from rev 809, trunk/config.sub)
===================================================================
--- trunk/c-version/config.sub	                        (rev 0)
+++ trunk/c-version/config.sub	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,1579 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-07-08'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Please send patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo &quot;$0&quot; | sed -e 's,.*/,,'`
+
+usage=&quot;\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.&quot;
+
+version=&quot;\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&quot;
+
+help=&quot;
+Try \`$me --help' for more information.&quot;
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo &quot;$timestamp&quot; ; exit ;;
+    --version | -v )
+       echo &quot;$version&quot; ; exit ;;
+    --help | --h* | -h )
+       echo &quot;$usage&quot;; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo &quot;$me: invalid option $1$help&quot;
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo &quot;$me: missing argument$help&quot; &gt;&amp;2
+    exit 1;;
+ 1) ;;
+ *) echo &quot;$me: too many arguments$help&quot; &gt;&amp;2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
+  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| ms1 \
+	| msp430 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m32c)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word &quot;unknown&quot; tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1&gt;&amp;2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| ms1-* \
+	| msp430-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	m32c-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16c)
+		basic_machine=cr16c-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what &quot;Sysv32&quot; means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1&gt;&amp;2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x&quot;$os&quot; != x&quot;&quot; ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+        -tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1&gt;&amp;2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match &quot;-MANUFACTURER&quot; here (say,
+# &quot;-sun&quot;), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed &quot;s/unknown/$vendor/&quot;`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;timestamp='&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d&quot;
+# time-stamp-end: &quot;'&quot;
+# End:

Copied: trunk/c-version/configure.ac (from rev 809, trunk/configure.ac)
===================================================================
--- trunk/c-version/configure.ac	                        (rev 0)
+++ trunk/c-version/configure.ac	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,52 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ(2.57)
+AC_INIT(sst, 2.0, stsp)
+AM_INIT_AUTOMAKE([])
+AM_GNU_GETTEXT([external])
+AM_GNU_GETTEXT_VERSION(0.14.5)
+AM_CONFIG_HEADER([src/config.h])
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_LN_S
+
+AC_CHECK_TOOL(have_xmlto, xmlto, &quot;no&quot;)
+if test &quot;$have_xmlto&quot; = &quot;no&quot;;
+then
+    AC_MSG_ERROR([xmlto is not installed])
+fi
+AC_CHECK_TOOL(have_python, python, &quot;no&quot;)
+if test &quot;$have_python&quot; = &quot;no&quot;;
+then
+    AC_MSG_ERROR([python is not installed])
+fi
+
+# Checks for libraries.
+AC_CHECK_LIB(m, floor, [],
+    AC_MSG_ERROR([math library is missing on your system.]))
+AC_CHECK_LIB(ncursesw, newwin, [],
+    AC_MSG_ERROR([ncurses library is missing on your system.]))
+
+# Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS([curses.h],
+    [], AC_MSG_ERROR([curses headers are missing on your system.]))
+AC_CHECK_HEADERS([fcntl.h sys/ioctl.h linux/kd.h])
+# Checks for typedefs, structures, and compiler characteristics.
+
+# Checks for library functions.
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_VPRINTF
+AC_CHECK_FUNCS([pow sqrt floor strcasecmp strncasecmp strchr strstr atexit], [],
+    AC_MSG_ERROR([some functions are missing on your system.]))
+
+AC_CONFIG_FILES([
+    Makefile
+    src/Makefile
+    po/Makefile.in
+    doc/Makefile
+])
+AC_OUTPUT

Copied: trunk/c-version/depcomp (from rev 809, trunk/depcomp)
===================================================================
--- trunk/c-version/depcomp	                        (rev 0)
+++ trunk/c-version/depcomp	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,530 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2005-07-09.11
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">oliva at dcc.unicamp.br</A>&gt;.
+
+case $1 in
+  '')
+     echo &quot;$0: No command.  Try \`$0 --help' for more information.&quot; 1&gt;&amp;2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat &lt;&lt;\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo &quot;depcomp $scriptversion&quot;
+    exit $?
+    ;;
+esac
+
+if test -z &quot;$depmode&quot; || test -z &quot;$source&quot; || test -z &quot;$object&quot;; then
+  echo &quot;depcomp: Variables source, object and depmode must be set&quot; 1&gt;&amp;2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo &quot;$object&quot; |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&amp;|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo &quot;$depfile&quot; | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f &quot;$tmpdepfile&quot;
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test &quot;$depmode&quot; = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test &quot;$depmode&quot; = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+case &quot;$depmode&quot; in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+  &quot;$@&quot; -MT &quot;$object&quot; -MD -MP -MF &quot;$tmpdepfile&quot;
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f &quot;$tmpdepfile&quot;
+    exit $stat
+  fi
+  mv &quot;$tmpdepfile&quot; &quot;$depfile&quot;
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z &quot;$gccflag&quot;; then
+    gccflag=-MD,
+  fi
+  &quot;$@&quot; -Wp,&quot;$gccflag$tmpdepfile&quot;
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f &quot;$tmpdepfile&quot;
+    exit $stat
+  fi
+  rm -f &quot;$depfile&quot;
+  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' &lt; &quot;$tmpdepfile&quot; |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test &quot;$libtool&quot; = yes; then
+    &quot;$@&quot; &quot;-Wp,-MDupdate,$tmpdepfile&quot;
+  else
+    &quot;$@&quot; -MDupdate &quot;$tmpdepfile&quot;
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f &quot;$tmpdepfile&quot;
+    exit $stat
+  fi
+  rm -f &quot;$depfile&quot;
+
+  if test -f &quot;$tmpdepfile&quot;; then  # yes, the sourcefile depend on other files
+    echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' &lt; &quot;$tmpdepfile&quot; \
+    | sed -e 's/^.*\.<A HREF="o://">o://</A>' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' &gt;&gt; $depfile
+    echo &gt;&gt; $depfile
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' &lt; &quot;$tmpdepfile&quot; \
+   | sed -e 's/^.*\.<A HREF="o://">o://</A>' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   &gt;&gt; $depfile
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # &quot;include basename.Plo&quot; scheme.
+    echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
+  fi
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  stripped=`echo &quot;$object&quot; | sed 's/\(.*\)\..*$/\1/'`
+  tmpdepfile=&quot;$stripped.u&quot;
+  if test &quot;$libtool&quot; = yes; then
+    &quot;$@&quot; -Wc,-M
+  else
+    &quot;$@&quot; -M
+  fi
+  stat=$?
+
+  if test -f &quot;$tmpdepfile&quot;; then :
+  else
+    stripped=`echo &quot;$stripped&quot; | sed 's,^.*/,,'`
+    tmpdepfile=&quot;$stripped.u&quot;
+  fi
+
+  if test $stat -eq 0; then :
+  else
+    rm -f &quot;$tmpdepfile&quot;
+    exit $stat
+  fi
+
+  if test -f &quot;$tmpdepfile&quot;; then
+    outname=&quot;$stripped.o&quot;
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e &quot;s,^$outname:,$object :,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
+    sed -e &quot;s,^$outname: \(.*\)$,\1:,&quot; &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # &quot;include basename.Plo&quot; scheme.
+    echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
+  fi
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  &quot;$@&quot; -MD -MF &quot;$tmpdepfile&quot;
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f &quot;$tmpdepfile&quot;
+    exit $stat
+  fi
+  rm -f &quot;$depfile&quot;
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed &quot;s,^[^:]*:,$object :,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' &lt; &quot;$tmpdepfile&quot; |
+    sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo &quot;$object&quot; | sed -e 's|/[^/]*$|/|'`
+   test &quot;x$dir&quot; = &quot;x$object&quot; &amp;&amp; dir=
+   base=`echo &quot;$object&quot; | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test &quot;$libtool&quot; = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mecanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      &quot;$@&quot; -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      &quot;$@&quot; -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f &quot;$tmpdepfile1&quot; &quot;$tmpdepfile2&quot; &quot;$tmpdepfile3&quot; &quot;$tmpdepfile4&quot;
+      exit $stat
+   fi
+
+   for tmpdepfile in &quot;$tmpdepfile1&quot; &quot;$tmpdepfile2&quot; &quot;$tmpdepfile3&quot; &quot;$tmpdepfile4&quot;
+   do
+     test -f &quot;$tmpdepfile&quot; &amp;&amp; break
+   done
+   if test -f &quot;$tmpdepfile&quot;; then
+      sed -e &quot;s,^.*\.[a-z]*:,$object:,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
+   else
+      echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
+   fi
+   rm -f &quot;$tmpdepfile&quot;
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  &quot;$@&quot; || exit $?
+
+  # Remove the call to Libtool.
+  if test &quot;$libtool&quot; = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=&quot; &quot;
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord &quot;$@&quot; &quot;$arg&quot;
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z &quot;$dashmflag&quot; &amp;&amp; dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  &quot;$@&quot; $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'&quot;$object&quot;'\: :' &gt; &quot;$tmpdepfile&quot;
+  rm -f &quot;$depfile&quot;
+  cat &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
+  tr ' ' '
+' &lt; &quot;$tmpdepfile&quot; | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  &quot;$@&quot; || exit $?
+  # Remove any Libtool call
+  if test &quot;$libtool&quot; = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no
+  for arg in &quot;$@&quot;; do
+    case $cleared in
+    no)
+      set &quot;&quot;; shift
+      cleared=yes ;;
+    esac
+    case &quot;$arg&quot; in
+    -D*|-I*)
+      set fnord &quot;$@&quot; &quot;$arg&quot;; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -*|$object)
+      ;;
+    *)
+      set fnord &quot;$@&quot; &quot;$arg&quot;; shift ;;
+    esac
+  done
+  obj_suffix=&quot;`echo $object | sed 's/^.*\././'`&quot;
+  touch &quot;$tmpdepfile&quot;
+  ${MAKEDEPEND-makedepend} -o&quot;$obj_suffix&quot; -f&quot;$tmpdepfile&quot; &quot;$@&quot;
+  rm -f &quot;$depfile&quot;
+  cat &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
+  sed '1,2d' &quot;$tmpdepfile&quot; | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot; &quot;$tmpdepfile&quot;.bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  &quot;$@&quot; || exit $?
+
+  # Remove the call to Libtool.
+  if test &quot;$libtool&quot; = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=&quot; &quot;
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord &quot;$@&quot; &quot;$arg&quot;
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  &quot;$@&quot; -E |
+    sed -n -e '/^# [0-9][0-9]* &quot;\([^&quot;]*\)&quot;.*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* &quot;\([^&quot;]*\)&quot;.*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' &gt; &quot;$tmpdepfile&quot;
+  rm -f &quot;$depfile&quot;
+  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
+  cat &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
+  sed &lt; &quot;$tmpdepfile&quot; '/^$/d;s/^ //;s/ \\$//;s/$/ :/' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o,
+  # because we must use -o when running libtool.
+  &quot;$@&quot; || exit $?
+  IFS=&quot; &quot;
+  for arg
+  do
+    case &quot;$arg&quot; in
+    &quot;-Gm&quot;|&quot;/Gm&quot;|&quot;-Gi&quot;|&quot;/Gi&quot;|&quot;-ZI&quot;|&quot;/ZI&quot;)
+	set fnord &quot;$@&quot;
+	shift
+	shift
+	;;
+    *)
+	set fnord &quot;$@&quot; &quot;$arg&quot;
+	shift
+	shift
+	;;
+    esac
+  done
+  &quot;$@&quot; -E |
+  sed -n '/^#line [0-9][0-9]* &quot;\([^&quot;]*\)&quot;/ s::echo &quot;`cygpath -u \\&quot;\1\\&quot;`&quot;:p' | sort | uniq &gt; &quot;$tmpdepfile&quot;
+  rm -f &quot;$depfile&quot;
+  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
+  . &quot;$tmpdepfile&quot; | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' &gt;&gt; &quot;$depfile&quot;
+  echo &quot;	&quot; &gt;&gt; &quot;$depfile&quot;
+  . &quot;$tmpdepfile&quot; | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' &gt;&gt; &quot;$depfile&quot;
+  rm -f &quot;$tmpdepfile&quot;
+  ;;
+
+none)
+  exec &quot;$@&quot;
+  ;;
+
+*)
+  echo &quot;Unknown depmode $depmode&quot; 1&gt;&amp;2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;scriptversion=&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
+# time-stamp-end: &quot;$&quot;
+# End:

Copied: trunk/c-version/install-sh (from rev 809, trunk/install-sh)
===================================================================
--- trunk/c-version/install-sh	                        (rev 0)
+++ trunk/c-version/install-sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,323 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2005-05-14.22
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the &quot;Software&quot;), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=&quot;${DOITPROG-}&quot;
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog=&quot;${MVPROG-mv}&quot;
+cpprog=&quot;${CPPROG-cp}&quot;
+chmodprog=&quot;${CHMODPROG-chmod}&quot;
+chownprog=&quot;${CHOWNPROG-chown}&quot;
+chgrpprog=&quot;${CHGRPPROG-chgrp}&quot;
+stripprog=&quot;${STRIPPROG-strip}&quot;
+rmprog=&quot;${RMPROG-rm}&quot;
+mkdirprog=&quot;${MKDIRPROG-mkdir}&quot;
+
+chmodcmd=&quot;$chmodprog 0755&quot;
+chowncmd=
+chgrpcmd=
+stripcmd=
+rmcmd=&quot;$rmprog -f&quot;
+mvcmd=&quot;$mvprog&quot;
+src=
+dst=
+dir_arg=
+dstarg=
+no_target_directory=
+
+usage=&quot;Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+-c         (ignored)
+-d         create directories instead of installing files.
+-g GROUP   $chgrpprog installed files to GROUP.
+-m MODE    $chmodprog installed files to MODE.
+-o USER    $chownprog installed files to USER.
+-s         $stripprog installed files.
+-t DIRECTORY  install into DIRECTORY.
+-T         report an error if DSTFILE is a directory.
+--help     display this help and exit.
+--version  display version info and exit.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
+&quot;
+
+while test -n &quot;$1&quot;; do
+  case $1 in
+    -c) shift
+        continue;;
+
+    -d) dir_arg=true
+        shift
+        continue;;
+
+    -g) chgrpcmd=&quot;$chgrpprog $2&quot;
+        shift
+        shift
+        continue;;
+
+    --help) echo &quot;$usage&quot;; exit $?;;
+
+    -m) chmodcmd=&quot;$chmodprog $2&quot;
+        shift
+        shift
+        continue;;
+
+    -o) chowncmd=&quot;$chownprog $2&quot;
+        shift
+        shift
+        continue;;
+
+    -s) stripcmd=$stripprog
+        shift
+        continue;;
+
+    -t) dstarg=$2
+	shift
+	shift
+	continue;;
+
+    -T) no_target_directory=true
+	shift
+	continue;;
+
+    --version) echo &quot;$0 $scriptversion&quot;; exit $?;;
+
+    *)  # When -d is used, all remaining arguments are directories to create.
+	# When -t is used, the destination is already specified.
+	test -n &quot;$dir_arg$dstarg&quot; &amp;&amp; break
+        # Otherwise, the last argument is the destination.  Remove it from $@.
+	for arg
+	do
+          if test -n &quot;$dstarg&quot;; then
+	    # $@ is not empty: it contains at least $arg.
+	    set fnord &quot;$@&quot; &quot;$dstarg&quot;
+	    shift # fnord
+	  fi
+	  shift # arg
+	  dstarg=$arg
+	done
+	break;;
+  esac
+done
+
+if test -z &quot;$1&quot;; then
+  if test -z &quot;$dir_arg&quot;; then
+    echo &quot;$0: no input file specified.&quot; &gt;&amp;2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src ;;
+  esac
+
+  if test -n &quot;$dir_arg&quot;; then
+    dst=$src
+    src=
+
+    if test -d &quot;$dst&quot;; then
+      mkdircmd=:
+      chmodcmd=
+    else
+      mkdircmd=$mkdirprog
+    fi
+  else
+    # Waiting for this to be detected by the &quot;$cpprog $src $dsttmp&quot; command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f &quot;$src&quot; &amp;&amp; test ! -d &quot;$src&quot;; then
+      echo &quot;$0: $src does not exist.&quot; &gt;&amp;2
+      exit 1
+    fi
+
+    if test -z &quot;$dstarg&quot;; then
+      echo &quot;$0: no destination specified.&quot; &gt;&amp;2
+      exit 1
+    fi
+
+    dst=$dstarg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst ;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d &quot;$dst&quot;; then
+      if test -n &quot;$no_target_directory&quot;; then
+	echo &quot;$0: $dstarg: Is a directory&quot; &gt;&amp;2
+	exit 1
+      fi
+      dst=$dst/`basename &quot;$src&quot;`
+    fi
+  fi
+
+  # This sed command emulates the dirname command.
+  dstdir=`echo &quot;$dst&quot; | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`
+
+  # Make sure that the destination directory exists.
+
+  # Skip lots of stat calls in the usual case.
+  if test ! -d &quot;$dstdir&quot;; then
+    defaultIFS='
+	 '
+    IFS=&quot;${IFS-$defaultIFS}&quot;
+
+    oIFS=$IFS
+    # Some sh's can't handle IFS=/ for some reason.
+    IFS='%'
+    set x `echo &quot;$dstdir&quot; | sed -e 's@/@%@g' -e 's@^%@/@'`
+    shift
+    IFS=$oIFS
+
+    pathcomp=
+
+    while test $# -ne 0 ; do
+      pathcomp=$pathcomp$1
+      shift
+      if test ! -d &quot;$pathcomp&quot;; then
+        $mkdirprog &quot;$pathcomp&quot;
+	# mkdir can fail with a `File exist' error in case several
+	# install-sh are creating the directory concurrently.  This
+	# is OK.
+	test -d &quot;$pathcomp&quot; || exit
+      fi
+      pathcomp=$pathcomp/
+    done
+  fi
+
+  if test -n &quot;$dir_arg&quot;; then
+    $doit $mkdircmd &quot;$dst&quot; \
+      &amp;&amp; { test -z &quot;$chowncmd&quot; || $doit $chowncmd &quot;$dst&quot;; } \
+      &amp;&amp; { test -z &quot;$chgrpcmd&quot; || $doit $chgrpcmd &quot;$dst&quot;; } \
+      &amp;&amp; { test -z &quot;$stripcmd&quot; || $doit $stripcmd &quot;$dst&quot;; } \
+      &amp;&amp; { test -z &quot;$chmodcmd&quot; || $doit $chmodcmd &quot;$dst&quot;; }
+
+  else
+    dstfile=`basename &quot;$dst&quot;`
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f &quot;$dsttmp&quot; &quot;$rmtmp&quot; &amp;&amp; exit $ret' 0
+    trap '(exit $?); exit' 1 2 13 15
+
+    # Copy the file name to the temp name.
+    $doit $cpprog &quot;$src&quot; &quot;$dsttmp&quot; &amp;&amp;
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above &quot;$doit $cpprog $src $dsttmp&quot; command.
+    #
+    { test -z &quot;$chowncmd&quot; || $doit $chowncmd &quot;$dsttmp&quot;; } \
+      &amp;&amp; { test -z &quot;$chgrpcmd&quot; || $doit $chgrpcmd &quot;$dsttmp&quot;; } \
+      &amp;&amp; { test -z &quot;$stripcmd&quot; || $doit $stripcmd &quot;$dsttmp&quot;; } \
+      &amp;&amp; { test -z &quot;$chmodcmd&quot; || $doit $chmodcmd &quot;$dsttmp&quot;; } &amp;&amp;
+
+    # Now rename the file to the real destination.
+    { $doit $mvcmd -f &quot;$dsttmp&quot; &quot;$dstdir/$dstfile&quot; 2&gt;/dev/null \
+      || {
+	   # The rename failed, perhaps because mv can't rename something else
+	   # to itself, or perhaps because mv is so ancient that it does not
+	   # support -f.
+
+	   # Now remove or move aside any old file at destination location.
+	   # We try this two ways since rm can't unlink itself on some
+	   # systems and the destination file might be busy for other
+	   # reasons.  In this case, the final cleanup might fail but the new
+	   # file should still install successfully.
+	   {
+	     if test -f &quot;$dstdir/$dstfile&quot;; then
+	       $doit $rmcmd -f &quot;$dstdir/$dstfile&quot; 2&gt;/dev/null \
+	       || $doit $mvcmd -f &quot;$dstdir/$dstfile&quot; &quot;$rmtmp&quot; 2&gt;/dev/null \
+	       || {
+		 echo &quot;$0: cannot unlink or rename $dstdir/$dstfile&quot; &gt;&amp;2
+		 (exit 1); exit 1
+	       }
+	     else
+	       :
+	     fi
+	   } &amp;&amp;
+
+	   # Now rename the file to the real destination.
+	   $doit $mvcmd &quot;$dsttmp&quot; &quot;$dstdir/$dstfile&quot;
+	 }
+    }
+  fi || { (exit 1); exit 1; }
+done
+
+# The final little trick to &quot;correctly&quot; pass the exit status to the exit trap.
+{
+  (exit 0); exit 0
+}
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;scriptversion=&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
+# time-stamp-end: &quot;$&quot;
+# End:

Copied: trunk/c-version/missing (from rev 809, trunk/missing)
===================================================================
--- trunk/c-version/missing	                        (rev 0)
+++ trunk/c-version/missing	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,360 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2005-06-08.21
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005
+#   Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">pinard at iro.umontreal.ca</A>&gt;, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1&gt;&amp;2 &quot;Try \`$0 --help' for more information&quot;
+  exit 1
+fi
+
+run=:
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg=&quot;missing on your system&quot;
+
+case &quot;$1&quot; in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  &quot;$@&quot; &amp;&amp; exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg=&quot;probably too old&quot;
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo &quot;\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Send bug reports to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.&quot;
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo &quot;missing $scriptversion (GNU Automake)&quot;
+    exit $?
+    ;;
+
+  -*)
+    echo 1&gt;&amp;2 &quot;$0: Unknown \`$1' option&quot;
+    echo 1&gt;&amp;2 &quot;Try \`$0 --help' for more information&quot;
+    exit 1
+    ;;
+
+esac
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).
+case &quot;$1&quot; in
+  lex|yacc)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar)
+    if test -n &quot;$run&quot;; then
+       echo 1&gt;&amp;2 &quot;ERROR: \`tar' requires --run&quot;
+       exit 1
+    elif test &quot;x$2&quot; = &quot;x--version&quot; || test &quot;x$2&quot; = &quot;x--help&quot;; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z &quot;$run&quot; &amp;&amp; ($1 --version) &gt; /dev/null 2&gt;&amp;1; then
+       # We have it, but it failed.
+       exit 1
+    elif test &quot;x$2&quot; = &quot;x--version&quot; || test &quot;x$2&quot; = &quot;x--help&quot;; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case &quot;$1&quot; in
+  aclocal*)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site.&quot;
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site.&quot;
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site.&quot;
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z &quot;$files&quot; &amp;&amp; files=&quot;config.h&quot;
+    touch_files=
+    for f in $files; do
+      case &quot;$f&quot; in
+      *:*) touch_files=&quot;$touch_files &quot;`echo &quot;$f&quot; |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files=&quot;$touch_files $f.in&quot;;;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site.&quot;
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch &quot;$f&quot;; done
+    ;;
+
+  autom4te)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site.&quot;
+
+    file=`echo &quot;$*&quot; | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
+    test -z &quot;$file&quot; &amp;&amp; file=`echo &quot;$*&quot; | sed -n 's/.*-o[ ]*\([^ ]*\).*/\1/p'`
+    if test -f &quot;$file&quot;; then
+	touch $file
+    else
+	test -z &quot;$file&quot; || exec &gt;$file
+	echo &quot;#! /bin/sh&quot;
+	echo &quot;# Created by GNU Automake missing as a replacement of&quot;
+	echo &quot;#  $ $@&quot;
+	echo &quot;exit 0&quot;
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison|yacc)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site.&quot;
+    rm -f y.tab.c y.tab.h
+    if [ $# -ne 1 ]; then
+        eval LASTARG=&quot;\${$#}&quot;
+	case &quot;$LASTARG&quot; in
+	*.y)
+	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/y$/c/'`
+	    if [ -f &quot;$SRCFILE&quot; ]; then
+	         cp &quot;$SRCFILE&quot; y.tab.c
+	    fi
+	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/y$/h/'`
+	    if [ -f &quot;$SRCFILE&quot; ]; then
+	         cp &quot;$SRCFILE&quot; y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f y.tab.h ]; then
+	echo &gt;y.tab.h
+    fi
+    if [ ! -f y.tab.c ]; then
+	echo 'main() { return 0; }' &gt;y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site.&quot;
+    rm -f lex.yy.c
+    if [ $# -ne 1 ]; then
+        eval LASTARG=&quot;\${$#}&quot;
+	case &quot;$LASTARG&quot; in
+	*.l)
+	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/l$/c/'`
+	    if [ -f &quot;$SRCFILE&quot; ]; then
+	         cp &quot;$SRCFILE&quot; lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f lex.yy.c ]; then
+	echo 'main() { return 0; }' &gt;lex.yy.c
+    fi
+    ;;
+
+  help2man)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site.&quot;
+
+    file=`echo &quot;$*&quot; | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z &quot;$file&quot;; then
+	file=`echo &quot;$*&quot; | sed -n 's/.*--output=\([^ ]*\).*/\1/p'`
+    fi
+    if [ -f &quot;$file&quot; ]; then
+	touch $file
+    else
+	test -z &quot;$file&quot; || exec &gt;$file
+	echo &quot;.ab help2man is required to generate this page&quot;
+	exit 1
+    fi
+    ;;
+
+  makeinfo)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site.&quot;
+    # The file to touch is that specified with -o ...
+    file=`echo &quot;$*&quot; | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z &quot;$file&quot;; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo &quot;$*&quot; | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z &quot;$file&quot; &amp;&amp; file=`echo &quot;$infile&quot; | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version &gt; /dev/null 2&gt;&amp;1); then
+       gnutar &quot;$@&quot; &amp;&amp; exit 0
+    fi
+    if (gtar --version &gt; /dev/null 2&gt;&amp;1); then
+       gtar &quot;$@&quot; &amp;&amp; exit 0
+    fi
+    firstarg=&quot;$1&quot;
+    if shift; then
+	case &quot;$firstarg&quot; in
+	*o*)
+	    firstarg=`echo &quot;$firstarg&quot; | sed s/o//`
+	    tar &quot;$firstarg&quot; &quot;$@&quot; &amp;&amp; exit 0
+	    ;;
+	esac
+	case &quot;$firstarg&quot; in
+	*h*)
+	    firstarg=`echo &quot;$firstarg&quot; | sed s/h//`
+	    tar &quot;$firstarg&quot; &quot;$@&quot; &amp;&amp; exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1&gt;&amp;2 &quot;\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments.&quot;
+    exit 1
+    ;;
+
+  *)
+    echo 1&gt;&amp;2 &quot;\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program.&quot;
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;scriptversion=&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
+# time-stamp-end: &quot;$&quot;
+# End:

Copied: trunk/c-version/mkinstalldirs (from rev 809, trunk/mkinstalldirs)
===================================================================
--- trunk/c-version/mkinstalldirs	                        (rev 0)
+++ trunk/c-version/mkinstalldirs	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,150 @@
+#! /bin/sh
+# mkinstalldirs --- make directory hierarchy
+
+scriptversion=2004-02-15.20
+
+# Original author: Noah Friedman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">friedman at prep.ai.mit.edu</A>&gt;
+# Created: 1993-05-16
+# Public domain.
+#
+# This file is maintained in Automake, please report
+# bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt; or send patches to
+# &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">automake-patches at gnu.org</A>&gt;.
+
+errstatus=0
+dirmode=&quot;&quot;
+
+usage=&quot;\
+Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
+
+Create each directory DIR (with mode MODE, if specified), including all
+leading file name components.
+
+Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.&quot;
+
+# process command line arguments
+while test $# -gt 0 ; do
+  case $1 in
+    -h | --help | --h*)         # -h for help
+      echo &quot;$usage&quot;
+      exit 0
+      ;;
+    -m)                         # -m PERM arg
+      shift
+      test $# -eq 0 &amp;&amp; { echo &quot;$usage&quot; 1&gt;&amp;2; exit 1; }
+      dirmode=$1
+      shift
+      ;;
+    --version)
+      echo &quot;$0 $scriptversion&quot;
+      exit 0
+      ;;
+    --)                         # stop option processing
+      shift
+      break
+      ;;
+    -*)                         # unknown option
+      echo &quot;$usage&quot; 1&gt;&amp;2
+      exit 1
+      ;;
+    *)                          # first non-opt arg
+      break
+      ;;
+  esac
+done
+
+for file
+do
+  if test -d &quot;$file&quot;; then
+    shift
+  else
+    break
+  fi
+done
+
+case $# in
+  0) exit 0 ;;
+esac
+
+# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
+# mkdir -p a/c at the same time, both will detect that a is missing,
+# one will create a, then the other will try to create a and die with
+# a &quot;File exists&quot; error.  This is a problem when calling mkinstalldirs
+# from a parallel make.  We use --version in the probe to restrict
+# ourselves to GNU mkdir, which is thread-safe.
+case $dirmode in
+  '')
+    if mkdir -p --version . &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test ! -d ./--version; then
+      echo &quot;mkdir -p -- $*&quot;
+      exec mkdir -p -- &quot;$@&quot;
+    else
+      # On NextStep and OpenStep, the `mkdir' command does not
+      # recognize any option.  It will interpret all options as
+      # directories to create, and then abort because `.' already
+      # exists.
+      test -d ./-p &amp;&amp; rmdir ./-p
+      test -d ./--version &amp;&amp; rmdir ./--version
+    fi
+    ;;
+  *)
+    if mkdir -m &quot;$dirmode&quot; -p --version . &gt;/dev/null 2&gt;&amp;1 &amp;&amp;
+       test ! -d ./--version; then
+      echo &quot;mkdir -m $dirmode -p -- $*&quot;
+      exec mkdir -m &quot;$dirmode&quot; -p -- &quot;$@&quot;
+    else
+      # Clean up after NextStep and OpenStep mkdir.
+      for d in ./-m ./-p ./--version &quot;./$dirmode&quot;;
+      do
+        test -d $d &amp;&amp; rmdir $d
+      done
+    fi
+    ;;
+esac
+
+for file
+do
+  set fnord `echo &quot;:$file&quot; | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+  shift
+
+  pathcomp=
+  for d
+  do
+    pathcomp=&quot;$pathcomp$d&quot;
+    case $pathcomp in
+      -*) pathcomp=./$pathcomp ;;
+    esac
+
+    if test ! -d &quot;$pathcomp&quot;; then
+      echo &quot;mkdir $pathcomp&quot;
+
+      mkdir &quot;$pathcomp&quot; || lasterr=$?
+
+      if test ! -d &quot;$pathcomp&quot;; then
+	errstatus=$lasterr
+      else
+	if test ! -z &quot;$dirmode&quot;; then
+	  echo &quot;chmod $dirmode $pathcomp&quot;
+	  lasterr=&quot;&quot;
+	  chmod &quot;$dirmode&quot; &quot;$pathcomp&quot; || lasterr=$?
+
+	  if test ! -z &quot;$lasterr&quot;; then
+	    errstatus=$lasterr
+	  fi
+	fi
+      fi
+    fi
+
+    pathcomp=&quot;$pathcomp/&quot;
+  done
+done
+
+exit $errstatus
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: &quot;scriptversion=&quot;
+# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
+# time-stamp-end: &quot;$&quot;
+# End:

Deleted: trunk/c-version/src/sst.py
===================================================================
--- trunk/src/sst.py	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/c-version/src/sst.py	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,6339 +0,0 @@
-#!/usr/bin/env python
-&quot;&quot;&quot;
-sst.py -- Super Star Trek 2K
-
-SST2K is a Python translation of a C translation of a FORTRAN
-original dating back to 1973.  Beautiful Python it is not, but it
-works.  Translation by Eric S. Raymond; original game by David Matuszek
-and Paul Reynolds, with modifications by Don Smith, Tom Almy,
-Stas Sergeev, and Eric S. Raymond.
-
-See the doc/HACKING file in the distribution for designers notes and advice
-on how to modify (and how not to modify!) this code.
-&quot;&quot;&quot;
-import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
-
-docpath  	= (&quot;.&quot;, &quot;../doc&quot;, &quot;/usr/share/doc/sst&quot;)
-
-def _(str): return gettext.gettext(str)
-
-GALSIZE 	= 8		# Galaxy size in quadrants
-NINHAB  	= (GALSIZE * GALSIZE / 2)	# Number of inhabited worlds
-MAXUNINHAB	= 10		# Maximum uninhabited worlds
-QUADSIZE	= 10		# Quadrant size in sectors
-BASEMIN		= 2				# Minimum starbases
-BASEMAX 	= (GALSIZE * GALSIZE / 12)	# Maximum starbases
-MAXKLGAME	= 127		# Maximum Klingons per game
-MAXKLQUAD	= 9		# Maximum Klingons per quadrant
-FULLCREW	= 428		# Crew size. BSD Trek was 387, that's wrong 
-FOREVER 	= 1e30		# Time for the indefinite future
-MAXBURST	= 3		# Max # of torps you can launch in one turn
-MINCMDR 	= 10		# Minimum number of Klingon commanders
-DOCKFAC		= 0.25		# Repair faster when docked
-PHASEFAC	= 2.0		# Unclear what this is, it was in the C version
-
-DEFAULT      = -1
-BLACK        = 0
-BLUE         = 1
-GREEN        = 2
-CYAN         = 3
-RED          = 4
-MAGENTA      = 5
-BROWN        = 6
-LIGHTGRAY    = 7
-DARKGRAY     = 8
-LIGHTBLUE    = 9
-LIGHTGREEN   = 10
-LIGHTCYAN    = 11
-LIGHTRED     = 12
-LIGHTMAGENTA = 13
-YELLOW       = 14
-WHITE        = 15
-
-class TrekError:
-    pass
-
-class coord:
-    def __init__(self, x=None, y=None):
-        self.i = x
-        self.j = y
-    def valid_quadrant(self):
-        return self.i&gt;=0 and self.i&lt;GALSIZE and self.j&gt;=0 and self.j&lt;GALSIZE
-    def valid_sector(self):
-	return self.i&gt;=0 and self.i&lt;QUADSIZE and self.j&gt;=0 and self.j&lt;QUADSIZE
-    def invalidate(self):
-        self.i = self.j = None
-    def is_valid(self):
-        return self.i != None and self.j != None
-    def __eq__(self, other):
-        return other != None and self.i == other.i and self.j == other.j
-    def __ne__(self, other):
-        return other == None or self.i != other.i or self.j != other.j
-    def __add__(self, other):
-        return coord(self.i+other.i, self.j+other.j)
-    def __sub__(self, other):
-        return coord(self.i-other.i, self.j-other.j)
-    def __mul__(self, other):
-        return coord(self.i*other, self.j*other)
-    def __rmul__(self, other):
-        return coord(self.i*other, self.j*other)
-    def __div__(self, other):
-        return coord(self.i/other, self.j/other)
-    def __mod__(self, other):
-        return coord(self.i % other, self.j % other)
-    def __rdiv__(self, other):
-        return coord(self.i/other, self.j/other)
-    def roundtogrid(self):
-        return coord(int(round(self.i)), int(round(self.j)))
-    def distance(self, other=None):
-        if not other: other = coord(0, 0)
-        return math.sqrt((self.i - other.i)**2 + (self.j - other.j)**2)
-    def bearing(self):
-        return 1.90985*math.atan2(self.j, self.i)
-    def sgn(self):
-        s = coord()
-        if self.i == 0:
-            s.i = 0
-        else:
-            s.i = self.i / abs(self.i)
-        if self.j == 0:
-            s.j = 0
-        else:
-            s.j = self.j / abs(self.j)
-        return s
-    def quadrant(self):
-        #print &quot;Location %s -&gt; %s&quot; % (self, (self / QUADSIZE).roundtogrid())
-        return self.roundtogrid() / QUADSIZE
-    def sector(self):
-        return self.roundtogrid() % QUADSIZE
-    def scatter(self):
-        s = coord()
-        s.i = self.i + randrange(-1, 2)
-        s.j = self.j + randrange(-1, 2)
-        return s
-    def __str__(self):
-        if self.i == None or self.j == None:
-            return &quot;Nowhere&quot;
-        return &quot;%s - %s&quot; % (self.i+1, self.j+1)
-    __repr__ = __str__
-
-class planet:
-    def __init__(self):
-        self.name = None	# string-valued if inhabited
-        self.quadrant = coord()	# quadrant located
-        self.pclass = None	# could be &quot;&quot;M&quot;, &quot;N&quot;, &quot;O&quot;, or &quot;destroyed&quot;
-        self.crystals = &quot;absent&quot;# could be &quot;mined&quot;, &quot;present&quot;, &quot;absent&quot;
-        self.known = &quot;unknown&quot;	# could be &quot;unknown&quot;, &quot;known&quot;, &quot;shuttle_down&quot;
-        self.inhabited = False	# is it inhabites?
-    def __str__(self):
-        return self.name
-
-class quadrant:
-    def __init__(self):
-        self.stars = 0
-        self.planet = None
-	self.starbase = False
-	self.klingons = 0
-	self.romulans = 0
-	self.supernova = False
-	self.charted = False
-        self.status = &quot;secure&quot;	# Could be &quot;secure&quot;, &quot;distressed&quot;, &quot;enslaved&quot;
-
-class page:
-    def __init__(self):
-	self.stars = None
-	self.starbase = None
-	self.klingons = None
-
-def fill2d(size, fillfun):
-    &quot;Fill an empty list in 2D.&quot;
-    lst = []
-    for i in range(size):
-        lst.append([]) 
-        for j in range(size):
-            lst[i].append(fillfun(i, j))
-    return lst
-
-class snapshot:
-    def __init__(self):
-        self.snap = False	# snapshot taken
-        self.crew = 0   	# crew complement
-	self.remkl = 0  	# remaining klingons
-	self.nscrem = 0		# remaining super commanders
-	self.starkl = 0 	# destroyed stars
-	self.basekl = 0 	# destroyed bases
-	self.nromrem = 0	# Romulans remaining
-	self.nplankl = 0	# destroyed uninhabited planets
-	self.nworldkl = 0	# destroyed inhabited planets
-        self.planets = []	# Planet information
-        self.date = 0.0   	# stardate
-	self.remres = 0 	# remaining resources
-	self.remtime = 0	# remaining time
-        self.baseq = [] 	# Base quadrant coordinates
-        self.kcmdr = [] 	# Commander quadrant coordinates
-	self.kscmdr = coord()	# Supercommander quadrant coordinates
-        # the galaxy
-        self.galaxy = fill2d(GALSIZE, lambda i, j: quadrant())
-        # the starchart
-    	self.chart = fill2d(GALSIZE, lambda i, j: page())
-
-class event:
-    def __init__(self):
-        self.date = None	# A real number
-        self.quadrant = None	# A coord structure
-
-# game options 
-OPTION_ALL	= 0xffffffff
-OPTION_TTY	= 0x00000001	# old interface 
-OPTION_CURSES	= 0x00000002	# new interface 
-OPTION_IOMODES	= 0x00000003	# cover both interfaces 
-OPTION_PLANETS	= 0x00000004	# planets and mining 
-OPTION_THOLIAN	= 0x00000008	# Tholians and their webs (UT 1979 version)
-OPTION_THINGY	= 0x00000010	# Space Thingy can shoot back (Stas, 2005)
-OPTION_PROBE	= 0x00000020	# deep-space probes (DECUS version, 1980)
-OPTION_SHOWME	= 0x00000040	# bracket Enterprise in chart 
-OPTION_RAMMING	= 0x00000080	# enemies may ram Enterprise (Almy)
-OPTION_MVBADDY	= 0x00000100	# more enemies can move (Almy)
-OPTION_BLKHOLE	= 0x00000200	# black hole may timewarp you (Stas, 2005) 
-OPTION_BASE	= 0x00000400	# bases have good shields (Stas, 2005)
-OPTION_WORLDS	= 0x00000800	# logic for inhabited worlds (ESR, 2006)
-OPTION_AUTOSCAN	= 0x00001000	# automatic LRSCAN before CHART (ESR, 2006)
-OPTION_PLAIN	= 0x01000000	# user chose plain game 
-OPTION_ALMY	= 0x02000000	# user chose Almy variant 
-OPTION_COLOR    = 0x04000000	# enable color display (experimental, ESR, 2010)
-
-# Define devices 
-DSRSENS	= 0
-DLRSENS	= 1
-DPHASER	= 2
-DPHOTON	= 3
-DLIFSUP	= 4
-DWARPEN	= 5
-DIMPULS	= 6
-DSHIELD	= 7
-DRADIO	= 0
-DSHUTTL = 9
-DCOMPTR = 10
-DNAVSYS	= 11
-DTRANSP = 12
-DSHCTRL	= 13
-DDRAY	= 14
-DDSP	= 15
-NDEVICES= 16	# Number of devices
-
-SKILL_NONE	= 0
-SKILL_NOVICE	= 1
-SKILL_FAIR	= 2
-SKILL_GOOD	= 3
-SKILL_EXPERT	= 4
-SKILL_EMERITUS	= 5
-
-def damaged(dev):	return (game.damage[dev] != 0.0)
-def communicating():	return not damaged(DRADIO) or game.condition==&quot;docked&quot;
-
-# Define future events 
-FSPY	= 0	# Spy event happens always (no future[] entry)
-		# can cause SC to tractor beam Enterprise
-FSNOVA  = 1	# Supernova
-FTBEAM  = 2	# Commander tractor beams Enterprise
-FSNAP   = 3	# Snapshot for time warp
-FBATTAK = 4	# Commander attacks base
-FCDBAS  = 5	# Commander destroys base
-FSCMOVE = 6	# Supercommander moves (might attack base)
-FSCDBAS = 7	# Supercommander destroys base
-FDSPROB = 8	# Move deep space probe
-FDISTR	= 9	# Emit distress call from an inhabited world 
-FENSLV	= 10	# Inhabited word is enslaved */
-FREPRO	= 11	# Klingons build a ship in an enslaved system
-NEVENTS	= 12
-
-# Abstract out the event handling -- underlying data structures will change
-# when we implement stateful events 
-def findevent(evtype):	return game.future[evtype]
-
-class enemy:
-    def __init__(self, type=None, loc=None, power=None):
-        self.type = type
-        self.location = coord()
-        if loc:
-            self.move(loc)
-        self.power = power	# enemy energy level
-        game.enemies.append(self)
-    def move(self, loc):
-        motion = (loc != self.location)
-        if self.location.i is not None and self.location.j is not None:
-            if motion:
-                if self.type == 'T':
-                    game.quad[self.location.i][self.location.j] = '#'
-                else:
-                    game.quad[self.location.i][self.location.j] = '.'
-        if loc:
-            self.location = copy.copy(loc)
-            game.quad[self.location.i][self.location.j] = self.type
-            self.kdist = self.kavgd = (game.sector - loc).distance()
-        else:
-            self.location = coord()
-            self.kdist = self.kavgd = None
-            game.enemies.remove(self)
-        return motion
-    def __repr__(self):
-        return &quot;&lt;%s,%s.%f&gt;&quot; % (self.type, self.location, self.power)	# For debugging
-
-class gamestate:
-    def __init__(self):
-        self.options = None	# Game options
-        self.state = snapshot()	# A snapshot structure
-        self.snapsht = snapshot()	# Last snapshot taken for time-travel purposes
-        self.quad = None	# contents of our quadrant
-        self.damage = [0.0] * NDEVICES	# damage encountered
-        self.future = []		# future events
-        for i in range(NEVENTS):
-            self.future.append(event())
-        self.passwd  = None;		# Self Destruct password
-        self.enemies = []
-        self.quadrant = None	# where we are in the large
-        self.sector = None	# where we are in the small
-        self.tholian = None	# Tholian enemy object
-        self.base = None	# position of base in current quadrant
-        self.battle = None	# base coordinates being attacked
-        self.plnet = None	# location of planet in quadrant
-        self.gamewon = False	# Finished!
-        self.ididit = False	# action taken -- allows enemy to attack
-        self.alive = False	# we are alive (not killed)
-        self.justin = False	# just entered quadrant
-        self.shldup = False	# shields are up
-        self.shldchg = False	# shield is changing (affects efficiency)
-        self.iscate = False	# super commander is here
-        self.ientesc = False	# attempted escape from supercommander
-        self.resting = False	# rest time
-        self.icraft = False	# Kirk in Galileo
-        self.landed = False	# party on planet (true), on ship (false)
-        self.alldone = False	# game is now finished
-        self.neutz = False	# Romulan Neutral Zone
-        self.isarmed = False	# probe is armed
-        self.inorbit = False	# orbiting a planet
-        self.imine = False	# mining
-        self.icrystl = False	# dilithium crystals aboard
-        self.iseenit = False	# seen base attack report
-        self.thawed = False	# thawed game
-        self.condition = None	# &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;docked&quot;, &quot;dead&quot;
-        self.iscraft = None	# &quot;onship&quot;, &quot;offship&quot;, &quot;removed&quot;
-        self.skill = None	# Player skill level
-        self.inkling = 0	# initial number of klingons
-        self.inbase = 0		# initial number of bases
-        self.incom = 0		# initial number of commanders
-        self.inscom = 0		# initial number of commanders
-        self.inrom = 0		# initial number of commanders
-        self.instar = 0		# initial stars
-        self.intorps = 0	# initial/max torpedoes
-        self.torps = 0		# number of torpedoes
-        self.ship = 0		# ship type -- 'E' is Enterprise
-        self.abandoned = 0	# count of crew abandoned in space
-        self.length = 0		# length of game
-        self.klhere = 0		# klingons here
-        self.casual = 0		# causalties
-        self.nhelp = 0		# calls for help
-        self.nkinks = 0		# count of energy-barrier crossings
-        self.iplnet = None	# planet # in quadrant
-        self.inplan = 0		# initial planets
-        self.irhere = 0		# Romulans in quadrant
-        self.isatb = 0		# =2 if super commander is attacking base
-        self.tourn = None	# tournament number
-        self.nprobes = 0	# number of probes available
-        self.inresor = 0.0	# initial resources
-        self.intime = 0.0	# initial time
-        self.inenrg = 0.0	# initial/max energy
-        self.inshld = 0.0	# initial/max shield
-        self.inlsr = 0.0	# initial life support resources
-        self.indate = 0.0	# initial date
-        self.energy = 0.0	# energy level
-        self.shield = 0.0	# shield level
-        self.warpfac = 0.0	# warp speed
-        self.lsupres = 0.0	# life support reserves
-        self.optime = 0.0	# time taken by current operation
-        self.damfac = 0.0	# damage factor
-        self.lastchart = 0.0	# time star chart was last updated
-        self.cryprob = 0.0	# probability that crystal will work
-        self.probe = None	# object holding probe course info
-        self.height = 0.0	# height of orbit around planet
-    def recompute(self):
-        # Stas thinks this should be (C expression): 
-        # game.state.remkl + len(game.state.kcmdr) &gt; 0 ?
-	#	game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr)) : 99
-        # He says the existing expression is prone to divide-by-zero errors
-        # after killing the last klingon when score is shown -- perhaps also
-        # if the only remaining klingon is SCOM.
-        game.state.remtime = game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr))
-
-FWON = 0
-FDEPLETE = 1
-FLIFESUP = 2
-FNRG = 3
-FBATTLE = 4
-FNEG3 = 5
-FNOVA = 6
-FSNOVAED = 7
-FABANDN = 8
-FDILITHIUM = 9
-FMATERIALIZE = 10
-FPHASER = 11
-FLOST = 12
-FMINING = 13
-FDPLANET = 14
-FPNOVA = 15
-FSSC = 16
-FSTRACTOR = 17
-FDRAY = 18
-FTRIBBLE = 19
-FHOLE = 20
-FCREW = 21
-
-def withprob(p):
-    return random.random() &lt; p
-
-def randrange(*args):
-    return random.randrange(*args)
-
-def randreal(*args):
-    v = random.random()
-    if len(args) == 1:
-        v *= args[0] 		# from [0, args[0])
-    elif len(args) == 2:
-        v = args[0] + v*(args[1]-args[0])	# from [args[0], args[1])
-    return v
-
-# Code from ai.c begins here
-
-def welcoming(iq):
-    &quot;Would this quadrant welcome another Klingon?&quot;
-    return iq.valid_quadrant() and \
-	not game.state.galaxy[iq.i][iq.j].supernova and \
-	game.state.galaxy[iq.i][iq.j].klingons &lt; MAXKLQUAD
-
-def tryexit(enemy, look, irun):
-    &quot;A bad guy attempts to bug out.&quot;
-    iq = coord()
-    iq.i = game.quadrant.i+(look.i+(QUADSIZE-1))/QUADSIZE - 1
-    iq.j = game.quadrant.j+(look.j+(QUADSIZE-1))/QUADSIZE - 1
-    if not welcoming(iq):
-	return False;
-    if enemy.type == 'R':
-	return False; # Romulans cannot escape! 
-    if not irun:
-	# avoid intruding on another commander's territory 
-	if enemy.type == 'C':
-            if iq in game.state.kcmdr:
-                return False
-	    # refuse to leave if currently attacking starbase 
-	    if game.battle == game.quadrant:
-		return False
-	# don't leave if over 1000 units of energy 
-	if enemy.power &gt; 1000.0:
-	    return False
-    # emit escape message and move out of quadrant.
-    # we know this if either short or long range sensors are working
-    if not damaged(DSRSENS) or not damaged(DLRSENS) or \
-	game.condition == &quot;docked&quot;:
-	prout(crmena(True, enemy.type, &quot;sector&quot;, enemy.location) + \
-              (_(&quot; escapes to Quadrant %s (and regains strength).&quot;) % q))
-    # handle local matters related to escape
-    enemy.move(None)
-    game.klhere -= 1
-    if game.condition != &quot;docked&quot;:
-	newcnd()
-    # Handle global matters related to escape 
-    game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
-    game.state.galaxy[iq.i][iq.j].klingons += 1
-    if enemy.type=='S':
-	game.iscate = False
-	game.ientesc = False
-	game.isatb = 0
-	schedule(FSCMOVE, 0.2777)
-	unschedule(FSCDBAS)
-	game.state.kscmdr=iq
-    else:
-	for cmdr in game.state.kcmdr:
-	    if cmdr == game.quadrant:
-		game.state.kcmdr[n] = iq
-		break
-    return True; # success 
-
-# The bad-guy movement algorithm:
-# 
-# 1. Enterprise has &quot;force&quot; based on condition of phaser and photon torpedoes.
-# If both are operating full strength, force is 1000. If both are damaged,
-# force is -1000. Having shields down subtracts an additional 1000.
-# 
-# 2. Enemy has forces equal to the energy of the attacker plus
-# 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
-# 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
-# 
-# Attacker Initial energy levels (nominal):
-# Klingon   Romulan   Commander   Super-Commander
-# Novice    400        700        1200        
-# Fair      425        750        1250
-# Good      450        800        1300        1750
-# Expert    475        850        1350        1875
-# Emeritus  500        900        1400        2000
-# VARIANCE   75        200         200         200
-# 
-# Enemy vessels only move prior to their attack. In Novice - Good games
-# only commanders move. In Expert games, all enemy vessels move if there
-# is a commander present. In Emeritus games all enemy vessels move.
-# 
-# 3. If Enterprise is not docked, an aggressive action is taken if enemy
-# forces are 1000 greater than Enterprise.
-# 
-# Agressive action on average cuts the distance between the ship and
-# the enemy to 1/4 the original.
-# 
-# 4.  At lower energy advantage, movement units are proportional to the
-# advantage with a 650 advantage being to hold ground, 800 to move forward
-# 1, 950 for two, 150 for back 4, etc. Variance of 100.
-# 
-# If docked, is reduced by roughly 1.75*game.skill, generally forcing a
-# retreat, especially at high skill levels.
-# 
-# 5.  Motion is limited to skill level, except for SC hi-tailing it out.
-
-def movebaddy(enemy):
-    &quot;Tactical movement for the bad guys.&quot;
-    next = coord(); look = coord()
-    irun = False
-    # This should probably be just (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant) 
-    if game.skill &gt;= SKILL_EXPERT:
-	nbaddys = (((game.quadrant in game.state.kcmdr)*2 + (game.state.kscmdr==game.quadrant)*2+game.klhere*1.23+game.irhere*1.5)/2.0)
-    else:
-	nbaddys = (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant)
-    dist1 = enemy.kdist
-    mdist = int(dist1 + 0.5); # Nearest integer distance 
-    # If SC, check with spy to see if should hi-tail it 
-    if enemy.type=='S' and \
-	(enemy.power &lt;= 500.0 or (game.condition==&quot;docked&quot; and not damaged(DPHOTON))):
-	irun = True
-	motion = -QUADSIZE
-    else:
-	# decide whether to advance, retreat, or hold position 
-	forces = enemy.power+100.0*len(game.enemies)+400*(nbaddys-1)
-	if not game.shldup:
-	    forces += 1000; # Good for enemy if shield is down! 
-	if not damaged(DPHASER) or not damaged(DPHOTON):
-            if damaged(DPHASER): # phasers damaged 
-		forces += 300.0
-	    else:
-		forces -= 0.2*(game.energy - 2500.0)
-	    if damaged(DPHOTON): # photon torpedoes damaged 
-		forces += 300.0
-	    else:
-		forces -= 50.0*game.torps
-	else:
-	    # phasers and photon tubes both out! 
-	    forces += 1000.0
-	motion = 0
-        if forces &lt;= 1000.0 and game.condition != &quot;docked&quot;: # Typical situation 
-	    motion = ((forces + randreal(200))/150.0) - 5.0
-	else:
-            if forces &gt; 1000.0: # Very strong -- move in for kill 
-		motion = (1.0 - randreal())**2 * dist1 + 1.0
-	    if game.condition==&quot;docked&quot; and (game.options &amp; OPTION_BASE): # protected by base -- back off ! 
-		motion -= game.skill*(2.0-randreal()**2)
-	if idebug:
-	    proutn(&quot;=== MOTION = %d, FORCES = %1.2f, &quot; % (motion, forces))
-	# don't move if no motion 
-	if motion==0:
-	    return
-	# Limit motion according to skill 
-	if abs(motion) &gt; game.skill:
-            if motion &lt; 0:
-                motion = -game.skill
-            else:
-                motion = game.skill
-    # calculate preferred number of steps 
-    nsteps = abs(int(motion))
-    if motion &gt; 0 and nsteps &gt; mdist:
-	nsteps = mdist; # don't overshoot 
-    if nsteps &gt; QUADSIZE:
-	nsteps = QUADSIZE; # This shouldn't be necessary 
-    if nsteps &lt; 1:
-	nsteps = 1; # This shouldn't be necessary 
-    if idebug:
-	proutn(&quot;NSTEPS = %d:&quot; % nsteps)
-    # Compute preferred values of delta X and Y 
-    m = game.sector - enemy.location
-    if 2.0 * abs(m.i) &lt; abs(m.j):
-	m.i = 0
-    if 2.0 * abs(m.j) &lt; abs(game.sector.i-enemy.location.i):
-	m.j = 0
-    m = (motion * m).sgn()
-    next = enemy.location
-    # main move loop 
-    for ll in range(nsteps):
-	if idebug:
-	    proutn(&quot; %d&quot; % (ll+1))
-	# Check if preferred position available 
-	look = next + m
-        if m.i &lt; 0:
-            krawli = 1
-        else:
-            krawli = -1
-        if m.j &lt; 0:
-            krawlj = 1
-        else:
-            krawlj = -1
-	success = False
-	attempts = 0; # Settle mysterious hang problem 
-	while attempts &lt; 20 and not success:
-            attempts += 1
-	    if look.i &lt; 0 or look.i &gt;= QUADSIZE:
-		if motion &lt; 0 and tryexit(enemy, look, irun):
-		    return
-		if krawli == m.i or m.j == 0:
-		    break
-		look.i = next.i + krawli
-		krawli = -krawli
-	    elif look.j &lt; 0 or look.j &gt;= QUADSIZE:
-		if motion &lt; 0 and tryexit(enemy, look, irun):
-		    return
-		if krawlj == m.j or m.i == 0:
-		    break
-		look.j = next.j + krawlj
-		krawlj = -krawlj
-	    elif (game.options &amp; OPTION_RAMMING) and game.quad[look.i][look.j] != '.':
-		# See if enemy should ram ship 
-		if game.quad[look.i][look.j] == game.ship and \
-		    (enemy.type == 'C' or enemy.type == 'S'):
-		    collision(rammed=True, enemy=enemy)
-		    return
-		if krawli != m.i and m.j != 0:
-		    look.i = next.i + krawli
-		    krawli = -krawli
-		elif krawlj != m.j and m.i != 0:
-		    look.j = next.j + krawlj
-		    krawlj = -krawlj
-		else:
-		    break; # we have failed 
-	    else:
-		success = True
-	if success:
-	    next = look
-	    if idebug:
-		proutn(`next`)
-	else:
-	    break; # done early 
-    if idebug:
-	skip(1)
-    if enemy.move(next):
-	if not damaged(DSRSENS) or game.condition == &quot;docked&quot;:
-	    proutn(_(&quot;*** %s from Sector %s&quot;) % (cramen(enemy.type), enemy.location))
-	    if enemy.kdist &lt; dist1:
-		proutn(_(&quot; advances to &quot;))
-	    else:
-		proutn(_(&quot; retreats to &quot;))
-	    prout(&quot;Sector %s.&quot; % next)
-
-def moveklings():
-    &quot;Sequence Klingon tactical movement.&quot;
-    if idebug:
-	prout(&quot;== MOVCOM&quot;)
-    # Figure out which Klingon is the commander (or Supercommander)
-    # and do move
-    if game.quadrant in game.state.kcmdr:
-        for enemy in game.enemies:
-	    if enemy.type == 'C':
-		movebaddy(enemy)
-    if game.state.kscmdr==game.quadrant:
-        for enemy in game.enemies:
-	    if enemy.type == 'S':
-		movebaddy(enemy)
-		break
-    # If skill level is high, move other Klingons and Romulans too!
-    # Move these last so they can base their actions on what the
-    # commander(s) do.
-    if game.skill &gt;= SKILL_EXPERT and (game.options &amp; OPTION_MVBADDY):
-        for enemy in game.enemies:
-            if enemy.type in ('K', 'R'):
-		movebaddy(enemy)
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-
-def movescom(iq, avoid):
-    &quot;Commander movement helper.&quot; 
-    # Avoid quadrants with bases if we want to avoid Enterprise 
-    if not welcoming(iq) or (avoid and iq in game.state.baseq):
-	return False
-    if game.justin and not game.iscate:
-	return False
-    # do the move 
-    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons -= 1
-    game.state.kscmdr = iq
-    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons += 1
-    if game.state.kscmdr==game.quadrant:
-	# SC has scooted, remove him from current quadrant 
-	game.iscate=False
-	game.isatb=0
-	game.ientesc = False
-	unschedule(FSCDBAS)
-	for enemy in game.enemies:
-	    if enemy.type == 'S':
-		break
-	enemy.move(None)
-	game.klhere -= 1
-	if game.condition != &quot;docked&quot;:
-	    newcnd()
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # check for a helpful planet 
-    for i in range(game.inplan):
-	if game.state.planets[i].quadrant == game.state.kscmdr and \
-	    game.state.planets[i].crystals == &quot;present&quot;:
-	    # destroy the planet 
-	    game.state.planets[i].pclass = &quot;destroyed&quot;
-	    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].planet = None
-	    if communicating():
-		announce()
-		prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
-		proutn(_(&quot;   a planet in Quadrant %s has been destroyed&quot;) % game.state.kscmdr)
-		prout(_(&quot;   by the Super-commander.\&quot;&quot;))
-	    break
-    return True; # looks good! 
-			
-def supercommander():
-    &quot;Move the Super Commander.&quot; 
-    iq = coord(); sc = coord(); ibq = coord(); idelta = coord()
-    basetbl = []
-    if idebug:
-	prout(&quot;== SUPERCOMMANDER&quot;)
-    # Decide on being active or passive 
-    avoid = ((game.incom - len(game.state.kcmdr) + game.inkling - game.state.remkl)/(game.state.date+0.01-game.indate) &lt; 0.1*game.skill*(game.skill+1.0) or \
-	    (game.state.date-game.indate) &lt; 3.0)
-    if not game.iscate and avoid:
-	# compute move away from Enterprise 
-	idelta = game.state.kscmdr-game.quadrant
-	if idelta.distance() &gt; 2.0:
-	    # circulate in space 
-	    idelta.i = game.state.kscmdr.j-game.quadrant.j
-	    idelta.j = game.quadrant.i-game.state.kscmdr.i
-    else:
-	# compute distances to starbases 
-	if not game.state.baseq:
-	    # nothing left to do 
-	    unschedule(FSCMOVE)
-	    return
-	sc = game.state.kscmdr
-        for base in game.state.baseq:
-	    basetbl.append((i, (base - sc).distance()))
-	if game.state.baseq &gt; 1:
-            basetbl.sort(lambda x, y: cmp(x[1]. y[1]))
-	# look for nearest base without a commander, no Enterprise, and
-        # without too many Klingons, and not already under attack. 
-	ifindit = iwhichb = 0
-	for (i2, base) in enumerate(game.state.baseq):
-	    i = basetbl[i2][0];	# bug in original had it not finding nearest
-	    if base==game.quadrant or base==game.battle or not welcoming(base):
-		continue
-	    # if there is a commander, and no other base is appropriate,
-	    # we will take the one with the commander
-            for cmdr in game.state.kcmdr:
-		if base == cmdr and ifindit != 2:
-		    ifindit = 2
-		    iwhichb = i
-		    break
-	    else:	# no commander -- use this one 
-		ifindit = 1
-		iwhichb = i
-		break
-	if ifindit==0:
-	    return # Nothing suitable -- wait until next time
-	ibq = game.state.baseq[iwhichb]
-	# decide how to move toward base 
-	idelta = ibq - game.state.kscmdr
-    # Maximum movement is 1 quadrant in either or both axes 
-    idelta = idelta.sgn()
-    # try moving in both x and y directions
-    # there was what looked like a bug in the Almy C code here,
-    # but it might be this translation is just wrong.
-    iq = game.state.kscmdr + idelta
-    if not movescom(iq, avoid):
-	# failed -- try some other maneuvers 
-	if idelta.i==0 or idelta.j==0:
-	    # attempt angle move 
-	    if idelta.i != 0:
-		iq.j = game.state.kscmdr.j + 1
-		if not movescom(iq, avoid):
-		    iq.j = game.state.kscmdr.j - 1
-		    movescom(iq, avoid)
-	    elif idelta.j != 0:
-		iq.i = game.state.kscmdr.i + 1
-		if not movescom(iq, avoid):
-		    iq.i = game.state.kscmdr.i - 1
-		    movescom(iq, avoid)
-	else:
-	    # try moving just in x or y 
-	    iq.j = game.state.kscmdr.j
-	    if not movescom(iq, avoid):
-		iq.j = game.state.kscmdr.j + idelta.j
-		iq.i = game.state.kscmdr.i
-		movescom(iq, avoid)
-    # check for a base 
-    if len(game.state.baseq) == 0:
-	unschedule(FSCMOVE)
-    else:
-        for ibq in game.state.baseq:
-	    if ibq == game.state.kscmdr and game.state.kscmdr == game.battle:
-		# attack the base 
-		if avoid:
-		    return # no, don't attack base! 
-		game.iseenit = False
-		game.isatb = 1
-		schedule(FSCDBAS, randreal(1.0, 3.0))
-		if is_scheduled(FCDBAS):
-		    postpone(FSCDBAS, scheduled(FCDBAS)-game.state.date)
-		if not communicating():
-		    return # no warning 
-		game.iseenit = True
-		announce()
-		prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) \
-                      % game.state.kscmdr)
-		prout(_(&quot;   reports that it is under attack from the Klingon Super-commander.&quot;))
-		proutn(_(&quot;   It can survive until stardate %d.\&quot;&quot;) \
-                       % int(scheduled(FSCDBAS)))
-		if not game.resting:
-		    return
-		prout(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
-		if ja() == False:
-		    return
-		game.resting = False
-		game.optime = 0.0; # actually finished 
-		return
-    # Check for intelligence report 
-    if not idebug and \
-	(withprob(0.8) or \
-	 (not communicating()) or \
-	 not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].charted):
-	return
-    announce()
-    prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
-    proutn(_(&quot;   the Super-commander is in Quadrant %s,&quot;) % game.state.kscmdr)
-    return
-
-def movetholian():
-    &quot;Move the Tholian.&quot;
-    if not game.tholian or game.justin:
-	return
-    id = coord()
-    if game.tholian.location.i == 0 and game.tholian.location.j == 0:
-	id.i = 0; id.j = QUADSIZE-1
-    elif game.tholian.location.i == 0 and game.tholian.location.j == QUADSIZE-1:
-	id.i = QUADSIZE-1; id.j = QUADSIZE-1
-    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == QUADSIZE-1:
-	id.i = QUADSIZE-1; id.j = 0
-    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == 0:
-	id.i = 0; id.j = 0
-    else:
-	# something is wrong! 
-	game.tholian.move(None)
-        prout(&quot;***Internal error: Tholian in a bad spot.&quot;)
-	return
-    # do nothing if we are blocked 
-    if game.quad[id.i][id.j] not in ('.', '#'):
-	return
-    here = copy.copy(game.tholian.location)
-    delta = (id - game.tholian.location).sgn()
-    # move in x axis 
-    while here.i != id.i:
-        here.i += delta.i
-        if game.quad[here.i][here.j]=='.':
-            game.tholian.move(here)
-    # move in y axis 
-    while here.j != id.j:
-        here.j += delta.j
-        if game.quad[here.i][here.j]=='.':
-            game.tholian.move(here)
-    # check to see if all holes plugged 
-    for i in range(QUADSIZE):
-	if game.quad[0][i]!='#' and game.quad[0][i]!='T':
-	    return
-	if game.quad[QUADSIZE-1][i]!='#' and game.quad[QUADSIZE-1][i]!='T':
-	    return
-	if game.quad[i][0]!='#' and game.quad[i][0]!='T':
-	    return
-	if game.quad[i][QUADSIZE-1]!='#' and game.quad[i][QUADSIZE-1]!='T':
-	    return
-    # All plugged up -- Tholian splits 
-    game.quad[game.tholian.location.i][game.tholian.location.j]='#'
-    dropin(' ')
-    prout(crmena(True, 'T', &quot;sector&quot;, game.tholian) + _(&quot; completes web.&quot;))
-    game.tholian.move(None)
-    return
-
-# Code from battle.c begins here
-
-def doshield(shraise):
-    &quot;Change shield status.&quot;
-    action = &quot;NONE&quot;
-    game.ididit = False
-    if shraise:
-	action = &quot;SHUP&quot;
-    else:
-	key = scanner.next()
-	if key == &quot;IHALPHA&quot;:
-	    if scanner.sees(&quot;transfer&quot;):
-		action = &quot;NRG&quot;
-	    else:
-		if damaged(DSHIELD):
-		    prout(_(&quot;Shields damaged and down.&quot;))
-		    return
-		if scanner.sees(&quot;up&quot;):
-		    action = &quot;SHUP&quot;
-		elif scanner.sees(&quot;down&quot;):
-		    action = &quot;SHDN&quot;
-	if action==&quot;NONE&quot;:
-	    proutn(_(&quot;Do you wish to change shield energy? &quot;))
-	    if ja() == True:
-		action = &quot;NRG&quot;
-	    elif damaged(DSHIELD):
-		prout(_(&quot;Shields damaged and down.&quot;))
-		return
-	    elif game.shldup:
-		proutn(_(&quot;Shields are up. Do you want them down? &quot;))
-		if ja() == True:
-		    action = &quot;SHDN&quot;
-		else:
-		    scanner.chew()
-		    return
-	    else:
-		proutn(_(&quot;Shields are down. Do you want them up? &quot;))
-		if ja() == True:
-		    action = &quot;SHUP&quot;
-		else:
-		    scanner.chew()
-		    return    
-    if action == &quot;SHUP&quot;: # raise shields 
-	if game.shldup:
-	    prout(_(&quot;Shields already up.&quot;))
-	    return
-	game.shldup = True
-	game.shldchg = True
-	if game.condition != &quot;docked&quot;:
-	    game.energy -= 50.0
-	prout(_(&quot;Shields raised.&quot;))
-	if game.energy &lt;= 0:
-	    skip(1)
-	    prout(_(&quot;Shields raising uses up last of energy.&quot;))
-	    finish(FNRG)
-	    return
-	game.ididit=True
-	return
-    elif action == &quot;SHDN&quot;:
-	if not game.shldup:
-	    prout(_(&quot;Shields already down.&quot;))
-	    return
-	game.shldup=False
-	game.shldchg=True
-	prout(_(&quot;Shields lowered.&quot;))
-	game.ididit = True
-	return
-    elif action == &quot;NRG&quot;:
-	while scanner.next() != &quot;IHREAL&quot;:
-	    scanner.chew()
-	    proutn(_(&quot;Energy to transfer to shields- &quot;))
-        nrg = scanner.real
-	scanner.chew()
-	if nrg == 0:
-	    return
-	if nrg &gt; game.energy:
-	    prout(_(&quot;Insufficient ship energy.&quot;))
-	    return
-	game.ididit = True
-	if game.shield+nrg &gt;= game.inshld:
-	    prout(_(&quot;Shield energy maximized.&quot;))
-	    if game.shield+nrg &gt; game.inshld:
-		prout(_(&quot;Excess energy requested returned to ship energy&quot;))
-	    game.energy -= game.inshld-game.shield
-	    game.shield = game.inshld
-	    return
-	if nrg &lt; 0.0 and game.energy-nrg &gt; game.inenrg:
-	    # Prevent shield drain loophole 
-	    skip(1)
-	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Scott here. Power circuit problem, Captain.&quot;))
-	    prout(_(&quot;  I can't drain the shields.&quot;))
-	    game.ididit = False
-	    return
-	if game.shield+nrg &lt; 0:
-	    prout(_(&quot;All shield energy transferred to ship.&quot;))
-	    game.energy += game.shield
-	    game.shield = 0.0
-	    return
-	proutn(_(&quot;Scotty- \&quot;&quot;))
-	if nrg &gt; 0:
-	    prout(_(&quot;Transferring energy to shields.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Draining energy from shields.\&quot;&quot;))
-	game.shield += nrg
-	game.energy -= nrg
-	return
-
-def randdevice():
-    &quot;Choose a device to damage, at random.&quot;
-    weights = (
-	105,	# DSRSENS: short range scanners	10.5% 
-	105,	# DLRSENS: long range scanners		10.5% 
-	120,	# DPHASER: phasers			12.0% 
-	120,	# DPHOTON: photon torpedoes		12.0% 
-	25,	# DLIFSUP: life support			 2.5% 
-	65,	# DWARPEN: warp drive			 6.5% 
-	70,	# DIMPULS: impulse engines		 6.5% 
-	145,	# DSHIELD: deflector shields		14.5% 
-	30,	# DRADIO:  subspace radio		 3.0% 
-	45,	# DSHUTTL: shuttle			 4.5% 
-	15,	# DCOMPTR: computer			 1.5% 
-	20,	# NAVCOMP: navigation system		 2.0% 
-	75,	# DTRANSP: transporter			 7.5% 
-	20,	# DSHCTRL: high-speed shield controller  2.0% 
-	10,	# DDRAY: death ray			 1.0% 
-	30,	# DDSP: deep-space probes		 3.0% 
-    )
-    assert(sum(weights) == 1000)
-    idx = randrange(1000)
-    sum = 0
-    for (i, w) in enumerate(weights):
-	sum += w
-	if idx &lt; sum:
-	    return i
-    return None;	# we should never get here
-
-def collision(rammed, enemy):
-    &quot;Collision handling fot rammong events.&quot;
-    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-    skip(1)
-    prout(_(&quot;***COLLISION IMMINENT.&quot;))
-    skip(2)
-    proutn(&quot;***&quot;)
-    proutn(crmshp())
-    hardness = {'R':1.5, 'C':2.0, 'S':2.5, 'T':0.5, '?':4.0}.get(enemy.type, 1.0)
-    if rammed:
-        proutn(_(&quot; rammed by &quot;))
-    else:
-        proutn(_(&quot; rams &quot;))
-    proutn(crmena(False, enemy.type, &quot;sector&quot;, enemy.location))
-    if rammed:
-	proutn(_(&quot; (original position)&quot;))
-    skip(1)
-    deadkl(enemy.location, enemy.type, game.sector)
-    proutn(&quot;***&quot; + crmship() + &quot; heavily damaged.&quot;)
-    icas = randrange(10, 30)
-    prout(_(&quot;***Sickbay reports %d casualties&quot;), icas)
-    game.casual += icas
-    game.state.crew -= icas
-    # In the pre-SST2K version, all devices got equiprobably damaged,
-    # which was silly.  Instead, pick up to half the devices at
-    # random according to our weighting table,
-    ncrits = randrange(NDEVICES/2)
-    for m in range(ncrits):
-	dev = randdevice()
-	if game.damage[dev] &lt; 0:
-	    continue
-	extradm = (10.0*hardness*randreal()+1.0)*game.damfac
-	# Damage for at least time of travel! 
-	game.damage[dev] += game.optime + extradm
-    game.shldup = False
-    prout(_(&quot;***Shields are down.&quot;))
-    if game.state.remkl + len(game.state.kcmdr) + game.state.nscrem:
-	announce()
-	damagereport()
-    else:
-	finish(FWON)
-    return
-
-def torpedo(origin, bearing, dispersion, number, nburst):
-    &quot;Let a photon torpedo fly&quot; 
-    if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
-	setwnd(srscan_window)
-    else: 
-	setwnd(message_window)
-    ac = bearing + 0.25*dispersion	# dispersion is a random variable
-    bullseye = (15.0 - bearing)*0.5235988
-    track = course(bearing=ac, distance=QUADSIZE, origin=cartesian(origin)) 
-    bumpto = coord(0, 0)
-    # Loop to move a single torpedo 
-    setwnd(message_window)
-    for step in range(1, QUADSIZE*2):
-        if not track.next(): break
-        w = track.sector()
-	if not w.valid_sector():
-	    break
-	iquad=game.quad[w.i][w.j]
-	tracktorpedo(origin, w, step, number, nburst, iquad)
-	if iquad=='.':
-	    continue
-	# hit something 
-	if not damaged(DSRSENS) or game.condition == &quot;docked&quot;:
-	    skip(1);	# start new line after text track 
-	if iquad in ('E', 'F'): # Hit our ship 
-	    skip(1)
-	    prout(_(&quot;Torpedo hits %s.&quot;) % crmshp())
-	    hit = 700.0 + randreal(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
-	    newcnd(); # we're blown out of dock 
-	    if game.landed or game.condition==&quot;docked&quot;:
-		return hit # Cheat if on a planet 
-            # In the C/FORTRAN version, dispersion was 2.5 radians, which
-            # is 143 degrees, which is almost exactly 4.8 clockface units
-            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
-            displacement.next()
-            bumpto = displacement.sector()
-	    if not bumpto.valid_sector():
-		return hit
-	    if game.quad[bumpto.i][bumpto.j]==' ':
-		finish(FHOLE)
-		return hit
-	    if game.quad[bumpto.i][bumpto.j]!='.':
-		# can't move into object 
-		return hit
-	    game.sector = bumpto
-	    proutn(crmshp())
-            game.quad[w.i][w.j]='.'
-            game.quad[bumpto.i][bumpto.j]=iquad
-            prout(_(&quot; displaced by blast to Sector %s &quot;) % bumpto)
-            for enemy in game.enemies:
-                enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
-            game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-            return None
-	elif iquad in ('C', 'S', 'R', 'K'): # Hit a regular enemy 
-	    # find the enemy 
-	    if iquad in ('C', 'S') and withprob(0.05):
-		prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; uses anti-photon device;&quot;))
-		prout(_(&quot;   torpedo neutralized.&quot;))
-		return None
-            for enemy in game.enemies:
-		if w == enemy.location:
-		    break
-	    kp = math.fabs(enemy.power)
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
-	    h1 = math.fabs(h1)
-	    if kp &lt; h1:
-		h1 = kp
-            if enemy.power &lt; 0:
-                enemy.power -= -h1
-            else:
-                enemy.power -= h1
-	    if enemy.power == 0:
-		deadkl(w, iquad, w)
-		return None
-	    proutn(crmena(True, iquad, &quot;sector&quot;, w))
-            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
-            displacement.next()
-            bumpto = displacement.sector()
-            if not bumpto.valid_sector():
-		prout(_(&quot; damaged but not destroyed.&quot;))
-		return
-	    if game.quad[bumpto.i][bumpto.j] == ' ':
-		prout(_(&quot; buffeted into black hole.&quot;))
-		deadkl(w, iquad, bumpto)
-	    if game.quad[bumpto.i][bumpto.j] != '.':
-		prout(_(&quot; damaged but not destroyed.&quot;))
-            else:
-                prout(_(&quot; damaged-- displaced by blast to Sector %s &quot;)%bumpto)
-                enemy.location = bumpto
-                game.quad[w.i][w.j]='.'
-                game.quad[bumpto.i][bumpto.j]=iquad
-                for enemy in game.enemies:
-                    enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
-                game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-            return None
-	elif iquad == 'B': # Hit a base 
-	    skip(1)
-	    prout(_(&quot;***STARBASE DESTROYED..&quot;))
-            game.state.baseq = filter(lambda x: x != game.quadrant, game.state.baseq)
-	    game.quad[w.i][w.j]='.'
-	    game.base.invalidate()
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase -= 1
-	    game.state.chart[game.quadrant.i][game.quadrant.j].starbase -= 1
-	    game.state.basekl += 1
-	    newcnd()
-	    return None
-	elif iquad == 'P': # Hit a planet 
-	    prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; destroyed.&quot;))
-	    game.state.nplankl += 1
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-	    game.iplnet.pclass = &quot;destroyed&quot;
-	    game.iplnet = None
-	    game.plnet.invalidate()
-	    game.quad[w.i][w.j] = '.'
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    return None
-	elif iquad == '@': # Hit an inhabited world -- very bad! 
-	    prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; destroyed.&quot;))
-	    game.state.nworldkl += 1
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-	    game.iplnet.pclass = &quot;destroyed&quot;
-	    game.iplnet = None
-	    game.plnet.invalidate()
-	    game.quad[w.i][w.j] = '.'
-	    if game.landed:
-		# captain perishes on planet 
-		finish(FDPLANET)
-	    prout(_(&quot;The torpedo destroyed an inhabited planet.&quot;))
-	    return None
-	elif iquad == '*': # Hit a star 
-	    if withprob(0.9):
-		nova(w)
-            else:
-                prout(crmena(True, '*', &quot;sector&quot;, w) + _(&quot; unaffected by photon blast.&quot;))
-	    return None
-	elif iquad == '?': # Hit a thingy 
-	    if not (game.options &amp; OPTION_THINGY) or withprob(0.3):
-		skip(1)
-		prouts(_(&quot;AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!&quot;))
-		skip(1)
-		prouts(_(&quot;    HACK!     HACK!    HACK!        *CHOKE!*  &quot;))
-		skip(1)
-		proutn(_(&quot;Mr. Spock-&quot;))
-		prouts(_(&quot;  \&quot;Fascinating!\&quot;&quot;))
-		skip(1)
-		deadkl(w, iquad, w)
-	    else:
-		# Stas Sergeev added the possibility that
-		# you can shove the Thingy and piss it off.
-		# It then becomes an enemy and may fire at you.
-		thing.angry = True
-		shoved = True
-	    return None
-	elif iquad == ' ': # Black hole 
-	    skip(1)
-	    prout(crmena(True, ' ', &quot;sector&quot;, w) + _(&quot; swallows torpedo.&quot;))
-	    return None
-	elif iquad == '#': # hit the web 
-	    skip(1)
-	    prout(_(&quot;***Torpedo absorbed by Tholian web.&quot;))
-	    return None
-	elif iquad == 'T':  # Hit a Tholian 
-	    h1 = 700.0 + randrange(100) - \
-		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-angle))
-	    h1 = math.fabs(h1)
-	    if h1 &gt;= 600:
-		game.quad[w.i][w.j] = '.'
-		deadkl(w, iquad, w)
-		game.tholian = None
-		return None
-	    skip(1)
-	    proutn(crmena(True, 'T', &quot;sector&quot;, w))
-	    if withprob(0.05):
-		prout(_(&quot; survives photon blast.&quot;))
-		return None
-	    prout(_(&quot; disappears.&quot;))
-	    game.tholian.move(None)
-	    game.quad[w.i][w.j] = '#'
-	    dropin(' ')
-	    return None
-        else: # Problem!
-	    skip(1)
-	    proutn(&quot;Don't know how to handle torpedo collision with &quot;)
-	    proutn(crmena(True, iquad, &quot;sector&quot;, w))
-	    skip(1)
-	    return None
-	break
-    skip(1)
-    prout(_(&quot;Torpedo missed.&quot;))
-    return None;
-
-def fry(hit):
-    &quot;Critical-hit resolution.&quot; 
-    if hit &lt; (275.0-25.0*game.skill)*randreal(1.0, 1.5):
-	return
-    ncrit = int(1.0 + hit/(500.0+randreal(100)))
-    proutn(_(&quot;***CRITICAL HIT--&quot;))
-    # Select devices and cause damage
-    cdam = []
-    for loop1 in range(ncrit):
-        while True:
-	    j = randdevice()
-	    # Cheat to prevent shuttle damage unless on ship 
-            if not (game.damage[j]&lt;0.0 or (j==DSHUTTL and game.iscraft != &quot;onship&quot;)):
-                break
-	cdam.append(j)
-	extradm = (hit*game.damfac)/(ncrit*randreal(75, 100))
-	game.damage[j] += extradm
-    skipcount = 0
-    for (i, j) in enumerate(cdam):
-	proutn(device[j])
-        if skipcount % 3 == 2 and i &lt; len(cdam)-1:
-            skip(1)
-        skipcount += 1
-        if i &lt; len(cdam)-1:
-            proutn(_(&quot; and &quot;))
-    prout(_(&quot; damaged.&quot;))
-    if damaged(DSHIELD) and game.shldup:
-	prout(_(&quot;***Shields knocked down.&quot;))
-	game.shldup=False
-
-def attack(torps_ok):
-    # bad guy attacks us 
-    # torps_ok == False forces use of phasers in an attack 
-    # game could be over at this point, check
-    if game.alldone:
-	return
-    attempt = False; ihurt = False;
-    hitmax=0.0; hittot=0.0; chgfac=1.0
-    where = &quot;neither&quot;
-    if idebug:
-	prout(&quot;=== ATTACK!&quot;)
-    # Tholian gets to move before attacking 
-    if game.tholian:
-	movetholian()
-    # if you have just entered the RNZ, you'll get a warning 
-    if game.neutz: # The one chance not to be attacked 
-	game.neutz = False
-	return
-    # commanders get a chance to tac-move towards you 
-    if (((game.quadrant in game.state.kcmdr or game.state.kscmdr==game.quadrant) and not game.justin) or game.skill == SKILL_EMERITUS) and torps_ok:
-	moveklings()
-    # if no enemies remain after movement, we're done 
-    if len(game.enemies)==0 or (len(game.enemies)==1 and thing == game.quadrant and not thing.angry):
-	return
-    # set up partial hits if attack happens during shield status change 
-    pfac = 1.0/game.inshld
-    if game.shldchg:
-	chgfac = 0.25 + randreal(0.5)
-    skip(1)
-    # message verbosity control 
-    if game.skill &lt;= SKILL_FAIR:
-	where = &quot;sector&quot;
-    for enemy in game.enemies:
-	if enemy.power &lt; 0:
-	    continue;	# too weak to attack 
-	# compute hit strength and diminish shield power 
-	r = randreal()
-	# Increase chance of photon torpedos if docked or enemy energy is low 
-	if game.condition == &quot;docked&quot;:
-	    r *= 0.25
-	if enemy.power &lt; 500:
-	    r *= 0.25; 
-	if enemy.type=='T' or (enemy.type=='?' and not thing.angry):
-	    continue
-	# different enemies have different probabilities of throwing a torp 
-	usephasers = not torps_ok or \
-	    (enemy.type == 'K' and r &gt; 0.0005) or \
-	    (enemy.type=='C' and r &gt; 0.015) or \
-	    (enemy.type=='R' and r &gt; 0.3) or \
-	    (enemy.type=='S' and r &gt; 0.07) or \
-	    (enemy.type=='?' and r &gt; 0.05)
-	if usephasers:	    # Enemy uses phasers 
-	    if game.condition == &quot;docked&quot;:
-		continue; # Don't waste the effort! 
-	    attempt = True; # Attempt to attack 
-	    dustfac = randreal(0.8, 0.85)
-	    hit = enemy.power*math.pow(dustfac,enemy.kavgd)
-	    enemy.power *= 0.75
-	else: # Enemy uses photon torpedo 
-	    # We should be able to make the bearing() method work here
-	    course = 1.90985*math.atan2(game.sector.j-enemy.location.j, enemy.location.i-game.sector.i)
-	    hit = 0
-	    proutn(_(&quot;***TORPEDO INCOMING&quot;))
-	    if not damaged(DSRSENS):
-		proutn(_(&quot; From &quot;) + crmena(False, enemy.type, where, enemy.location))
-	    attempt = True
-	    prout(&quot;  &quot;)
-	    dispersion = (randreal()+randreal())*0.5 - 0.5
-	    dispersion += 0.002*enemy.power*dispersion
-	    hit = torpedo(enemy.location, course, dispersion, number=1, nburst=1)
-	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-		finish(FWON); # Klingons did themselves in! 
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.alldone:
-		return # Supernova or finished 
-	    if hit == None:
-		continue
-	# incoming phaser or torpedo, shields may dissipate it 
-	if game.shldup or game.shldchg or game.condition==&quot;docked&quot;:
-	    # shields will take hits 
-	    propor = pfac * game.shield
-            if game.condition ==&quot;docked&quot;:
-                propr *= 2.1
-	    if propor &lt; 0.1:
-		propor = 0.1
-	    hitsh = propor*chgfac*hit+1.0
-	    absorb = 0.8*hitsh
-	    if absorb &gt; game.shield:
-		absorb = game.shield
-	    game.shield -= absorb
-	    hit -= hitsh
-	    # taking a hit blasts us out of a starbase dock 
-	    if game.condition == &quot;docked&quot;:
-		dock(False)
-	    # but the shields may take care of it 
-	    if propor &gt; 0.1 and hit &lt; 0.005*game.energy:
-		continue
-	# hit from this opponent got through shields, so take damage 
-	ihurt = True
-	proutn(_(&quot;%d unit hit&quot;) % int(hit))
-	if (damaged(DSRSENS) and usephasers) or game.skill&lt;=SKILL_FAIR:
-	    proutn(_(&quot; on the &quot;) + crmshp())
-	if not damaged(DSRSENS) and usephasers:
-	    prout(_(&quot; from &quot;) + crmena(False, enemy.type, where, enemy.location))
-	skip(1)
-	# Decide if hit is critical 
-	if hit &gt; hitmax:
-	    hitmax = hit
-	hittot += hit
-	fry(hit)
-	game.energy -= hit
-    if game.energy &lt;= 0:
-	# Returning home upon your shield, not with it... 
-	finish(FBATTLE)
-	return
-    if not attempt and game.condition == &quot;docked&quot;:
-	prout(_(&quot;***Enemies decide against attacking your ship.&quot;))
-    percent = 100.0*pfac*game.shield+0.5
-    if not ihurt:
-	# Shields fully protect ship 
-	proutn(_(&quot;Enemy attack reduces shield strength to &quot;))
-    else:
-	# Emit message if starship suffered hit(s) 
-	skip(1)
-	proutn(_(&quot;Energy left %2d    shields &quot;) % int(game.energy))
-	if game.shldup:
-	    proutn(_(&quot;up &quot;))
-	elif not damaged(DSHIELD):
-	    proutn(_(&quot;down &quot;))
-	else:
-	    proutn(_(&quot;damaged, &quot;))
-    prout(_(&quot;%d%%,   torpedoes left %d&quot;) % (percent, game.torps))
-    # Check if anyone was hurt 
-    if hitmax &gt;= 200 or hittot &gt;= 500:
-	icas = randrange(int(hittot * 0.015))
-	if icas &gt;= 2:
-	    skip(1)
-	    prout(_(&quot;Mc Coy-  \&quot;Sickbay to bridge.  We suffered %d casualties&quot;) % icas)
-	    prout(_(&quot;   in that last attack.\&quot;&quot;))
-	    game.casual += icas
-	    game.state.crew -= icas
-    # After attack, reset average distance to enemies 
-    for enemy in game.enemies:
-	enemy.kavgd = enemy.kdist
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    return
-		
-def deadkl(w, type, mv):
-    &quot;Kill a Klingon, Tholian, Romulan, or Thingy.&quot; 
-    # Added mv to allow enemy to &quot;move&quot; before dying 
-    proutn(crmena(True, type, &quot;sector&quot;, mv))
-    # Decide what kind of enemy it is and update appropriately 
-    if type == 'R':
-        # Chalk up a Romulan 
-        game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans -= 1
-        game.irhere -= 1
-        game.state.nromrem -= 1
-    elif type == 'T':
-        # Killed a Tholian 
-        game.tholian = None
-    elif type == '?':
-        # Killed a Thingy
-        global thing
-        thing = None
-    else:
-        # Killed some type of Klingon 
-        game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
-        game.klhere -= 1
-        if type == 'C':
-            game.state.kcmdr.remove(game.quadrant)
-            unschedule(FTBEAM)
-            if game.state.kcmdr:
-                schedule(FTBEAM, expran(1.0*game.incom/len(game.state.kcmdr)))
-            if is_scheduled(FCDBAS) and game.battle == game.quadrant:
-                unschedule(FCDBAS)    
-        elif type ==  'K':
-            game.state.remkl -= 1
-        elif type ==  'S':
-            game.state.nscrem -= 1
-            game.state.kscmdr.invalidate()
-            game.isatb = 0
-            game.iscate = False
-            unschedule(FSCMOVE)
-            unschedule(FSCDBAS)
-    # For each kind of enemy, finish message to player 
-    prout(_(&quot; destroyed.&quot;))
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-	return
-    game.recompute()
-    # Remove enemy ship from arrays describing local conditions
-    for e in game.enemies:
-	if e.location == w:
-            e.move(None)
-	    break
-    return
-
-def targetcheck(w):
-    &quot;Return None if target is invalid, otherwise return a course angle.&quot;
-    if not w.valid_sector():
-	huh()
-	return None
-    delta = coord()
-    # FIXME: C code this was translated from is wacky -- why the sign reversal?
-    delta.j = (w.j - game.sector.j);
-    delta.i = (game.sector.i - w.i);
-    if delta == coord(0, 0):
-	skip(1)
-	prout(_(&quot;Spock-  \&quot;Bridge to sickbay.  Dr. McCoy,&quot;))
-	prout(_(&quot;  I recommend an immediate review of&quot;))
-	prout(_(&quot;  the Captain's psychological profile.\&quot;&quot;))
-	scanner.chew()
-	return None
-    return delta.bearing()
-
-def torps():
-    &quot;Launch photon torpedo salvo.&quot;
-    course = []
-    game.ididit = False
-    if damaged(DPHOTON):
-	prout(_(&quot;Photon tubes damaged.&quot;))
-	scanner.chew()
-	return
-    if game.torps == 0:
-	prout(_(&quot;No torpedoes left.&quot;))
-	scanner.chew()
-	return
-    # First, get torpedo count
-    while True:
-        scanner.next()
-	if scanner.token == &quot;IHALPHA&quot;:
-	    huh()
-	    return
-	elif scanner.token == &quot;IHEOL&quot; or not scanner.waiting():
-	    prout(_(&quot;%d torpedoes left.&quot;) % game.torps)
-            scanner.chew()
-	    proutn(_(&quot;Number of torpedoes to fire- &quot;))
-            continue	# Go back around to get a number
-	else: # key == &quot;IHREAL&quot;
-	    n = scanner.int()
-	    if n &lt;= 0: # abort command 
-		scanner.chew()
-		return
-	    if n &gt; MAXBURST:
-		scanner.chew()
-		prout(_(&quot;Maximum of %d torpedoes per burst.&quot;) % MAXBURST)
-		return
-            if n &gt; game.torps:
-                scanner.chew()	# User requested more torps than available
-                continue	# Go back around
-            break	# All is good, go to next stage
-    # Next, get targets
-    target = []
-    for i in range(n):
-	key = scanner.next()
-	if i==0 and key == &quot;IHEOL&quot;:
-	    break;	# no coordinate waiting, we will try prompting 
-	if i==1 and key == &quot;IHEOL&quot;:
-	    # direct all torpedoes at one target 
-	    while i &lt; n:
-		target.append(target[0])
-		course.append(course[0])
-		i += 1
-	    break
-        scanner.push(scanner.token)
-        target.append(scanner.getcoord())
-        if target[-1] == None:
-            return
-        course.append(targetcheck(target[-1]))
-        if course[-1] == None:
-	    return
-    scanner.chew()
-    if len(target) == 0:
-	# prompt for each one 
-	for i in range(n):
-	    proutn(_(&quot;Target sector for torpedo number %d- &quot;) % (i+1))
-	    scanner.chew()
-            target.append(scanner.getcoord())
-            if target[-1] == None:
-                return
-            course.append(targetcheck(target[-1]))
-            if course[-1] == None:
-                return
-    game.ididit = True
-    # Loop for moving &lt;n&gt; torpedoes 
-    for i in range(n):
-	if game.condition != &quot;docked&quot;:
-	    game.torps -= 1
-	dispersion = (randreal()+randreal())*0.5 -0.5
-	if math.fabs(dispersion) &gt;= 0.47:
-	    # misfire! 
-	    dispersion *= randreal(1.2, 2.2)
-	    if n &gt; 0:
-		prouts(_(&quot;***TORPEDO NUMBER %d MISFIRES&quot;) % (i+1))
-	    else:
-		prouts(_(&quot;***TORPEDO MISFIRES.&quot;))
-	    skip(1)
-	    if i &lt; n:
-		prout(_(&quot;  Remainder of burst aborted.&quot;))
-	    if withprob(0.2):
-		prout(_(&quot;***Photon tubes damaged by misfire.&quot;))
-		game.damage[DPHOTON] = game.damfac * randreal(1.0, 3.0)
-	    break
-	if game.shldup or game.condition == &quot;docked&quot;:
-	    dispersion *= 1.0 + 0.0001*game.shield
-	torpedo(game.sector, course[i], dispersion, number=i, nburst=n)
-	if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-	    return
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-	finish(FWON);
-
-def overheat(rpow):
-    &quot;Check for phasers overheating.&quot;
-    if rpow &gt; 1500:
-        checkburn = (rpow-1500.0)*0.00038
-        if withprob(checkburn):
-	    prout(_(&quot;Weapons officer Sulu-  \&quot;Phasers overheated, sir.\&quot;&quot;))
-	    game.damage[DPHASER] = game.damfac* randreal(1.0, 2.0) * (1.0+checkburn)
-
-def checkshctrl(rpow):
-    &quot;Check shield control.&quot;
-    skip(1)
-    if withprob(0.998):
-	prout(_(&quot;Shields lowered.&quot;))
-	return False
-    # Something bad has happened 
-    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-    skip(2)
-    hit = rpow*game.shield/game.inshld
-    game.energy -= rpow+hit*0.8
-    game.shield -= hit*0.2
-    if game.energy &lt;= 0.0:
-	prouts(_(&quot;Sulu-  \&quot;Captain! Shield malf***********************\&quot;&quot;))
-	skip(1)
-	stars()
-	finish(FPHASER)
-	return True
-    prouts(_(&quot;Sulu-  \&quot;Captain! Shield malfunction! Phaser fire contained!\&quot;&quot;))
-    skip(2)
-    prout(_(&quot;Lt. Uhura-  \&quot;Sir, all decks reporting damage.\&quot;&quot;))
-    icas = randrange(int(hit*0.012))
-    skip(1)
-    fry(0.8*hit)
-    if icas:
-	skip(1)
-	prout(_(&quot;McCoy to bridge- \&quot;Severe radiation burns, Jim.&quot;))
-	prout(_(&quot;  %d casualties so far.\&quot;&quot;) % icas)
-	game.casual += icas
-	game.state.crew -= icas
-    skip(1)
-    prout(_(&quot;Phaser energy dispersed by shields.&quot;))
-    prout(_(&quot;Enemy unaffected.&quot;))
-    overheat(rpow)
-    return True;
-
-def hittem(hits):
-    &quot;Register a phaser hit on Klingons and Romulans.&quot;
-    nenhr2 = len(game.enemies); kk=0
-    w = coord()
-    skip(1)
-    for (k, wham) in enumerate(hits):
-	if wham==0:
-	    continue
-	dustfac = randreal(0.9, 1.0)
-	hit = wham*math.pow(dustfac,game.enemies[kk].kdist)
-	kpini = game.enemies[kk].power
-	kp = math.fabs(kpini)
-	if PHASEFAC*hit &lt; kp:
-	    kp = PHASEFAC*hit
-        if game.enemies[kk].power &lt; 0:
-            game.enemies[kk].power -= -kp
-        else:
-            game.enemies[kk].power -= kp
-	kpow = game.enemies[kk].power
-	w = game.enemies[kk].location
-	if hit &gt; 0.005:
-	    if not damaged(DSRSENS):
-		boom(w)
-	    proutn(_(&quot;%d unit hit on &quot;) % int(hit))
-	else:
-	    proutn(_(&quot;Very small hit on &quot;))
-	ienm = game.quad[w.i][w.j]
-	if ienm=='?':
-	    thing.angry = True
-	proutn(crmena(False, ienm, &quot;sector&quot;, w))
-	skip(1)
-	if kpow == 0:
-	    deadkl(w, ienm, w)
-	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
-		finish(FWON);		
-	    if game.alldone:
-		return
-	    kk -= 1	# don't do the increment
-            continue
-	else: # decide whether or not to emasculate klingon 
-	    if kpow&gt;0 and withprob(0.9) and kpow &lt;= randreal(0.4, 0.8)*kpini:
-		prout(_(&quot;***Mr. Spock-  \&quot;Captain, the vessel at Sector %s&quot;)%w)
-		prout(_(&quot;   has just lost its firepower.\&quot;&quot;))
-		game.enemies[kk].power = -kpow
-        kk += 1
-    return
-
-def phasers():
-    &quot;Fire phasers at bad guys.&quot;
-    hits = []
-    kz = 0; k = 1; irec=0 # Cheating inhibitor 
-    ifast = False; no = False; itarg = True; msgflag = True; rpow=0
-    automode = &quot;NOTSET&quot;
-    key=0
-    skip(1)
-    # SR sensors and Computer are needed for automode 
-    if damaged(DSRSENS) or damaged(DCOMPTR):
-	itarg = False
-    if game.condition == &quot;docked&quot;:
-	prout(_(&quot;Phasers can't be fired through base shields.&quot;))
-	scanner.chew()
-	return
-    if damaged(DPHASER):
-	prout(_(&quot;Phaser control damaged.&quot;))
-	scanner.chew()
-	return
-    if game.shldup:
-	if damaged(DSHCTRL):
-	    prout(_(&quot;High speed shield control damaged.&quot;))
-	    scanner.chew()
-	    return
-	if game.energy &lt;= 200.0:
-	    prout(_(&quot;Insufficient energy to activate high-speed shield control.&quot;))
-	    scanner.chew()
-	    return
-	prout(_(&quot;Weapons Officer Sulu-  \&quot;High-speed shield control enabled, sir.\&quot;&quot;))
-	ifast = True
-    # Original code so convoluted, I re-did it all
-    # (That was Tom Almy talking about the C code, I think -- ESR)
-    while automode==&quot;NOTSET&quot;:
-	key=scanner.next()
-	if key == &quot;IHALPHA&quot;:
-	    if scanner.sees(&quot;manual&quot;):
-		if len(game.enemies)==0:
-		    prout(_(&quot;There is no enemy present to select.&quot;))
-		    scanner.chew()
-		    key = &quot;IHEOL&quot;
-		    automode=&quot;AUTOMATIC&quot;
-		else:
-		    automode = &quot;MANUAL&quot;
-		    key = scanner.next()
-	    elif scanner.sees(&quot;automatic&quot;):
-		if (not itarg) and len(game.enemies) != 0:
-		    automode = &quot;FORCEMAN&quot;
-		else:
-		    if len(game.enemies)==0:
-			prout(_(&quot;Energy will be expended into space.&quot;))
-		    automode = &quot;AUTOMATIC&quot;
-		    key = scanner.next()
-	    elif scanner.sees(&quot;no&quot;):
-		no = True
-	    else:
-		huh()
-		return
-	elif key == &quot;IHREAL&quot;:
-	    if len(game.enemies)==0:
-		prout(_(&quot;Energy will be expended into space.&quot;))
-		automode = &quot;AUTOMATIC&quot;
-	    elif not itarg:
-		automode = &quot;FORCEMAN&quot;
-	    else:
-		automode = &quot;AUTOMATIC&quot;
-	else:
-	    # &quot;IHEOL&quot; 
-	    if len(game.enemies)==0:
-		prout(_(&quot;Energy will be expended into space.&quot;))
-		automode = &quot;AUTOMATIC&quot;
-	    elif not itarg:
-		automode = &quot;FORCEMAN&quot;
-	    else: 
-		proutn(_(&quot;Manual or automatic? &quot;))
-                scanner.chew()
-    avail = game.energy
-    if ifast:
-        avail -= 200.0
-    if automode == &quot;AUTOMATIC&quot;:
-	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
-	    no = True
-	    key = scanner.next()
-	if key != &quot;IHREAL&quot; and len(game.enemies) != 0:
-	    prout(_(&quot;Phasers locked on target. Energy available: %.2f&quot;)%avail)
-	irec=0
-        while True:
-	    scanner.chew()
-	    if not kz:
-		for i in range(len(game.enemies)):
-		    irec += math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))*randreal(1.01, 1.06) + 1.0
-	    kz=1
-	    proutn(_(&quot;%d units required. &quot;) % irec)
-	    scanner.chew()
-	    proutn(_(&quot;Units to fire= &quot;))
-	    key = scanner.next()
-	    if key!=&quot;IHREAL&quot;:
-		return
-	    rpow = scanner.real
-	    if rpow &gt; avail:
-		proutn(_(&quot;Energy available= %.2f&quot;) % avail)
-		skip(1)
-		key = &quot;IHEOL&quot;
-            if not rpow &gt; avail:
-                break
-	if rpow&lt;=0:
-	    # chicken out 
-	    scanner.chew()
-	    return
-        key=scanner.next()
-	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
-	    no = True
-	if ifast:
-	    game.energy -= 200; # Go and do it! 
-	    if checkshctrl(rpow):
-		return
-	scanner.chew()
-	game.energy -= rpow
-	extra = rpow
-	if len(game.enemies):
-	    extra = 0.0
-	    powrem = rpow
-	    for i in range(len(game.enemies)):
-		hits.append(0.0)
-		if powrem &lt;= 0:
-		    continue
-		hits[i] = math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))
-		over = randreal(1.01, 1.06) * hits[i]
-		temp = powrem
-		powrem -= hits[i] + over
-		if powrem &lt;= 0 and temp &lt; hits[i]:
-		    hits[i] = temp
-		if powrem &lt;= 0:
-		    over = 0.0
-		extra += over
-	    if powrem &gt; 0.0:
-		extra += powrem
-	    hittem(hits)
-	    game.ididit = True
-	if extra &gt; 0 and not game.alldone:
-	    if game.tholian:
-		proutn(_(&quot;*** Tholian web absorbs &quot;))
-		if len(game.enemies)&gt;0:
-		    proutn(_(&quot;excess &quot;))
-		prout(_(&quot;phaser energy.&quot;))
-	    else:
-		prout(_(&quot;%d expended on empty space.&quot;) % int(extra))
-    elif automode == &quot;FORCEMAN&quot;:
-	scanner.chew()
-	key = &quot;IHEOL&quot;
-	if damaged(DCOMPTR):
-	    prout(_(&quot;Battle computer damaged, manual fire only.&quot;))
-	else:
-	    skip(1)
-	    prouts(_(&quot;---WORKING---&quot;))
-	    skip(1)
-	    prout(_(&quot;Short-range-sensors-damaged&quot;))
-	    prout(_(&quot;Insufficient-data-for-automatic-phaser-fire&quot;))
-	    prout(_(&quot;Manual-fire-must-be-used&quot;))
-	    skip(1)
-    elif automode == &quot;MANUAL&quot;:
-	rpow = 0.0
-        for k in range(len(game.enemies)):
-	    aim = game.enemies[k].location
-	    ienm = game.quad[aim.i][aim.j]
-	    if msgflag:
-		proutn(_(&quot;Energy available= %.2f&quot;) % (avail-0.006))
-		skip(1)
-		msgflag = False
-		rpow = 0.0
-	    if damaged(DSRSENS) and \
-               not game.sector.distance(aim)&lt;2**0.5 and ienm in ('C', 'S'):
-		prout(cramen(ienm) + _(&quot; can't be located without short range scan.&quot;))
-		scanner.chew()
-		key = &quot;IHEOL&quot;
-		hits[k] = 0; # prevent overflow -- thanks to Alexei Voitenko 
-		k += 1
-		continue
-	    if key == &quot;IHEOL&quot;:
-		scanner.chew()
-		if itarg and k &gt; kz:
-		    irec=(abs(game.enemies[k].power)/(PHASEFAC*math.pow(0.9,game.enemies[k].kdist))) *	randreal(1.01, 1.06) + 1.0
-		kz = k
-		proutn(&quot;(&quot;)
-		if not damaged(DCOMPTR):
-		    proutn(&quot;%d&quot; % irec)
-		else:
-		    proutn(&quot;??&quot;)
-		proutn(&quot;)  &quot;)
-		proutn(_(&quot;units to fire at %s-  &quot;) % crmena(False, ienm, &quot;sector&quot;, aim))		
-		key = scanner.next()
-	    if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
-		no = True
-		key = scanner.next()
-		continue
-	    if key == &quot;IHALPHA&quot;:
-		huh()
-		return
-	    if key == &quot;IHEOL&quot;:
-		if k==1: # Let me say I'm baffled by this 
-		    msgflag = True
-		continue
-	    if scanner.real &lt; 0:
-		# abort out 
-		scanner.chew()
-		return
-	    hits[k] = scanner.real
-	    rpow += scanner.real
-	    # If total requested is too much, inform and start over 
-            if rpow &gt; avail:
-		prout(_(&quot;Available energy exceeded -- try again.&quot;))
-		scanner.chew()
-		return
-	    key = scanner.next(); # scan for next value 
-	    k += 1
-	if rpow == 0.0:
-	    # zero energy -- abort 
-	    scanner.chew()
-	    return
-	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
-	    no = True
-	game.energy -= rpow
-	scanner.chew()
-	if ifast:
-	    game.energy -= 200.0
-	    if checkshctrl(rpow):
-		return
-	hittem(hits)
-	game.ididit = True
-     # Say shield raised or malfunction, if necessary 
-    if game.alldone:
-	return
-    if ifast:
-	skip(1)
-	if no == 0:
-	    if withprob(0.01):
-		prout(_(&quot;Sulu-  \&quot;Sir, the high-speed shield control has malfunctioned . . .&quot;))
-		prouts(_(&quot;         CLICK   CLICK   POP  . . .&quot;))
-		prout(_(&quot; No response, sir!&quot;))
-		game.shldup = False
-	    else:
-		prout(_(&quot;Shields raised.&quot;))
-	else:
-	    game.shldup = False
-    overheat(rpow);
-
-# Code from events,c begins here.
-
-# This isn't a real event queue a la BSD Trek yet -- you can only have one 
-# event of each type active at any given time.  Mostly these means we can 
-# only have one FDISTR/FENSLV/FREPRO sequence going at any given time
-# BSD Trek, from which we swiped the idea, can have up to 5.
-
-def unschedule(evtype):
-    &quot;Remove an event from the schedule.&quot;
-    game.future[evtype].date = FOREVER
-    return game.future[evtype]
-
-def is_scheduled(evtype):
-    &quot;Is an event of specified type scheduled.&quot;
-    return game.future[evtype].date != FOREVER
-
-def scheduled(evtype):
-    &quot;When will this event happen?&quot;
-    return game.future[evtype].date
-
-def schedule(evtype, offset):
-    &quot;Schedule an event of specified type.&quot;
-    game.future[evtype].date = game.state.date + offset
-    return game.future[evtype]
-
-def postpone(evtype, offset):
-    &quot;Postpone a scheduled event.&quot;
-    game.future[evtype].date += offset
-
-def cancelrest():
-    &quot;Rest period is interrupted by event.&quot;
-    if game.resting:
-	skip(1)
-	proutn(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
-	if ja() == True:
-	    game.resting = False
-	    game.optime = 0.0
-	    return True
-    return False
-
-def events():
-    &quot;Run through the event queue looking for things to do.&quot;
-    i=0
-    fintim = game.state.date + game.optime; yank=0
-    ictbeam = False; istract = False
-    w = coord(); hold = coord()
-    ev = event(); ev2 = event()
-
-    def tractorbeam(yank):
-        &quot;Tractor-beaming cases merge here.&quot; 
-        announce()
-        game.optime = (10.0/(7.5*7.5))*yank # 7.5 is yank rate (warp 7.5) 
-        skip(1)
-        prout(&quot;***&quot; + crmshp() + _(&quot; caught in long range tractor beam--&quot;))
-        # If Kirk &amp; Co. screwing around on planet, handle 
-        atover(True) # atover(true) is Grab 
-        if game.alldone:
-            return
-        if game.icraft: # Caught in Galileo? 
-            finish(FSTRACTOR)
-            return
-        # Check to see if shuttle is aboard 
-        if game.iscraft == &quot;offship&quot;:
-            skip(1)
-            if withprob(0.5):
-                prout(_(&quot;Galileo, left on the planet surface, is captured&quot;))
-                prout(_(&quot;by aliens and made into a flying McDonald's.&quot;))
-                game.damage[DSHUTTL] = -10
-                game.iscraft = &quot;removed&quot;
-            else:
-                prout(_(&quot;Galileo, left on the planet surface, is well hidden.&quot;))
-        if evcode == FSPY:
-            game.quadrant = game.state.kscmdr
-        else:
-            game.quadrant = game.state.kcmdr[i]
-        game.sector = randplace(QUADSIZE)
-        prout(crmshp() + _(&quot; is pulled to Quadrant %s, Sector %s&quot;) \
-               % (game.quadrant, game.sector))
-        if game.resting:
-            prout(_(&quot;(Remainder of rest/repair period cancelled.)&quot;))
-            game.resting = False
-        if not game.shldup:
-            if not damaged(DSHIELD) and game.shield &gt; 0:
-                doshield(shraise=True) # raise shields 
-                game.shldchg = False
-            else:
-                prout(_(&quot;(Shields not currently useable.)&quot;))
-        newqad()
-        # Adjust finish time to time of tractor beaming 
-        fintim = game.state.date+game.optime
-        attack(torps_ok=False)
-        if not game.state.kcmdr:
-            unschedule(FTBEAM)
-        else: 
-            schedule(FTBEAM, game.optime+expran(1.5*game.intime/len(game.state.kcmdr)))
-
-    def destroybase():
-        &quot;Code merges here for any commander destroying a starbase.&quot; 
-        # Not perfect, but will have to do 
-        # Handle case where base is in same quadrant as starship 
-        if game.battle == game.quadrant:
-            game.state.chart[game.battle.i][game.battle.j].starbase = False
-            game.quad[game.base.i][game.base.j] = '.'
-            game.base.invalidate()
-            newcnd()
-            skip(1)
-            prout(_(&quot;Spock-  \&quot;Captain, I believe the starbase has been destroyed.\&quot;&quot;))
-        elif game.state.baseq and communicating():
-            # Get word via subspace radio 
-            announce()
-            skip(1)
-            prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Command reports that&quot;))
-            proutn(_(&quot;   the starbase in Quadrant %s has been destroyed by&quot;) % game.battle)
-            if game.isatb == 2: 
-                prout(_(&quot;the Klingon Super-Commander&quot;))
-            else:
-                prout(_(&quot;a Klingon Commander&quot;))
-            game.state.chart[game.battle.i][game.battle.j].starbase = False
-        # Remove Starbase from galaxy 
-        game.state.galaxy[game.battle.i][game.battle.j].starbase = False
-        game.state.baseq = filter(lambda x: x != game.battle, game.state.baseq)
-        if game.isatb == 2:
-            # reinstate a commander's base attack 
-            game.battle = hold
-            game.isatb = 0
-        else:
-            game.battle.invalidate()
-    if idebug:
-	prout(&quot;=== EVENTS from %.2f to %.2f:&quot; % (game.state.date, fintim))
-	for i in range(1, NEVENTS):
-	    if   i == FSNOVA:  proutn(&quot;=== Supernova       &quot;)
-	    elif i == FTBEAM:  proutn(&quot;=== T Beam          &quot;)
-	    elif i == FSNAP:   proutn(&quot;=== Snapshot        &quot;)
-	    elif i == FBATTAK: proutn(&quot;=== Base Attack     &quot;)
-	    elif i == FCDBAS:  proutn(&quot;=== Base Destroy    &quot;)
-	    elif i == FSCMOVE: proutn(&quot;=== SC Move         &quot;)
-	    elif i == FSCDBAS: proutn(&quot;=== SC Base Destroy &quot;)
-	    elif i == FDSPROB: proutn(&quot;=== Probe Move      &quot;)
-	    elif i == FDISTR:  proutn(&quot;=== Distress Call   &quot;)
-	    elif i == FENSLV:  proutn(&quot;=== Enslavement     &quot;)
-	    elif i == FREPRO:  proutn(&quot;=== Klingon Build   &quot;)
-	    if is_scheduled(i):
-		prout(&quot;%.2f&quot; % (scheduled(i)))
-	    else:
-		prout(&quot;never&quot;)
-    radio_was_broken = damaged(DRADIO)
-    hold.i = hold.j = 0
-    while True:
-	# Select earliest extraneous event, evcode==0 if no events 
-	evcode = FSPY
-	if game.alldone:
-	    return
-	datemin = fintim
-	for l in range(1, NEVENTS):
-	    if game.future[l].date &lt; datemin:
-		evcode = l
-		if idebug:
-		    prout(&quot;== Event %d fires&quot; % evcode)
-		datemin = game.future[l].date
-	xtime = datemin-game.state.date
-	game.state.date = datemin
-	# Decrement Federation resources and recompute remaining time 
-	game.state.remres -= (game.state.remkl+4*len(game.state.kcmdr))*xtime
-        game.recompute()
-	if game.state.remtime &lt;=0:
-	    finish(FDEPLETE)
-	    return
-	# Any crew left alive? 
-	if game.state.crew &lt;=0:
-	    finish(FCREW)
-	    return
-	# Is life support adequate? 
-	if damaged(DLIFSUP) and game.condition != &quot;docked&quot;:
-	    if game.lsupres &lt; xtime and game.damage[DLIFSUP] &gt; game.lsupres:
-		finish(FLIFESUP)
-		return
-	    game.lsupres -= xtime
-	    if game.damage[DLIFSUP] &lt;= xtime:
-		game.lsupres = game.inlsr
-	# Fix devices 
-	repair = xtime
-	if game.condition == &quot;docked&quot;:
-	    repair /= DOCKFAC
-	# Don't fix Deathray here 
-	for l in range(NDEVICES):
-	    if game.damage[l] &gt; 0.0 and l != DDRAY:
-                if game.damage[l]-repair &gt; 0.0:
-                    game.damage[l] -= repair
-                else:
-                    game.damage[l] = 0.0
-	# If radio repaired, update star chart and attack reports 
-	if radio_was_broken and not damaged(DRADIO):
-	    prout(_(&quot;Lt. Uhura- \&quot;Captain, the sub-space radio is working and&quot;))
-	    prout(_(&quot;   surveillance reports are coming in.&quot;))
-	    skip(1)
-	    if not game.iseenit:
-		attackreport(False)
-		game.iseenit = True
-	    rechart()
-	    prout(_(&quot;   The star chart is now up to date.\&quot;&quot;))
-	    skip(1)
-	# Cause extraneous event EVCODE to occur 
-	game.optime -= xtime
-	if evcode == FSNOVA: # Supernova 
-	    announce()
-	    supernova(None)
-	    schedule(FSNOVA, expran(0.5*game.intime))
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		return
-	elif evcode == FSPY: # Check with spy to see if SC should tractor beam 
-	    if game.state.nscrem == 0 or \
-		ictbeam or istract or \
-                game.condition==&quot;docked&quot; or game.isatb==1 or game.iscate:
-		return
-	    if game.ientesc or \
-		(game.energy&lt;2000 and game.torps&lt;4 and game.shield &lt; 1250) or \
-		(damaged(DPHASER) and (damaged(DPHOTON) or game.torps&lt;4)) or \
-		(damaged(DSHIELD) and \
-		 (game.energy &lt; 2500 or damaged(DPHASER)) and \
-                 (game.torps &lt; 5 or damaged(DPHOTON))):
-		# Tractor-beam her! 
-		istract = ictbeam = True
-                tractorbeam((game.state.kscmdr-game.quadrant).distance())
-	    else:
-		return
-	elif evcode == FTBEAM: # Tractor beam 
-            if not game.state.kcmdr:
-                unschedule(FTBEAM)
-                continue
-            i = randrange(len(game.state.kcmdr))
-            yank = (game.state.kcmdr[i]-game.quadrant).distance()
-            if istract or game.condition == &quot;docked&quot; or yank == 0:
-                # Drats! Have to reschedule 
-                schedule(FTBEAM, 
-                         game.optime + expran(1.5*game.intime/len(game.state.kcmdr)))
-                continue
-            ictbeam = True
-            tractorbeam(yank)
-	elif evcode == FSNAP: # Snapshot of the universe (for time warp) 
-	    game.snapsht = copy.deepcopy(game.state)
-	    game.state.snap = True
-	    schedule(FSNAP, expran(0.5 * game.intime))
-	elif evcode == FBATTAK: # Commander attacks starbase 
-	    if not game.state.kcmdr or not game.state.baseq:
-		# no can do 
-		unschedule(FBATTAK)
-		unschedule(FCDBAS)
-                continue
-            try:
-                for ibq in game.state.baseq:
-                   for cmdr in game.state.kcmdr: 
-                       if ibq == cmdr and ibq != game.quadrant and ibq != game.state.kscmdr:
-                           raise ibq
-                else:
-                    # no match found -- try later 
-                    schedule(FBATTAK, expran(0.3*game.intime))
-                    unschedule(FCDBAS)
-                    continue
-            except coord:
-                pass
-	    # commander + starbase combination found -- launch attack 
-	    game.battle = ibq
-	    schedule(FCDBAS, randreal(1.0, 4.0))
-	    if game.isatb: # extra time if SC already attacking 
-		postpone(FCDBAS, scheduled(FSCDBAS)-game.state.date)
-	    game.future[FBATTAK].date = game.future[FCDBAS].date + expran(0.3*game.intime)
-	    game.iseenit = False
-            if not communicating():
-		continue # No warning :-( 
-	    game.iseenit = True
-	    announce()
-	    skip(1)
-	    prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) % game.battle)
-	    prout(_(&quot;   reports that it is under attack and that it can&quot;))
-	    prout(_(&quot;   hold out only until stardate %d.\&quot;&quot;) % (int(scheduled(FCDBAS))))
-	    if cancelrest():
-                return
-	elif evcode == FSCDBAS: # Supercommander destroys base 
-	    unschedule(FSCDBAS)
-	    game.isatb = 2
-	    if not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].starbase: 
-		continue # WAS RETURN! 
-	    hold = game.battle
-	    game.battle = game.state.kscmdr
-	    destroybase()
-	elif evcode == FCDBAS: # Commander succeeds in destroying base 
-	    if evcode==FCDBAS:
-		unschedule(FCDBAS)
-                if not game.state.baseq() \
-                       or not game.state.galaxy[game.battle.i][game.battle.j].starbase:
-		    game.battle.invalidate()
-                    continue
-		# find the lucky pair 
-		for cmdr in game.state.kcmdr:
-		    if cmdr == game.battle: 
-			break
-                else:
-		    # No action to take after all 
-		    continue
-            destroybase()
-	elif evcode == FSCMOVE: # Supercommander moves 
-	    schedule(FSCMOVE, 0.2777)
-	    if not game.ientesc and not istract and game.isatb != 1 and \
-                   (not game.iscate or not game.justin): 
-		supercommander()
-	elif evcode == FDSPROB: # Move deep space probe 
-	    schedule(FDSPROB, 0.01)
-            if not game.probe.next():
-		if not game.probe.quadrant().valid_quadrant() or \
-		    game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j].supernova:
-		    # Left galaxy or ran into supernova
-                    if communicating():
-			announce()
-			skip(1)
-			proutn(_(&quot;Lt. Uhura-  \&quot;The deep space probe &quot;))
-			if not game.probe.quadrant().valid_quadrant():
-			    prout(_(&quot;has left the galaxy.\&quot;&quot;))
-			else:
-			    prout(_(&quot;is no longer transmitting.\&quot;&quot;))
-		    unschedule(FDSPROB)
-		    continue
-                if communicating():
-		    #announce()
-		    skip(1)
-		    prout(_(&quot;Lt. Uhura-  \&quot;The deep space probe is now in Quadrant %s.\&quot;&quot;) % game.probe.quadrant())
-	    pdest = game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j]
-	    if communicating():
-		chp = game.state.chart[game.probe.quadrant().i][game.probe.quadrant().j]
-		chp.klingons = pdest.klingons
-		chp.starbase = pdest.starbase
-		chp.stars = pdest.stars
-		pdest.charted = True
-	    game.probe.moves -= 1 # One less to travel
-	    if game.probe.arrived() and game.isarmed and pdest.stars:
-		supernova(game.probe)		# fire in the hole!
-		unschedule(FDSPROB)
-		if game.state.galaxy[game.quadrant().i][game.quadrant().j].supernova: 
-		    return
-	elif evcode == FDISTR: # inhabited system issues distress call 
-	    unschedule(FDISTR)
-	    # try a whole bunch of times to find something suitable 
-            for i in range(100):
-		# need a quadrant which is not the current one,
-		# which has some stars which are inhabited and
-		# not already under attack, which is not
-		# supernova'ed, and which has some Klingons in it
-		w = randplace(GALSIZE)
-		q = game.state.galaxy[w.i][w.j]
-                if not (game.quadrant == w or q.planet == None or \
-		      not q.planet.inhabited or \
-		      q.supernova or q.status!=&quot;secure&quot; or q.klingons&lt;=0):
-                    break
-            else:
-		# can't seem to find one; ignore this call 
-		if idebug:
-		    prout(&quot;=== Couldn't find location for distress event.&quot;)
-		continue
-	    # got one!!  Schedule its enslavement 
-	    ev = schedule(FENSLV, expran(game.intime))
-	    ev.quadrant = w
-	    q.status = &quot;distressed&quot;
-	    # tell the captain about it if we can 
-	    if communicating():
-		prout(_(&quot;Uhura- Captain, %s in Quadrant %s reports it is under attack&quot;) \
-                        % (q.planet, `w`))
-		prout(_(&quot;by a Klingon invasion fleet.&quot;))
-		if cancelrest():
-		    return
-	elif evcode == FENSLV:		# starsystem is enslaved 
-	    ev = unschedule(FENSLV)
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
-	    if q.klingons &lt;= 0:
-		q.status = &quot;secure&quot;
-		continue
-	    q.status = &quot;enslaved&quot;
-
-	    # play stork and schedule the first baby 
-	    ev2 = schedule(FREPRO, expran(2.0 * game.intime))
-	    ev2.quadrant = ev.quadrant
-
-	    # report the disaster if we can 
-	    if communicating():
-		prout(_(&quot;Uhura- We've lost contact with starsystem %s&quot;) % \
-                        q.planet)
-		prout(_(&quot;in Quadrant %s.\n&quot;) % ev.quadrant)
-	elif evcode == FREPRO:		# Klingon reproduces 
-	    # If we ever switch to a real event queue, we'll need to
-	    # explicitly retrieve and restore the x and y.
-	    ev = schedule(FREPRO, expran(1.0 * game.intime))
-	    # see if current distress call still active 
-	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
-	    if q.klingons &lt;= 0:
-		q.status = &quot;secure&quot;
-		continue
-	    if game.state.remkl &gt;=MAXKLGAME:
-		continue		# full right now 
-	    # reproduce one Klingon 
-	    w = ev.quadrant
-            m = coord()
-	    if game.klhere &gt;= MAXKLQUAD:
-                try:
-                    # this quadrant not ok, pick an adjacent one 
-                    for m.i in range(w.i - 1, w.i + 2):
-                        for m.j in range(w.j - 1, w.j + 2):
-                            if not m.valid_quadrant():
-                                continue
-                            q = game.state.galaxy[m.i][m.j]
-                            # check for this quad ok (not full &amp; no snova) 
-                            if q.klingons &gt;= MAXKLQUAD or q.supernova:
-                                continue
-                            raise &quot;FOUNDIT&quot;
-                    else:
-                        continue	# search for eligible quadrant failed
-                except &quot;FOUNDIT&quot;:
-                    w = m
-	    # deliver the child 
-	    game.state.remkl += 1
-	    q.klingons += 1
-	    if game.quadrant == w:
-                game.klhere += 1
-		game.enemies.append(newkling())
-	    # recompute time left
-            game.recompute()
-	    if communicating():
-		if game.quadrant == w:
-		    prout(_(&quot;Spock- sensors indicate the Klingons have&quot;))
-		    prout(_(&quot;launched a warship from %s.&quot;) % q.planet)
-		else:
-		    prout(_(&quot;Uhura- Starfleet reports increased Klingon activity&quot;))
-		    if q.planet != None:
-			proutn(_(&quot;near %s &quot;) % q.planet)
-		    prout(_(&quot;in Quadrant %s.&quot;) % w)
-				
-def wait():
-    &quot;Wait on events.&quot;
-    game.ididit = False
-    while True:
-	key = scanner.next()
-	if key  != &quot;IHEOL&quot;:
-	    break
-	proutn(_(&quot;How long? &quot;))
-    scanner.chew()
-    if key != &quot;IHREAL&quot;:
-	huh()
-	return
-    origTime = delay = scanner.real
-    if delay &lt;= 0.0:
-	return
-    if delay &gt;= game.state.remtime or len(game.enemies) != 0:
-	proutn(_(&quot;Are you sure? &quot;))
-	if ja() == False:
-	    return
-    # Alternate resting periods (events) with attacks 
-    game.resting = True
-    while True:
-	if delay &lt;= 0:
-	    game.resting = False
-	if not game.resting:
-	    prout(_(&quot;%d stardates left.&quot;) % int(game.state.remtime))
-	    return
-	temp = game.optime = delay
-	if len(game.enemies):
-	    rtime = randreal(1.0, 2.0)
-	    if rtime &lt; temp:
-		temp = rtime
-	    game.optime = temp
-	if game.optime &lt; delay:
-	    attack(torps_ok=False)
-	if game.alldone:
-	    return
-	events()
-	game.ididit = True
-	if game.alldone:
-	    return
-	delay -= temp
-	# Repair Deathray if long rest at starbase 
-	if origTime-delay &gt;= 9.99 and game.condition == &quot;docked&quot;:
-	    game.damage[DDRAY] = 0.0
-	# leave if quadrant supernovas
-        if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            break
-    game.resting = False
-    game.optime = 0
-
-def nova(nov):
-    &quot;Star goes nova.&quot; 
-    course = (0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5)
-    newc = coord(); neighbor = coord(); bump = coord(0, 0)
-    if withprob(0.05):
-	# Wow! We've supernova'ed 
-	supernova(game.quadrant)
-	return
-    # handle initial nova 
-    game.quad[nov.i][nov.j] = '.'
-    prout(crmena(False, '*', &quot;sector&quot;, nov) + _(&quot; novas.&quot;))
-    game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
-    game.state.starkl += 1
-    # Set up queue to recursively trigger adjacent stars 
-    hits = [nov]
-    kount = 0
-    while hits:
-        offset = coord()
-        start = hits.pop()
-        for offset.i in range(-1, 1+1):
-            for offset.j in range(-1, 1+1):
-                if offset.j==0 and offset.i==0:
-                    continue
-                neighbor = start + offset
-                if not neighbor.valid_sector():
-                    continue
-                iquad = game.quad[neighbor.i][neighbor.j]
-                # Empty space ends reaction
-                if iquad in ('.', '?', ' ', 'T', '#'):
-                    pass
-                elif iquad == '*': # Affect another star 
-                    if withprob(0.05):
-                        # This star supernovas 
-                        supernova(game.quadrant)
-                        return
-                    else:
-                        hits.append(neighbor)
-			game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
-			game.state.starkl += 1
-			proutn(crmena(True, '*', &quot;sector&quot;, neighbor))
-			prout(_(&quot; novas.&quot;))
-                        game.quad[neighbor.i][neighbor.j] = '.'
-                        kount += 1
-                elif iquad in ('P', '@'): # Destroy planet 
-                    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
-                    if iquad == 'P':
-                        game.state.nplankl += 1
-                    else:
-                        game.state.worldkl += 1
-                    prout(crmena(True, 'B', &quot;sector&quot;, neighbor) + _(&quot; destroyed.&quot;))
-                    game.iplnet.pclass = &quot;destroyed&quot;
-                    game.iplnet = None
-                    game.plnet.invalidate()
-                    if game.landed:
-                        finish(FPNOVA)
-                        return
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                elif iquad == 'B': # Destroy base 
-                    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase = False
-                    game.state.baseq = filter(lambda x: x!= game.quadrant, game.state.baseq)
-                    game.base.invalidate()
-                    game.state.basekl += 1
-                    newcnd()
-                    prout(crmena(True, 'B', &quot;sector&quot;, neighbor) + _(&quot; destroyed.&quot;))
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                elif iquad in ('E', 'F'): # Buffet ship 
-                    prout(_(&quot;***Starship buffeted by nova.&quot;))
-                    if game.shldup:
-                        if game.shield &gt;= 2000.0:
-                            game.shield -= 2000.0
-                        else:
-                            diff = 2000.0 - game.shield
-                            game.energy -= diff
-                            game.shield = 0.0
-                            game.shldup = False
-                            prout(_(&quot;***Shields knocked out.&quot;))
-                            game.damage[DSHIELD] += 0.005*game.damfac*randreal()*diff
-                    else:
-                        game.energy -= 2000.0
-                    if game.energy &lt;= 0:
-                        finish(FNOVA)
-                        return
-                    # add in course nova contributes to kicking starship
-                    bump += (game.sector-hits[mm]).sgn()
-                elif iquad == 'K': # kill klingon 
-                    deadkl(neighbor, iquad, neighbor)
-                elif iquad in ('C','S','R'): # Damage/destroy big enemies 
-                    for ll in range(len(game.enemies)):
-                        if game.enemies[ll].location == neighbor:
-                            break
-                    game.enemies[ll].power -= 800.0 # If firepower is lost, die 
-                    if game.enemies[ll].power &lt;= 0.0:
-                        deadkl(neighbor, iquad, neighbor)
-                        break
-                    newc = neighbor + neighbor - hits[mm]
-                    proutn(crmena(True, iquad, &quot;sector&quot;, neighbor) + _(&quot; damaged&quot;))
-                    if not newc.valid_sector():
-                        # can't leave quadrant 
-                        skip(1)
-                        break
-                    iquad1 = game.quad[newc.i][newc.j]
-                    if iquad1 == ' ':
-                        proutn(_(&quot;, blasted into &quot;) + crmena(False, ' ', &quot;sector&quot;, newc))
-                        skip(1)
-                        deadkl(neighbor, iquad, newc)
-                        break
-                    if iquad1 != '.':
-                        # can't move into something else 
-                        skip(1)
-                        break
-                    proutn(_(&quot;, buffeted to Sector %s&quot;) % newc)
-                    game.quad[neighbor.i][neighbor.j] = '.'
-                    game.quad[newc.i][newc.j] = iquad
-                    game.enemies[ll].move(newc)
-    # Starship affected by nova -- kick it away. 
-    dist = kount*0.1
-    direc = course[3*(bump.i+1)+bump.j+2]
-    if direc == 0.0:
-	dist = 0.0
-    if dist == 0.0:
-	return
-    course = course(bearing=direc, distance=dist)
-    game.optime = course.time(warp=4)
-    skip(1)
-    prout(_(&quot;Force of nova displaces starship.&quot;))
-    imove(course, noattack=True)
-    game.optime = course.time(warp=4)
-    return
-	
-def supernova(w):
-    &quot;Star goes supernova.&quot;
-    num = 0; npdead = 0
-    if w != None: 
-	nq = copy.copy(w)
-    else:
-	# Scheduled supernova -- select star at random. 
-	stars = 0
-        nq = coord()
-	for nq.i in range(GALSIZE):
-	    for nq.j in range(GALSIZE):
-		stars += game.state.galaxy[nq.i][nq.j].stars
-	if stars == 0:
-	    return # nothing to supernova exists 
-	num = randrange(stars) + 1
-	for nq.i in range(GALSIZE):
-	    for nq.j in range(GALSIZE):
-		num -= game.state.galaxy[nq.i][nq.j].stars
-		if num &lt;= 0:
-		    break
-	    if num &lt;=0:
-		break
-	if idebug:
-	    proutn(&quot;=== Super nova here?&quot;)
-	    if ja() == True:
-		nq = game.quadrant
-    if not nq == game.quadrant or game.justin:
-	# it isn't here, or we just entered (treat as enroute) 
-	if communicating():
-	    skip(1)
-	    prout(_(&quot;Message from Starfleet Command       Stardate %.2f&quot;) % game.state.date)
-	    prout(_(&quot;     Supernova in Quadrant %s; caution advised.&quot;) % nq)
-    else:
-	ns = coord()
-	# we are in the quadrant! 
-	num = randrange(game.state.galaxy[nq.i][nq.j].stars) + 1
-	for ns.i in range(QUADSIZE):
-	    for ns.j in range(QUADSIZE):
-		if game.quad[ns.i][ns.j]=='*':
-		    num -= 1
-		    if num==0:
-			break
-	    if num==0:
-		break
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	skip(1)
-	prout(_(&quot;***Incipient supernova detected at Sector %s&quot;) % ns)
-	if (ns.i-game.sector.i)**2 + (ns.j-game.sector.j)**2 &lt;= 2.1:
-	    proutn(_(&quot;Emergency override attempts t&quot;))
-	    prouts(&quot;***************&quot;)
-	    skip(1)
-	    stars()
-	    game.alldone = True
-    # destroy any Klingons in supernovaed quadrant
-    kldead = game.state.galaxy[nq.i][nq.j].klingons
-    game.state.galaxy[nq.i][nq.j].klingons = 0
-    if nq == game.state.kscmdr:
-	# did in the Supercommander! 
-	game.state.nscrem = game.state.kscmdr.i = game.state.kscmdr.j = game.isatb =  0
-	game.iscate = False
-	unschedule(FSCMOVE)
-	unschedule(FSCDBAS)
-    survivors = filter(lambda w: w != nq, game.state.kcmdr)
-    comkills = len(game.state.kcmdr) - len(survivors)
-    game.state.kcmdr = survivors
-    kldead -= comkills
-    if not game.state.kcmdr:
-        unschedule(FTBEAM)
-    game.state.remkl -= kldead
-    # destroy Romulans and planets in supernovaed quadrant 
-    nrmdead = game.state.galaxy[nq.i][nq.j].romulans
-    game.state.galaxy[nq.i][nq.j].romulans = 0
-    game.state.nromrem -= nrmdead
-    # Destroy planets 
-    for loop in range(game.inplan):
-	if game.state.planets[loop].quadrant == nq:
-	    game.state.planets[loop].pclass = &quot;destroyed&quot;
-	    npdead += 1
-    # Destroy any base in supernovaed quadrant
-    game.state.baseq = filter(lambda x: x != nq, game.state.baseq)
-    # If starship caused supernova, tally up destruction 
-    if w != None:
-	game.state.starkl += game.state.galaxy[nq.i][nq.j].stars
-	game.state.basekl += game.state.galaxy[nq.i][nq.j].starbase
-	game.state.nplankl += npdead
-    # mark supernova in galaxy and in star chart 
-    if game.quadrant == nq or communicating():
-	game.state.galaxy[nq.i][nq.j].supernova = True
-    # If supernova destroys last Klingons give special message 
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0 and not nq == game.quadrant:
-	skip(2)
-	if w == None:
-	    prout(_(&quot;Lucky you!&quot;))
-	proutn(_(&quot;A supernova in %s has just destroyed the last Klingons.&quot;) % nq)
-	finish(FWON)
-	return
-    # if some Klingons remain, continue or die in supernova 
-    if game.alldone:
-	finish(FSNOVAED)
-    return
-
-# Code from finish.c ends here.
-
-def selfdestruct():
-    &quot;Self-destruct maneuver. Finish with a BANG!&quot; 
-    scanner.chew()
-    if damaged(DCOMPTR):
-	prout(_(&quot;Computer damaged; cannot execute destruct sequence.&quot;))
-	return
-    prouts(_(&quot;---WORKING---&quot;)); skip(1)
-    prouts(_(&quot;SELF-DESTRUCT-SEQUENCE-ACTIVATED&quot;)); skip(1)
-    prouts(&quot;   10&quot;); skip(1)
-    prouts(&quot;       9&quot;); skip(1)
-    prouts(&quot;          8&quot;); skip(1)
-    prouts(&quot;             7&quot;); skip(1)
-    prouts(&quot;                6&quot;); skip(1)
-    skip(1)
-    prout(_(&quot;ENTER-CORRECT-PASSWORD-TO-CONTINUE-&quot;))
-    skip(1)
-    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-OTHERWISE-&quot;))
-    skip(1)
-    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED&quot;))
-    skip(1)
-    scanner.next()
-    scanner.chew()
-    if game.passwd != scanner.token:
-	prouts(_(&quot;PASSWORD-REJECTED;&quot;))
-	skip(1)
-	prouts(_(&quot;CONTINUITY-EFFECTED&quot;))
-	skip(2)
-	return
-    prouts(_(&quot;PASSWORD-ACCEPTED&quot;)); skip(1)
-    prouts(&quot;                   5&quot;); skip(1)
-    prouts(&quot;                      4&quot;); skip(1)
-    prouts(&quot;                         3&quot;); skip(1)
-    prouts(&quot;                            2&quot;); skip(1)
-    prouts(&quot;                              1&quot;); skip(1)
-    if withprob(0.15):
-	prouts(_(&quot;GOODBYE-CRUEL-WORLD&quot;))
-	skip(1)
-    kaboom()
-
-def kaboom():
-    stars()
-    if game.ship=='E':
-	prouts(&quot;***&quot;)
-    prouts(_(&quot;********* Entropy of %s maximized *********&quot;) % crmshp())
-    skip(1)
-    stars()
-    skip(1)
-    if len(game.enemies) != 0:
-	whammo = 25.0 * game.energy
-	l=1
-	while l &lt;= len(game.enemies):
-	    if game.enemies[l].power*game.enemies[l].kdist &lt;= whammo: 
-		deadkl(game.enemies[l].location, game.quad[game.enemies[l].location.i][game.enemies[l].location.j], game.enemies[l].location)
-	    l += 1
-    finish(FDILITHIUM)
-				
-def killrate():
-    &quot;Compute our rate of kils over time.&quot;
-    elapsed = game.state.date - game.indate
-    if elapsed == 0:	# Avoid divide-by-zero error if calculated on turn 0
-        return 0
-    else:
-        starting = (game.inkling + game.incom + game.inscom)
-        remaining = (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)
-        return (starting - remaining)/elapsed
-
-def badpoints():
-    &quot;Compute demerits.&quot;
-    badpt = 5.0*game.state.starkl + \
-            game.casual + \
-            10.0*game.state.nplankl + \
-            300*game.state.nworldkl + \
-            45.0*game.nhelp +\
-            100.0*game.state.basekl +\
-            3.0*game.abandoned
-    if game.ship == 'F':
-        badpt += 100.0
-    elif game.ship == None:
-        badpt += 200.0
-    return badpt
-
-def finish(ifin):
-    # end the game, with appropriate notfications 
-    igotit = False
-    game.alldone = True
-    skip(3)
-    prout(_(&quot;It is stardate %.1f.&quot;) % game.state.date)
-    skip(1)
-    if ifin == FWON: # Game has been won
-	if game.state.nromrem != 0:
-	    prout(_(&quot;The remaining %d Romulans surrender to Starfleet Command.&quot;) %
-		  game.state.nromrem)
-
-	prout(_(&quot;You have smashed the Klingon invasion fleet and saved&quot;))
-	prout(_(&quot;the Federation.&quot;))
-	game.gamewon = True
-	if game.alive:
-            badpt = badpoints()
-            if badpt &lt; 100.0:
-                badpt = 0.0	# Close enough!
-            # killsPerDate &gt;= RateMax
-	    if game.state.date-game.indate &lt; 5.0 or \
-                killrate() &gt;= 0.1*game.skill*(game.skill+1.0) + 0.1 + 0.008*badpt:
-		skip(1)
-		prout(_(&quot;In fact, you have done so well that Starfleet Command&quot;))
-		if game.skill == SKILL_NOVICE:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Novice\&quot; to \&quot;Fair\&quot;.&quot;))
-		elif game.skill == SKILL_FAIR:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Fair\&quot; to \&quot;Good\&quot;.&quot;))
-		elif game.skill == SKILL_GOOD:
-		    prout(_(&quot;promotes you one step in rank from \&quot;Good\&quot; to \&quot;Expert\&quot;.&quot;))
-		elif game.skill == SKILL_EXPERT:
-		    prout(_(&quot;promotes you to Commodore Emeritus.&quot;))
-		    skip(1)
-		    prout(_(&quot;Now that you think you're really good, try playing&quot;))
-		    prout(_(&quot;the \&quot;Emeritus\&quot; game. It will splatter your ego.&quot;))
-		elif game.skill == SKILL_EMERITUS:
-		    skip(1)
-		    proutn(_(&quot;Computer-  &quot;))
-		    prouts(_(&quot;ERROR-ERROR-ERROR-ERROR&quot;))
-		    skip(2)
-		    prouts(_(&quot;  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
-		    skip(1)
-		    prouts(_(&quot;  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI&quot;))
-		    skip(2)
-		    prout(_(&quot;Now you can retire and write your own Star Trek game!&quot;))
-		    skip(1)
-		elif game.skill &gt;= SKILL_EXPERT:
-		    if game.thawed and not idebug:
-			prout(_(&quot;You cannot get a citation, so...&quot;))
-		    else:
-			proutn(_(&quot;Do you want your Commodore Emeritus Citation printed? &quot;))
-			scanner.chew()
-			if ja() == True:
-			    igotit = True
-	    # Only grant long life if alive (original didn't!)
-	    skip(1)
-	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
-	score()
-	if igotit:
-	    plaque()	    
-	return
-    elif ifin == FDEPLETE: # Federation Resources Depleted
-	prout(_(&quot;Your time has run out and the Federation has been&quot;))
-	prout(_(&quot;conquered.  Your starship is now Klingon property,&quot;))
-	prout(_(&quot;and you are put on trial as a war criminal.  On the&quot;))
-	proutn(_(&quot;basis of your record, you are &quot;))
-	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)*3.0 &gt; (game.inkling + game.incom + game.inscom):
-	    prout(_(&quot;acquitted.&quot;))
-	    skip(1)
-	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
-	else:
-	    prout(_(&quot;found guilty and&quot;))
-	    prout(_(&quot;sentenced to death by slow torture.&quot;))
-	    game.alive = False
-	score()
-	return
-    elif ifin == FLIFESUP:
-	prout(_(&quot;Your life support reserves have run out, and&quot;))
-	prout(_(&quot;you die of thirst, starvation, and asphyxiation.&quot;))
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FNRG:
-	prout(_(&quot;Your energy supply is exhausted.&quot;))
-	skip(1)
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FBATTLE:
-	prout(_(&quot;The %s has been destroyed in battle.&quot;) % crmshp())
-	skip(1)
-	prout(_(&quot;Dulce et decorum est pro patria mori.&quot;))
-    elif ifin == FNEG3:
-	prout(_(&quot;You have made three attempts to cross the negative energy&quot;))
-	prout(_(&quot;barrier which surrounds the galaxy.&quot;))
-	skip(1)
-	prout(_(&quot;Your navigation is abominable.&quot;))
-	score()
-    elif ifin == FNOVA:
-	prout(_(&quot;Your starship has been destroyed by a nova.&quot;))
-	prout(_(&quot;That was a great shot.&quot;))
-	skip(1)
-    elif ifin == FSNOVAED:
-	prout(_(&quot;The %s has been fried by a supernova.&quot;) % crmshp())
-	prout(_(&quot;...Not even cinders remain...&quot;))
-    elif ifin == FABANDN:
-	prout(_(&quot;You have been captured by the Klingons. If you still&quot;))
-	prout(_(&quot;had a starbase to be returned to, you would have been&quot;))
-	prout(_(&quot;repatriated and given another chance. Since you have&quot;))
-	prout(_(&quot;no starbases, you will be mercilessly tortured to death.&quot;))
-    elif ifin == FDILITHIUM:
-	prout(_(&quot;Your starship is now an expanding cloud of subatomic particles&quot;))
-    elif ifin == FMATERIALIZE:
-	prout(_(&quot;Starbase was unable to re-materialize your starship.&quot;))
-	prout(_(&quot;Sic transit gloria mundi&quot;))
-    elif ifin == FPHASER:
-	prout(_(&quot;The %s has been cremated by its own phasers.&quot;) % crmshp())
-    elif ifin == FLOST:
-	prout(_(&quot;You and your landing party have been&quot;))
-	prout(_(&quot;converted to energy, disipating through space.&quot;))
-    elif ifin == FMINING:
-	prout(_(&quot;You are left with your landing party on&quot;))
-	prout(_(&quot;a wild jungle planet inhabited by primitive cannibals.&quot;))
-	skip(1)
-	prout(_(&quot;They are very fond of \&quot;Captain Kirk\&quot; soup.&quot;))
-	skip(1)
-	prout(_(&quot;Without your leadership, the %s is destroyed.&quot;) % crmshp())
-    elif ifin == FDPLANET:
-	prout(_(&quot;You and your mining party perish.&quot;))
-	skip(1)
-	prout(_(&quot;That was a great shot.&quot;))
-	skip(1)
-    elif ifin == FSSC:
-	prout(_(&quot;The Galileo is instantly annihilated by the supernova.&quot;))
-	prout(_(&quot;You and your mining party are atomized.&quot;))
-	skip(1)
-	prout(_(&quot;Mr. Spock takes command of the %s and&quot;) % crmshp())
-	prout(_(&quot;joins the Romulans, wreaking terror on the Federation.&quot;))
-    elif ifin == FPNOVA:
-	prout(_(&quot;You and your mining party are atomized.&quot;))
-	skip(1)
-	prout(_(&quot;Mr. Spock takes command of the %s and&quot;) % crmshp())
-	prout(_(&quot;joins the Romulans, wreaking terror on the Federation.&quot;))
-    elif ifin == FSTRACTOR:
-	prout(_(&quot;The shuttle craft Galileo is also caught,&quot;))
-	prout(_(&quot;and breaks up under the strain.&quot;))
-	skip(1)
-	prout(_(&quot;Your debris is scattered for millions of miles.&quot;))
-	prout(_(&quot;Without your leadership, the %s is destroyed.&quot;) % crmshp())
-    elif ifin == FDRAY:
-	prout(_(&quot;The mutants attack and kill Spock.&quot;))
-	prout(_(&quot;Your ship is captured by Klingons, and&quot;))
-	prout(_(&quot;your crew is put on display in a Klingon zoo.&quot;))
-    elif ifin == FTRIBBLE:
-	prout(_(&quot;Tribbles consume all remaining water,&quot;))
-	prout(_(&quot;food, and oxygen on your ship.&quot;))
-	skip(1)
-	prout(_(&quot;You die of thirst, starvation, and asphyxiation.&quot;))
-	prout(_(&quot;Your starship is a derelict in space.&quot;))
-    elif ifin == FHOLE:
-	prout(_(&quot;Your ship is drawn to the center of the black hole.&quot;))
-	prout(_(&quot;You are crushed into extremely dense matter.&quot;))
-    elif ifin == FCREW:
-	prout(_(&quot;Your last crew member has died.&quot;))
-    if game.ship == 'F':
-	game.ship = None
-    elif game.ship == 'E':
-	game.ship = 'F'
-    game.alive = False
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0:
-	goodies = game.state.remres/game.inresor
-	baddies = (game.state.remkl + 2.0*len(game.state.kcmdr))/(game.inkling+2.0*game.incom)
-	if goodies/baddies &gt;= randreal(1.0, 1.5):
-	    prout(_(&quot;As a result of your actions, a treaty with the Klingon&quot;))
-	    prout(_(&quot;Empire has been signed. The terms of the treaty are&quot;))
-	    if goodies/baddies &gt;= randreal(3.0):
-		prout(_(&quot;favorable to the Federation.&quot;))
-		skip(1)
-		prout(_(&quot;Congratulations!&quot;))
-	    else:
-		prout(_(&quot;highly unfavorable to the Federation.&quot;))
-	else:
-	    prout(_(&quot;The Federation will be destroyed.&quot;))
-    else:
-	prout(_(&quot;Since you took the last Klingon with you, you are a&quot;))
-	prout(_(&quot;martyr and a hero. Someday maybe they'll erect a&quot;))
-	prout(_(&quot;statue in your memory. Rest in peace, and try not&quot;))
-	prout(_(&quot;to think about pigeons.&quot;))
-	game.gamewon = True
-    score()
-
-def score():
-    &quot;Compute player's score.&quot;
-    timused = game.state.date - game.indate
-    iskill = game.skill
-    if (timused == 0 or (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0) and timused &lt; 5.0:
-	timused = 5.0
-    perdate = killrate()
-    ithperd = 500*perdate + 0.5
-    iwon = 0
-    if game.gamewon:
-	iwon = 100*game.skill
-    if game.ship == 'E': 
-	klship = 0
-    elif game.ship == 'F': 
-	klship = 1
-    else:
-	klship = 2
-    iscore = 10*(game.inkling - game.state.remkl) \
-             + 50*(game.incom - len(game.state.kcmdr)) \
-             + ithperd + iwon \
-             + 20*(game.inrom - game.state.nromrem) \
-             + 200*(game.inscom - game.state.nscrem) \
-    	     - game.state.nromrem \
-             - badpoints()
-    if not game.alive:
-	iscore -= 200
-    skip(2)
-    prout(_(&quot;Your score --&quot;))
-    if game.inrom - game.state.nromrem:
-	prout(_(&quot;%6d Romulans destroyed                 %5d&quot;) %
-	      (game.inrom - game.state.nromrem, 20*(game.inrom - game.state.nromrem)))
-    if game.state.nromrem and game.gamewon:
-	prout(_(&quot;%6d Romulans captured                  %5d&quot;) %
-	      (game.state.nromrem, game.state.nromrem))
-    if game.inkling - game.state.remkl:
-	prout(_(&quot;%6d ordinary Klingons destroyed        %5d&quot;) %
-	      (game.inkling - game.state.remkl, 10*(game.inkling - game.state.remkl)))
-    if game.incom - len(game.state.kcmdr):
-	prout(_(&quot;%6d Klingon commanders destroyed       %5d&quot;) %
-	      (game.incom - len(game.state.kcmdr), 50*(game.incom - len(game.state.kcmdr))))
-    if game.inscom - game.state.nscrem:
-	prout(_(&quot;%6d Super-Commander destroyed          %5d&quot;) %
-	      (game.inscom - game.state.nscrem, 200*(game.inscom - game.state.nscrem)))
-    if ithperd:
-	prout(_(&quot;%6.2f Klingons per stardate              %5d&quot;) %
-	      (perdate, ithperd))
-    if game.state.starkl:
-	prout(_(&quot;%6d stars destroyed by your action     %5d&quot;) %
-	      (game.state.starkl, -5*game.state.starkl))
-    if game.state.nplankl:
-	prout(_(&quot;%6d planets destroyed by your action   %5d&quot;) %
-	      (game.state.nplankl, -10*game.state.nplankl))
-    if (game.options &amp; OPTION_WORLDS) and game.state.nworldkl:
-	prout(_(&quot;%6d inhabited planets destroyed by your action   %5d&quot;) %
-	      (game.state.nworldkl, -300*game.state.nworldkl))
-    if game.state.basekl:
-	prout(_(&quot;%6d bases destroyed by your action     %5d&quot;) %
-	      (game.state.basekl, -100*game.state.basekl))
-    if game.nhelp:
-	prout(_(&quot;%6d calls for help from starbase       %5d&quot;) %
-	      (game.nhelp, -45*game.nhelp))
-    if game.casual:
-	prout(_(&quot;%6d casualties incurred                %5d&quot;) %
-	      (game.casual, -game.casual))
-    if game.abandoned:
-	prout(_(&quot;%6d crew abandoned in space            %5d&quot;) %
-	      (game.abandoned, -3*game.abandoned))
-    if klship:
-	prout(_(&quot;%6d ship(s) lost or destroyed          %5d&quot;) %
-	      (klship, -100*klship))
-    if not game.alive:
-	prout(_(&quot;Penalty for getting yourself killed        -200&quot;))
-    if game.gamewon:
-	proutn(_(&quot;Bonus for winning &quot;))
-	if game.skill   == SKILL_NOVICE:	proutn(_(&quot;Novice game  &quot;))
-	elif game.skill == SKILL_FAIR:  	proutn(_(&quot;Fair game    &quot;))
-	elif game.skill ==  SKILL_GOOD: 	proutn(_(&quot;Good game    &quot;))
-	elif game.skill ==  SKILL_EXPERT:	proutn(_(&quot;Expert game  &quot;))
-	elif game.skill ==  SKILL_EMERITUS:	proutn(_(&quot;Emeritus game&quot;))
-	prout(&quot;           %5d&quot; % iwon)
-    skip(1)
-    prout(_(&quot;TOTAL SCORE                               %5d&quot;) % iscore)
-
-def plaque():
-    &quot;Emit winner's commemmorative plaque.&quot; 
-    skip(2)
-    while True:
-        proutn(_(&quot;File or device name for your plaque: &quot;))
-        winner = cgetline()
-        try:
-            fp = open(winner, &quot;w&quot;)
-            break
-        except IOError:
-            prout(_(&quot;Invalid name.&quot;))
-
-    proutn(_(&quot;Enter name to go on plaque (up to 30 characters): &quot;))
-    winner = cgetline()
-    # The 38 below must be 64 for 132-column paper 
-    nskip = 38 - len(winner)/2
-    fp.write(&quot;\n\n\n\n&quot;)
-    # --------DRAW ENTERPRISE PICTURE. 
-    fp.write(&quot;                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot; )
-    fp.write(&quot;                                      EEE                      E  : :                                         :  E\n&quot; )
-    fp.write(&quot;                                    EE   EEE                   E  : :                   NCC-1701              :  E\n&quot;)
-    fp.write(&quot;EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n&quot;)
-    fp.write(&quot; E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
-    fp.write(&quot;                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n&quot;)
-    fp.write(&quot;                               EEEEEEE   EEEEE    E          E              E  E\n&quot;)
-    fp.write(&quot;                                      EEE           E          E            E  E\n&quot;)
-    fp.write(&quot;                                                       E         E          E  E\n&quot;)
-    fp.write(&quot;                                                         EEEEEEEEEEEEE      E  E\n&quot;)
-    fp.write(&quot;                                                      EEE :           EEEEEEE  EEEEEEEE\n&quot;)
-    fp.write(&quot;                                                    :E    :                 EEEE       E\n&quot;)
-    fp.write(&quot;                                                   .-E   -:-----                       E\n&quot;)
-    fp.write(&quot;                                                    :E    :                            E\n&quot;)
-    fp.write(&quot;                                                      EE  :                    EEEEEEEE\n&quot;)
-    fp.write(&quot;                                                       EEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
-    fp.write(&quot;\n\n\n&quot;)
-    fp.write(_(&quot;                                                       U. S. S. ENTERPRISE\n&quot;))
-    fp.write(&quot;\n\n\n\n&quot;)
-    fp.write(_(&quot;                                  For demonstrating outstanding ability as a starship captain\n&quot;))
-    fp.write(&quot;\n&quot;)
-    fp.write(_(&quot;                                                Starfleet Command bestows to you\n&quot;))
-    fp.write(&quot;\n&quot;)
-    fp.write(&quot;%*s%s\n\n&quot; % (nskip, &quot;&quot;, winner))
-    fp.write(_(&quot;                                                           the rank of\n\n&quot;))
-    fp.write(_(&quot;                                                       \&quot;Commodore Emeritus\&quot;\n\n&quot;))
-    fp.write(&quot;                                                          &quot;)
-    if game.skill ==  SKILL_EXPERT:
-        fp.write(_(&quot; Expert level\n\n&quot;))
-    elif game.skill == SKILL_EMERITUS:
-        fp.write(_(&quot;Emeritus level\n\n&quot;))
-    else:
-        fp.write(_(&quot; Cheat level\n\n&quot;))
-    timestring = time.ctime()
-    fp.write(_(&quot;                                                 This day of %.6s %.4s, %.8s\n\n&quot;) %
-                    (timestring+4, timestring+20, timestring+11))
-    fp.write(_(&quot;                                                        Your score:  %d\n\n&quot;) % iscore)
-    fp.write(_(&quot;                                                    Klingons per stardate:  %.2f\n&quot;) % perdate)
-    fp.close()
-
-# Code from io.c begins here
-
-rows = linecount = 0	# for paging 
-stdscr = None
-replayfp = None
-fullscreen_window = None
-srscan_window     = None
-report_window     = None
-status_window     = None
-lrscan_window     = None
-message_window    = None
-prompt_window     = None
-curwnd = None
-
-def iostart():
-    global stdscr, rows
-    &quot;for some recent versions of python2, the following enables UTF8&quot;
-    &quot;for the older ones we probably need to set C locale, and the python3&quot;
-    &quot;has no problems at all&quot;
-    if sys.version_info.major &lt; 3:
-	import locale
-	locale.setlocale(locale.LC_ALL, &quot;&quot;)
-    gettext.bindtextdomain(&quot;sst&quot;, &quot;/usr/local/share/locale&quot;)
-    gettext.textdomain(&quot;sst&quot;)
-    if not (game.options &amp; OPTION_CURSES):
-	ln_env = os.getenv(&quot;LINES&quot;)
-        if ln_env:
-            rows = ln_env
-        else:
-            rows = 25
-    else:
-	stdscr = curses.initscr()
-	stdscr.keypad(True)
-	curses.nonl()
-	curses.cbreak()
-        if game.options &amp; OPTION_COLOR:
-            curses.start_color();
-            curses.use_default_colors()
-            curses.init_pair(curses.COLOR_BLACK,   curses.COLOR_BLACK, -1);
-            curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN, -1);
-            curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED, -1);
-            curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN, -1);
-            curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE, -1);
-            curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1);
-            curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE, -1);
-            curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW, -1);
-        global fullscreen_window, srscan_window, report_window, status_window
-        global lrscan_window, message_window, prompt_window
-        (rows, columns)   = stdscr.getmaxyx()
-	fullscreen_window = stdscr
-	srscan_window     = curses.newwin(12, 25, 0,       0)
-	report_window     = curses.newwin(11, 0,  1,       25)
-	status_window     = curses.newwin(10, 0,  1,       39)
-	lrscan_window     = curses.newwin(5,  0,  0,       64) 
-	message_window    = curses.newwin(0,  0,  12,      0)
-	prompt_window     = curses.newwin(1,  0,  rows-2,  0) 
-	message_window.scrollok(True)
-	setwnd(fullscreen_window)
-
-def ioend():
-    &quot;Wrap up I/O.&quot;
-    if game.options &amp; OPTION_CURSES:
-        stdscr.keypad(False)
-        curses.echo()
-        curses.nocbreak()
-        curses.endwin()
-
-def waitfor():
-    &quot;Wait for user action -- OK to do nothing if on a TTY&quot;
-    if game.options &amp; OPTION_CURSES:
-	stdscr.getch()
-
-def announce():
-    skip(1)
-    prouts(_(&quot;[ANNOUNCEMENT ARRIVING...]&quot;))
-    skip(1)
-
-def pause_game():
-    if game.skill &gt; SKILL_FAIR:
-        prompt = _(&quot;[CONTINUE?]&quot;)
-    else:
-        prompt = _(&quot;[PRESS ENTER TO CONTINUE]&quot;)
-
-    if game.options &amp; OPTION_CURSES:
-        drawmaps(0)
-        setwnd(prompt_window)
-        prompt_window.clear()
-        prompt_window.addstr(prompt)
-        prompt_window.getstr()
-        prompt_window.clear()
-        prompt_window.refresh()
-        setwnd(message_window)
-    else:
-        global linecount
-        sys.stdout.write('\n')
-        proutn(prompt)
-        raw_input()
-        for j in range(rows):
-            sys.stdout.write('\n')
-        linecount = 0
-
-def skip(i):
-    &quot;Skip i lines.  Pause game if this would cause a scrolling event.&quot;
-    for dummy in range(i):
-	if game.options &amp; OPTION_CURSES:
-            (y, x) = curwnd.getyx()
-            (my, mx) = curwnd.getmaxyx()
-	    if curwnd == message_window and y &gt;= my - 2:
-		pause_game()
-		clrscr()
-	    else:
-                try:
-                    curwnd.move(y+1, 0)
-                except curses.error:
-                    pass
-	else:
-            global linecount
-	    linecount += 1
-	    if rows and linecount &gt;= rows:
-		pause_game()
-	    else:
-		sys.stdout.write('\n')
-
-def proutn(line):
-    &quot;Utter a line with no following line feed.&quot;
-    if game.options &amp; OPTION_CURSES:
-	curwnd.addstr(line)
-	curwnd.refresh()
-    else:
-	sys.stdout.write(line)
-        sys.stdout.flush()
-
-def prout(line):
-    proutn(line)
-    skip(1)
-
-def prouts(line):
-    &quot;Emit slowly!&quot; 
-    for c in line:
-        if not replayfp or replayfp.closed:	# Don't slow down replays
-            time.sleep(0.03)
-	proutn(c)
-	if game.options &amp; OPTION_CURSES:
-	    curwnd.refresh()
-	else:
-	    sys.stdout.flush()
-    if not replayfp or replayfp.closed:
-        time.sleep(0.03)
-
-def cgetline():
-    &quot;Get a line of input.&quot;
-    if game.options &amp; OPTION_CURSES:
-	line = curwnd.getstr() + &quot;\n&quot;
-	curwnd.refresh()
-    else:
-	if replayfp and not replayfp.closed:
-            while True:
-                line = replayfp.readline()
-                proutn(line)
-                if line == '':
-                    prout(&quot;*** Replay finished&quot;)
-                    replayfp.close()
-                    break
-                elif line[0] != &quot;#&quot;:
-                    break
-	else:
-	    line = raw_input() + &quot;\n&quot;
-    if logfp:
-	logfp.write(line)
-    return line
-
-def setwnd(wnd):
-    &quot;Change windows -- OK for this to be a no-op in tty mode.&quot;
-    global curwnd
-    if game.options &amp; OPTION_CURSES:
-        curwnd = wnd
-        curses.curs_set(wnd == fullscreen_window or wnd == message_window or wnd == prompt_window)
-
-def clreol():
-    &quot;Clear to end of line -- can be a no-op in tty mode&quot; 
-    if game.options &amp; OPTION_CURSES:
-        curwnd.clrtoeol()
-        curwnd.refresh()
-
-def clrscr():
-    &quot;Clear screen -- can be a no-op in tty mode.&quot;
-    global linecount
-    if game.options &amp; OPTION_CURSES:
-       curwnd.clear()
-       curwnd.move(0, 0)
-       curwnd.refresh()
-    linecount = 0
-
-def textcolor(color=DEFAULT):
-    if game.options &amp; OPTION_COLOR:
-	if color == DEFAULT: 
-	    curwnd.attrset(0);
-	elif color ==  BLACK: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK));
-	elif color ==  BLUE: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE));
-	elif color ==  GREEN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN));
-	elif color ==  CYAN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN));
-	elif color ==  RED: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_RED));
-	elif color ==  MAGENTA: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA));
-	elif color ==  BROWN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW));
-	elif color ==  LIGHTGRAY: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE));
-	elif color ==  DARKGRAY: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK) | curses.A_BOLD);
-	elif color ==  LIGHTBLUE: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE) | curses.A_BOLD);
-	elif color ==  LIGHTGREEN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN) | curses.A_BOLD);
-	elif color ==  LIGHTCYAN: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN) | curses.A_BOLD);
-	elif color ==  LIGHTRED: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_RED) | curses.A_BOLD);
-	elif color ==  LIGHTMAGENTA: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA) | curses.A_BOLD);
-	elif color ==  YELLOW: 
-	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW) | curses.A_BOLD);
-	elif color ==  WHITE:
-	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE) | curses.A_BOLD);
-
-def highvideo():
-    if game.options &amp; OPTION_COLOR:
-        curwnd.attron(curses.A_REVERSE)
-
-#
-# Things past this point have policy implications.
-# 
-
-def drawmaps(mode):
-    &quot;Hook to be called after moving to redraw maps.&quot;
-    if game.options &amp; OPTION_CURSES:
-	if mode == 1:
-	    sensor()
-        setwnd(srscan_window)
-        curwnd.move(0, 0)
-        srscan()
-	if mode != 2:
-	    setwnd(status_window)
-	    status_window.clear()
-	    status_window.move(0, 0)
-	    setwnd(report_window)
-	    report_window.clear()
-	    report_window.move(0, 0)
-	    status()
-	    setwnd(lrscan_window)
-	    lrscan_window.clear()
-	    lrscan_window.move(0, 0)
-	    lrscan(silent=False)
-
-def put_srscan_sym(w, sym):
-    &quot;Emit symbol for short-range scan.&quot;
-    srscan_window.move(w.i+1, w.j*2+2)
-    srscan_window.addch(sym)
-    srscan_window.refresh()
-
-def boom(w):
-    &quot;Enemy fall down, go boom.&quot;  
-    if game.options &amp; OPTION_CURSES:
-	drawmaps(2)
-	setwnd(srscan_window)
-	srscan_window.attron(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.i][w.j])
-	#sound(500)
-	#time.sleep(1.0)
-	#nosound()
-	srscan_window.attroff(curses.A_REVERSE)
-	put_srscan_sym(w, game.quad[w.i][w.j])
-	curses.delay_output(500)
-	setwnd(message_window) 
-
-def warble():
-    &quot;Sound and visual effects for teleportation.&quot;
-    if game.options &amp; OPTION_CURSES:
-	drawmaps(2)
-	setwnd(message_window)
-	#sound(50)
-    prouts(&quot;     . . . . .     &quot;)
-    if game.options &amp; OPTION_CURSES:
-	#curses.delay_output(1000)
-	#nosound()
-        pass
-
-def tracktorpedo(origin, w, step, i, n, iquad):
-    &quot;Torpedo-track animation.&quot; 
-    if not game.options &amp; OPTION_CURSES:
-	if step == 1:
-	    if n != 1:
-		skip(1)
-		proutn(_(&quot;Track for torpedo number %d-  &quot;) % (i+1))
-	    else:
-		skip(1)
-		proutn(_(&quot;Torpedo track- &quot;))
-	elif step==4 or step==9: 
-	    skip(1)
-	proutn(&quot;%s   &quot; % w)
-    else:
-	if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
-	    if i != 0 and step == 1:
-		drawmaps(2)
-		time.sleep(0.4)
-	    if (iquad=='.') or (iquad==' '):
-		put_srscan_sym(w, '+')
-		#sound(step*10)
-		#time.sleep(0.1)
-		#nosound()
-		put_srscan_sym(w, iquad)
-	    else:
-		curwnd.attron(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-		#sound(500)
-		#time.sleep(1.0)
-		#nosound()
-		curwnd.attroff(curses.A_REVERSE)
-		put_srscan_sym(w, iquad)
-	else:
-	    proutn(&quot;%s   &quot; % w)
-
-def makechart():
-    &quot;Display the current galaxy chart.&quot;
-    if game.options &amp; OPTION_CURSES:
-	setwnd(message_window)
-	message_window.clear()
-    chart()
-    if game.options &amp; OPTION_TTY:
-	skip(1)
-
-NSYM	= 14
-
-def prstat(txt, data):
-    proutn(txt)
-    if game.options &amp; OPTION_CURSES:
-	skip(1)
-	setwnd(status_window)
-    else:
-        proutn(&quot; &quot; * (NSYM - len(txt)))
-    proutn(data)
-    skip(1)
-    if game.options &amp; OPTION_CURSES:
-	setwnd(report_window)
-
-# Code from moving.c begins here
-
-def imove(course=None, noattack=False):
-    &quot;Movement execution for warp, impulse, supernova, and tractor-beam events.&quot;
-    w = coord()
-
-    def newquadrant(noattack):
-        # Leaving quadrant -- allow final enemy attack 
-        # Don't do it if being pushed by Nova 
-        if len(game.enemies) != 0 and not noattack:
-            newcnd()
-            for enemy in game.enemies:
-                finald = (w - enemy.location).distance()
-                enemy.kavgd = 0.5 * (finald + enemy.kdist)
-            # Stas Sergeev added the condition
-            # that attacks only happen if Klingons
-            # are present and your skill is good.
-            if game.skill &gt; SKILL_GOOD and game.klhere &gt; 0 and not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-                attack(torps_ok=False)
-            if game.alldone:
-                return
-        # check for edge of galaxy 
-        kinks = 0
-        while True:
-            kink = False
-            if course.final.i &lt; 0:
-                course.final.i = -course.final.i
-                kink = True
-            if course.final.j &lt; 0:
-                course.final.j = -course.final.j
-                kink = True
-            if course.final.i &gt;= GALSIZE*QUADSIZE:
-                course.final.i = (GALSIZE*QUADSIZE*2) - course.final.i
-                kink = True
-            if course.final.j &gt;= GALSIZE*QUADSIZE:
-                course.final.j = (GALSIZE*QUADSIZE*2) - course.final.j
-                kink = True
-            if kink:
-                kinks += 1
-            else:
-                break
-        if kinks:
-            game.nkinks += 1
-            if game.nkinks == 3:
-                # Three strikes -- you're out! 
-                finish(FNEG3)
-                return
-            skip(1)
-            prout(_(&quot;YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER&quot;))
-            prout(_(&quot;AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,&quot;))
-            prout(_(&quot;YOU WILL BE DESTROYED.&quot;))
-        # Compute final position in new quadrant 
-        if trbeam: # Don't bother if we are to be beamed 
-            return
-        game.quadrant = course.final.quadrant()
-        game.sector = course.final.sector()
-        skip(1)
-        prout(_(&quot;Entering Quadrant %s.&quot;) % game.quadrant)
-        game.quad[game.sector.i][game.sector.j] = game.ship
-        newqad()
-        if game.skill&gt;SKILL_NOVICE:
-            attack(torps_ok=False)  
-
-    def check_collision(h):
-        iquad = game.quad[h.i][h.j]
-        if iquad != '.':
-            # object encountered in flight path 
-            stopegy = 50.0*course.distance/game.optime
-            if iquad in ('T', 'K', 'C', 'S', 'R', '?'):
-                for enemy in game.enemies:
-                    if enemy.location == game.sector:
-                        break
-                collision(rammed=False, enemy=enemy)
-                return True
-            elif iquad == ' ':
-                skip(1)
-                prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-                skip(1)
-                proutn(&quot;***&quot; + crmshp())
-                proutn(_(&quot; pulled into black hole at Sector %s&quot;) % h)
-                # Getting pulled into a black hole was certain
-                # death in Almy's original.  Stas Sergeev added a
-                # possibility that you'll get timewarped instead.
-                n=0
-                for m in range(NDEVICES):
-                    if game.damage[m]&gt;0: 
-                        n += 1
-                probf=math.pow(1.4,(game.energy+game.shield)/5000.0-1.0)*math.pow(1.3,1.0/(n+1)-1.0)
-                if (game.options &amp; OPTION_BLKHOLE) and withprob(1-probf): 
-                    timwrp()
-                else: 
-                    finish(FHOLE)
-                return True
-            else:
-                # something else 
-                skip(1)
-                proutn(crmshp())
-                if iquad == '#':
-                    prout(_(&quot; encounters Tholian web at %s;&quot;) % h)
-                else:
-                    prout(_(&quot; blocked by object at %s;&quot;) % h)
-                proutn(_(&quot;Emergency stop required &quot;))
-                prout(_(&quot;%2d units of energy.&quot;) % int(stopegy))
-                game.energy -= stopegy
-                if game.energy &lt;= 0:
-                    finish(FNRG)
-                return True
-        return False
-
-    trbeam = False
-    if game.inorbit:
-	prout(_(&quot;Helmsman Sulu- \&quot;Leaving standard orbit.\&quot;&quot;))
-	game.inorbit = False
-    # If tractor beam is to occur, don't move full distance 
-    if game.state.date+game.optime &gt;= scheduled(FTBEAM):
-	trbeam = True
-	game.condition = &quot;red&quot;
-	course.distance = course.distance*(scheduled(FTBEAM)-game.state.date)/game.optime + 0.1
-	game.optime = scheduled(FTBEAM) - game.state.date + 1e-5
-    # Move out
-    game.quad[game.sector.i][game.sector.j] = '.'
-    for m in range(course.moves):
-        course.next()
-        w = course.sector()
-        if course.origin.quadrant() != course.location.quadrant():
-            newquadrant(noattack)
-            break
-        elif check_collision(w):
-            print &quot;Collision detected&quot;
-            break
-        else:
-            game.sector = w
-    # We're in destination quadrant -- compute new average enemy distances
-    game.quad[game.sector.i][game.sector.j] = game.ship
-    if game.enemies:
-        for enemy in game.enemies:
-            finald = (w-enemy.location).distance()
-            enemy.kavgd = 0.5 * (finald + enemy.kdist)
-            enemy.kdist = finald
-        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            attack(torps_ok=False)
-        for enemy in game.enemies:
-            enemy.kavgd = enemy.kdist
-    newcnd()
-    drawmaps(0)
-    setwnd(message_window)
-    return
-
-def dock(verbose):
-    &quot;Dock our ship at a starbase.&quot;
-    scanner.chew()
-    if game.condition == &quot;docked&quot; and verbose:
-	prout(_(&quot;Already docked.&quot;))
-	return
-    if game.inorbit:
-	prout(_(&quot;You must first leave standard orbit.&quot;))
-	return
-    if not game.base.is_valid() or abs(game.sector.i-game.base.i) &gt; 1 or abs(game.sector.j-game.base.j) &gt; 1:
-	prout(crmshp() + _(&quot; not adjacent to base.&quot;))
-	return
-    game.condition = &quot;docked&quot;
-    if &quot;verbose&quot;:
-	prout(_(&quot;Docked.&quot;))
-    game.ididit = True
-    if game.energy &lt; game.inenrg:
-	game.energy = game.inenrg
-    game.shield = game.inshld
-    game.torps = game.intorps
-    game.lsupres = game.inlsr
-    game.state.crew = FULLCREW
-    if not damaged(DRADIO) and \
-	((is_scheduled(FCDBAS) or game.isatb == 1) and not game.iseenit):
-	# get attack report from base 
-	prout(_(&quot;Lt. Uhura- \&quot;Captain, an important message from the starbase:\&quot;&quot;))
-	attackreport(False)
-	game.iseenit = True
-
-def cartesian(loc1=None, loc2=None):
-    if loc1 is None:
-        return game.quadrant * QUADSIZE + game.sector
-    elif loc2 is None:
-        return game.quadrant * QUADSIZE + loc1
-    else:
-        return loc1 * QUADSIZE + loc2
-
-def getcourse(isprobe):
-    &quot;Get a course and distance from the user.&quot;
-    key = 0
-    dquad = copy.copy(game.quadrant)
-    navmode = &quot;unspecified&quot;
-    itemp = &quot;curt&quot;
-    dsect = coord()
-    iprompt = False
-    if game.landed and not isprobe:
-	prout(_(&quot;Dummy! You can't leave standard orbit until you&quot;))
-	proutn(_(&quot;are back aboard the ship.&quot;))
-	scanner.chew()
-	raise TrekError
-    while navmode == &quot;unspecified&quot;:
-	if damaged(DNAVSYS):
-	    if isprobe:
-		prout(_(&quot;Computer damaged; manual navigation only&quot;))
-	    else:
-		prout(_(&quot;Computer damaged; manual movement only&quot;))
-	    scanner.chew()
-	    navmode = &quot;manual&quot;
-	    key = &quot;IHEOL&quot;
-	    break
-        key = scanner.next()
-	if key == &quot;IHEOL&quot;:
-	    proutn(_(&quot;Manual or automatic- &quot;))
-	    iprompt = True
-	    scanner.chew()
-	elif key == &quot;IHALPHA&quot;:
-            if scanner.sees(&quot;manual&quot;):
-		navmode = &quot;manual&quot;
-		key = scanner.next()
-		break
-            elif scanner.sees(&quot;automatic&quot;):
-		navmode = &quot;automatic&quot;
-		key = scanner.next()
-		break
-	    else:
-		huh()
-		scanner.chew()
-		raise TrekError
-	else: # numeric 
-	    if isprobe:
-		prout(_(&quot;(Manual navigation assumed.)&quot;))
-	    else:
-		prout(_(&quot;(Manual movement assumed.)&quot;))
-	    navmode = &quot;manual&quot;
-	    break
-    delta = coord()
-    if navmode == &quot;automatic&quot;:
-	while key == &quot;IHEOL&quot;:
-	    if isprobe:
-		proutn(_(&quot;Target quadrant or quadrant&amp;sector- &quot;))
-	    else:
-		proutn(_(&quot;Destination sector or quadrant&amp;sector- &quot;))
-	    scanner.chew()
-	    iprompt = True
-	    key = scanner.next()
-	if key != &quot;IHREAL&quot;:
-	    huh()
-	    raise TrekError
-	xi = int(round(scanner.real))-1
-	key = scanner.next()
-	if key != &quot;IHREAL&quot;:
-	    huh()
-	    raise TrekError
-	xj = int(round(scanner.real))-1
-	key = scanner.next()
-	if key == &quot;IHREAL&quot;:
-	    # both quadrant and sector specified 
-	    xk = int(round(scanner.real))-1
-	    key = scanner.next()
-	    if key != &quot;IHREAL&quot;:
-		huh()
-		raise TrekError
-	    xl = int(round(scanner.real))-1
-	    dquad.i = xi
-	    dquad.j = xj
-	    dsect.i = xk
-	    dsect.j = xl
-	else:
-            # only one pair of numbers was specified
-	    if isprobe:
-		# only quadrant specified -- go to center of dest quad 
-		dquad.i = xi
-		dquad.j = xj
-		dsect.j = dsect.i = 4	# preserves 1-origin behavior
-	    else:
-                # only sector specified
-		dsect.i = xi
-		dsect.j = xj
-	    itemp = &quot;normal&quot;
-	if not dquad.valid_quadrant() or not dsect.valid_sector():
-	    huh()
-	    raise TrekError
-	skip(1)
-	if not isprobe:
-	    if itemp &gt; &quot;curt&quot;:
-		if iprompt:
-		    prout(_(&quot;Helmsman Sulu- \&quot;Course locked in for Sector %s.\&quot;&quot;) % dsect)
-	    else:
-		prout(_(&quot;Ensign Chekov- \&quot;Course laid in, Captain.\&quot;&quot;))
-        # the actual deltas get computed here
-	delta.j = dquad.j-game.quadrant.j + (dsect.j-game.sector.j)/(QUADSIZE*1.0)
-	delta.i = game.quadrant.i-dquad.i + (game.sector.i-dsect.i)/(QUADSIZE*1.0)
-    else: # manual 
-	while key == &quot;IHEOL&quot;:
-	    proutn(_(&quot;X and Y displacements- &quot;))
-	    scanner.chew()
-	    iprompt = True
-	    key = scanner.next()
-	itemp = &quot;verbose&quot;
-	if key != &quot;IHREAL&quot;:
-	    huh()
-	    raise TrekError
-	delta.j = scanner.real
-	key = scanner.next()
-	if key != &quot;IHREAL&quot;:
-	    huh()
-	    raise TrekError
-	delta.i = scanner.real
-    # Check for zero movement 
-    if delta.i == 0 and delta.j == 0:
-	scanner.chew()
-	raise TrekError
-    if itemp == &quot;verbose&quot; and not isprobe:
-	skip(1)
-	prout(_(&quot;Helmsman Sulu- \&quot;Aye, Sir.\&quot;&quot;))
-    scanner.chew()
-    return course(bearing=delta.bearing(), distance=delta.distance())
-
-class course:
-    def __init__(self, bearing, distance, origin=None): 
-        self.distance = distance
-        self.bearing = bearing
-        if origin is None:
-            self.origin = cartesian(game.quadrant, game.sector)
-        else:
-            self.origin = origin
-        # The bearing() code we inherited from FORTRAN is actually computing
-        # clockface directions!
-        if self.bearing &lt; 0.0:
-            self.bearing += 12.0
-        self.angle = ((15.0 - self.bearing) * 0.5235988)
-        if origin is None:
-            self.origin = cartesian(game.quadrant, game.sector)
-        else:
-            self.origin = cartesian(game.quadrant, origin)
-        self.increment = coord(-math.sin(self.angle), math.cos(self.angle))
-        bigger = max(abs(self.increment.i), abs(self.increment.j))
-        self.increment /= bigger
-        self.moves = int(round(10*self.distance*bigger))
-        self.reset()
-        self.final = (self.location + self.moves*self.increment).roundtogrid()
-    def reset(self):
-        self.location = self.origin
-        self.step = 0
-    def arrived(self):
-        return self.location.roundtogrid() == self.final
-    def next(self):
-        &quot;Next step on course.&quot;
-        self.step += 1
-        self.nextlocation = self.location + self.increment
-        samequad = (self.location.quadrant() == self.nextlocation.quadrant())
-        self.location = self.nextlocation
-        return samequad
-    def quadrant(self):
-        return self.location.quadrant()
-    def sector(self):
-        return self.location.sector()
-    def power(self, warp):
-	return self.distance*(warp**3)*(game.shldup+1)
-    def time(self, warp):
-        return 10.0*self.distance/warp**2
-
-def impulse():
-    &quot;Move under impulse power.&quot;
-    game.ididit = False
-    if damaged(DIMPULS):
-	scanner.chew()
-	skip(1)
-	prout(_(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;))
-	return
-    if game.energy &gt; 30.0:
-        try:
-            course = getcourse(isprobe=False)
-        except TrekError:
-	    return
-	power = 20.0 + 100.0*course.distance
-    else:
-	power = 30.0
-    if power &gt;= game.energy:
-	# Insufficient power for trip 
-	skip(1)
-	prout(_(&quot;First Officer Spock- \&quot;Captain, the impulse engines&quot;))
-	prout(_(&quot;require 20.0 units to engage, plus 100.0 units per&quot;))
-	if game.energy &gt; 30:
-	    proutn(_(&quot;quadrant.  We can go, therefore, a maximum of %d&quot;) %
-                     int(0.01 * (game.energy-20.0)-0.05))
-	    prout(_(&quot; quadrants.\&quot;&quot;))
-	else:
-	    prout(_(&quot;quadrant.  They are, therefore, useless.\&quot;&quot;))
-	scanner.chew()
-	return
-    # Make sure enough time is left for the trip 
-    game.optime = course.dist/0.095
-    if game.optime &gt;= game.state.remtime:
-	prout(_(&quot;First Officer Spock- \&quot;Captain, our speed under impulse&quot;))
-	prout(_(&quot;power is only 0.95 sectors per stardate. Are you sure&quot;))
-	proutn(_(&quot;we dare spend the time?\&quot; &quot;))
-	if ja() == False:
-	    return
-    # Activate impulse engines and pay the cost 
-    imove(course, noattack=False)
-    game.ididit = True
-    if game.alldone:
-	return
-    power = 20.0 + 100.0*course.dist
-    game.energy -= power
-    game.optime = course.dist/0.095
-    if game.energy &lt;= 0:
-	finish(FNRG)
-    return
-
-def warp(course, involuntary):
-    &quot;ove under warp drive.&quot;
-    blooey = False; twarp = False
-    if not involuntary: # Not WARPX entry 
-	game.ididit = False
-	if game.damage[DWARPEN] &gt; 10.0:
-	    scanner.chew()
-	    skip(1)
-	    prout(_(&quot;Engineer Scott- \&quot;The warp engines are damaged, Sir.\&quot;&quot;))
-	    return
-	if damaged(DWARPEN) and game.warpfac &gt; 4.0:
-	    scanner.chew()
-	    skip(1)
-	    prout(_(&quot;Engineer Scott- \&quot;Sorry, Captain. Until this damage&quot;))
-	    prout(_(&quot;  is repaired, I can only give you warp 4.\&quot;&quot;))
-	    return
-       	# Read in course and distance
-        if course==None:
-            try:
-                course = getcourse(isprobe=False)
-            except TrekError:
-                return
-	# Make sure starship has enough energy for the trip
-        # Note: this formula is slightly different from the C version,
-        # and lets you skate a bit closer to the edge.
-	if course.power(game.warpfac) &gt;= game.energy:
-	    # Insufficient power for trip 
-	    game.ididit = False
-	    skip(1)
-	    prout(_(&quot;Engineering to bridge--&quot;))
-	    if not game.shldup or 0.5*power &gt; game.energy:
-		iwarp = (game.energy/(course.dist+0.05)) ** 0.333333333
-		if iwarp &lt;= 0:
-		    prout(_(&quot;We can't do it, Captain. We don't have enough energy.&quot;))
-		else:
-		    proutn(_(&quot;We don't have enough energy, but we could do it at warp %d&quot;) % iwarp)
-		    if game.shldup:
-			prout(&quot;,&quot;)
-			prout(_(&quot;if you'll lower the shields.&quot;))
-		    else:
-			prout(&quot;.&quot;)
-	    else:
-		prout(_(&quot;We haven't the energy to go that far with the shields up.&quot;))
-	    return				
-	# Make sure enough time is left for the trip 
-	game.optime = course.time(game.warpfac)
-	if game.optime &gt;= 0.8*game.state.remtime:
-	    skip(1)
-	    prout(_(&quot;First Officer Spock- \&quot;Captain, I compute that such&quot;))
-	    proutn(_(&quot;  a trip would require approximately %2.0f&quot;) %
-		   (100.0*game.optime/game.state.remtime))
-	    prout(_(&quot; percent of our&quot;))
-	    proutn(_(&quot;  remaining time.  Are you sure this is wise?\&quot; &quot;))
-	    if ja() == False:
-		game.ididit = False
-		game.optime=0 
-		return
-    # Entry WARPX 
-    if game.warpfac &gt; 6.0:
-	# Decide if engine damage will occur
-        # ESR: Seems wrong. Probability of damage goes *down* with distance? 
-	prob = course.distance*(6.0-game.warpfac)**2/66.666666666
-	if prob &gt; randreal():
-	    blooey = True
-	    course.distance = randreal(course.distance)
-	# Decide if time warp will occur 
-	if 0.5*course.distance*math.pow(7.0,game.warpfac-10.0) &gt; randreal():
-	    twarp = True
-	if idebug and game.warpfac==10 and not twarp:
-	    blooey = False
-	    proutn(&quot;=== Force time warp? &quot;)
-	    if ja() == True:
-		twarp = True
-	if blooey or twarp:
-	    # If time warp or engine damage, check path 
-	    # If it is obstructed, don't do warp or damage 
-            for m in range(course.moves):
-                course.next()
-                w = course.sector()
-                if not w.valid_sector():
-                    break
-		if game.quad[w.i][w.j] != '.':
-		    blooey = False
-		    twarp = False
-            course.reset()
-    # Activate Warp Engines and pay the cost 
-    imove(course, noattack=False)
-    if game.alldone:
-	return
-    game.energy -= course.power(game.warpfac)
-    if game.energy &lt;= 0:
-	finish(FNRG)
-    game.optime = course.time(game.warpfac)
-    if twarp:
-	timwrp()
-    if blooey:
-	game.damage[DWARPEN] = game.damfac * randreal(1.0, 4.0)
-	skip(1)
-	prout(_(&quot;Engineering to bridge--&quot;))
-	prout(_(&quot;  Scott here.  The warp engines are damaged.&quot;))
-	prout(_(&quot;  We'll have to reduce speed to warp 4.&quot;))
-    game.ididit = True
-    return
-
-def setwarp():
-    &quot;Change the warp factor.&quot;
-    while True:
-        key=scanner.next()
-        if key != &quot;IHEOL&quot;:
-            break
-	scanner.chew()
-	proutn(_(&quot;Warp factor- &quot;))
-    if key != &quot;IHREAL&quot;:
-	huh()
-	return
-    if game.damage[DWARPEN] &gt; 10.0:
-	prout(_(&quot;Warp engines inoperative.&quot;))
-	return
-    if damaged(DWARPEN) and scanner.real &gt; 4.0:
-	prout(_(&quot;Engineer Scott- \&quot;I'm doing my best, Captain,&quot;))
-	prout(_(&quot;  but right now we can only go warp 4.\&quot;&quot;))
-	return
-    if scanner.real &gt; 10.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;Our top speed is warp 10, Captain.\&quot;&quot;))
-	return
-    if scanner.real &lt; 1.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;We can't go below warp 1, Captain.\&quot;&quot;))
-	return
-    oldfac = game.warpfac
-    game.warpfac = scanner.real
-    if game.warpfac &lt;= oldfac or game.warpfac &lt;= 6.0:
-	prout(_(&quot;Helmsman Sulu- \&quot;Warp factor %d, Captain.\&quot;&quot;) %
-	       int(game.warpfac))
-	return
-    if game.warpfac &lt; 8.00:
-	prout(_(&quot;Engineer Scott- \&quot;Aye, but our maximum safe speed is warp 6.\&quot;&quot;))
-	return
-    if game.warpfac == 10.0:
-	prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, we'll try it.\&quot;&quot;))
-	return
-    prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, but our engines may not take it.\&quot;&quot;))
-    return
-
-def atover(igrab):
-    &quot;Cope with being tossed out of quadrant by supernova or yanked by beam.&quot;
-    scanner.chew()
-    # is captain on planet? 
-    if game.landed:
-	if damaged(DTRANSP):
-	    finish(FPNOVA)
-	    return
-	prout(_(&quot;Scotty rushes to the transporter controls.&quot;))
-	if game.shldup:
-	    prout(_(&quot;But with the shields up it's hopeless.&quot;))
-	    finish(FPNOVA)
-	prouts(_(&quot;His desperate attempt to rescue you . . .&quot;))
-	if withprob(0.5):
-	    prout(_(&quot;fails.&quot;))
-	    finish(FPNOVA)
-	    return
-	prout(_(&quot;SUCCEEDS!&quot;))
-	if game.imine:
-	    game.imine = False
-	    proutn(_(&quot;The crystals mined were &quot;))
-	    if withprob(0.25):
-		prout(_(&quot;lost.&quot;))
-	    else:
-		prout(_(&quot;saved.&quot;))
-		game.icrystl = True
-    if igrab:
-	return
-    # Check to see if captain in shuttle craft 
-    if game.icraft:
-	finish(FSTRACTOR)
-    if game.alldone:
-	return
-    # Inform captain of attempt to reach safety 
-    skip(1)
-    while True:
-	if game.justin:
-	    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	    skip(1)
-	    proutn(_(&quot;The %s has stopped in a quadrant containing&quot;) % crmshp())
-	    prouts(_(&quot;   a supernova.&quot;))
-	    skip(2)
-	prout(_(&quot;***Emergency automatic override attempts to hurl &quot;)+crmshp())
-	prout(_(&quot;safely out of quadrant.&quot;))
-	if not damaged(DRADIO):
-	    game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
-	# Try to use warp engines 
-	if damaged(DWARPEN):
-	    skip(1)
-	    prout(_(&quot;Warp engines damaged.&quot;))
-	    finish(FSNOVAED)
-	    return
-	game.warpfac = randreal(6.0, 8.0)
-	prout(_(&quot;Warp factor set to %d&quot;) % int(game.warpfac))
-	power = 0.75*game.energy
-	dist = power/(game.warpfac*game.warpfac*game.warpfac*(game.shldup+1))
-	dist = max(dist, randreal(math.sqrt(2)))
-        bugout = course(bearing=randreal(12), distance=dist)	# How dumb!
-	game.optime = bugout.time(game.warpfac)
-	game.justin = False
-	game.inorbit = False
-	warp(bugout, involuntary=True)
-	if not game.justin:
-	    # This is bad news, we didn't leave quadrant. 
-	    if game.alldone:
-		return
-	    skip(1)
-	    prout(_(&quot;Insufficient energy to leave quadrant.&quot;))
-	    finish(FSNOVAED)
-	    return
-	# Repeat if another snova
-        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-            break
-    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0: 
-	finish(FWON) # Snova killed remaining enemy. 
-
-def timwrp():
-    &quot;Let's do the time warp again.&quot;
-    prout(_(&quot;***TIME WARP ENTERED.&quot;))
-    if game.state.snap and withprob(0.5):
-	# Go back in time 
-	prout(_(&quot;You are traveling backwards in time %d stardates.&quot;) %
-	      int(game.state.date-game.snapsht.date))
-	game.state = game.snapsht
-	game.state.snap = False
-	if len(game.state.kcmdr):
-	    schedule(FTBEAM, expran(game.intime/len(game.state.kcmdr)))
-	    schedule(FBATTAK, expran(0.3*game.intime))
-	schedule(FSNOVA, expran(0.5*game.intime))
-	# next snapshot will be sooner 
-	schedule(FSNAP, expran(0.25*game.state.remtime))
-				
-	if game.state.nscrem:
-	    schedule(FSCMOVE, 0.2777)	    
-	game.isatb = 0
-	unschedule(FCDBAS)
-	unschedule(FSCDBAS)
-	game.battle.invalidate()
-	# Make sure Galileo is consistant -- Snapshot may have been taken
-        # when on planet, which would give us two Galileos! 
-	gotit = False
-	for l in range(game.inplan):
-	    if game.state.planets[l].known == &quot;shuttle_down&quot;:
-		gotit = True
-		if game.iscraft == &quot;onship&quot; and game.ship=='E':
-		    prout(_(&quot;Chekov-  \&quot;Security reports the Galileo has disappeared, Sir!&quot;))
-		    game.iscraft = &quot;offship&quot;
-	# Likewise, if in the original time the Galileo was abandoned, but
-	# was on ship earlier, it would have vanished -- let's restore it.
-	if game.iscraft == &quot;offship&quot; and not gotit and game.damage[DSHUTTL] &gt;= 0.0:
-	    prout(_(&quot;Chekov-  \&quot;Security reports the Galileo has reappeared in the dock!\&quot;&quot;))
-	    game.iscraft = &quot;onship&quot;
-        # There used to be code to do the actual reconstrction here,
-        # but the starchart is now part of the snapshotted galaxy state.
-	prout(_(&quot;Spock has reconstructed a correct star chart from memory&quot;))
-    else:
-	# Go forward in time 
-	game.optime = expran(0.5*game.intime)
-	prout(_(&quot;You are traveling forward in time %d stardates.&quot;) % int(game.optime))
-	# cheat to make sure no tractor beams occur during time warp 
-	postpone(FTBEAM, game.optime)
-	game.damage[DRADIO] += game.optime
-    newqad()
-    events()	# Stas Sergeev added this -- do pending events 
-
-def probe():
-    &quot;Launch deep-space probe.&quot; 
-    # New code to launch a deep space probe 
-    if game.nprobes == 0:
-	scanner.chew()
-	skip(1)
-	if game.ship == 'E': 
-	    prout(_(&quot;Engineer Scott- \&quot;We have no more deep space probes, Sir.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Ye Faerie Queene has no deep space probes.&quot;))
-	return
-    if damaged(DDSP):
-	scanner.chew()
-	skip(1)
-	prout(_(&quot;Engineer Scott- \&quot;The probe launcher is damaged, Sir.\&quot;&quot;))
-	return
-    if is_scheduled(FDSPROB):
-	scanner.chew()
-	skip(1)
-	if damaged(DRADIO) and game.condition != &quot;docked&quot;:
-	    prout(_(&quot;Spock-  \&quot;Records show the previous probe has not yet&quot;))
-	    prout(_(&quot;   reached its destination.\&quot;&quot;))
-	else:
-	    prout(_(&quot;Uhura- \&quot;The previous probe is still reporting data, Sir.\&quot;&quot;))
-	return
-    key = scanner.next()
-    if key == &quot;IHEOL&quot;:
-        if game.nprobes == 1:
-            prout(_(&quot;1 probe left.&quot;))
-        else:
-            prout(_(&quot;%d probes left&quot;) % game.nprobes)
-	proutn(_(&quot;Are you sure you want to fire a probe? &quot;))
-	if ja() == False:
-	    return
-    game.isarmed = False
-    if key == &quot;IHALPHA&quot; and scanner.token == &quot;armed&quot;:
-	game.isarmed = True
-	key = scanner.next()
-    elif key == &quot;IHEOL&quot;:
-	proutn(_(&quot;Arm NOVAMAX warhead? &quot;))
-	game.isarmed = ja()
-    elif key == &quot;IHREAL&quot;:		# first element of course
-        scanner.push(scanner.token)
-    try:
-        game.probe = getcourse(isprobe=True)
-    except TrekError:
-        return
-    game.nprobes -= 1
-    schedule(FDSPROB, 0.01) # Time to move one sector
-    prout(_(&quot;Ensign Chekov-  \&quot;The deep space probe is launched, Captain.\&quot;&quot;))
-    game.ididit = True
-    return
-
-def mayday():
-    &quot;Yell for help from nearest starbase.&quot;
-    # There's more than one way to move in this game! 
-    scanner.chew()
-    # Test for conditions which prevent calling for help 
-    if game.condition == &quot;docked&quot;:
-	prout(_(&quot;Lt. Uhura-  \&quot;But Captain, we're already docked.\&quot;&quot;))
-	return
-    if damaged(DRADIO):
-	prout(_(&quot;Subspace radio damaged.&quot;))
-	return
-    if not game.state.baseq:
-	prout(_(&quot;Lt. Uhura-  \&quot;Captain, I'm not getting any response from Starbase.\&quot;&quot;))
-	return
-    if game.landed:
-	prout(_(&quot;You must be aboard the %s.&quot;) % crmshp())
-	return
-    # OK -- call for help from nearest starbase 
-    game.nhelp += 1
-    if game.base.i!=0:
-	# There's one in this quadrant 
-	ddist = (game.base - game.sector).distance()
-    else:
-	ddist = FOREVER
-        for ibq in game.state.baseq:
-	    xdist = QUADSIZE * (ibq - game.quadrant).distance()
-	    if xdist &lt; ddist:
-		ddist = xdist
-	# Since starbase not in quadrant, set up new quadrant 
-	game.quadrant = ibq
-	newqad()
-    # dematerialize starship 
-    game.quad[game.sector.i][game.sector.j]='.'
-    proutn(_(&quot;Starbase in Quadrant %s responds--%s dematerializes&quot;) \
-           % (game.quadrant, crmshp()))
-    game.sector.invalidate()
-    for m in range(1, 5+1):
-        w = game.base.scatter() 
-	if w.valid_sector() and game.quad[w.i][w.j]=='.':
-	    # found one -- finish up 
-            game.sector = w
-	    break
-    if not game.sector.is_valid():
-	prout(_(&quot;You have been lost in space...&quot;))
-	finish(FMATERIALIZE)
-	return
-    # Give starbase three chances to rematerialize starship 
-    probf = math.pow((1.0 - math.pow(0.98,ddist)), 0.33333333)
-    for m in range(1, 3+1):
-	if m == 1: proutn(_(&quot;1st&quot;))
-	elif m == 2: proutn(_(&quot;2nd&quot;))
-	elif m == 3: proutn(_(&quot;3rd&quot;))
-	proutn(_(&quot; attempt to re-materialize &quot;) + crmshp())
-	game.quad[ix][iy]=('-','o','O')[m-1]
-        textcolor(RED)
-	warble()
-	if randreal() &gt; probf:
-	    break
-	prout(_(&quot;fails.&quot;))
-        textcolor(DEFAULT)
-	curses.delay_output(500)
-    if m &gt; 3:
-	game.quad[ix][iy]='?'
-	game.alive = False
-	drawmaps(1)
-	setwnd(message_window)
-	finish(FMATERIALIZE)
-	return
-    game.quad[ix][iy]=game.ship
-    textcolor(GREEN);
-    prout(_(&quot;succeeds.&quot;))
-    textcolor(DEFAULT);
-    dock(False)
-    skip(1)
-    prout(_(&quot;Lt. Uhura-  \&quot;Captain, we made it!\&quot;&quot;))
-
-def abandon():
-    &quot;Abandon ship.&quot;
-    scanner.chew()
-    if game.condition==&quot;docked&quot;:
-	if game.ship!='E':
-	    prout(_(&quot;You cannot abandon Ye Faerie Queene.&quot;))
-	    return
-    else:
-	# Must take shuttle craft to exit 
-	if game.damage[DSHUTTL]==-1:
-	    prout(_(&quot;Ye Faerie Queene has no shuttle craft.&quot;))
-	    return
-	if game.damage[DSHUTTL]&lt;0:
-	    prout(_(&quot;Shuttle craft now serving Big Macs.&quot;))
-	    return
-	if game.damage[DSHUTTL]&gt;0:
-	    prout(_(&quot;Shuttle craft damaged.&quot;))
-	    return
-	if game.landed:
-	    prout(_(&quot;You must be aboard the ship.&quot;))
-	    return
-	if game.iscraft != &quot;onship&quot;:
-	    prout(_(&quot;Shuttle craft not currently available.&quot;))
-	    return
-	# Emit abandon ship messages 
-	skip(1)
-	prouts(_(&quot;***ABANDON SHIP!  ABANDON SHIP!&quot;))
-	skip(1)
-	prouts(_(&quot;***ALL HANDS ABANDON SHIP!&quot;))
-	skip(2)
-	prout(_(&quot;Captain and crew escape in shuttle craft.&quot;))
-	if not game.state.baseq:
-	    # Oops! no place to go... 
-	    finish(FABANDN)
-	    return
-	q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
-	# Dispose of crew 
-	if not (game.options &amp; OPTION_WORLDS) and not damaged(DTRANSP):
-	    prout(_(&quot;Remainder of ship's complement beam down&quot;))
-	    prout(_(&quot;to nearest habitable planet.&quot;))
-	elif q.planet != None and not damaged(DTRANSP):
-	    prout(_(&quot;Remainder of ship's complement beam down to %s.&quot;) %
-		    q.planet)
-	else:
-	    prout(_(&quot;Entire crew of %d left to die in outer space.&quot;) %
-		    game.state.crew)
-	    game.casual += game.state.crew
-	    game.abandoned += game.state.crew
-	# If at least one base left, give 'em the Faerie Queene 
-	skip(1)
-	game.icrystl = False # crystals are lost 
-	game.nprobes = 0 # No probes 
-	prout(_(&quot;You are captured by Klingons and released to&quot;))
-	prout(_(&quot;the Federation in a prisoner-of-war exchange.&quot;))
-	nb = randrange(len(game.state.baseq))
-	# Set up quadrant and position FQ adjacient to base 
-	if not game.quadrant == game.state.baseq[nb]:
-	    game.quadrant = game.state.baseq[nb]
-	    game.sector.i = game.sector.j = 5
-	    newqad()
-	while True:
-	    # position next to base by trial and error 
-	    game.quad[game.sector.i][game.sector.j] = '.'
-	    for l in range(QUADSIZE):
-		game.sector = game.base.scatter()
-		if game.sector.valid_sector() and \
-                       game.quad[game.sector.i][game.sector.j] == '.':
-                    break
-	    if l &lt; QUADSIZE+1:
-		break # found a spot 
-	    game.sector.i=QUADSIZE/2
-	    game.sector.j=QUADSIZE/2
-	    newqad()
-    # Get new commission 
-    game.quad[game.sector.i][game.sector.j] = game.ship = 'F'
-    game.state.crew = FULLCREW
-    prout(_(&quot;Starfleet puts you in command of another ship,&quot;))
-    prout(_(&quot;the Faerie Queene, which is antiquated but,&quot;))
-    prout(_(&quot;still useable.&quot;))
-    if game.icrystl:
-	prout(_(&quot;The dilithium crystals have been moved.&quot;))
-    game.imine = False
-    game.iscraft = &quot;offship&quot; # Galileo disappears 
-    # Resupply ship 
-    game.condition=&quot;docked&quot;
-    for l in range(NDEVICES): 
-	game.damage[l] = 0.0
-    game.damage[DSHUTTL] = -1
-    game.energy = game.inenrg = 3000.0
-    game.shield = game.inshld = 1250.0
-    game.torps = game.intorps = 6
-    game.lsupres=game.inlsr=3.0
-    game.shldup=False
-    game.warpfac=5.0
-    return
-
-# Code from planets.c begins here.
-
-def consumeTime():
-    &quot;Abort a lengthy operation if an event interrupts it.&quot; 
-    game.ididit = True
-    events()
-    if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.justin: 
-	return True
-    return False
-
-def survey():
-    &quot;Report on (uninhabited) planets in the galaxy.&quot;
-    iknow = False
-    skip(1)
-    scanner.chew()
-    prout(_(&quot;Spock-  \&quot;Planet report follows, Captain.\&quot;&quot;))
-    skip(1)
-    for i in range(game.inplan):
-	if game.state.planets[i].pclass == &quot;destroyed&quot;:
-	    continue
-	if (game.state.planets[i].known != &quot;unknown&quot; \
-            and not game.state.planets[i].inhabited) \
-            or idebug:
-	    iknow = True
-	    if idebug and game.state.planets[i].known==&quot;unknown&quot;:
-		proutn(&quot;(Unknown) &quot;)
-	    proutn(_(&quot;Quadrant %s&quot;) % game.state.planets[i].quadrant)
-	    proutn(_(&quot;   class &quot;))
-	    proutn(game.state.planets[i].pclass)
-	    proutn(&quot;   &quot;)
-	    if game.state.planets[i].crystals != present:
-		proutn(_(&quot;no &quot;))
-	    prout(_(&quot;dilithium crystals present.&quot;))
-	    if game.state.planets[i].known==&quot;shuttle_down&quot;: 
-		prout(_(&quot;    Shuttle Craft Galileo on surface.&quot;))
-    if not iknow:
-	prout(_(&quot;No information available.&quot;))
-
-def orbit():
-    &quot;Enter standard orbit.&quot; 
-    skip(1)
-    scanner.chew()
-    if game.inorbit:
-	prout(_(&quot;Already in standard orbit.&quot;))
-	return
-    if damaged(DWARPEN) and damaged(DIMPULS):
-	prout(_(&quot;Both warp and impulse engines damaged.&quot;))
-	return
-    if not game.plnet.is_valid():
-        prout(&quot;There is no planet in this sector.&quot;)
-        return
-    if abs(game.sector.i-game.plnet.i)&gt;1 or abs(game.sector.j-game.plnet.j)&gt;1:
-	prout(crmshp() + _(&quot; not adjacent to planet.&quot;))
-	skip(1)
-	return
-    game.optime = randreal(0.02, 0.05)
-    prout(_(&quot;Helmsman Sulu-  \&quot;Entering standard orbit, Sir.\&quot;&quot;))
-    newcnd()
-    if consumeTime():
-	return
-    game.height = randreal(1400, 8600)
-    prout(_(&quot;Sulu-  \&quot;Entered orbit at altitude %.2f kilometers.\&quot;&quot;) % game.height)
-    game.inorbit = True
-    game.ididit = True
-
-def sensor():
-    &quot;Examine planets in this quadrant.&quot;
-    if damaged(DSRSENS):
-	if game.options &amp; OPTION_TTY:
-	    prout(_(&quot;Short range sensors damaged.&quot;))
-	return
-    if game.iplnet == None:
-	if game.options &amp; OPTION_TTY:
-	    prout(_(&quot;Spock- \&quot;No planet in this quadrant, Captain.\&quot;&quot;))
-	return
-    if game.iplnet.known == &quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Sensor scan for Quadrant %s-&quot;) % game.quadrant)
-	skip(1)
-	prout(_(&quot;         Planet at Sector %s is of class %s.&quot;) %
-	      (game.plnet, game.iplnet.pclass))
-	if game.iplnet.known==&quot;shuttle_down&quot;: 
-	    prout(_(&quot;         Sensors show Galileo still on surface.&quot;))
-	proutn(_(&quot;         Readings indicate&quot;))
-	if game.iplnet.crystals != &quot;present&quot;:
-	    proutn(_(&quot; no&quot;))
-	prout(_(&quot; dilithium crystals present.\&quot;&quot;))
-	if game.iplnet.known == &quot;unknown&quot;:
-	    game.iplnet.known = &quot;known&quot;
-    elif game.iplnet.inhabited:
-        prout(_(&quot;Spock-  \&quot;The inhabited planet %s &quot;) % game.iplnet.name)
-        prout(_(&quot;        is located at Sector %s, Captain.\&quot;&quot;) % game.plnet)
-
-def beam():
-    &quot;Use the transporter.&quot;
-    nrgneed = 0
-    scanner.chew()
-    skip(1)
-    if damaged(DTRANSP):
-	prout(_(&quot;Transporter damaged.&quot;))
-	if not damaged(DSHUTTL) and (game.iplnet.known==&quot;shuttle_down&quot; or game.iscraft == &quot;onship&quot;):
-	    skip(1)
-	    proutn(_(&quot;Spock-  \&quot;May I suggest the shuttle craft, Sir?\&quot; &quot;))
-	    if ja() == True:
-		shuttle()
-	return
-    if not game.inorbit:
-	prout(crmshp() + _(&quot; not in standard orbit.&quot;))
-	return
-    if game.shldup:
-	prout(_(&quot;Impossible to transport through shields.&quot;))
-	return
-    if game.iplnet.known==&quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
-	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
-	prout(_(&quot;  you may not go down.\&quot;&quot;))
-	return
-    if not game.landed and game.iplnet.crystals==&quot;absent&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, I fail to see the logic in&quot;))
-	prout(_(&quot;  exploring a planet with no dilithium crystals.&quot;))
-	proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-	if ja() == False:
-	    scanner.chew()
-	    return
-    if not (game.options &amp; OPTION_PLAIN):
-	nrgneed = 50 * game.skill + game.height / 100.0
-	if nrgneed &gt; game.energy:
-    	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Captain, we don't have enough energy for transportation.&quot;))
-	    return
-	if not game.landed and nrgneed * 2 &gt; game.energy:
-    	    prout(_(&quot;Engineering to bridge--&quot;))
-	    prout(_(&quot;  Captain, we have enough energy only to transport you down to&quot;))
-	    prout(_(&quot;  the planet, but there wouldn't be an energy for the trip back.&quot;))
-	    if game.iplnet.known == &quot;shuttle_down&quot;:
-		prout(_(&quot;  Although the Galileo shuttle craft may still be on a surface.&quot;))
-	    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-	    if ja() == False:
-		scanner.chew()
-		return
-    if game.landed:
-	# Coming from planet 
-	if game.iplnet.known==&quot;shuttle_down&quot;:
-	    proutn(_(&quot;Spock-  \&quot;Wouldn't you rather take the Galileo?\&quot; &quot;))
-	    if ja() == True:
-		scanner.chew()
-		return
-	    prout(_(&quot;Your crew hides the Galileo to prevent capture by aliens.&quot;))
-	prout(_(&quot;Landing party assembled, ready to beam up.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk whips out communicator...&quot;))
-	prouts(_(&quot;BEEP  BEEP  BEEP&quot;))
-	skip(2)
-	prout(_(&quot;\&quot;Kirk to enterprise-  Lock on coordinates...energize.\&quot;&quot;))
-    else:
-	# Going to planet 
-	prout(_(&quot;Scotty-  \&quot;Transporter room ready, Sir.\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Kirk and landing party prepare to beam down to planet surface.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk-  \&quot;Energize.\&quot;&quot;))
-    game.ididit = True
-    skip(1)
-    prouts(&quot;WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .&quot;)
-    skip(2)
-    if withprob(0.98):
-	prouts(&quot;BOOOIIIOOOIIOOOOIIIOIING . . .&quot;)
-	skip(2)
-	prout(_(&quot;Scotty-  \&quot;Oh my God!  I've lost them.\&quot;&quot;))
-	finish(FLOST)
-	return
-    prouts(&quot;.    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW&quot;)
-    game.landed = not game.landed
-    game.energy -= nrgneed
-    skip(2)
-    prout(_(&quot;Transport complete.&quot;))
-    if game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
-	prout(_(&quot;The shuttle craft Galileo is here!&quot;))
-    if not game.landed and game.imine:
-	game.icrystl = True
-	game.cryprob = 0.05
-    game.imine = False
-    return
-
-def mine():
-    &quot;Strip-mine a world for dilithium.&quot;
-    skip(1)
-    scanner.chew()
-    if not game.landed:
-	prout(_(&quot;Mining party not on planet.&quot;))
-	return
-    if game.iplnet.crystals == &quot;mined&quot;:
-	prout(_(&quot;This planet has already been strip-mined for dilithium.&quot;))
-	return
-    elif game.iplnet.crystals == &quot;absent&quot;:
-	prout(_(&quot;No dilithium crystals on this planet.&quot;))
-	return
-    if game.imine:
-	prout(_(&quot;You've already mined enough crystals for this trip.&quot;))
-	return
-    if game.icrystl and game.cryprob == 0.05:
-	prout(_(&quot;With all those fresh crystals aboard the &quot;) + crmshp())
-	prout(_(&quot;there's no reason to mine more at this time.&quot;))
-	return
-    game.optime = randreal(0.1, 0.3)*(ord(game.iplnet.pclass)-ord(&quot;L&quot;))
-    if consumeTime():
-	return
-    prout(_(&quot;Mining operation complete.&quot;))
-    game.iplnet.crystals = &quot;mined&quot;
-    game.imine = game.ididit = True
-
-def usecrystals():
-    &quot;Use dilithium crystals.&quot;
-    game.ididit = False
-    skip(1)
-    scanner.chew()
-    if not game.icrystl:
-	prout(_(&quot;No dilithium crystals available.&quot;))
-	return
-    if game.energy &gt;= 1000:
-	prout(_(&quot;Spock-  \&quot;Captain, Starfleet Regulations prohibit such an operation&quot;))
-	prout(_(&quot;  except when Condition Yellow exists.&quot;))
-	return
-    prout(_(&quot;Spock- \&quot;Captain, I must warn you that loading&quot;))
-    prout(_(&quot;  raw dilithium crystals into the ship's power&quot;))
-    prout(_(&quot;  system may risk a severe explosion.&quot;))
-    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
-    if ja() == False:
-	scanner.chew()
-	return
-    skip(1)
-    prout(_(&quot;Engineering Officer Scott-  \&quot;(GULP) Aye Sir.&quot;))
-    prout(_(&quot;  Mr. Spock and I will try it.\&quot;&quot;))
-    skip(1)
-    prout(_(&quot;Spock-  \&quot;Crystals in place, Sir.&quot;))
-    prout(_(&quot;  Ready to activate circuit.\&quot;&quot;))
-    skip(1)
-    prouts(_(&quot;Scotty-  \&quot;Keep your fingers crossed, Sir!\&quot;&quot;))
-    skip(1)
-    if withprob(game.cryprob):
-	prouts(_(&quot;  \&quot;Activating now! - - No good!  It's***&quot;))
-	skip(2)
-	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
-	skip(1)
-	stars()
-	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
-	skip(1)
-	kaboom()
-	return
-    game.energy += randreal(5000.0, 5500.0)
-    prouts(_(&quot;  \&quot;Activating now! - - &quot;))
-    prout(_(&quot;The instruments&quot;))
-    prout(_(&quot;   are going crazy, but I think it's&quot;))
-    prout(_(&quot;   going to work!!  Congratulations, Sir!\&quot;&quot;))
-    game.cryprob *= 2.0
-    game.ididit = True
-
-def shuttle():
-    &quot;Use shuttlecraft for planetary jaunt.&quot;
-    scanner.chew()
-    skip(1)
-    if damaged(DSHUTTL):
-	if game.damage[DSHUTTL] == -1.0:
-	    if game.inorbit and game.iplnet.known == &quot;shuttle_down&quot;:
-		prout(_(&quot;Ye Faerie Queene has no shuttle craft bay to dock it at.&quot;))
-	    else:
-		prout(_(&quot;Ye Faerie Queene had no shuttle craft.&quot;))
-	elif game.damage[DSHUTTL] &gt; 0:
-	    prout(_(&quot;The Galileo is damaged.&quot;))
-	else: # game.damage[DSHUTTL] &lt; 0  
-	    prout(_(&quot;Shuttle craft is now serving Big Macs.&quot;))
-	return
-    if not game.inorbit:
-	prout(crmshp() + _(&quot; not in standard orbit.&quot;))
-	return
-    if (game.iplnet.known != &quot;shuttle_down&quot;) and game.iscraft != &quot;onship&quot;:
-	prout(_(&quot;Shuttle craft not currently available.&quot;))
-	return
-    if not game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
-	prout(_(&quot;You will have to beam down to retrieve the shuttle craft.&quot;))
-	return
-    if game.shldup or game.condition == &quot;docked&quot;:
-	prout(_(&quot;Shuttle craft cannot pass through shields.&quot;))
-	return
-    if game.iplnet.known==&quot;unknown&quot;:
-	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
-	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
-	prout(_(&quot;  you may not fly down.\&quot;&quot;))
-	return
-    game.optime = 3.0e-5*game.height
-    if game.optime &gt;= 0.8*game.state.remtime:
-	prout(_(&quot;First Officer Spock-  \&quot;Captain, I compute that such&quot;))
-	proutn(_(&quot;  a maneuver would require approximately %2d%% of our&quot;) % \
-	       int(100*game.optime/game.state.remtime))
-	prout(_(&quot;remaining time.&quot;))
-	proutn(_(&quot;Are you sure this is wise?\&quot; &quot;))
-	if ja() == False:
-	    game.optime = 0.0
-	    return
-    if game.landed:
-	# Kirk on planet 
-	if game.iscraft == &quot;onship&quot;:
-	    # Galileo on ship! 
-	    if not damaged(DTRANSP):
-		proutn(_(&quot;Spock-  \&quot;Would you rather use the transporter?\&quot; &quot;))
-		if ja() == True:
-		    beam()
-		    return
-		proutn(_(&quot;Shuttle crew&quot;))
-	    else:
-		proutn(_(&quot;Rescue party&quot;))
-	    prout(_(&quot; boards Galileo and swoops toward planet surface.&quot;))
-	    game.iscraft = &quot;offship&quot;
-	    skip(1)
-	    if consumeTime():
-		return
-	    game.iplnet.known=&quot;shuttle_down&quot;
-	    prout(_(&quot;Trip complete.&quot;))
-	    return
-	else:
-	    # Ready to go back to ship 
-	    prout(_(&quot;You and your mining party board the&quot;))
-	    prout(_(&quot;shuttle craft for the trip back to the Enterprise.&quot;))
-	    skip(1)
-	    prouts(_(&quot;The short hop begins . . .&quot;))
-	    skip(1)
-	    game.iplnet.known=&quot;known&quot;
-	    game.icraft = True
-	    skip(1)
-	    game.landed = False
-	    if consumeTime():
-		return
-	    game.iscraft = &quot;onship&quot;
-	    game.icraft = False
-	    if game.imine:
-		game.icrystl = True
-		game.cryprob = 0.05
-	    game.imine = False
-	    prout(_(&quot;Trip complete.&quot;))
-	    return
-    else:
-	# Kirk on ship and so is Galileo 
-	prout(_(&quot;Mining party assembles in the hangar deck,&quot;))
-	prout(_(&quot;ready to board the shuttle craft \&quot;Galileo\&quot;.&quot;))
-	skip(1)
-	prouts(_(&quot;The hangar doors open; the trip begins.&quot;))
-	skip(1)
-	game.icraft = True
-	game.iscraft = &quot;offship&quot;
-	if consumeTime():
-	    return
-	game.iplnet.known = &quot;shuttle_down&quot;
-	game.landed = True
-	game.icraft = False
-	prout(_(&quot;Trip complete.&quot;))
-	return
-
-def deathray():
-    &quot;Use the big zapper.&quot;
-    game.ididit = False
-    skip(1)
-    scanner.chew()
-    if game.ship != 'E':
-	prout(_(&quot;Ye Faerie Queene has no death ray.&quot;))
-	return
-    if len(game.enemies)==0:
-	prout(_(&quot;Sulu-  \&quot;But Sir, there are no enemies in this quadrant.\&quot;&quot;))
-	return
-    if damaged(DDRAY):
-	prout(_(&quot;Death Ray is damaged.&quot;))
-	return
-    prout(_(&quot;Spock-  \&quot;Captain, the 'Experimental Death Ray'&quot;))
-    prout(_(&quot;  is highly unpredictible.  Considering the alternatives,&quot;))
-    proutn(_(&quot;  are you sure this is wise?\&quot; &quot;))
-    if ja() == False:
-	return
-    prout(_(&quot;Spock-  \&quot;Acknowledged.\&quot;&quot;))
-    skip(1)
-    game.ididit = True
-    prouts(_(&quot;WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE&quot;))
-    skip(1)
-    prout(_(&quot;Crew scrambles in emergency preparation.&quot;))
-    prout(_(&quot;Spock and Scotty ready the death ray and&quot;))
-    prout(_(&quot;prepare to channel all ship's power to the device.&quot;))
-    skip(1)
-    prout(_(&quot;Spock-  \&quot;Preparations complete, sir.\&quot;&quot;))
-    prout(_(&quot;Kirk-  \&quot;Engage!\&quot;&quot;))
-    skip(1)
-    prouts(_(&quot;WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&quot;))
-    skip(1)
-    dprob = 0.30
-    if game.options &amp; OPTION_PLAIN:
-	dprob = 0.5
-    r = randreal()
-    if r &gt; dprob:
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
-	skip(2)
-	while len(game.enemies) &gt; 0:
-	    deadkl(game.enemies[1].location, game.quad[game.enemies[1].location.i][game.enemies[1].location.j],game.enemies[1].location)
-	prout(_(&quot;Ensign Chekov-  \&quot;Congratulations, Captain!\&quot;&quot;))
-	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) == 0:
-	    finish(FWON)    
-	if (game.options &amp; OPTION_PLAIN) == 0:
-	    prout(_(&quot;Spock-  \&quot;Captain, I believe the `Experimental Death Ray'&quot;))
-	    if withprob(0.05):
-		prout(_(&quot;   is still operational.\&quot;&quot;))
-	    else:
-		prout(_(&quot;   has been rendered nonfunctional.\&quot;&quot;))
-		game.damage[DDRAY] = 39.95
-	return
-    r = randreal()	# Pick failure method 
-    if r &lt;= 0.30:
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
-	skip(1)
-	prout(_(&quot;***MATTER-ANTIMATTER IMPLOSION IMMINENT!&quot;))
-	skip(1)
-	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
-	skip(1)
-	stars()
-	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
-	skip(1)
-	kaboom()
-	return
-    if r &lt;= 0.55:
-	prouts(_(&quot;Sulu- \&quot;Captain!  Yagabandaghangrapl, brachriigringlanbla!\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Lt. Uhura-  \&quot;Graaeek!  Graaeek!\&quot;&quot;))
-	skip(1)
-	prout(_(&quot;Spock-  \&quot;Fascinating!  . . . All humans aboard&quot;))
-	prout(_(&quot;  have apparently been transformed into strange mutations.&quot;))
-	prout(_(&quot;  Vulcans do not seem to be affected.&quot;))
-	skip(1)
-	prout(_(&quot;Kirk-  \&quot;Raauch!  Raauch!\&quot;&quot;))
-	finish(FDRAY)
-	return
-    if r &lt;= 0.75:
-	intj
-	prouts(_(&quot;Sulu- \&quot;Captain!  It's   --WHAT?!?!\&quot;&quot;))
-	skip(2)
-	proutn(_(&quot;Spock-  \&quot;I believe the word is&quot;))
-	prouts(_(&quot; *ASTONISHING*&quot;))
-	prout(_(&quot; Mr. Sulu.&quot;))
-	for i in range(QUADSIZE):
-	    for j in range(QUADSIZE):
-		if game.quad[i][j] == '.':
-		    game.quad[i][j] = '?'
-	prout(_(&quot;  Captain, our quadrant is now infested with&quot;))
-	prouts(_(&quot; - - - - - -  *THINGS*.&quot;))
-	skip(1)
-	prout(_(&quot;  I have no logical explanation.\&quot;&quot;))
-	return
-    prouts(_(&quot;Sulu- \&quot;Captain!  The Death Ray is creating tribbles!\&quot;&quot;))
-    skip(1)
-    prout(_(&quot;Scotty-  \&quot;There are so many tribbles down here&quot;))
-    prout(_(&quot;  in Engineering, we can't move for 'em, Captain.\&quot;&quot;))
-    finish(FTRIBBLE)
-    return
-
-# Code from reports.c begins here
-
-def attackreport(curt):
-    &quot;eport status of bases under attack.&quot;
-    if not curt:
-	if is_scheduled(FCDBAS):
-	    prout(_(&quot;Starbase in Quadrant %s is currently under Commander attack.&quot;) % game.battle)
-	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FCDBAS)))
-	elif game.isatb == 1:
-	    prout(_(&quot;Starbase in Quadrant %s is under Super-commander attack.&quot;) % game.state.kscmdr)
-	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FSCDBAS)))
-	else:
-	    prout(_(&quot;No Starbase is currently under attack.&quot;))
-    else:
-        if is_scheduled(FCDBAS):
-	    proutn(_(&quot;Base in %s attacked by C. Alive until %.1f&quot;) % (game.battle, scheduled(FCDBAS)))
-        if game.isatb:
-	    proutn(_(&quot;Base in %s attacked by S. Alive until %.1f&quot;) % (game.state.kscmdr, scheduled(FSCDBAS)))
-	clreol()
-
-def report():
-    # report on general game status 
-    scanner.chew()
-    s1 = &quot;&quot; and game.thawed and _(&quot;thawed &quot;)
-    s2 = {1:&quot;short&quot;, 2:&quot;medium&quot;, 4:&quot;long&quot;}[game.length]
-    s3 = (None, _(&quot;novice&quot;), _(&quot;fair&quot;),
-          _(&quot;good&quot;), _(&quot;expert&quot;), _(&quot;emeritus&quot;))[game.skill]
-    prout(_(&quot;You %s a %s%s %s game.&quot;) % ((_(&quot;were playing&quot;), _(&quot;are playing&quot;))[game.alldone], s1, s2, s3))
-    if game.skill&gt;SKILL_GOOD and game.thawed and not game.alldone:
-	prout(_(&quot;No plaque is allowed.&quot;))
-    if game.tourn:
-	prout(_(&quot;This is tournament game %d.&quot;) % game.tourn)
-    prout(_(&quot;Your secret password is \&quot;%s\&quot;&quot;) % game.passwd)
-    proutn(_(&quot;%d of %d Klingons have been killed&quot;) % (((game.inkling + game.incom + game.inscom) - (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)), 
-	   (game.inkling + game.incom + game.inscom)))
-    if game.incom - len(game.state.kcmdr):
-	prout(_(&quot;, including %d Commander%s.&quot;) % (game.incom - len(game.state.kcmdr), (_(&quot;s&quot;), &quot;&quot;)[(game.incom - len(game.state.kcmdr))==1]))
-    elif game.inkling - game.state.remkl + (game.inscom - game.state.nscrem) &gt; 0:
-	prout(_(&quot;, but no Commanders.&quot;))
-    else:
-	prout(&quot;.&quot;)
-    if game.skill &gt; SKILL_FAIR:
-	prout(_(&quot;The Super Commander has %sbeen destroyed.&quot;) % (&quot;&quot;, _(&quot;not &quot;))[game.state.nscrem])
-    if len(game.state.baseq) != game.inbase:
-	proutn(_(&quot;There &quot;))
-	if game.inbase-len(game.state.baseq)==1:
-	    proutn(_(&quot;has been 1 base&quot;))
-	else:
-	    proutn(_(&quot;have been %d bases&quot;) % (game.inbase-len(game.state.baseq)))
-	prout(_(&quot; destroyed, %d remaining.&quot;) % len(game.state.baseq))
-    else:
-	prout(_(&quot;There are %d bases.&quot;) % game.inbase)
-    if communicating() or game.iseenit:
-	# Don't report this if not seen and
-	# either the radio is dead or not at base!
-	attackreport(False)
-	game.iseenit = True
-    if game.casual: 
-	prout(_(&quot;%d casualt%s suffered so far.&quot;) % (game.casual, (&quot;y&quot;, &quot;ies&quot;)[game.casual!=1]))
-    if game.nhelp:
-	prout(_(&quot;There were %d call%s for help.&quot;) % (game.nhelp,  (&quot;&quot; , _(&quot;s&quot;))[game.nhelp!=1]))
-    if game.ship == 'E':
-	proutn(_(&quot;You have &quot;))
-	if game.nprobes:
-	    proutn(&quot;%d&quot; % (game.nprobes))
-	else:
-	    proutn(_(&quot;no&quot;))
-	proutn(_(&quot; deep space probe&quot;))
-	if game.nprobes!=1:
-	    proutn(_(&quot;s&quot;))
-	prout(&quot;.&quot;)
-    if communicating() and is_scheduled(FDSPROB):
-	if game.isarmed: 
-	    proutn(_(&quot;An armed deep space probe is in &quot;))
-	else:
-	    proutn(_(&quot;A deep space probe is in &quot;))
-	prout(&quot;Quadrant %s.&quot; % game.probec)
-    if game.icrystl:
-	if game.cryprob &lt;= .05:
-	    prout(_(&quot;Dilithium crystals aboard ship... not yet used.&quot;))
-	else:
-	    i=0
-	    ai = 0.05
-	    while game.cryprob &gt; ai:
-		ai *= 2.0
-		i += 1
-	    prout(_(&quot;Dilithium crystals have been used %d time%s.&quot;) % \
-                  (i, (_(&quot;s&quot;), &quot;&quot;)[i==1]))
-    skip(1)
-	
-def lrscan(silent):
-    &quot;Long-range sensor scan.&quot;
-    if damaged(DLRSENS):
-	# Now allow base's sensors if docked 
-	if game.condition != &quot;docked&quot;:
-            if not silent:
-                prout(_(&quot;LONG-RANGE SENSORS DAMAGED.&quot;))
-	    return
-        if not silent:
-            prout(_(&quot;Starbase's long-range scan&quot;))
-    elif not silent:
-	prout(_(&quot;Long-range scan&quot;))
-    for x in range(game.quadrant.i-1, game.quadrant.i+2):
-        if not silent:
-            proutn(&quot; &quot;)
-        for y in range(game.quadrant.j-1, game.quadrant.j+2):
-	    if not coord(x, y).valid_quadrant():
-                if not silent:
-                    proutn(&quot;  -1&quot;)
-	    else:
-		if not damaged(DRADIO):
-		    game.state.galaxy[x][y].charted = True
-		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons
-		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase
-		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars
-		if not silent and game.state.galaxy[x][y].supernova: 
-		    proutn(&quot; ***&quot;)
-		elif not silent:
-		    proutn(&quot; %3d&quot; % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
-	if not silent:
-	    prout(&quot; &quot;)
-
-def damagereport():
-    &quot;Damage report.&quot;
-    jdam = False
-    scanner.chew()
-    for i in range(NDEVICES):
-	if damaged(i):
-	    if not jdam:
-		prout(_(&quot;\tDEVICE\t\t\t-REPAIR TIMES-&quot;))
-		prout(_(&quot;\t\t\tIN FLIGHT\t\tDOCKED&quot;))
-		jdam = True
-	    prout(&quot;  %-26s\t%8.2f\t\t%8.2f&quot; % (device[i],
-                                               game.damage[i]+0.05,
-                                               DOCKFAC*game.damage[i]+0.005))
-    if not jdam:
-	prout(_(&quot;All devices functional.&quot;))
-
-def rechart():
-    &quot;Update the chart in the Enterprise's computer from galaxy data.&quot;
-    game.lastchart = game.state.date
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    if game.state.galaxy[i][j].charted:
-		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons
-		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase
-		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars
-
-def chart():
-    &quot;Display the star chart.&quot;
-    scanner.chew()
-    if (game.options &amp; OPTION_AUTOSCAN):
-        lrscan(silent=True)
-    if not damaged(DRADIO):
-	rechart()
-    if game.lastchart &lt; game.state.date and game.condition == &quot;docked&quot;:
-	prout(_(&quot;Spock-  \&quot;I revised the Star Chart from the starbase's records.\&quot;&quot;))
-	rechart()
-    prout(_(&quot;       STAR CHART FOR THE KNOWN GALAXY&quot;))
-    if game.state.date &gt; game.lastchart:
-	prout(_(&quot;(Last surveillance update %d stardates ago).&quot;) % ((int)(game.state.date-game.lastchart)))
-    prout(&quot;      1    2    3    4    5    6    7    8&quot;)
-    for i in range(GALSIZE):
-	proutn(&quot;%d |&quot; % (i+1))
-	for j in range(GALSIZE):
-	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
-		proutn(&quot;&lt;&quot;)
-	    else:
-		proutn(&quot; &quot;)
-	    if game.state.galaxy[i][j].supernova:
-		show = &quot;***&quot;
-	    elif not game.state.galaxy[i][j].charted and game.state.galaxy[i][j].starbase:
-		show = &quot;.1.&quot;
-	    elif game.state.galaxy[i][j].charted:
-		show = &quot;%3d&quot; % (game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars)
-	    else:
-		show = &quot;...&quot;
-	    proutn(show)
-	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
-		proutn(&quot;&gt;&quot;)
-	    else:
-		proutn(&quot; &quot;)
-	proutn(&quot;  |&quot;)
-	if i&lt;GALSIZE:
-	    skip(1)
-
-def sectscan(goodScan, i, j):
-    &quot;Light up an individual dot in a sector.&quot;
-    if goodScan or (abs(i-game.sector.i)&lt;= 1 and abs(j-game.sector.j) &lt;= 1):
-        textcolor({&quot;green&quot;:GREEN,
-                   &quot;yellow&quot;:YELLOW,
-                   &quot;red&quot;:RED,
-                   &quot;docked&quot;:CYAN,
-                   &quot;dead&quot;:BROWN}[game.condition]) 
-        if game.quad[i][j] != game.ship: 
-            highvideo();
-	proutn(&quot;%c &quot; % game.quad[i][j])
-        textcolor(DEFAULT)
-    else:
-	proutn(&quot;- &quot;)
-
-def status(req=0):
-    &quot;Emit status report lines&quot;
-    if not req or req == 1:
-	prstat(_(&quot;Stardate&quot;), _(&quot;%.1f, Time Left %.2f&quot;) \
-               % (game.state.date, game.state.remtime))
-    if not req or req == 2:
-	if game.condition != &quot;docked&quot;:
-	    newcnd()
-	prstat(_(&quot;Condition&quot;), _(&quot;%s, %i DAMAGES&quot;) % \
-               (game.condition.upper(), sum(map(lambda x: x &gt; 0, game.damage))))
-    if not req or req == 3:
-	prstat(_(&quot;Position&quot;), &quot;%s , %s&quot; % (game.quadrant, game.sector))
-    if not req or req == 4:
-	if damaged(DLIFSUP):
-	    if game.condition == &quot;docked&quot;:
-		s = _(&quot;DAMAGED, Base provides&quot;)
-	    else:
-		s = _(&quot;DAMAGED, reserves=%4.2f&quot;) % game.lsupres
-	else:
-	    s = _(&quot;ACTIVE&quot;)
-	prstat(_(&quot;Life Support&quot;), s)
-    if not req or req == 5:
-	prstat(_(&quot;Warp Factor&quot;), &quot;%.1f&quot; % game.warpfac)
-    if not req or req == 6:
-        extra = &quot;&quot;
-        if game.icrystl and (game.options &amp; OPTION_SHOWME):
-            extra = _(&quot; (have crystals)&quot;)
-	prstat(_(&quot;Energy&quot;), &quot;%.2f%s&quot; % (game.energy, extra))
-    if not req or req == 7:
-	prstat(_(&quot;Torpedoes&quot;), &quot;%d&quot; % (game.torps))
-    if not req or req == 8:
-	if damaged(DSHIELD):
-	    s = _(&quot;DAMAGED,&quot;)
-	elif game.shldup:
-	    s = _(&quot;UP,&quot;)
-	else:
-	    s = _(&quot;DOWN,&quot;)
-	data = _(&quot; %d%% %.1f units&quot;) \
-               % (int((100.0*game.shield)/game.inshld + 0.5), game.shield)
-	prstat(_(&quot;Shields&quot;), s+data)
-    if not req or req == 9:
-        prstat(_(&quot;Klingons Left&quot;), &quot;%d&quot; \
-               % (game.state.remkl+len(game.state.kcmdr)+game.state.nscrem))
-    if not req or req == 10:
-	if game.options &amp; OPTION_WORLDS:
-	    plnet = game.state.galaxy[game.quadrant.i][game.quadrant.j].planet
-	    if plnet and plnet.inhabited:
-		prstat(_(&quot;Major system&quot;), plnet.name)
-	    else:
-		prout(_(&quot;Sector is uninhabited&quot;))
-    elif not req or req == 11:
-	attackreport(not req)
-
-def request():
-    &quot;Request specified status data, a historical relic from slow TTYs.&quot;
-    requests = (&quot;da&quot;,&quot;co&quot;,&quot;po&quot;,&quot;ls&quot;,&quot;wa&quot;,&quot;en&quot;,&quot;to&quot;,&quot;sh&quot;,&quot;kl&quot;,&quot;sy&quot;, &quot;ti&quot;)
-    while scanner.next() == &quot;IHEOL&quot;:
-	proutn(_(&quot;Information desired? &quot;))
-    scanner.chew()
-    if scanner.token in requests:
-        status(requests.index(scanner.token))
-    else:
-	prout(_(&quot;UNRECOGNIZED REQUEST. Legal requests are:&quot;))
-	prout((&quot;  date, condition, position, lsupport, warpfactor,&quot;))
-	prout((&quot;  energy, torpedoes, shields, klingons, system, time.&quot;))
-		
-def srscan():
-    &quot;Short-range scan.&quot; 
-    goodScan=True
-    if damaged(DSRSENS):
-	# Allow base's sensors if docked 
-	if game.condition != &quot;docked&quot;:
-	    prout(_(&quot;   S.R. SENSORS DAMAGED!&quot;))
-	    goodScan=False
-	else:
-	    prout(_(&quot;  [Using Base's sensors]&quot;))
-    else:
-	prout(_(&quot;     Short-range scan&quot;))
-    if goodScan and not damaged(DRADIO): 
-	game.state.chart[game.quadrant.i][game.quadrant.j].klingons = game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons
-	game.state.chart[game.quadrant.i][game.quadrant.j].starbase = game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase
-	game.state.chart[game.quadrant.i][game.quadrant.j].stars = game.state.galaxy[game.quadrant.i][game.quadrant.j].stars
-	game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
-    prout(&quot;    1 2 3 4 5 6 7 8 9 10&quot;)
-    if game.condition != &quot;docked&quot;:
-	newcnd()
-    for i in range(QUADSIZE):
-	proutn(&quot;%2d  &quot; % (i+1))
-	for j in range(QUADSIZE):
-	    sectscan(goodScan, i, j)
-	skip(1)
-		
-def eta():
-    &quot;Use computer to get estimated time of arrival for a warp jump.&quot;
-    w1 = coord(); w2 = coord()
-    prompt = False
-    if damaged(DCOMPTR):
-	prout(_(&quot;COMPUTER DAMAGED, USE A POCKET CALCULATOR.&quot;))
-	skip(1)
-	return
-    if scanner.next() != &quot;IHREAL&quot;:
-	prompt = True
-	scanner.chew()
-	proutn(_(&quot;Destination quadrant and/or sector? &quot;))
-	if scanner.next()!=&quot;IHREAL&quot;:
-	    huh()
-	    return
-    w1.j = int(scanner.real-0.5)
-    if scanner.next() != &quot;IHREAL&quot;:
-	huh()
-	return
-    w1.i = int(scanner.real-0.5)
-    if scanner.next() == &quot;IHREAL&quot;:
-	w2.j = int(scanner.real-0.5)
-	if scanner.next() != &quot;IHREAL&quot;:
-	    huh()
-	    return
-	w2.i = int(scanner.real-0.5)
-    else:
-	if game.quadrant.j&gt;w1.i:
-	    w2.i = 0
-	else:
-	    w2.i=QUADSIZE-1
-	if game.quadrant.i&gt;w1.j:
-	    w2.j = 0
-	else:
-	    w2.j=QUADSIZE-1
-    if not w1.valid_quadrant() or not w2.valid_sector():
-	huh()
-	return
-    dist = math.sqrt((w1.j-game.quadrant.j+(w2.j-game.sector.j)/(QUADSIZE*1.0))**2+
-		(w1.i-game.quadrant.i+(w2.i-game.sector.i)/(QUADSIZE*1.0))**2)
-    wfl = False
-    if prompt:
-	prout(_(&quot;Answer \&quot;no\&quot; if you don't know the value:&quot;))
-    while True:
-	scanner.chew()
-	proutn(_(&quot;Time or arrival date? &quot;))
-	if scanner.next()==&quot;IHREAL&quot;:
-	    ttime = scanner.real
-	    if ttime &gt; game.state.date:
-		ttime -= game.state.date # Actually a star date
-            twarp=(math.floor(math.sqrt((10.0*dist)/ttime)*10.0)+1.0)/10.0
-            if ttime &lt;= 1e-10 or twarp &gt; 10:
-		prout(_(&quot;We'll never make it, sir.&quot;))
-		scanner.chew()
-		return
-	    if twarp &lt; 1.0:
-		twarp = 1.0
-	    break
-	scanner.chew()
-	proutn(_(&quot;Warp factor? &quot;))
-	if scanner.next()== &quot;IHREAL&quot;:
-	    wfl = True
-	    twarp = scanner.real
-	    if twarp&lt;1.0 or twarp &gt; 10.0:
-		huh()
-		return
-	    break
-	prout(_(&quot;Captain, certainly you can give me one of these.&quot;))
-    while True:
-	scanner.chew()
-	ttime = (10.0*dist)/twarp**2
-	tpower = dist*twarp*twarp*twarp*(game.shldup+1)
-	if tpower &gt;= game.energy:
-	    prout(_(&quot;Insufficient energy, sir.&quot;))
-	    if not game.shldup or tpower &gt; game.energy*2.0:
-		if not wfl:
-		    return
-		proutn(_(&quot;New warp factor to try? &quot;))
-		if scanner.next() == &quot;IHREAL&quot;:
-		    wfl = True
-		    twarp = scanner.real
-		    if twarp&lt;1.0 or twarp &gt; 10.0:
-			huh()
-			return
-		    continue
-		else:
-		    scanner.chew()
-		    skip(1)
-		    return
-	    prout(_(&quot;But if you lower your shields,&quot;))
-	    proutn(_(&quot;remaining&quot;))
-	    tpower /= 2
-	else:
-	    proutn(_(&quot;Remaining&quot;))
-	prout(_(&quot; energy will be %.2f.&quot;) % (game.energy-tpower))
-	if wfl:
-	    prout(_(&quot;And we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
-	elif twarp==1.0:
-	    prout(_(&quot;Any warp speed is adequate.&quot;))
-	else:
-	    prout(_(&quot;Minimum warp needed is %.2f,&quot;) % (twarp))
-	    prout(_(&quot;and we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
-	if game.state.remtime &lt; ttime:
-	    prout(_(&quot;Unfortunately, the Federation will be destroyed by then.&quot;))
-	if twarp &gt; 6.0:
-	    prout(_(&quot;You'll be taking risks at that speed, Captain&quot;))
-	if (game.isatb==1 and game.state.kscmdr == w1 and \
-	     scheduled(FSCDBAS)&lt; ttime+game.state.date) or \
-	    (scheduled(FCDBAS)&lt;ttime+game.state.date and game.battle == w1):
-	    prout(_(&quot;The starbase there will be destroyed by then.&quot;))
-	proutn(_(&quot;New warp factor to try? &quot;))
-	if scanner.next() == &quot;IHREAL&quot;:
-	    wfl = True
-	    twarp = scanner.real
-	    if twarp&lt;1.0 or twarp &gt; 10.0:
-		huh()
-		return
-	else:
-	    scanner.chew()
-	    skip(1)
-	    return
-
-# Code from setup.c begins here
-
-def prelim():
-    &quot;Issue a historically correct banner.&quot;
-    skip(2)
-    prout(_(&quot;-SUPER- STAR TREK&quot;))
-    skip(1)
-# From the FORTRAN original
-#    prout(_(&quot;Latest update-21 Sept 78&quot;))
-#    skip(1)
-
-def freeze(boss):
-    &quot;Save game.&quot;
-    if boss:
-	scanner.push(&quot;emsave.trk&quot;)
-    key = scanner.next()
-    if key == &quot;IHEOL&quot;:
-        proutn(_(&quot;File name: &quot;))
-        key = scanner.next()
-    if key != &quot;IHALPHA&quot;:
-        huh()
-        return
-    scanner.chew()
-    if '.' not in scanner.token:
-        scanner.token += &quot;.trk&quot;
-    try:
-        fp = open(scanner.token, &quot;wb&quot;)
-    except IOError:
-	prout(_(&quot;Can't freeze game as file %s&quot;) % scanner.token)
-	return
-    cPickle.dump(game, fp)
-    fp.close()
-
-def thaw():
-    &quot;Retrieve saved game.&quot; 
-    game.passwd[0] = '\0'
-    key = scanner.next()
-    if key == &quot;IHEOL&quot;:
-	proutn(_(&quot;File name: &quot;))
-	key = scanner.next()
-    if key != &quot;IHALPHA&quot;:
-	huh()
-	return True
-    scanner.chew()
-    if '.' not in scanner.token:
-        scanner.token += &quot;.trk&quot;
-    try:
-        fp = open(scanner.token, &quot;rb&quot;)
-    except IOError:
-	prout(_(&quot;Can't thaw game in %s&quot;) % scanner.token)
-	return
-    game = cPickle.load(fp)
-    fp.close()
-    return False
-
-# I used &lt;<A HREF="http://www.memory-alpha.org">http://www.memory-alpha.org</A>&gt; to find planets
-# with references in ST:TOS.  Eath and the Alpha Centauri
-# Colony have been omitted.
-# 
-# Some planets marked Class G and P here will be displayed as class M
-# because of the way planets are generated. This is a known bug.
-systnames = (
-    # Federation Worlds 
-    _(&quot;Andoria (Fesoan)&quot;),	# several episodes 
-    _(&quot;Tellar Prime (Miracht)&quot;),	# TOS: &quot;Journey to Babel&quot; 
-    _(&quot;Vulcan (T'Khasi)&quot;),	# many episodes 
-    _(&quot;Medusa&quot;),		# TOS: &quot;Is There in Truth No Beauty?&quot; 
-    _(&quot;Argelius II (Nelphia)&quot;),	# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
-    _(&quot;Ardana&quot;),		# TOS: &quot;The Cloud Minders&quot; 
-    _(&quot;Catulla (Cendo-Prae)&quot;),	# TOS: &quot;The Way to Eden&quot; 
-    _(&quot;Gideon&quot;),		# TOS: &quot;The Mark of Gideon&quot; 
-    _(&quot;Aldebaran III&quot;),		# TOS: &quot;The Deadly Years&quot; 
-    _(&quot;Alpha Majoris I&quot;),	# TOS: &quot;Wolf in the Fold&quot; 
-    _(&quot;Altair IV&quot;),		# TOS: &quot;Amok Time 
-    _(&quot;Ariannus&quot;),		# TOS: &quot;Let That Be Your Last Battlefield&quot; 
-    _(&quot;Benecia&quot;),		# TOS: &quot;The Conscience of the King&quot; 
-    _(&quot;Beta Niobe I (Sarpeidon)&quot;),	# TOS: &quot;All Our Yesterdays&quot; 
-    _(&quot;Alpha Carinae II&quot;),	# TOS: &quot;The Ultimate Computer&quot; 
-    _(&quot;Capella IV (Kohath)&quot;),	# TOS: &quot;Friday's Child&quot; (Class G) 
-    _(&quot;Daran V&quot;),		# TOS: &quot;For the World is Hollow and I Have Touched the Sky&quot; 
-    _(&quot;Deneb II&quot;),		# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
-    _(&quot;Eminiar VII&quot;),		# TOS: &quot;A Taste of Armageddon&quot; 
-    _(&quot;Gamma Canaris IV&quot;),	# TOS: &quot;Metamorphosis&quot; 
-    _(&quot;Gamma Tranguli VI (Vaalel)&quot;),	# TOS: &quot;The Apple&quot; 
-    _(&quot;Ingraham B&quot;),		# TOS: &quot;Operation: Annihilate&quot; 
-    _(&quot;Janus IV&quot;),		# TOS: &quot;The Devil in the Dark&quot; 
-    _(&quot;Makus III&quot;),		# TOS: &quot;The Galileo Seven&quot; 
-    _(&quot;Marcos XII&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
-    _(&quot;Omega IV&quot;),		# TOS: &quot;The Omega Glory&quot; 
-    _(&quot;Regulus V&quot;),		# TOS: &quot;Amok Time 
-    _(&quot;Deneva&quot;),		# TOS: &quot;Operation -- Annihilate!&quot; 
-    # Worlds from BSD Trek 
-    _(&quot;Rigel II&quot;),		# TOS: &quot;Shore Leave&quot; (&quot;III&quot; in BSD) 
-    _(&quot;Beta III&quot;),		# TOS: &quot;The Return of the Archons&quot; 
-    _(&quot;Triacus&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
-    _(&quot;Exo III&quot;),		# TOS: &quot;What Are Little Girls Made Of?&quot; (Class P) 
-#	# Others 
-#    _(&quot;Hansen's Planet&quot;),	# TOS: &quot;The Galileo Seven&quot; 
-#    _(&quot;Taurus IV&quot;),		# TOS: &quot;The Galileo Seven&quot; (class G) 
-#    _(&quot;Antos IV (Doraphane)&quot;),	# TOS: &quot;Whom Gods Destroy&quot;, &quot;Who Mourns for Adonais?&quot; 
-#    _(&quot;Izar&quot;),			# TOS: &quot;Whom Gods Destroy&quot; 
-#    _(&quot;Tiburon&quot;),		# TOS: &quot;The Way to Eden&quot; 
-#    _(&quot;Merak II&quot;),		# TOS: &quot;The Cloud Minders&quot; 
-#    _(&quot;Coridan (Desotriana)&quot;),	# TOS: &quot;Journey to Babel&quot; 
-#    _(&quot;Iotia&quot;),		# TOS: &quot;A Piece of the Action&quot; 
-)
-
-device = (
-	_(&quot;S. R. Sensors&quot;), \
-	_(&quot;L. R. Sensors&quot;), \
-	_(&quot;Phasers&quot;), \
-	_(&quot;Photon Tubes&quot;), \
-	_(&quot;Life Support&quot;), \
-	_(&quot;Warp Engines&quot;), \
-	_(&quot;Impulse Engines&quot;), \
-	_(&quot;Shields&quot;), \
-	_(&quot;Subspace Radio&quot;), \
-	_(&quot;Shuttle Craft&quot;), \
-	_(&quot;Computer&quot;), \
-	_(&quot;Navigation System&quot;), \
-	_(&quot;Transporter&quot;), \
-	_(&quot;Shield Control&quot;), \
-	_(&quot;Death Ray&quot;), \
-	_(&quot;D. S. Probe&quot;), \
-)
-
-def setup():
-    &quot;Prepare to play, set up cosmos.&quot;
-    w = coord()
-    #  Decide how many of everything
-    if choose():
-	return # frozen game
-    # Prepare the Enterprise
-    game.alldone = game.gamewon = game.shldchg = game.shldup = False
-    game.ship = 'E'
-    game.state.crew = FULLCREW
-    game.energy = game.inenrg = 5000.0
-    game.shield = game.inshld = 2500.0
-    game.inlsr = 4.0
-    game.lsupres = 4.0
-    game.quadrant = randplace(GALSIZE)
-    game.sector = randplace(QUADSIZE)
-    game.torps = game.intorps = 10
-    game.nprobes = randrange(2, 5)
-    game.warpfac = 5.0
-    for i in range(NDEVICES): 
-	game.damage[i] = 0.0
-    # Set up assorted game parameters
-    game.battle = coord()
-    game.state.date = game.indate = 100.0 * randreal(20, 51)
-    game.nkinks = game.nhelp = game.casual = game.abandoned = 0
-    game.iscate = game.resting = game.imine = game.icrystl = game.icraft = False
-    game.isatb = game.state.nplankl = 0
-    game.state.starkl = game.state.basekl = 0
-    game.iscraft = &quot;onship&quot;
-    game.landed = False
-    game.alive = True
-    # Starchart is functional but we've never seen it
-    game.lastchart = FOREVER
-    # Put stars in the galaxy
-    game.instar = 0
-    for i in range(GALSIZE):
-	for j in range(GALSIZE):
-	    k = randrange(1, QUADSIZE**2/10+1)
-	    game.instar += k
-	    game.state.galaxy[i][j].stars = k
-    # Locate star bases in galaxy
-    for i in range(game.inbase):
-        while True:
-            while True:
-                w = randplace(GALSIZE)
-                if not game.state.galaxy[w.i][w.j].starbase:
-                    break
-	    contflag = False
-            # C version: for (j = i-1; j &gt; 0; j--)
-            # so it did them in the opposite order.
-            for j in range(1, i):
-		# Improved placement algorithm to spread out bases
-		distq = (w - game.state.baseq[j]).distance()
-		if distq &lt; 6.0*(BASEMAX+1-game.inbase) and withprob(0.75):
-		    contflag = True
-		    if idebug:
-			prout(&quot;=== Abandoning base #%d at %s&quot; % (i, w))
-		    break
-		elif distq &lt; 6.0 * (BASEMAX+1-game.inbase):
-		    if idebug:
-			prout(&quot;=== Saving base #%d, close to #%d&quot; % (i, j))
-            if not contflag:
-                break
-	game.state.baseq.append(w)
-	game.state.galaxy[w.i][w.j].starbase = game.state.chart[w.i][w.j].starbase = True
-    # Position ordinary Klingon Battle Cruisers
-    krem = game.inkling
-    klumper = 0.25*game.skill*(9.0-game.length)+1.0
-    if klumper &gt; MAXKLQUAD: 
-	klumper = MAXKLQUAD
-    while True:
-	r = randreal()
-	klump = (1.0 - r*r)*klumper
-	if klump &gt; krem:
-	    klump = krem
-	krem -= klump
-        while True:
-            w = randplace(GALSIZE)
-            if not game.state.galaxy[w.i][w.j].supernova and \
-               game.state.galaxy[w.i][w.j].klingons + klump &lt;= MAXKLQUAD:
-                break
-	game.state.galaxy[w.i][w.j].klingons += int(klump)
-        if krem &lt;= 0:
-            break
-    # Position Klingon Commander Ships
-    for i in range(game.incom):
-        while True:
-            w = randplace(GALSIZE)
-            if not welcoming(w) or w in game.state.kcmdr:
-                continue
-            if (game.state.galaxy[w.i][w.j].klingons or withprob(0.25)):
-                break
-	game.state.galaxy[w.i][w.j].klingons += 1
-	game.state.kcmdr.append(w)
-    # Locate planets in galaxy
-    for i in range(game.inplan):
-        while True:
-            w = randplace(GALSIZE) 
-            if game.state.galaxy[w.i][w.j].planet == None:
-                break
-        new = planet()
-	new.quadrant = w
-        new.crystals = &quot;absent&quot;
-	if (game.options &amp; OPTION_WORLDS) and i &lt; NINHAB:
-	    new.pclass = &quot;M&quot;	# All inhabited planets are class M
-	    new.crystals = &quot;absent&quot;
-	    new.known = &quot;known&quot;
-            new.name = systnames[i]
-	    new.inhabited = True
-	else:
-	    new.pclass = (&quot;M&quot;, &quot;N&quot;, &quot;O&quot;)[randrange(0, 3)]
-            if withprob(0.33):
-                new.crystals = &quot;present&quot;
-	    new.known = &quot;unknown&quot;
-	    new.inhabited = False
-	game.state.galaxy[w.i][w.j].planet = new
-        game.state.planets.append(new)
-    # Locate Romulans
-    for i in range(game.state.nromrem):
-	w = randplace(GALSIZE)
-	game.state.galaxy[w.i][w.j].romulans += 1
-    # Place the Super-Commander if needed
-    if game.state.nscrem &gt; 0:
-        while True:
-            w = randplace(GALSIZE)
-            if welcoming(w):
-                break
-	game.state.kscmdr = w
-	game.state.galaxy[w.i][w.j].klingons += 1
-    # Initialize times for extraneous events
-    schedule(FSNOVA, expran(0.5 * game.intime))
-    schedule(FTBEAM, expran(1.5 * (game.intime / len(game.state.kcmdr))))
-    schedule(FSNAP, randreal(1.0, 2.0)) # Force an early snapshot
-    schedule(FBATTAK, expran(0.3*game.intime))
-    unschedule(FCDBAS)
-    if game.state.nscrem:
-	schedule(FSCMOVE, 0.2777)
-    else:
-	unschedule(FSCMOVE)
-    unschedule(FSCDBAS)
-    unschedule(FDSPROB)
-    if (game.options &amp; OPTION_WORLDS) and game.skill &gt;= SKILL_GOOD:
-	schedule(FDISTR, expran(1.0 + game.intime))
-    else:
-	unschedule(FDISTR)
-    unschedule(FENSLV)
-    unschedule(FREPRO)
-    # Place thing (in tournament game, we don't want one!)
-    # New in SST2K: never place the Thing near a starbase.
-    # This makes sense and avoids a special case in the old code.
-    global thing
-    if game.tourn is None:
-        while True:
-            thing = randplace(GALSIZE)
-            if thing not in game.state.baseq:
-                break
-    skip(2)
-    game.state.snap = False
-    if game.skill == SKILL_NOVICE:
-	prout(_(&quot;It is stardate %d. The Federation is being attacked by&quot;) % int(game.state.date))
-	prout(_(&quot;a deadly Klingon invasion force. As captain of the United&quot;))
-	prout(_(&quot;Starship U.S.S. Enterprise, it is your mission to seek out&quot;))
-	prout(_(&quot;and destroy this invasion force of %d battle cruisers.&quot;) % ((game.inkling + game.incom + game.inscom)))
-	prout(_(&quot;You have an initial allotment of %d stardates to complete&quot;) % int(game.intime))
-	prout(_(&quot;your mission.  As you proceed you may be given more time.&quot;))
-	skip(1)
-	prout(_(&quot;You will have %d supporting starbases.&quot;) % (game.inbase))
-	proutn(_(&quot;Starbase locations-  &quot;))
-    else:
-	prout(_(&quot;Stardate %d.&quot;) % int(game.state.date))
-	skip(1)
-	prout(_(&quot;%d Klingons.&quot;) % (game.inkling + game.incom + game.inscom))
-	prout(_(&quot;An unknown number of Romulans.&quot;))
-	if game.state.nscrem:
-	    prout(_(&quot;And one (GULP) Super-Commander.&quot;))
-	prout(_(&quot;%d stardates.&quot;) % int(game.intime))
-	proutn(_(&quot;%d starbases in &quot;) % game.inbase)
-    for i in range(game.inbase):
-	proutn(`game.state.baseq[i]`)
-	proutn(&quot;  &quot;)
-    skip(2)
-    proutn(_(&quot;The Enterprise is currently in Quadrant %s&quot;) % game.quadrant)
-    proutn(_(&quot; Sector %s&quot;) % game.sector)
-    skip(2)
-    prout(_(&quot;Good Luck!&quot;))
-    if game.state.nscrem:
-	prout(_(&quot;  YOU'LL NEED IT.&quot;))
-    waitfor()
-    newqad()
-    if len(game.enemies) - (thing == game.quadrant) - (game.tholian != None):
-	game.shldup = True
-    if game.neutz:	# bad luck to start in a Romulan Neutral Zone
-	attack(torps_ok=False)
-
-def choose():
-    &quot;Choose your game type.&quot;
-    while True:
-	game.tourn = game.length = 0
-	game.thawed = False
-	game.skill = SKILL_NONE
-	if not scanner.inqueue: # Can start with command line options 
-	    proutn(_(&quot;Would you like a regular, tournament, or saved game? &quot;))
-        scanner.next()
-        if scanner.sees(&quot;tournament&quot;):
-	    while scanner.next() == &quot;IHEOL&quot;:
-		proutn(_(&quot;Type in tournament number-&quot;))
-	    if scanner.real == 0:
-		scanner.chew()
-		continue # We don't want a blank entry
-	    game.tourn = int(round(scanner.real))
-	    random.seed(scanner.real)
-            if logfp:
-                logfp.write(&quot;# random.seed(%d)\n&quot; % scanner.real)
-	    break
-        if scanner.sees(&quot;saved&quot;) or scanner.sees(&quot;frozen&quot;):
-	    if thaw():
-		continue
-	    scanner.chew()
-	    if game.passwd == None:
-		continue
-	    if not game.alldone:
-		game.thawed = True # No plaque if not finished
-	    report()
-	    waitfor()
-	    return True
-        if scanner.sees(&quot;regular&quot;):
-	    break
-	proutn(_(&quot;What is \&quot;%s\&quot;?&quot;) % scanner.token)
-	scanner.chew()
-    while game.length==0 or game.skill==SKILL_NONE:
-	if scanner.next() == &quot;IHALPHA&quot;:
-            if scanner.sees(&quot;short&quot;):
-		game.length = 1
-	    elif scanner.sees(&quot;medium&quot;):
-		game.length = 2
-	    elif scanner.sees(&quot;long&quot;):
-		game.length = 4
-	    elif scanner.sees(&quot;novice&quot;):
-		game.skill = SKILL_NOVICE
-	    elif scanner.sees(&quot;fair&quot;):
-		game.skill = SKILL_FAIR
-	    elif scanner.sees(&quot;good&quot;):
-		game.skill = SKILL_GOOD
-	    elif scanner.sees(&quot;expert&quot;):
-		game.skill = SKILL_EXPERT
-	    elif scanner.sees(&quot;emeritus&quot;):
-		game.skill = SKILL_EMERITUS
-	    else:
-		proutn(_(&quot;What is \&quot;&quot;))
-		proutn(scanner.token)
-		prout(&quot;\&quot;?&quot;)
-	else:
-	    scanner.chew()
-	    if game.length==0:
-		proutn(_(&quot;Would you like a Short, Medium, or Long game? &quot;))
-	    elif game.skill == SKILL_NONE:
-		proutn(_(&quot;Are you a Novice, Fair, Good, Expert, or Emeritus player? &quot;))
-    # Choose game options -- added by ESR for SST2K
-    if scanner.next() != &quot;IHALPHA&quot;:
-	scanner.chew()
-	proutn(_(&quot;Choose your game style (plain, almy, fancy or just press enter): &quot;))
-	scanner.next()
-    if scanner.sees(&quot;plain&quot;):
-	# Approximates the UT FORTRAN version.
-	game.options &amp;=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_PLAIN
-    elif scanner.sees(&quot;almy&quot;):
-	# Approximates Tom Almy's version.
-	game.options &amp;=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
-	game.options |= OPTION_ALMY
-    elif scanner.sees(&quot;fancy&quot;) or scanner.sees(&quot;\n&quot;):
-	pass
-    elif len(scanner.token):
-        proutn(_(&quot;What is \&quot;%s\&quot;?&quot;) % scanner.token)
-    game.options &amp;=~ OPTION_COLOR
-    setpassword()
-    if game.passwd == &quot;debug&quot;:
-	idebug = True
-	prout(&quot;=== Debug mode enabled.&quot;)
-    # Use parameters to generate initial values of things
-    game.damfac = 0.5 * game.skill
-    game.inbase = randrange(BASEMIN, BASEMAX+1)
-    game.inplan = 0
-    if game.options &amp; OPTION_PLANETS:
-	game.inplan += randrange(MAXUNINHAB/2, MAXUNINHAB+1)
-    if game.options &amp; OPTION_WORLDS:
-	game.inplan += int(NINHAB)
-    game.state.nromrem = game.inrom = randrange(2 *game.skill)
-    game.state.nscrem = game.inscom = (game.skill &gt; SKILL_FAIR)
-    game.state.remtime = 7.0 * game.length
-    game.intime = game.state.remtime
-    game.state.remkl = game.inkling = 2.0*game.intime*((game.skill+1 - 2*randreal())*game.skill*0.1+.15)
-    game.incom = min(MINCMDR, int(game.skill + 0.0625*game.inkling*randreal()))
-    game.state.remres = (game.inkling+4*game.incom)*game.intime
-    game.inresor = game.state.remres
-    if game.inkling &gt; 50:
-        game.state.inbase += 1
-    return False
-
-def dropin(iquad=None):
-    &quot;Drop a feature on a random dot in the current quadrant.&quot;
-    while True:
-        w = randplace(QUADSIZE)
-        if game.quad[w.i][w.j] == '.':
-            break
-    if iquad is not None:
-        game.quad[w.i][w.j] = iquad
-    return w
-
-def newcnd():
-    &quot;Update our alert status.&quot;
-    game.condition = &quot;green&quot;
-    if game.energy &lt; 1000.0:
-	game.condition = &quot;yellow&quot;
-    if game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons or game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans:
-	game.condition = &quot;red&quot;
-    if not game.alive:
-	game.condition=&quot;dead&quot;
-
-def newkling():
-    &quot;Drop new Klingon into current quadrant.&quot;
-    return enemy('K', loc=dropin(), power=randreal(300,450)+25.0*game.skill)
-
-def newqad():
-    &quot;Set up a new state of quadrant, for when we enter or re-enter it.&quot;
-    game.justin = True
-    game.iplnet = None
-    game.neutz = game.inorbit = game.landed = False
-    game.ientesc = game.iseenit = False
-    # Create a blank quadrant
-    game.quad = fill2d(QUADSIZE, lambda i, j: '.')
-    if game.iscate:
-	# Attempt to escape Super-commander, so tbeam back!
-	game.iscate = False
-	game.ientesc = True
-    q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
-    # cope with supernova
-    if q.supernova:
-	return
-    game.klhere = q.klingons
-    game.irhere = q.romulans
-    # Position Starship
-    game.quad[game.sector.i][game.sector.j] = game.ship
-    game.enemies = []
-    if q.klingons:
-	# Position ordinary Klingons
-	for i in range(game.klhere):
-            newkling()
-	# If we need a commander, promote a Klingon
-        for cmdr in game.state.kcmdr:
-	    if cmdr == game.quadrant:
-                e = game.enemies[game.klhere-1]
-                game.quad[e.location.i][e.location.j] = 'C'
-                e.power = randreal(950,1350) + 50.0*game.skill
-		break	
-	# If we need a super-commander, promote a Klingon
-	if game.quadrant == game.state.kscmdr:
-            e = game.enemies[0]
-	    game.quad[e.location.i][e.location.j] = 'S'
-	    e.power = randreal(1175.0,  1575.0) + 125.0*game.skill
-	    game.iscate = (game.state.remkl &gt; 1)
-    # Put in Romulans if needed
-    for i in range(q.romulans):
-        enemy('R', loc=dropin(), power=randreal(400.0,850.0)+50.0*game.skill)
-    # If quadrant needs a starbase, put it in
-    if q.starbase:
-	game.base = dropin('B')
-    # If quadrant needs a planet, put it in
-    if q.planet:
-	game.iplnet = q.planet
-	if not q.planet.inhabited:
-	    game.plnet = dropin('P')
-	else:
-	    game.plnet = dropin('@')
-    # Check for condition
-    newcnd()
-    # Check for RNZ
-    if game.irhere &gt; 0 and game.klhere == 0:
-	game.neutz = True
-	if not damaged(DRADIO):
-	    skip(1)
-	    prout(_(&quot;LT. Uhura- \&quot;Captain, an urgent message.&quot;))
-	    prout(_(&quot;  I'll put it on audio.\&quot;  CLICK&quot;))
-	    skip(1)
-	    prout(_(&quot;INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE.&quot;))
-	    prout(_(&quot;LEAVE AT ONCE, OR YOU WILL BE DESTROYED!&quot;))
-    # Put in THING if needed
-    if thing == game.quadrant:
-        enemy(type='?', loc=dropin(),
-                  power=randreal(6000,6500.0)+250.0*game.skill)
-        if not damaged(DSRSENS):
-            skip(1)
-            prout(_(&quot;Mr. Spock- \&quot;Captain, this is most unusual.&quot;))
-            prout(_(&quot;    Please examine your short-range scan.\&quot;&quot;))
-    # Decide if quadrant needs a Tholian; lighten up if skill is low 
-    if game.options &amp; OPTION_THOLIAN:
-	if (game.skill &lt; SKILL_GOOD and withprob(0.02)) or \
-	    (game.skill == SKILL_GOOD and withprob(0.05)) or \
-            (game.skill &gt; SKILL_GOOD and withprob(0.08)):
-            w = coord()
-            while True:
-		w.i = withprob(0.5) * (QUADSIZE-1)
-		w.j = withprob(0.5) * (QUADSIZE-1)
-                if game.quad[w.i][w.j] == '.':
-                    break
-            game.tholian = enemy(type='T', loc=w,
-                                 power=randrange(100, 500) + 25.0*game.skill)
-	    # Reserve unoccupied corners 
-	    if game.quad[0][0]=='.':
-		game.quad[0][0] = 'X'
-	    if game.quad[0][QUADSIZE-1]=='.':
-		game.quad[0][QUADSIZE-1] = 'X'
-	    if game.quad[QUADSIZE-1][0]=='.':
-		game.quad[QUADSIZE-1][0] = 'X'
-	    if game.quad[QUADSIZE-1][QUADSIZE-1]=='.':
-		game.quad[QUADSIZE-1][QUADSIZE-1] = 'X'
-    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
-    # And finally the stars
-    for i in range(q.stars):
-	dropin('*')
-    # Put in a few black holes
-    for i in range(1, 3+1):
-	if withprob(0.5): 
-	    dropin(' ')
-    # Take out X's in corners if Tholian present
-    if game.tholian:
-	if game.quad[0][0]=='X':
-	    game.quad[0][0] = '.'
-	if game.quad[0][QUADSIZE-1]=='X':
-	    game.quad[0][QUADSIZE-1] = '.'
-	if game.quad[QUADSIZE-1][0]=='X':
-	    game.quad[QUADSIZE-1][0] = '.'
-	if game.quad[QUADSIZE-1][QUADSIZE-1]=='X':
-	    game.quad[QUADSIZE-1][QUADSIZE-1] = '.'
-
-def setpassword():
-    &quot;Set the self-destruct password.&quot;
-    if game.options &amp; OPTION_PLAIN:
-	while True:
-	    scanner.chew()
-	    proutn(_(&quot;Please type in a secret password- &quot;))
-	    scanner.next()
-	    game.passwd = scanner.token
-	    if game.passwd != None:
-		break
-    else:
-        game.passwd = &quot;&quot;
-        for i in range(3):
-	    game.passwd += chr(ord('a')+randrange(26))
-
-# Code from sst.c begins here
-
-commands = {
-    &quot;SRSCAN&quot;:   	OPTION_TTY,
-    &quot;STATUS&quot;:   	OPTION_TTY,
-    &quot;REQUEST&quot;:  	OPTION_TTY,
-    &quot;LRSCAN&quot;:   	OPTION_TTY,
-    &quot;PHASERS&quot;:  	0,
-    &quot;TORPEDO&quot;:  	0,
-    &quot;PHOTONS&quot;:  	0,
-    &quot;MOVE&quot;:     	0,
-    &quot;SHIELDS&quot;:   	0,
-    &quot;DOCK&quot;:     	0,
-    &quot;DAMAGES&quot;:   	0,
-    &quot;CHART&quot;:    	0,
-    &quot;IMPULSE&quot;:  	0,
-    &quot;REST&quot;:     	0,
-    &quot;WARP&quot;:     	0,
-    &quot;SCORE&quot;:    	0,
-    &quot;SENSORS&quot;:  	OPTION_PLANETS,
-    &quot;ORBIT&quot;:		OPTION_PLANETS,
-    &quot;TRANSPORT&quot;:	OPTION_PLANETS,
-    &quot;MINE&quot;:		OPTION_PLANETS,
-    &quot;CRYSTALS&quot;:  	OPTION_PLANETS,
-    &quot;SHUTTLE&quot;:  	OPTION_PLANETS,
-    &quot;PLANETS&quot;:  	OPTION_PLANETS,
-    &quot;REPORT&quot;:   	0,
-    &quot;COMPUTER&quot;: 	0,
-    &quot;COMMANDS&quot;: 	0,
-    &quot;EMEXIT&quot;:		0,
-    &quot;PROBE&quot;:		OPTION_PROBE,
-    &quot;SAVE&quot;:		0,
-    &quot;FREEZE&quot;:		0,	# Synonym for SAVE
-    &quot;ABANDON&quot;:  	0,
-    &quot;DESTRUCT&quot;: 	0,
-    &quot;DEATHRAY&quot;: 	0,
-    &quot;DEBUG&quot;:    	0,
-    &quot;MAYDAY&quot;:		0,
-    &quot;SOS&quot;:		0,	# Synonym for MAYDAY
-    &quot;CALL&quot;:		0,	# Synonym for MAYDAY
-    &quot;QUIT&quot;:		0,
-    &quot;HELP&quot;:		0,
-}
-
-def listCommands():
-    &quot;Generate a list of legal commands.&quot;
-    prout(_(&quot;LEGAL COMMANDS ARE:&quot;))
-    emitted = 0
-    for key in commands:
-	if not commands[key] or (commands[key] &amp; game.options):
-            proutn(&quot;%-12s &quot; % key)
-            emitted += 1
-            if emitted % 5 == 4:
-                skip(1)
-    skip(1)
-
-def helpme():
-    &quot;Browse on-line help.&quot;
-    key = scanner.next()
-    while True:
-	if key == &quot;IHEOL&quot;:
-	    setwnd(prompt_window)
-	    proutn(_(&quot;Help on what command? &quot;))
-	    key = scanner.next()
-	setwnd(message_window)
-	if key == &quot;IHEOL&quot;:
-	    return
-        if scanner.token.upper() in commands or scanner.token == &quot;ABBREV&quot;:
-	    break
-	skip(1)
-	listCommands()
-	key = &quot;IHEOL&quot;
-	scanner.chew()
-	skip(1)
-    cmd = scanner.token.upper()
-    for directory in docpath:
-        try:
-            fp = open(os.path.join(directory, &quot;sst.doc&quot;), &quot;r&quot;)
-            break
-        except IOError:
-            pass
-    else:
-        prout(_(&quot;Spock-  \&quot;Captain, that information is missing from the&quot;))
-        prout(_(&quot;   computer. You need to find sst.doc and put it somewhere&quot;))
-        proutn(_(&quot;   in these directories: %s&quot;) % &quot;:&quot;.join(docpath))
-        prout(&quot;.\&quot;&quot;)
-        # This used to continue: &quot;You need to find SST.DOC and put 
-        # it in the current directory.&quot;
-        return
-    while True:
-        linebuf = fp.readline()
-	if linebuf == '':
-	    prout(_(&quot;Spock- \&quot;Captain, there is no information on that command.\&quot;&quot;))
-	    fp.close()
-	    return
-	if linebuf[0] == '%' and linebuf[1] == '%' and linebuf[2] == ' ':
-            linebuf = linebuf[3:].strip()
-            if cmd.upper() == linebuf:
-		break
-    skip(1)
-    prout(_(&quot;Spock- \&quot;Captain, I've found the following information:\&quot;&quot;))
-    skip(1)
-    while True:
-        linebuf = fp.readline()
-        if &quot;******&quot; in linebuf:
-	    break
-	proutn(linebuf)
-    fp.close()
-
-def makemoves():
-    &quot;Command-interpretation loop.&quot;
-    clrscr()
-    setwnd(message_window)
-    while True: 	# command loop 
-	drawmaps(1)
-        while True:	# get a command 
-	    hitme = False
-	    game.optime = game.justin = False
-	    scanner.chew()
-	    setwnd(prompt_window)
-	    clrscr()
-	    proutn(&quot;COMMAND&gt; &quot;)
-	    if scanner.next() == &quot;IHEOL&quot;:
-		if game.options &amp; OPTION_CURSES:
-		    makechart()
-		continue
-            elif scanner.token == &quot;&quot;:
-                continue
-	    game.ididit = False
-	    clrscr()
-	    setwnd(message_window)
-	    clrscr()
-            candidates = filter(lambda x: x.startswith(scanner.token.upper()),
-                                commands)
-            if len(candidates) == 1:
-                cmd = candidates[0]
-                break
-            elif candidates and not (game.options &amp; OPTION_PLAIN):
-                prout(&quot;Commands with prefix '%s': %s&quot; % (scanner.token, &quot; &quot;.join(candidates)))
-            else:
-                listCommands()
-                continue
-	if cmd == &quot;SRSCAN&quot;:		# srscan
-	    srscan()
-	elif cmd == &quot;STATUS&quot;:		# status
-	    status()
-	elif cmd == &quot;REQUEST&quot;:		# status request 
-	    request()
-	elif cmd == &quot;LRSCAN&quot;:		# long range scan
-	    lrscan(silent=False)
-	elif cmd == &quot;PHASERS&quot;:		# phasers
-	    phasers()
-	    if game.ididit:
-		hitme = True
-	elif cmd in (&quot;TORPEDO&quot;, &quot;PHOTONS&quot;):	# photon torpedos
-	    torps()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;MOVE&quot;:		# move under warp
-	    warp(course=None, involuntary=False)
-	elif cmd == &quot;SHIELDS&quot;:		# shields
-	    doshield(shraise=False)
-	    if game.ididit:
-		hitme = True
-		game.shldchg = False
-	elif cmd == &quot;DOCK&quot;:		# dock at starbase
-	    dock(True)
-	    if game.ididit:
-		attack(torps_ok=False)		
-	elif cmd == &quot;DAMAGES&quot;:		# damage reports
-	    damagereport()
-	elif cmd == &quot;CHART&quot;:		# chart
-	    makechart()
-	elif cmd == &quot;IMPULSE&quot;:		# impulse
-	    impulse()
-	elif cmd == &quot;REST&quot;:		# rest
-	    wait()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;WARP&quot;:		# warp
-	    setwarp()
-	elif cmd == &quot;SCORE&quot;:		# score
-	    score()
-	elif cmd == &quot;SENSORS&quot;:		# sensors
-	    sensor()
-	elif cmd == &quot;ORBIT&quot;:		# orbit
-	    orbit()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;TRANSPORT&quot;:		# transport &quot;beam&quot;
-	    beam()
-	elif cmd == &quot;MINE&quot;:		# mine
-	    mine()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;CRYSTALS&quot;:		# crystals
-	    usecrystals()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;SHUTTLE&quot;:		# shuttle
-	    shuttle()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;PLANETS&quot;:		# Planet list
-	    survey()
-	elif cmd == &quot;REPORT&quot;:		# Game Report 
-	    report()
-	elif cmd == &quot;COMPUTER&quot;:		# use COMPUTER!
-	    eta()
-	elif cmd == &quot;COMMANDS&quot;:
-	    listCommands()
-	elif cmd == &quot;EMEXIT&quot;:		# Emergency exit
-	    clrscr()			# Hide screen
-	    freeze(True)		# forced save
-	    raise SysExit,1			# And quick exit
-	elif cmd == &quot;PROBE&quot;:
-	    probe()			# Launch probe
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;ABANDON&quot;:		# Abandon Ship
-	    abandon()
-	elif cmd == &quot;DESTRUCT&quot;:		# Self Destruct
-	    selfdestruct()
-	elif cmd == &quot;SAVE&quot;:		# Save Game
-	    freeze(False)
-	    clrscr()
-	    if game.skill &gt; SKILL_GOOD:
-		prout(_(&quot;WARNING--Saved games produce no plaques!&quot;))
-	elif cmd == &quot;DEATHRAY&quot;:		# Try a desparation measure
-	    deathray()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;DEBUGCMD&quot;:		# What do we want for debug???
-	    debugme()
-	elif cmd == &quot;MAYDAY&quot;:		# Call for help
-	    mayday()
-	    if game.ididit:
-		hitme = True
-	elif cmd == &quot;QUIT&quot;:
-	    game.alldone = True		# quit the game
-	elif cmd == &quot;HELP&quot;:
-	    helpme()			# get help
-	while True:
-	    if game.alldone:
-		break		# Game has ended
-	    if game.optime != 0.0:
-		events()
-		if game.alldone:
-		    break	# Events did us in
-	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		atover(False)
-		continue
-	    if hitme and not game.justin:
-		attack(torps_ok=True)
-		if game.alldone:
-		    break
-		if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
-		    atover(False)
-		    hitme = True
-		    continue
-	    break
-	if game.alldone:
-	    break
-    if idebug:
-	prout(&quot;=== Ending&quot;)
-
-def cramen(type):
-    &quot;Emit the name of an enemy or feature.&quot; 
-    if   type == 'R': s = _(&quot;Romulan&quot;)
-    elif type == 'K': s = _(&quot;Klingon&quot;)
-    elif type == 'C': s = _(&quot;Commander&quot;)
-    elif type == 'S': s = _(&quot;Super-commander&quot;)
-    elif type == '*': s = _(&quot;Star&quot;)
-    elif type == 'P': s = _(&quot;Planet&quot;)
-    elif type == 'B': s = _(&quot;Starbase&quot;)
-    elif type == ' ': s = _(&quot;Black hole&quot;)
-    elif type == 'T': s = _(&quot;Tholian&quot;)
-    elif type == '#': s = _(&quot;Tholian web&quot;)
-    elif type == '?': s = _(&quot;Stranger&quot;)
-    elif type == '@': s = _(&quot;Inhabited World&quot;)
-    else: s = &quot;Unknown??&quot;
-    return s
-
-def crmena(stars, enemy, loctype, w):
-    &quot;Emit the name of an enemy and his location.&quot;
-    buf = &quot;&quot;
-    if stars:
-	buf += &quot;***&quot;
-    buf += cramen(enemy) + _(&quot; at &quot;)
-    if loctype == &quot;quadrant&quot;:
-	buf += _(&quot;Quadrant &quot;)
-    elif loctype == &quot;sector&quot;:
-	buf += _(&quot;Sector &quot;)
-    return buf + `w`
-
-def crmshp():
-    &quot;Emit our ship name.&quot; 
-    return{'E':_(&quot;Enterprise&quot;),'F':_(&quot;Faerie Queene&quot;)}.get(game.ship,&quot;Ship???&quot;)
-
-def stars():
-    &quot;Emit a line of stars&quot; 
-    prouts(&quot;******************************************************&quot;)
-    skip(1)
-
-def expran(avrage):
-    return -avrage*math.log(1e-7 + randreal())
-
-def randplace(size):
-    &quot;Choose a random location.&quot;
-    w = coord()
-    w.i = randrange(size) 
-    w.j = randrange(size)
-    return w
-
-class sstscanner:
-    def __init__(self):
-        self.type = None
-        self.token = None
-        self.real = 0.0
-        self.inqueue = []
-    def next(self):
-        # Get a token from the user
-        self.real = 0.0
-        self.token = ''
-        # Fill the token quue if nothing here
-        while not self.inqueue:
-            line = cgetline()
-            if curwnd==prompt_window:
-                clrscr()
-                setwnd(message_window)
-                clrscr()
-            if line == '':
-                return None
-            if not line:
-                continue
-            else:
-                self.inqueue = line.lstrip().split() + [&quot;\n&quot;]
-        # From here on in it's all looking at the queue
-        self.token = self.inqueue.pop(0)
-        if self.token == &quot;\n&quot;:
-            self.type = &quot;IHEOL&quot;
-            return &quot;IHEOL&quot;
-        try:
-            self.real = float(self.token)
-            self.type = &quot;IHREAL&quot;
-            return &quot;IHREAL&quot;
-        except ValueError:
-            pass
-        # Treat as alpha
-        self.token = self.token.lower()
-        self.type = &quot;IHALPHA&quot;
-        self.real = None
-        return &quot;IHALPHA&quot;
-    def append(self, tok):
-        self.inqueue.append(tok)
-    def push(self, tok):
-        self.inqueue.insert(0, tok)
-    def waiting(self):
-        return self.inqueue
-    def chew(self):
-        # Demand input for next scan
-        self.inqueue = []
-        self.real = self.token = None
-    def sees(self, s):
-        # compares s to item and returns true if it matches to the length of s
-        return s.startswith(self.token)
-    def int(self):
-        # Round token value to nearest integer
-        return int(round(scanner.real))
-    def getcoord(self):
-        s = coord()
-        scanner.next()
-    	if scanner.type != &quot;IHREAL&quot;:
-	    huh()
-	    return None
-	s.i = scanner.int()-1
-        scanner.next()
-	if scanner.type != &quot;IHREAL&quot;:
-	    huh()
-	    return None
-	s.j = scanner.int()-1
-        return s
-    def __repr__(str):
-        return &quot;&lt;sstcanner: token=%s, type=%s, queue=%s&gt;&quot; % (scanner.token, scanner.type, scanner.inqueue)
-
-def ja():
-    &quot;Yes-or-no confirmation.&quot;
-    scanner.chew()
-    while True:
-	scanner.next()
-	if scanner.token == 'y':
-	    return True
-	if scanner.token == 'n':
-	    return False
-	scanner.chew()
-	proutn(_(&quot;Please answer with \&quot;y\&quot; or \&quot;n\&quot;: &quot;))
-
-def huh():
-    &quot;Complain about unparseable input.&quot;
-    scanner.chew()
-    skip(1)
-    prout(_(&quot;Beg your pardon, Captain?&quot;))
-
-def debugme():
-    &quot;Access to the internals for debugging.&quot;
-    proutn(&quot;Reset levels? &quot;)
-    if ja() == True:
-	if game.energy &lt; game.inenrg:
-	    game.energy = game.inenrg
-	game.shield = game.inshld
-	game.torps = game.intorps
-	game.lsupres = game.inlsr
-    proutn(&quot;Reset damage? &quot;)
-    if ja() == True:
-	for i in range(NDEVICES): 
-	    if game.damage[i] &gt; 0.0: 
-		game.damage[i] = 0.0
-    proutn(&quot;Toggle debug flag? &quot;)
-    if ja() == True:
-	idebug = not idebug
-	if idebug:
-	    prout(&quot;Debug output ON&quot;)	    
-	else:
-	    prout(&quot;Debug output OFF&quot;)
-    proutn(&quot;Cause selective damage? &quot;)
-    if ja() == True:
-	for i in range(NDEVICES):
-	    proutn(&quot;Kill %s?&quot; % device[i])
-	    scanner.chew()
-	    key = scanner.next()
-            if key == &quot;IHALPHA&quot; and scanner.sees(&quot;y&quot;):
-		game.damage[i] = 10.0
-    proutn(&quot;Examine/change events? &quot;)
-    if ja() == True:
-	ev = event()
-	w = coord()
-        legends = {
-            FSNOVA:  &quot;Supernova       &quot;,
-            FTBEAM:  &quot;T Beam          &quot;,
-            FSNAP:   &quot;Snapshot        &quot;,
-            FBATTAK: &quot;Base Attack     &quot;,
-            FCDBAS:  &quot;Base Destroy    &quot;,
-            FSCMOVE: &quot;SC Move         &quot;,
-            FSCDBAS: &quot;SC Base Destroy &quot;,
-            FDSPROB: &quot;Probe Move      &quot;,
-            FDISTR:  &quot;Distress Call   &quot;,
-            FENSLV:  &quot;Enslavement     &quot;,
-            FREPRO:  &quot;Klingon Build   &quot;,
-        }
-	for i in range(1, NEVENTS):
-            proutn(legends[i])
-	    if is_scheduled(i):
-		proutn(&quot;%.2f&quot; % (scheduled(i)-game.state.date))
-		if i == FENSLV or i == FREPRO:
-		    ev = findevent(i)
-		    proutn(&quot; in %s&quot; % ev.quadrant)
-	    else:
-		proutn(&quot;never&quot;)
-	    proutn(&quot;? &quot;)
-	    scanner.chew()
-	    key = scanner.next()
-	    if key == 'n':
-		unschedule(i)
-		scanner.chew()
-	    elif key == &quot;IHREAL&quot;:
-		ev = schedule(i, scanner.real)
-		if i == FENSLV or i == FREPRO:
-		    scanner.chew()
-		    proutn(&quot;In quadrant- &quot;)
-		    key = scanner.next()
-		    # &quot;IHEOL&quot; says to leave coordinates as they are 
-		    if key != &quot;IHEOL&quot;:
-			if key != &quot;IHREAL&quot;:
-			    prout(&quot;Event %d canceled, no x coordinate.&quot; % (i))
-			    unschedule(i)
-			    continue
-			w.i = int(round(scanner.real))
-			key = scanner.next()
-			if key != &quot;IHREAL&quot;:
-			    prout(&quot;Event %d canceled, no y coordinate.&quot; % (i))
-			    unschedule(i)
-			    continue
-			w.j = int(round(scanner.real))
-			ev.quadrant = w
-	scanner.chew()
-    proutn(&quot;Induce supernova here? &quot;)
-    if ja() == True:
-	game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova = True
-	atover(True)
-
-if __name__ == '__main__':
-    import getopt, socket
-    try:
-        global line, thing, game, idebug
-        game = None
-        thing = coord()
-        thing.angry = False
-        game = gamestate()
-        idebug = 0
-        game.options = OPTION_ALL &amp;~ (OPTION_IOMODES | OPTION_PLAIN | OPTION_ALMY)
-        if os.getenv(&quot;TERM&quot;):
-            game.options |= OPTION_CURSES
-        else:
-            game.options |= OPTION_TTY
-        seed = int(time.time())
-        (options, arguments) = getopt.getopt(sys.argv[1:], &quot;r:s:tx&quot;)
-        for (switch, val) in options:
-            if switch == '-r':
-                try:
-                    replayfp = open(val, &quot;r&quot;)
-                except IOError:
-                    sys.stderr.write(&quot;sst: can't open replay file %s\n&quot; % val)
-                    raise SystemExit, 1
-                try:
-                    line = replayfp.readline().strip()
-                    (leader, key, seed) = line.split()
-                    seed = eval(seed)
-                    sys.stderr.write(&quot;sst2k: seed set to %s\n&quot; % seed)
-                    line = replayfp.readline().strip()
-                    arguments += line.split()[2:]
-                except ValueError:
-                    sys.stderr.write(&quot;sst: replay file %s is ill-formed\n&quot;% val)
-                    raise SystemExit(1)
-                game.options |= OPTION_TTY
-                game.options &amp;=~ OPTION_CURSES
-            elif switch == '-s':
-                seed = int(val)
-            elif switch == '-t':
-                game.options |= OPTION_TTY
-                game.options &amp;=~ OPTION_CURSES
-            elif switch == '-x':
-                idebug = True
-            else:
-                sys.stderr.write(&quot;usage: sst [-t] [-x] [startcommand...].\n&quot;)
-                raise SystemExit, 1
-        # where to save the input in case of bugs
-        if &quot;TMPDIR&quot; in os.environ:
-            tmpdir = os.environ['TMPDIR']
-        else:
-            tmpdir = &quot;/tmp&quot;
-        try:
-            logfp = open(os.path.join(tmpdir, &quot;sst-input.log&quot;), &quot;w&quot;)
-        except IOError:
-            sys.stderr.write(&quot;sst: warning, can't open logfile\n&quot;)
-            sys.exit(1)
-        if logfp:
-            logfp.write(&quot;# seed %s\n&quot; % seed)
-            logfp.write(&quot;# options %s\n&quot; % &quot; &quot;.join(arguments))
-            logfp.write(&quot;# recorded by %s@%s on %s\n&quot; % \
-                    (getpass.getuser(),socket.gethostname(),time.ctime()))
-        random.seed(seed)
-        scanner = sstscanner()
-        map(scanner.append, arguments)
-        try:
-            iostart()
-            while True: # Play a game 
-                setwnd(fullscreen_window)
-                clrscr()
-                prelim()
-                setup()
-                if game.alldone:
-                    score()
-                    game.alldone = False
-                else:
-                    makemoves()
-                skip(1)
-                stars()
-                skip(1)
-                if game.tourn and game.alldone:
-                    proutn(_(&quot;Do you want your score recorded?&quot;))
-                    if ja() == True:
-                        scanner.chew()
-                        scanner.push(&quot;\n&quot;)
-                        freeze(False)
-                scanner.chew()
-                proutn(_(&quot;Do you want to play again? &quot;))
-                if not ja():
-                    break
-            skip(1)
-            prout(_(&quot;May the Great Bird of the Galaxy roost upon your home planet.&quot;))
-        finally:
-            ioend()
-        raise SystemExit, 0
-    except KeyboardInterrupt:
-        if logfp:
-            logfp.close()
-        print &quot;&quot;

Copied: trunk/c-version/sst.spec (from rev 809, trunk/sst.spec)
===================================================================
--- trunk/c-version/sst.spec	                        (rev 0)
+++ trunk/c-version/sst.spec	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,49 @@
+Name: sst
+Version: 2.0
+Release: 1
+URL: <A HREF="http://sst.berlios.de">http://sst.berlios.de</A>
+Source0: %{name}-%{version}.tar.gz
+License: GPL
+Group: Games
+Summary: the classic game of Super Star Trek
+BuildRoot: %{_tmppath}/%{name}-root
+#Freshmeat-Name: strek
+
+%description
+Save the Federation from the invading Klingons!  Visit exotic planets and
+strip-mine them for dilithium!  Encounter mysterious space thingies!
+The classic Super Star Trek game from the days of slow teletypes, reloaded.
+
+%prep
+%setup -q
+
+%build
+make %{?_smp_mflags} all sst-doc.html
+
+%install
+[ &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf &quot;$RPM_BUILD_ROOT&quot;
+mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_bindir}
+mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_mandir}/man6/
+cp sst &quot;$RPM_BUILD_ROOT&quot;%{_bindir}
+cp sst.6 &quot;$RPM_BUILD_ROOT&quot;%{_mandir}/man6/
+mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/
+cp sst.doc &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/
+cp sst-doc.html &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/index.html
+
+%clean
+[ &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf &quot;$RPM_BUILD_ROOT&quot;
+
+%files
+%doc README COPYING
+%defattr(-,root,root,-)
+%{_mandir}/man6/sst.6*
+%{_bindir}/sst
+%{_defaultdocdir}/sst/sst.doc
+%{_defaultdocdir}/sst/index.html
+
+%changelog
+
+* Thu Apr 14 2005 Eric S. Raymond &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">esr at snark.thyrsus.com</A>&gt; - 2.0-1
+- First release under new management.
+
+

Deleted: trunk/compile
===================================================================
--- trunk/compile	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/compile	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,142 +0,0 @@
-#! /bin/sh
-# Wrapper for compilers which do not understand `-c -o'.
-
-scriptversion=2005-05-14.22
-
-# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
-# Written by Tom Tromey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">tromey at cygnus.com</A>&gt;.
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# This file is maintained in Automake, please report
-# bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt; or send patches to
-# &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">automake-patches at gnu.org</A>&gt;.
-
-case $1 in
-  '')
-     echo &quot;$0: No command.  Try \`$0 --help' for more information.&quot; 1&gt;&amp;2
-     exit 1;
-     ;;
-  -h | --h*)
-    cat &lt;&lt;\EOF
-Usage: compile [--help] [--version] PROGRAM [ARGS]
-
-Wrapper for compilers which do not understand `-c -o'.
-Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
-arguments, and rename the output as expected.
-
-If you are trying to build a whole package this is not the
-right script to run: please start by reading the file `INSTALL'.
-
-Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.
-EOF
-    exit $?
-    ;;
-  -v | --v*)
-    echo &quot;compile $scriptversion&quot;
-    exit $?
-    ;;
-esac
-
-ofile=
-cfile=
-eat=
-
-for arg
-do
-  if test -n &quot;$eat&quot;; then
-    eat=
-  else
-    case $1 in
-      -o)
-	# configure might choose to run compile as `compile cc -o foo foo.c'.
-	# So we strip `-o arg' only if arg is an object.
-	eat=1
-	case $2 in
-	  *.o | *.obj)
-	    ofile=$2
-	    ;;
-	  *)
-	    set x &quot;$@&quot; -o &quot;$2&quot;
-	    shift
-	    ;;
-	esac
-	;;
-      *.c)
-	cfile=$1
-	set x &quot;$@&quot; &quot;$1&quot;
-	shift
-	;;
-      *)
-	set x &quot;$@&quot; &quot;$1&quot;
-	shift
-	;;
-    esac
-  fi
-  shift
-done
-
-if test -z &quot;$ofile&quot; || test -z &quot;$cfile&quot;; then
-  # If no `-o' option was seen then we might have been invoked from a
-  # pattern rule where we don't need one.  That is ok -- this is a
-  # normal compilation that the losing compiler can handle.  If no
-  # `.c' file was seen then we are probably linking.  That is also
-  # ok.
-  exec &quot;$@&quot;
-fi
-
-# Name of file we expect compiler to create.
-cofile=`echo &quot;$cfile&quot; | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
-
-# Create the lock directory.
-# Note: use `[/.-]' here to ensure that we don't use the same name
-# that we are using for the .o file.  Also, base the name on the expected
-# object file name, since that is what matters with a parallel build.
-lockdir=`echo &quot;$cofile&quot; | sed -e 's|[/.-]|_|g'`.d
-while true; do
-  if mkdir &quot;$lockdir&quot; &gt;/dev/null 2&gt;&amp;1; then
-    break
-  fi
-  sleep 1
-done
-# FIXME: race condition here if user kills between mkdir and trap.
-trap &quot;rmdir '$lockdir'; exit 1&quot; 1 2 15
-
-# Run the compile.
-&quot;$@&quot;
-ret=$?
-
-if test -f &quot;$cofile&quot;; then
-  mv &quot;$cofile&quot; &quot;$ofile&quot;
-elif test -f &quot;${cofile}bj&quot;; then
-  mv &quot;${cofile}bj&quot; &quot;$ofile&quot;
-fi
-
-rmdir &quot;$lockdir&quot;
-exit $ret
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;scriptversion=&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
-# time-stamp-end: &quot;$&quot;
-# End:

Deleted: trunk/config.guess
===================================================================
--- trunk/config.guess	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.guess	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,1463 +0,0 @@
-#! /bin/sh
-# Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-timestamp='2005-07-08'
-
-# This file is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">per at bothner.com</A>&gt;.
-# Please send patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
-#
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
-
-me=`echo &quot;$0&quot; | sed -e 's,.*/,,'`
-
-usage=&quot;\
-Usage: $0 [OPTION]
-
-Output the configuration name of the system \`$me' is run on.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.&quot;
-
-version=&quot;\
-GNU config.guess ($timestamp)
-
-Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&quot;
-
-help=&quot;
-Try \`$me --help' for more information.&quot;
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo &quot;$timestamp&quot; ; exit ;;
-    --version | -v )
-       echo &quot;$version&quot; ; exit ;;
-    --help | --h* | -h )
-       echo &quot;$usage&quot;; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo &quot;$me: invalid option $1$help&quot; &gt;&amp;2
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo &quot;$me: too many arguments$help&quot; &gt;&amp;2
-  exit 1
-fi
-
-trap 'exit 1' 1 2 15
-
-# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
-# compiler to aid in system detection is discouraged as it requires
-# temporary files to be created and, as you can see below, it is a
-# headache to deal with in a portable fashion.
-
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
-
-# Portable tmp directory creation inspired by the Autoconf team.
-
-set_cc_for_build='
-trap &quot;exitcode=\$?; (rm -f \$tmpfiles 2&gt;/dev/null; rmdir \$tmp 2&gt;/dev/null) &amp;&amp; exit \$exitcode&quot; 0 ;
-trap &quot;rm -f \$tmpfiles 2&gt;/dev/null; rmdir \$tmp 2&gt;/dev/null; exit 1&quot; 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 &amp;&amp; mktemp -d -q &quot;$TMPDIR/cgXXXXXX&quot;) 2&gt;/dev/null` &amp;&amp; test -n &quot;$tmp&quot; &amp;&amp; test -d &quot;$tmp&quot; ; } ||
- { test -n &quot;$RANDOM&quot; &amp;&amp; tmp=$TMPDIR/cg$$-$RANDOM &amp;&amp; (umask 077 &amp;&amp; mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ &amp;&amp; (umask 077 &amp;&amp; mkdir $tmp) &amp;&amp; echo &quot;Warning: creating insecure temp directory&quot; &gt;&amp;2 ; } ||
- { echo &quot;$me: cannot create a temporary directory in $TMPDIR&quot; &gt;&amp;2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles=&quot;$dummy.c $dummy.o $dummy.rel $dummy&quot; ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo &quot;int x;&quot; &gt; $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) &gt;/dev/null 2&gt;&amp;1 ; then
-	     CC_FOR_BUILD=&quot;$c&quot;; break ;
-	  fi ;
-	done ;
-	if test x&quot;$CC_FOR_BUILD&quot; = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
-
-# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">ghazi at noc.rutgers.edu</A> 1994-08-24)
-if (test -f /.attbin/uname) &gt;/dev/null 2&gt;&amp;1 ; then
-	PATH=$PATH:/.attbin ; export PATH
-fi
-
-UNAME_MACHINE=`(uname -m) 2&gt;/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2&gt;/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2&gt;/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2&gt;/dev/null` || UNAME_VERSION=unknown
-
-# Note: order is significant - the case branches are not exclusive.
-
-case &quot;${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}&quot; in
-    *:NetBSD:*:*)
-	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
-	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
-	# switched to ELF, *-*-netbsd* would select the old
-	# object file format.  This provides both forward
-	# compatibility and a consistent mechanism for selecting the
-	# object file format.
-	#
-	# Note: NetBSD doesn't particularly care about the vendor
-	# portion of the name.  We always set it to &quot;unknown&quot;.
-	sysctl=&quot;sysctl -n hw.machine_arch&quot;
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2&gt;/dev/null || \
-	    /usr/sbin/$sysctl 2&gt;/dev/null || echo unknown)`
-	case &quot;${UNAME_MACHINE_ARCH}&quot; in
-	    armeb) machine=armeb-unknown ;;
-	    arm*) machine=arm-unknown ;;
-	    sh3el) machine=shl-unknown ;;
-	    sh3eb) machine=sh-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
-	esac
-	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case &quot;${UNAME_MACHINE_ARCH}&quot; in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
-		if echo __ELF__ | $CC_FOR_BUILD -E - 2&gt;/dev/null \
-			| grep __ELF__ &gt;/dev/null
-		then
-		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
-		    # Return netbsd for either.  FIX?
-		    os=netbsd
-		else
-		    os=netbsdelf
-		fi
-		;;
-	    *)
-	        os=netbsd
-		;;
-	esac
-	# The OS release
-	# Debian GNU/NetBSD machines have a different userland, and
-	# thus, need a distinct triplet. However, they do not need
-	# kernel version information, so it can be replaced with a
-	# suitable tag, in the style of linux-gnu.
-	case &quot;${UNAME_VERSION}&quot; in
-	    Debian*)
-		release='-gnu'
-		;;
-	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-		;;
-	esac
-	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
-	# contains redundant information, the shorter form:
-	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo &quot;${machine}-${os}${release}&quot;
-	exit ;;
-    *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
-	exit ;;
-    *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit ;;
-    macppc:MirBSD:*:*)
-	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    alpha:OSF1:*:*)
-	case $UNAME_RELEASE in
-	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-		;;
-	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
-		;;
-	esac
-	# According to Compaq, /usr/sbin/psrinfo has been available on
-	# OSF/1 and Tru64 systems produced since 1995.  I hope that
-	# covers most systems running today.  This code pipes the CPU
-	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case &quot;$ALPHA_CPU_TYPE&quot; in
-	    &quot;EV4 (21064)&quot;)
-		UNAME_MACHINE=&quot;alpha&quot; ;;
-	    &quot;EV4.5 (21064)&quot;)
-		UNAME_MACHINE=&quot;alpha&quot; ;;
-	    &quot;LCA4 (21066/21068)&quot;)
-		UNAME_MACHINE=&quot;alpha&quot; ;;
-	    &quot;EV5 (21164)&quot;)
-		UNAME_MACHINE=&quot;alphaev5&quot; ;;
-	    &quot;EV5.6 (21164A)&quot;)
-		UNAME_MACHINE=&quot;alphaev56&quot; ;;
-	    &quot;EV5.6 (21164PC)&quot;)
-		UNAME_MACHINE=&quot;alphapca56&quot; ;;
-	    &quot;EV5.7 (21164PC)&quot;)
-		UNAME_MACHINE=&quot;alphapca57&quot; ;;
-	    &quot;EV6 (21264)&quot;)
-		UNAME_MACHINE=&quot;alphaev6&quot; ;;
-	    &quot;EV6.7 (21264A)&quot;)
-		UNAME_MACHINE=&quot;alphaev67&quot; ;;
-	    &quot;EV6.8CB (21264C)&quot;)
-		UNAME_MACHINE=&quot;alphaev68&quot; ;;
-	    &quot;EV6.8AL (21264B)&quot;)
-		UNAME_MACHINE=&quot;alphaev68&quot; ;;
-	    &quot;EV6.8CX (21264D)&quot;)
-		UNAME_MACHINE=&quot;alphaev68&quot; ;;
-	    &quot;EV6.9A (21264/EV69A)&quot;)
-		UNAME_MACHINE=&quot;alphaev69&quot; ;;
-	    &quot;EV7 (21364)&quot;)
-		UNAME_MACHINE=&quot;alphaev7&quot; ;;
-	    &quot;EV7.9 (21364A)&quot;)
-		UNAME_MACHINE=&quot;alphaev79&quot; ;;
-	esac
-	# A Pn.n version is a patched version.
-	# A Vn.n version is a released version.
-	# A Tn.n version is a released field test version.
-	# A Xn.n version is an unreleased experimental baselevel.
-	# 1.2 uses &quot;1.2&quot; for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
-    Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
-    *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit ;;
-    *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
-	exit ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
-    *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
-    *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit ;;
-    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
-    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
-    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
-	# <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">akee at wpdis03.wpafb.af.mil</A> (Earle F. Ake) contributed MIS and NILE.
-	if test &quot;`(/bin/universe) 2&gt;/dev/null`&quot; = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
-    NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
-    DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
-    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
-    sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:6*:*)
-	# According to config.sub, this is the proper way to canonicalize
-	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
-	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:*:*)
-	case &quot;`/usr/bin/arch -k`&quot; in
-	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
-		;;
-	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit ;;
-    sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit ;;
-    sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2&gt;/dev/null`
-	test &quot;x${UNAME_RELEASE}&quot; = &quot;x&quot; &amp;&amp; UNAME_RELEASE=3
-	case &quot;`/bin/arch`&quot; in
-	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
-		;;
-	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
-		;;
-	esac
-	exit ;;
-    aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit ;;
-    # The situation for MiNT is a little confusing.  The machine name
-    # can be virtually everything (everything which is not
-    # &quot;atarist&quot; or &quot;atariste&quot; at least should have a processor
-    # &gt; m68000).  The system name ranges from &quot;MiNT&quot; over &quot;FreeMiNT&quot;
-    # to the lowercase version &quot;mint&quot; (or &quot;freemint&quot;).  Finally
-    # the system name &quot;TOS&quot; denotes a system which is actually not
-    # MiNT.  But MiNT is downward compatible to TOS, so this should
-    # be no problem.
-    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
-    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
-    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
-    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
-    m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit ;;
-    powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit ;;
-    RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
-    RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit ;;
-    mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
-#ifdef __cplusplus
-#include &lt;stdio.h&gt;  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-	#if defined (host_mips) &amp;&amp; defined (MIPSEB)
-	#if defined (SYSTYPE_SYSV)
-	  printf (&quot;mips-mips-riscos%ssysv\n&quot;, argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_SVR4)
-	  printf (&quot;mips-mips-riscos%ssvr4\n&quot;, argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf (&quot;mips-mips-riscos%sbsd\n&quot;, argv[1]); exit (0);
-	#endif
-	#endif
-	  exit (-1);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp;
-	  dummyarg=`echo &quot;${UNAME_RELEASE}&quot; | sed -n 's/\([0-9]*\).*/\1/p'` &amp;&amp;
-	  SYSTEM_NAME=`$dummy $dummyarg` &amp;&amp;
-	    { echo &quot;$SYSTEM_NAME&quot;; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit ;;
-    Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
-    Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
-    m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
-    m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
-    m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
-    AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
-	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
-	fi
- 	exit ;;
-    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
-    M88*:*:R3*:*)
-	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
-    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
-    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
-    *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit ;;
-    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo &quot;'`uname -s`'&quot; gives 'AIX '
-    i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
-    ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:2:3)
-	if grep bos325 /usr/include/stdio.h &gt;/dev/null 2&gt;&amp;1; then
-		eval $set_cc_for_build
-		sed 's/^		//' &lt;&lt; EOF &gt;$dummy.c
-		#include &lt;sys/systemcfg.h&gt;
-
-		main()
-			{
-			if (!__power_pc())
-				exit(1);
-			puts(&quot;powerpc-ibm-aix3.2.5&quot;);
-			exit(0);
-			}
-EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp; SYSTEM_NAME=`$dummy`
-		then
-			echo &quot;$SYSTEM_NAME&quot;
-		else
-			echo rs6000-ibm-aix3.2.5
-		fi
-	elif grep bos324 /usr/include/stdio.h &gt;/dev/null 2&gt;&amp;1; then
-		echo rs6000-ibm-aix3.2.4
-	else
-		echo rs6000-ibm-aix3.2
-	fi
-	exit ;;
-    *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' &gt;/dev/null 2&gt;&amp;1; then
-		IBM_ARCH=rs6000
-	else
-		IBM_ARCH=powerpc
-	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
-    *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
-    DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
-    9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
-    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
-    9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case &quot;${UNAME_MACHINE}&quot; in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2&gt;/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2&gt;/dev/null`
-                    case &quot;${sc_cpu_version}&quot; in
-                      523) HP_ARCH=&quot;hppa1.0&quot; ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH=&quot;hppa1.1&quot; ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case &quot;${sc_kernel_bits}&quot; in
-                          32) HP_ARCH=&quot;hppa2.0n&quot; ;;
-                          64) HP_ARCH=&quot;hppa2.0w&quot; ;;
-			  '') HP_ARCH=&quot;hppa2.0&quot; ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
-		fi
-		if [ &quot;${HP_ARCH}&quot; = &quot;&quot; ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' &lt;&lt; EOF &gt;$dummy.c
-
-              #define _HPUX_SOURCE
-              #include &lt;stdlib.h&gt;
-              #include &lt;unistd.h&gt;
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts (&quot;hppa1.0&quot;); break;
-              	case CPU_PA_RISC1_1: puts (&quot;hppa1.1&quot;); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts (&quot;hppa2.0w&quot;); break;
-              		case 32: puts (&quot;hppa2.0n&quot;); break;
-              		default: puts (&quot;hppa2.0&quot;); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts (&quot;hppa2.0&quot;); break;
-              #endif
-              	default: puts (&quot;hppa1.0&quot;); break;
-              	}
-                  exit (0);
-              }
-EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2&gt;/dev/null) &amp;&amp; HP_ARCH=`$dummy`
-		    test -z &quot;$HP_ARCH&quot; &amp;&amp; HP_ARCH=hppa
-		fi ;;
-	esac
-	if [ ${HP_ARCH} = &quot;hppa2.0w&quot; ]
-	then
-	    eval $set_cc_for_build
-
-	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
-	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
-	    # generating 64-bit code.  GNU and HP use different nomenclature:
-	    #
-	    # $ CC_FOR_BUILD=cc ./config.guess
-	    # =&gt; hppa2.0w-hp-hpux11.23
-	    # $ CC_FOR_BUILD=&quot;cc +DA2.0w&quot; ./config.guess
-	    # =&gt; hppa64-hp-hpux11.23
-
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2&gt;/dev/null) |
-		grep __LP64__ &gt;/dev/null
-	    then
-		HP_ARCH=&quot;hppa2.0w&quot;
-	    else
-		HP_ARCH=&quot;hppa64&quot;
-	    fi
-	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit ;;
-    ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
-	exit ;;
-    3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
-	#include &lt;unistd.h&gt;
-	int
-	main ()
-	{
-	  long cpu = sysconf (_SC_CPU_VERSION);
-	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
-	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
-	     results, however.  */
-	  if (CPU_IS_PA_RISC (cpu))
-	    {
-	      switch (cpu)
-		{
-		  case CPU_PA_RISC1_0: puts (&quot;hppa1.0-hitachi-hiuxwe2&quot;); break;
-		  case CPU_PA_RISC1_1: puts (&quot;hppa1.1-hitachi-hiuxwe2&quot;); break;
-		  case CPU_PA_RISC2_0: puts (&quot;hppa2.0-hitachi-hiuxwe2&quot;); break;
-		  default: puts (&quot;hppa-hitachi-hiuxwe2&quot;); break;
-		}
-	    }
-	  else if (CPU_IS_HP_MC68K (cpu))
-	    puts (&quot;m68k-hitachi-hiuxwe2&quot;);
-	  else puts (&quot;unknown-hitachi-hiuxwe2&quot;);
-	  exit (0);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &amp;&amp; SYSTEM_NAME=`$dummy` &amp;&amp;
-		{ echo &quot;$SYSTEM_NAME&quot;; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit ;;
-    9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
-    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit ;;
-    hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
-    i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
-	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
-	fi
-	exit ;;
-    parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
-    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit ;;
-    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-        exit ;;
-    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit ;;
-    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit ;;
-    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit ;;
-    CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
-	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
-	      -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo &quot;${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}&quot;
-        exit ;;
-    5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo &quot;sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}&quot;
-	exit ;;
-    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit ;;
-    sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit ;;
-    i*:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes &quot;-pc&quot; on this system.
-    	echo ${UNAME_MACHINE}-mingw32
-	exit ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit ;;
-    x86:Interix*:[34]*)
-	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
-	exit ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&amp;T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
-    i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit ;;
-    amd64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit ;;
-    prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    *:GNU:*:*)
-	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit ;;
-    *:GNU/*:*:*)
-	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit ;;
-    arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit ;;
-    crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
-	exit ;;
-    frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
-	exit ;;
-    ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^CPU=`
-	test x&quot;${CPU}&quot; != x &amp;&amp; { echo &quot;${CPU}-unknown-linux-gnu&quot;; exit; }
-	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^CPU=`
-	test x&quot;${CPU}&quot; != x &amp;&amp; { echo &quot;${CPU}-unknown-linux-gnu&quot;; exit; }
-	;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' &lt; /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 &gt;/dev/null
-	if test &quot;$?&quot; = 0 ; then LIBC=&quot;libc1&quot; ; else LIBC=&quot;&quot; ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
-    parisc:Linux:*:* | hppa:Linux:*:*)
-	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2&gt;/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
-	esac
-	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit ;;
-    s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit ;;
-    sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2&gt;&amp;1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case &quot;$ld_supported_targets&quot; in
-	  elf32-i386)
-		TENTATIVE=&quot;${UNAME_MACHINE}-pc-linux-gnu&quot;
-		;;
-	  a.out-i386-linux)
-		echo &quot;${UNAME_MACHINE}-pc-linux-gnuaout&quot;
-		exit ;;
-	  coff-i386)
-		echo &quot;${UNAME_MACHINE}-pc-linux-gnucoff&quot;
-		exit ;;
-	  &quot;&quot;)
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo &quot;${UNAME_MACHINE}-pc-linux-gnuoldld&quot;
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' &lt;&lt; EOF &gt;$dummy.c
-	#include &lt;features.h&gt;
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ &gt;= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#ifdef __INTEL_COMPILER
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2&gt;/dev/null | grep ^LIBC=`
-	test x&quot;${LIBC}&quot; != x &amp;&amp; {
-		echo &quot;${UNAME_MACHINE}-pc-linux-${LIBC}&quot;
-		exit
-	}
-	test x&quot;${TENTATIVE}&quot; != x &amp;&amp; { echo &quot;${TENTATIVE}&quot;; exit; }
-	;;
-    i*86:DYNIX/ptx:4*:*)
-	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
-	# earlier versions are messed up and put the nodename in both
-	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
-    i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
-	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit ;;
-    i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit ;;
-    i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
-	exit ;;
-    i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
-	if grep Novell /usr/include/link.h &gt;/dev/null 2&gt;/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
-	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
-	fi
-	exit ;;
-    i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case `/bin/uname -X | grep &quot;^Machine&quot;` in
-	    *486*)	     UNAME_MACHINE=i486 ;;
-	    *Pentium)	     UNAME_MACHINE=i586 ;;
-	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
-	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit ;;
-    i*86:*:3.2:*)
-	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' &lt;/usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
-	elif /bin/uname -X 2&gt;/dev/null &gt;/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|grep i80486 &gt;/dev/null) &amp;&amp; UNAME_MACHINE=i486
-		(/bin/uname -X|grep '^Machine.*Pentium' &gt;/dev/null) \
-			&amp;&amp; UNAME_MACHINE=i586
-		(/bin/uname -X|grep '^Machine.*Pent *II' &gt;/dev/null) \
-			&amp;&amp; UNAME_MACHINE=i686
-		(/bin/uname -X|grep '^Machine.*Pentium Pro' &gt;/dev/null) \
-			&amp;&amp; UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
-	else
-		echo ${UNAME_MACHINE}-pc-sysv32
-	fi
-	exit ;;
-    pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit ;;
-    Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
-    paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
-    i860:*:4.*:*) # i860-SVR4
-	if grep Stardent /usr/include/sys/uadmin.h &gt;/dev/null 2&gt;&amp;1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
-	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
-	fi
-	exit ;;
-    mini*:CTIX:SYS*5:*)
-	# &quot;miniframe&quot;
-	echo m68010-convergent-sysv
-	exit ;;
-    mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
-    M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
-    M68*:*:R3V[5678]*:*)
-	test -r /sysV68 &amp;&amp; { echo 'm68k-motorola-sysv'; exit; } ;;
-    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
-	OS_REL=''
-	test -r /etc/.relid \
-	&amp;&amp; OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' &lt; /etc/.relid`
-	/bin/uname -p 2&gt;/dev/null | grep 86 &gt;/dev/null \
-	  &amp;&amp; { echo i486-ncr-sysv4.3${OS_REL}; exit; }
-	/bin/uname -p 2&gt;/dev/null | /bin/grep entium &gt;/dev/null \
-	  &amp;&amp; { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
-    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2&gt;/dev/null | grep 86 &gt;/dev/null \
-          &amp;&amp; { echo i486-ncr-sysv4; exit; } ;;
-    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
-    TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit ;;
-    RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    *:SINIX-*:*:*)
-	if uname -p 2&gt;/dev/null &gt;/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2&gt;/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
-	else
-		echo ns32k-sni-sysv
-	fi
-	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Richard.M.Bartel at ccMail.Census.GOV</A>&gt;
-        echo i586-unisys-sysv4
-        exit ;;
-    *:UNIX_System_V:4*:FTX*)
-	# From Gerald Hewes &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">hewes at openmarket.com</A>&gt;.
-	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
-    *:*:*:FTX*)
-	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">seanf at swdc.stratus.com.</A>
-	echo i860-stratus-sysv4
-	exit ;;
-    i*86:VOS:*:*)
-	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Paul.Green at stratus.com.</A>
-	echo ${UNAME_MACHINE}-stratus-vos
-	exit ;;
-    *:VOS:*:*)
-	# From <A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">Paul.Green at stratus.com.</A>
-	echo hppa1.1-stratus-vos
-	exit ;;
-    mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit ;;
-    news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
-	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
-	fi
-        exit ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
-    SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
-	exit ;;
-    Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit ;;
-    *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
-	if test &quot;$UNAME_PROCESSOR&quot; = &quot;x86&quot;; then
-		UNAME_PROCESSOR=i386
-		UNAME_MACHINE=pc
-	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit ;;
-    *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
-    BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
-    DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit ;;
-    *:Plan9:*:*)
-	# &quot;uname -m&quot; is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test &quot;$cputype&quot; = &quot;386&quot;; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE=&quot;$cputype&quot;
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit ;;
-    *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
-    *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
-    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
-    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
-    *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
-    *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
-    SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit ;;
-    *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2&gt;/dev/null`
-	case &quot;${UNAME_MACHINE}&quot; in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
-	esac ;;
-    *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
-    i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
-	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1&gt;&amp;2
-#echo &quot;${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}&quot; 1&gt;&amp;2
-
-eval $set_cc_for_build
-cat &gt;$dummy.c &lt;&lt;EOF
-#ifdef _SEQUENT_
-# include &lt;sys/types.h&gt;
-# include &lt;sys/utsname.h&gt;
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants &quot;bsd&quot; instead of &quot;newsos&quot;.  Perhaps BFD should be changed,
-     I don't know....  */
-  printf (&quot;mips-sony-bsd\n&quot;); exit (0);
-#else
-#include &lt;sys/param.h&gt;
-  printf (&quot;m68k-sony-newsos%s\n&quot;,
-#ifdef NEWSOS4
-          &quot;4&quot;
-#else
-	  &quot;&quot;
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) &amp;&amp; defined (__acorn) &amp;&amp; defined (__unix)
-  printf (&quot;arm-acorn-riscix\n&quot;); exit (0);
-#endif
-
-#if defined (hp300) &amp;&amp; !defined (hpux)
-  printf (&quot;m68k-hp-bsd\n&quot;); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ &quot;m68k&quot;
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2&gt;/dev/null`;
-  if (version &lt; 4)
-    printf (&quot;%s-next-nextstep%d\n&quot;, __ARCHITECTURE__, version);
-  else
-    printf (&quot;%s-next-openstep%d\n&quot;, __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf (&quot;ns32k-encore-sysv\n&quot;); exit (0);
-#else
-#if defined (CMU)
-  printf (&quot;ns32k-encore-mach\n&quot;); exit (0);
-#else
-  printf (&quot;ns32k-encore-bsd\n&quot;); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf (&quot;i386-pc-bsd\n&quot;); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf (&quot;i386-sequent-dynix\n&quot;); exit (0);
-#endif
-#if defined (ns32000)
-  printf (&quot;ns32k-sequent-dynix\n&quot;); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&amp;un);
-
-    if (strncmp(un.version, &quot;V2&quot;, 2) == 0) {
-	printf (&quot;i386-sequent-ptx2\n&quot;); exit (0);
-    }
-    if (strncmp(un.version, &quot;V1&quot;, 2) == 0) { /* XXX is V1 correct? */
-	printf (&quot;i386-sequent-ptx1\n&quot;); exit (0);
-    }
-    printf (&quot;i386-sequent-ptx\n&quot;); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include &lt;sys/param.h&gt;
-#  if defined (BSD)
-#   if BSD == 43
-      printf (&quot;vax-dec-bsd4.3\n&quot;); exit (0);
-#   else
-#    if BSD == 199006
-      printf (&quot;vax-dec-bsd4.3reno\n&quot;); exit (0);
-#    else
-      printf (&quot;vax-dec-bsd\n&quot;); exit (0);
-#    endif
-#   endif
-#  else
-    printf (&quot;vax-dec-bsd\n&quot;); exit (0);
-#  endif
-# else
-    printf (&quot;vax-dec-ultrix\n&quot;); exit (0);
-# endif
-#endif
-
-#if defined (alliant) &amp;&amp; defined (i860)
-  printf (&quot;i860-alliant-bsd\n&quot;); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2&gt;/dev/null &amp;&amp; SYSTEM_NAME=`$dummy` &amp;&amp;
-	{ echo &quot;$SYSTEM_NAME&quot;; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo &amp;&amp; { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
-cat &gt;&amp;2 &lt;&lt;EOF
-$0: unable to guess system type
-
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
-
-  <A HREF="http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess">http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess</A>
-and
-  <A HREF="http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub">http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub</A>
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt; in order to provide the needed
-information to handle your system.
-
-config.guess timestamp = $timestamp
-
-uname -m = `(uname -m) 2&gt;/dev/null || echo unknown`
-uname -r = `(uname -r) 2&gt;/dev/null || echo unknown`
-uname -s = `(uname -s) 2&gt;/dev/null || echo unknown`
-uname -v = `(uname -v) 2&gt;/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2&gt;/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2&gt;/dev/null`
-
-hostinfo               = `(hostinfo) 2&gt;/dev/null`
-/bin/universe          = `(/bin/universe) 2&gt;/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2&gt;/dev/null`
-/bin/arch              = `(/bin/arch) 2&gt;/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2&gt;/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2&gt;/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
-
-exit 1
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;timestamp='&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d&quot;
-# time-stamp-end: &quot;'&quot;
-# End:

Deleted: trunk/config.rpath
===================================================================
--- trunk/config.rpath	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.rpath	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,571 +0,0 @@
-#! /bin/sh
-# Output a system dependent set of variables, describing how to set the
-# run time search path of shared libraries in an executable.
-#
-#   Copyright 1996-2005 Free Software Foundation, Inc.
-#   Taken from GNU libtool, 2001
-#   Originally by Gordon Matzigkeit &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">gord at gnu.ai.mit.edu</A>&gt;, 1996
-#
-#   This file is free software; the Free Software Foundation gives
-#   unlimited permission to copy and/or distribute it, with or without
-#   modifications, as long as this notice is preserved.
-#
-# The first argument passed to this file is the canonical host specification,
-#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or
-#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
-# should be set by the caller.
-#
-# The set of defined variables is at the end of this script.
-
-# Known limitations:
-# - On IRIX 6.5 with CC=&quot;cc&quot;, the run time search patch must not be longer
-#   than 256 bytes, otherwise the compiler driver will dump core. The only
-#   known workaround is to choose shorter directory names for the build
-#   directory and/or the installation directory.
-
-# All known linkers require a `.a' archive for static linking (except M$VC,
-# which needs '.lib').
-libext=a
-shrext=.so
-
-host=&quot;$1&quot;
-host_cpu=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
-host_vendor=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
-host_os=`echo &quot;$host&quot; | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
-
-cc_basename=`echo &quot;$CC&quot; | sed -e 's%^.*/%%'`
-
-# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
-
-wl=
-if test &quot;$GCC&quot; = yes; then
-  wl='-Wl,'
-else
-  case &quot;$host_os&quot; in
-    aix*)
-      wl='-Wl,'
-      ;;
-    darwin*)
-      case &quot;$cc_basename&quot; in
-        xlc*)
-          wl='-Wl,'
-          ;;
-      esac
-      ;;
-    mingw* | pw32* | os2*)
-      ;;
-    hpux9* | hpux10* | hpux11*)
-      wl='-Wl,'
-      ;;
-    irix5* | irix6* | nonstopux*)
-      wl='-Wl,'
-      ;;
-    newsos6)
-      ;;
-    linux*)
-      case $cc_basename in
-        icc* | ecc*)
-          wl='-Wl,'
-          ;;
-        pgcc | pgf77 | pgf90)
-          wl='-Wl,'
-          ;;
-        ccc*)
-          wl='-Wl,'
-          ;;
-        como)
-          wl='-lopt='
-          ;;
-      esac
-      ;;
-    osf3* | osf4* | osf5*)
-      wl='-Wl,'
-      ;;
-    sco3.2v5*)
-      ;;
-    solaris*)
-      wl='-Wl,'
-      ;;
-    sunos4*)
-      wl='-Qoption ld '
-      ;;
-    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-      wl='-Wl,'
-      ;;
-    sysv4*MP*)
-      ;;
-    unicos*)
-      wl='-Wl,'
-      ;;
-    uts4*)
-      ;;
-  esac
-fi
-
-# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
-
-hardcode_libdir_flag_spec=
-hardcode_libdir_separator=
-hardcode_direct=no
-hardcode_minus_L=no
-
-case &quot;$host_os&quot; in
-  cygwin* | mingw* | pw32*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test &quot;$GCC&quot; != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-esac
-
-ld_shlibs=yes
-if test &quot;$with_gnu_ld&quot; = yes; then
-  case &quot;$host_os&quot; in
-    aix3* | aix4* | aix5*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test &quot;$host_cpu&quot; != ia64; then
-        ld_shlibs=no
-      fi
-      ;;
-    amigaos*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      # Samuel A. Falvo II &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">kc5tja at dolphin.openprojects.net</A>&gt; reports
-      # that the semantics of dynamic libraries on AmigaOS, at least up
-      # to version 4, is to share data among multiple programs linked
-      # with the same dynamic library.  Since this doesn't match the
-      # behavior of shared libraries on other platforms, we cannot use
-      # them.
-      ld_shlibs=no
-      ;;
-    beos*)
-      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    cygwin* | mingw* | pw32*)
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      if $LD --help 2&gt;&amp;1 | grep 'auto-import' &gt; /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    netbsd*)
-      ;;
-    solaris* | sysv5*)
-      if $LD -v 2&gt;&amp;1 | grep 'BFD 2\.8' &gt; /dev/null; then
-        ld_shlibs=no
-      elif $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    sunos4*)
-      hardcode_direct=yes
-      ;;
-    linux*)
-      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-    *)
-      if $LD --help 2&gt;&amp;1 | grep ': supported targets:.* elf' &gt; /dev/null; then
-        :
-      else
-        ld_shlibs=no
-      fi
-      ;;
-  esac
-  if test &quot;$ld_shlibs&quot; = yes; then
-    # Unlike libtool, we use -rpath here, not --rpath, since the documented
-    # option of GNU ld is called -rpath, not --rpath.
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-  fi
-else
-  case &quot;$host_os&quot; in
-    aix3*)
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test &quot;$GCC&quot; = yes; then
-        # Neither direct hardcoding nor static linking is supported with a
-        # broken collect2.
-        hardcode_direct=unsupported
-      fi
-      ;;
-    aix4* | aix5*)
-      if test &quot;$host_cpu&quot; = ia64; then
-        # On IA64, the linker does run time linking by default, so we don't
-        # have to do anything special.
-        aix_use_runtimelinking=no
-      else
-        aix_use_runtimelinking=no
-        # Test if we are trying to use run time linking or normal
-        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-        # need to do runtime linking.
-        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
-          for ld_flag in $LDFLAGS; do
-            if (test $ld_flag = &quot;-brtl&quot; || test $ld_flag = &quot;-Wl,-brtl&quot;); then
-              aix_use_runtimelinking=yes
-              break
-            fi
-          done
-        esac
-      fi
-      hardcode_direct=yes
-      hardcode_libdir_separator=':'
-      if test &quot;$GCC&quot; = yes; then
-        case $host_os in aix4.[012]|aix4.[012].*)
-          collect2name=`${CC} -print-prog-name=collect2`
-          if test -f &quot;$collect2name&quot; &amp;&amp; \
-            strings &quot;$collect2name&quot; | grep resolve_lib_name &gt;/dev/null
-          then
-            # We have reworked collect2
-            hardcode_direct=yes
-          else
-            # We have old collect2
-            hardcode_direct=unsupported
-            hardcode_minus_L=yes
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_libdir_separator=
-          fi
-        esac
-      fi
-      # Begin _LT_AC_SYS_LIBPATH_AIX.
-      echo 'int main () { return 0; }' &gt; conftest.c
-      ${CC} ${LDFLAGS} conftest.c -o conftest
-      aix_libpath=`dump -H conftest 2&gt;/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
-}'`
-      if test -z &quot;$aix_libpath&quot;; then
-        aix_libpath=`dump -HX64 conftest 2&gt;/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
-}'`
-      fi
-      if test -z &quot;$aix_libpath&quot;; then
-        aix_libpath=&quot;/usr/lib:/lib&quot;
-      fi
-      rm -f conftest.c conftest
-      # End _LT_AC_SYS_LIBPATH_AIX.
-      if test &quot;$aix_use_runtimelinking&quot; = yes; then
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'&quot;$aix_libpath&quot;
-      else
-        if test &quot;$host_cpu&quot; = ia64; then
-          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-        else
-          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'&quot;$aix_libpath&quot;
-        fi
-      fi
-      ;;
-    amigaos*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      # see comment about different semantics on the GNU ld section
-      ld_shlibs=no
-      ;;
-    bsdi[45]*)
-      ;;
-    cygwin* | mingw* | pw32*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      libext=lib
-      ;;
-    darwin* | rhapsody*)
-      hardcode_direct=no
-      if test &quot;$GCC&quot; = yes ; then
-        :
-      else
-        case &quot;$cc_basename&quot; in
-          xlc*)
-            ;;
-          *)
-            ld_shlibs=no
-            ;;
-        esac
-      fi
-      ;;
-    dgux*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      ;;
-    freebsd1*)
-      ld_shlibs=no
-      ;;
-    freebsd2.2*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    freebsd2*)
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      ;;
-    freebsd* | kfreebsd*-gnu | dragonfly*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    hpux9*)
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      ;;
-    hpux10* | hpux11*)
-      if test &quot;$with_gnu_ld&quot; = no; then
-        case &quot;$host_cpu&quot; in
-          hppa*64*)
-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-            hardcode_libdir_separator=:
-            hardcode_direct=no
-            ;;
-          ia64*)
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_direct=no
-            # hardcode_minus_L: Not really in the search PATH,
-            # but as the default location of the library.
-            hardcode_minus_L=yes
-            ;;
-          *)
-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-            hardcode_libdir_separator=:
-            hardcode_direct=yes
-            # hardcode_minus_L: Not really in the search PATH,
-            # but as the default location of the library.
-            hardcode_minus_L=yes
-            ;;
-        esac
-      fi
-      ;;
-    irix5* | irix6* | nonstopux*)
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    netbsd*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      ;;
-    newsos6)
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    openbsd*)
-      hardcode_direct=yes
-      if test -z &quot;`echo __ELF__ | $CC -E - | grep __ELF__`&quot; || test &quot;$host_os-$host_cpu&quot; = &quot;openbsd2.8-powerpc&quot;; then
-        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      else
-        case &quot;$host_os&quot; in
-          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-            hardcode_libdir_flag_spec='-R$libdir'
-            ;;
-          *)
-            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-            ;;
-        esac
-      fi
-      ;;
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      ;;
-    osf3*)
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-    osf4* | osf5*)
-      if test &quot;$GCC&quot; = yes; then
-        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-        # Both cc and cxx compiler support -rpath directly
-        hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      hardcode_libdir_separator=:
-      ;;
-    sco3.2v5*)
-      ;;
-    solaris*)
-      hardcode_libdir_flag_spec='-R$libdir'
-      ;;
-    sunos4*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      ;;
-    sysv4)
-      case $host_vendor in
-        sni)
-          hardcode_direct=yes # is this really true???
-          ;;
-        siemens)
-          hardcode_direct=no
-          ;;
-        motorola)
-          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-          ;;
-      esac
-      ;;
-    sysv4.3*)
-      ;;
-    sysv4*MP*)
-      if test -d /usr/nec; then
-        ld_shlibs=yes
-      fi
-      ;;
-    sysv4.2uw2*)
-      hardcode_direct=yes
-      hardcode_minus_L=no
-      ;;
-    sysv5OpenUNIX8* | sysv5UnixWare7* |  sysv5uw[78]* | unixware7*)
-      ;;
-    sysv5*)
-      hardcode_libdir_flag_spec=
-      ;;
-    uts4*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      ;;
-    *)
-      ld_shlibs=no
-      ;;
-  esac
-fi
-
-# Check dynamic linker characteristics
-# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
-libname_spec='lib$name'
-case &quot;$host_os&quot; in
-  aix3*)
-    ;;
-  aix4* | aix5*)
-    ;;
-  amigaos*)
-    ;;
-  beos*)
-    ;;
-  bsdi[45]*)
-    ;;
-  cygwin* | mingw* | pw32*)
-    shrext=.dll
-    ;;
-  darwin* | rhapsody*)
-    shrext=.dylib
-    ;;
-  dgux*)
-    ;;
-  freebsd1*)
-    ;;
-  kfreebsd*-gnu)
-    ;;
-  freebsd*)
-    ;;
-  gnu*)
-    ;;
-  hpux9* | hpux10* | hpux11*)
-    case &quot;$host_cpu&quot; in
-      ia64*)
-        shrext=.so
-        ;;
-      hppa*64*)
-        shrext=.sl
-        ;;
-      *)
-        shrext=.sl
-        ;;
-    esac
-    ;;
-  irix5* | irix6* | nonstopux*)
-    case &quot;$host_os&quot; in
-      irix5* | nonstopux*)
-        libsuff= shlibsuff=
-        ;;
-      *)
-        case $LD in
-          *-32|*&quot;-32 &quot;|*-melf32bsmip|*&quot;-melf32bsmip &quot;) libsuff= shlibsuff= ;;
-          *-n32|*&quot;-n32 &quot;|*-melf32bmipn32|*&quot;-melf32bmipn32 &quot;) libsuff=32 shlibsuff=N32 ;;
-          *-64|*&quot;-64 &quot;|*-melf64bmip|*&quot;-melf64bmip &quot;) libsuff=64 shlibsuff=64 ;;
-          *) libsuff= shlibsuff= ;;
-        esac
-        ;;
-    esac
-    ;;
-  linux*oldld* | linux*aout* | linux*coff*)
-    ;;
-  linux*)
-    ;;
-  knetbsd*-gnu)
-    ;;
-  netbsd*)
-    ;;
-  newsos6)
-    ;;
-  nto-qnx*)
-    ;;
-  openbsd*)
-    ;;
-  os2*)
-    libname_spec='$name'
-    shrext=.dll
-    ;;
-  osf3* | osf4* | osf5*)
-    ;;
-  sco3.2v5*)
-    ;;
-  solaris*)
-    ;;
-  sunos4*)
-    ;;
-  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-    ;;
-  sysv4*MP*)
-    ;;
-  uts4*)
-    ;;
-esac
-
-sed_quote_subst='s/\([&quot;`$\\]\)/\\\1/g'
-escaped_wl=`echo &quot;X$wl&quot; | sed -e 's/^X//' -e &quot;$sed_quote_subst&quot;`
-shlibext=`echo &quot;$shrext&quot; | sed -e 's,^\.,,'`
-escaped_hardcode_libdir_flag_spec=`echo &quot;X$hardcode_libdir_flag_spec&quot; | sed -e 's/^X//' -e &quot;$sed_quote_subst&quot;`
-
-LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' &lt;&lt;EOF
-
-# How to pass a linker flag through the compiler.
-wl=&quot;$escaped_wl&quot;
-
-# Static library suffix (normally &quot;a&quot;).
-libext=&quot;$libext&quot;
-
-# Shared library suffix (normally &quot;so&quot;).
-shlibext=&quot;$shlibext&quot;
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec=&quot;$escaped_hardcode_libdir_flag_spec&quot;
-
-# Whether we need a single -rpath flag with a separated argument.
-hardcode_libdir_separator=&quot;$hardcode_libdir_separator&quot;
-
-# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
-# resulting binary.
-hardcode_direct=&quot;$hardcode_direct&quot;
-
-# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
-# resulting binary.
-hardcode_minus_L=&quot;$hardcode_minus_L&quot;
-
-EOF

Deleted: trunk/config.sub
===================================================================
--- trunk/config.sub	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/config.sub	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,1579 +0,0 @@
-#! /bin/sh
-# Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-timestamp='2005-07-08'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Please send patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
-# Configuration subroutine to validate and canonicalize a configuration type.
-# Supply the specified configuration type as an argument.
-# If it is invalid, we print an error message on stderr and exit with code 1.
-# Otherwise, we print the canonical config type on stdout and succeed.
-
-# This file is supposed to be the same for all GNU packages
-# and recognize all the CPU types, system types and aliases
-# that are meaningful with *any* GNU software.
-# Each package is responsible for reporting which valid configurations
-# it does not support.  The user should be able to distinguish
-# a failure to support a valid configuration from a meaningless
-# configuration.
-
-# The goal of this file is to map all the various variations of a given
-# machine specification into a single specification in the form:
-#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or in some cases, the newer four-part form:
-#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# It is wrong to echo any other type of specification.
-
-me=`echo &quot;$0&quot; | sed -e 's,.*/,,'`
-
-usage=&quot;\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">config-patches at gnu.org</A>&gt;.&quot;
-
-version=&quot;\
-GNU config.sub ($timestamp)
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&quot;
-
-help=&quot;
-Try \`$me --help' for more information.&quot;
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo &quot;$timestamp&quot; ; exit ;;
-    --version | -v )
-       echo &quot;$version&quot; ; exit ;;
-    --help | --h* | -h )
-       echo &quot;$usage&quot;; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo &quot;$me: invalid option $1$help&quot;
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit ;;
-
-    * )
-       break ;;
-  esac
-done
-
-case $# in
- 0) echo &quot;$me: missing argument$help&quot; &gt;&amp;2
-    exit 1;;
- 1) ;;
- *) echo &quot;$me: too many arguments$help&quot; &gt;&amp;2
-    exit 1;;
-esac
-
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
-  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
-		os=
-		basic_machine=$1
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
-		basic_machine=$1
-		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
-		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
-		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
-		;;
-	-psos*)
-		os=-psos
-		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-esac
-
-# Decode aliases for certain CPU-COMPANY combinations.
-case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| bfin \
-	| c4x | clipper \
-	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
-	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
-	| mips | mipsbe | mipseb | mipsel | mipsle \
-	| mips16 \
-	| mips64 | mips64el \
-	| mips64vr | mips64vrel \
-	| mips64orion | mips64orionel \
-	| mips64vr4100 | mips64vr4100el \
-	| mips64vr4300 | mips64vr4300el \
-	| mips64vr5000 | mips64vr5000el \
-	| mips64vr5900 | mips64vr5900el \
-	| mipsisa32 | mipsisa32el \
-	| mipsisa32r2 | mipsisa32r2el \
-	| mipsisa64 | mipsisa64el \
-	| mipsisa64r2 | mipsisa64r2el \
-	| mipsisa64sb1 | mipsisa64sb1el \
-	| mipsisa64sr71k | mipsisa64sr71kel \
-	| mipstx39 | mipstx39el \
-	| mn10200 | mn10300 \
-	| ms1 \
-	| msp430 \
-	| ns16k | ns32k \
-	| or32 \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
-	| sh64 | sh64le \
-	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
-	| sparcv8 | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
-	| we32k \
-	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k)
-		basic_machine=$basic_machine-unknown
-		;;
-	m32c)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
-		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word &quot;unknown&quot; tends to confuse beginning users.
-	i*86 | x86_64)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1&gt;&amp;2
-		exit 1
-		;;
-	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
-	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
-	| m32r-* | m32rle-* \
-	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* \
-	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
-	| mips16-* \
-	| mips64-* | mips64el-* \
-	| mips64vr-* | mips64vrel-* \
-	| mips64orion-* | mips64orionel-* \
-	| mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* \
-	| mips64vr5000-* | mips64vr5000el-* \
-	| mips64vr5900-* | mips64vr5900el-* \
-	| mipsisa32-* | mipsisa32el-* \
-	| mipsisa32r2-* | mipsisa32r2el-* \
-	| mipsisa64-* | mipsisa64el-* \
-	| mipsisa64r2-* | mipsisa64r2el-* \
-	| mipsisa64sb1-* | mipsisa64sb1el-* \
-	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
-	| mipstx39-* | mipstx39el-* \
-	| mmix-* \
-	| ms1-* \
-	| msp430-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
-	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
-	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
-	| tron-* \
-	| v850-* | v850e-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa-* \
-	| ymp-* \
-	| z8k-*)
-		;;
-	m32c-*)
-		;;
-	# Recognize the various machine names and aliases which stand
-	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
-	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
-		;;
-	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-    	abacus)
-		basic_machine=abacus-unknown
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amd64)
-		basic_machine=x86_64-pc
-		;;
-	amd64-*)
-		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-unknown
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-unknown
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	c90)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | j90)
-		basic_machine=j90-cray
-		os=-unicos
-		;;
-	craynv)
-		basic_machine=craynv-cray
-		os=-unicosmp
-		;;
-	cr16c)
-		basic_machine=cr16c-unknown
-		os=-elf
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	crisv32 | crisv32-* | etraxfs*)
-		basic_machine=crisv32-axis
-		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
-	crx)
-		basic_machine=crx-unknown
-		os=-elf
-		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
-		;;
-	decsystem10* | dec10*)
-		basic_machine=pdp10-dec
-		os=-tops10
-		;;
-	decsystem20* | dec20*)
-		basic_machine=pdp10-dec
-		os=-tops20
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	djgpp)
-		basic_machine=i586-pc
-		os=-msdosdjgpp
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
-		;;
-	encore | umax | mmax)
-		basic_machine=ns32k-encore
-		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
-		;;
-	fx2800)
-		basic_machine=i860-alliant
-		;;
-	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
-		;;
-	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
-		;;
-	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
-		;;
-	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
-		;;
-	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k78[0-9] | hp78[0-9])
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
-		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		;;
-# I'm not sure what &quot;Sysv32&quot; means.  Should this be sysv3.2?
-	i*86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
-		;;
-	i*86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
-		;;
-	i*86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
-		;;
-	i*86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
-		;;
-	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
-			;;
-		    *)
-			os=-irix4
-			;;
-		esac
-		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
-	miniframe)
-		basic_machine=m68000-convergent
-		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	morphos)
-		basic_machine=powerpc-unknown
-		os=-morphos
-		;;
-	msdos)
-		basic_machine=i386-pc
-		os=-msdos
-		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-rebel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
-		;;
-	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
-		;;
-	np1)
-		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
-		;;
-	openrisc | openrisc-*)
-		basic_machine=or32-unknown
-		;;
-	os400)
-		basic_machine=powerpc-ibm
-		os=-os400
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
-		;;
-	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	pbd)
-		basic_machine=sparc-tti
-		;;
-	pbb)
-		basic_machine=m68k-tti
-		;;
-	pc532 | pc532-*)
-		basic_machine=ns32k-pc532
-		;;
-	pentium | p5 | k5 | k6 | nexgen | viac3)
-		basic_machine=i586-pc
-		;;
-	pentiumpro | p6 | 6x86 | athlon | athlon_*)
-		basic_machine=i686-pc
-		;;
-	pentiumii | pentium2 | pentiumiii | pentium3)
-		basic_machine=i686-pc
-		;;
-	pentium4)
-		basic_machine=i786-pc
-		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentium4-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pn)
-		basic_machine=pn-gould
-		;;
-	power)	basic_machine=power-ibm
-		;;
-	ppc)	basic_machine=powerpc-unknown
-		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
-		;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64)	basic_machine=powerpc64-unknown
-		;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
-		;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ps2)
-		basic_machine=i386-ibm
-		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	rm[46]00)
-		basic_machine=mips-siemens
-		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
-		;;
-	s390 | s390-*)
-		basic_machine=s390-ibm
-		;;
-	s390x | s390x-*)
-		basic_machine=s390x-ibm
-		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	sb1)
-		basic_machine=mipsisa64sb1-unknown
-		;;
-	sb1el)
-		basic_machine=mipsisa64sb1el-unknown
-		;;
-	sei)
-		basic_machine=mips-sei
-		os=-seiux
-		;;
-	sequent)
-		basic_machine=i386-sequent
-		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
-		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparclite-wrs | simso-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
-		;;
-	spur)
-		basic_machine=spur-unknown
-		;;
-	st2000)
-		basic_machine=m68k-tandem
-		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
-	sun2)
-		basic_machine=m68000-sun
-		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
-		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
-		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
-		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
-		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
-		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
-		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
-		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
-		;;
-	sun4)
-		basic_machine=sparc-sun
-		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
-		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
-		;;
-	t3e)
-		basic_machine=alphaev5-cray
-		os=-unicos
-		;;
-	t90)
-		basic_machine=t90-cray
-		os=-unicos
-		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
-	toad1)
-		basic_machine=pdp10-xkl
-		os=-tops20
-		;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
-		;;
-	tpf)
-		basic_machine=s390x-ibm
-		os=-tpf
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
-		;;
-	vpp*|vx|vx-*)
-		basic_machine=f301-fujitsu
-		;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
-	xbox)
-		basic_machine=i686-pc
-		os=-mingw32
-		;;
-	xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
-	none)
-		basic_machine=none-none
-		os=-none
-		;;
-
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	mmix)
-		basic_machine=mmix-knuth
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
-		;;
-	we32k)
-		basic_machine=we32k-att
-		;;
-	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
-		basic_machine=sh-unknown
-		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b)
-		basic_machine=sparc-sun
-		;;
-	cydra)
-		basic_machine=cydra-cydrome
-		;;
-	orion)
-		basic_machine=orion-highlevel
-		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
-		;;
-	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1&gt;&amp;2
-		exit 1
-		;;
-esac
-
-# Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
-		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
-		;;
-	*)
-		;;
-esac
-
-# Decode manufacturer-specific aliases for certain operating systems.
-
-if [ x&quot;$os&quot; != x&quot;&quot; ]
-then
-case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware*)
-		os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
-	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
-	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
-		;;
-	-nto-qnx*)
-		;;
-	-nto*)
-		os=`echo $os | sed -e 's|nto|nto-qnx|'`
-		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
-		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
-		;;
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
-		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
-		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
-		;;
-	-opened*)
-		os=-openedition
-		;;
-        -os400*)
-		os=-os400
-		;;
-	-wince*)
-		os=-wince
-		;;
-	-osfrose*)
-		os=-osfrose
-		;;
-	-osf*)
-		os=-osf
-		;;
-	-utek*)
-		os=-bsd
-		;;
-	-dynix*)
-		os=-bsd
-		;;
-	-acis*)
-		os=-aos
-		;;
-	-atheos*)
-		os=-atheos
-		;;
-	-syllable*)
-		os=-syllable
-		;;
-	-386bsd)
-		os=-bsd
-		;;
-	-ctix* | -uts*)
-		os=-sysv
-		;;
-	-nova*)
-		os=-rtmk-nova
-		;;
-	-ns2 )
-		os=-nextstep2
-		;;
-	-nsk*)
-		os=-nsk
-		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
-		;;
-	-sinix*)
-		os=-sysv4
-		;;
-        -tpf*)
-		os=-tpf
-		;;
-	-triton*)
-		os=-sysv3
-		;;
-	-oss*)
-		os=-sysv3
-		;;
-	-svr4)
-		os=-sysv4
-		;;
-	-svr3)
-		os=-sysv3
-		;;
-	-sysvr4)
-		os=-sysv4
-		;;
-	# This must come after -sysvr4.
-	-sysv*)
-		;;
-	-ose*)
-		os=-ose
-		;;
-	-es1800*)
-		os=-ose
-		;;
-	-xenix)
-		os=-xenix
-		;;
-	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-		os=-mint
-		;;
-	-aros*)
-		os=-aros
-		;;
-	-kaos*)
-		os=-kaos
-		;;
-	-zvmoe)
-		os=-zvmoe
-		;;
-	-none)
-		;;
-	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1&gt;&amp;2
-		exit 1
-		;;
-esac
-else
-
-# Here we handle the default operating systems that come with various machines.
-# The value should be what the vendor currently ships out the door with their
-# machine or put another way, the most popular os provided with the machine.
-
-# Note that if you're going to try to match &quot;-MANUFACTURER&quot; here (say,
-# &quot;-sun&quot;), then you have to tell the case statement up towards the top
-# that MANUFACTURER isn't an operating system.  Otherwise, code above
-# will signal an error saying that MANUFACTURER isn't an operating
-# system, and we'll never get to this point.
-
-case $basic_machine in
-	*-acorn)
-		os=-riscix1.2
-		;;
-	arm*-rebel)
-		os=-linux
-		;;
-	arm*-semi)
-		os=-aout
-		;;
-    c4x-* | tic4x-*)
-        os=-coff
-        ;;
-	# This must come before the *-dec entry.
-	pdp10-*)
-		os=-tops20
-		;;
-	pdp11-*)
-		os=-none
-		;;
-	*-dec | vax-*)
-		os=-ultrix4.2
-		;;
-	m68*-apollo)
-		os=-domain
-		;;
-	i386-sun)
-		os=-sunos4.0.2
-		;;
-	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
-		;;
-	m68*-cisco)
-		os=-aout
-		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
-	or32-*)
-		os=-coff
-		;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
-		;;
-	sparc-* | *-sun)
-		os=-sunos4.1.1
-		;;
-	*-be)
-		os=-beos
-		;;
-	*-haiku)
-		os=-haiku
-		;;
-	*-ibm)
-		os=-aix
-		;;
-    	*-knuth)
-		os=-mmixware
-		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
-		;;
-	*-oki)
-		os=-proelf
-		;;
-	*-hp)
-		os=-hpux
-		;;
-	*-hitachi)
-		os=-hiux
-		;;
-	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
-		;;
-	*-cbm)
-		os=-amigaos
-		;;
-	*-dg)
-		os=-dgux
-		;;
-	*-dolphin)
-		os=-sysv3
-		;;
-	m68k-ccur)
-		os=-rtu
-		;;
-	m88k-omron*)
-		os=-luna
-		;;
-	*-next )
-		os=-nextstep
-		;;
-	*-sequent)
-		os=-ptx
-		;;
-	*-crds)
-		os=-unos
-		;;
-	*-ns)
-		os=-genix
-		;;
-	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
-		;;
-	*-gould)
-		os=-sysv
-		;;
-	*-highlevel)
-		os=-bsd
-		;;
-	*-encore)
-		os=-bsd
-		;;
-	*-sgi)
-		os=-irix
-		;;
-	*-siemens)
-		os=-sysv4
-		;;
-	*-masscomp)
-		os=-rtu
-		;;
-	f30[01]-fujitsu | f700-fujitsu)
-		os=-uxpv
-		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
-		;;
-	*)
-		os=-none
-		;;
-esac
-fi
-
-# Here we handle the case where we know the os, and the CPU type, but not the
-# manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
-				vendor=acorn
-				;;
-			-sunos*)
-				vendor=sun
-				;;
-			-aix*)
-				vendor=ibm
-				;;
-			-beos*)
-				vendor=be
-				;;
-			-hpux*)
-				vendor=hp
-				;;
-			-mpeix*)
-				vendor=hp
-				;;
-			-hiux*)
-				vendor=hitachi
-				;;
-			-unos*)
-				vendor=crds
-				;;
-			-dgux*)
-				vendor=dg
-				;;
-			-luna*)
-				vendor=omron
-				;;
-			-genix*)
-				vendor=ns
-				;;
-			-mvs* | -opened*)
-				vendor=ibm
-				;;
-			-os400*)
-				vendor=ibm
-				;;
-			-ptx*)
-				vendor=sequent
-				;;
-			-tpf*)
-				vendor=ibm
-				;;
-			-vxsim* | -vxworks* | -windiss*)
-				vendor=wrs
-				;;
-			-aux*)
-				vendor=apple
-				;;
-			-hms*)
-				vendor=hitachi
-				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-				vendor=atari
-				;;
-			-vos*)
-				vendor=stratus
-				;;
-		esac
-		basic_machine=`echo $basic_machine | sed &quot;s/unknown/$vendor/&quot;`
-		;;
-esac
-
-echo $basic_machine$os
-exit
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;timestamp='&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d&quot;
-# time-stamp-end: &quot;'&quot;
-# End:

Deleted: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/configure.ac	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,52 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ(2.57)
-AC_INIT(sst, 2.0, stsp)
-AM_INIT_AUTOMAKE([])
-AM_GNU_GETTEXT([external])
-AM_GNU_GETTEXT_VERSION(0.14.5)
-AM_CONFIG_HEADER([src/config.h])
-
-# Checks for programs.
-AC_PROG_CC
-AC_PROG_INSTALL
-AC_PROG_LN_S
-
-AC_CHECK_TOOL(have_xmlto, xmlto, &quot;no&quot;)
-if test &quot;$have_xmlto&quot; = &quot;no&quot;;
-then
-    AC_MSG_ERROR([xmlto is not installed])
-fi
-AC_CHECK_TOOL(have_python, python, &quot;no&quot;)
-if test &quot;$have_python&quot; = &quot;no&quot;;
-then
-    AC_MSG_ERROR([python is not installed])
-fi
-
-# Checks for libraries.
-AC_CHECK_LIB(m, floor, [],
-    AC_MSG_ERROR([math library is missing on your system.]))
-AC_CHECK_LIB(ncursesw, newwin, [],
-    AC_MSG_ERROR([ncurses library is missing on your system.]))
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([curses.h],
-    [], AC_MSG_ERROR([curses headers are missing on your system.]))
-AC_CHECK_HEADERS([fcntl.h sys/ioctl.h linux/kd.h])
-# Checks for typedefs, structures, and compiler characteristics.
-
-# Checks for library functions.
-AC_PROG_GCC_TRADITIONAL
-AC_FUNC_VPRINTF
-AC_CHECK_FUNCS([pow sqrt floor strcasecmp strncasecmp strchr strstr atexit], [],
-    AC_MSG_ERROR([some functions are missing on your system.]))
-
-AC_CONFIG_FILES([
-    Makefile
-    src/Makefile
-    po/Makefile.in
-    doc/Makefile
-])
-AC_OUTPUT

Deleted: trunk/depcomp
===================================================================
--- trunk/depcomp	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/depcomp	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,530 +0,0 @@
-#! /bin/sh
-# depcomp - compile a program generating dependencies as side-effects
-
-scriptversion=2005-07-09.11
-
-# Copyright (C) 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-# 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Originally written by Alexandre Oliva &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">oliva at dcc.unicamp.br</A>&gt;.
-
-case $1 in
-  '')
-     echo &quot;$0: No command.  Try \`$0 --help' for more information.&quot; 1&gt;&amp;2
-     exit 1;
-     ;;
-  -h | --h*)
-    cat &lt;&lt;\EOF
-Usage: depcomp [--help] [--version] PROGRAM [ARGS]
-
-Run PROGRAMS ARGS to compile a file, generating dependencies
-as side-effects.
-
-Environment variables:
-  depmode     Dependency tracking mode.
-  source      Source file read by `PROGRAMS ARGS'.
-  object      Object file output by `PROGRAMS ARGS'.
-  DEPDIR      directory where to store dependencies.
-  depfile     Dependency file to output.
-  tmpdepfile  Temporary file to use when outputing dependencies.
-  libtool     Whether libtool is used (yes/no).
-
-Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.
-EOF
-    exit $?
-    ;;
-  -v | --v*)
-    echo &quot;depcomp $scriptversion&quot;
-    exit $?
-    ;;
-esac
-
-if test -z &quot;$depmode&quot; || test -z &quot;$source&quot; || test -z &quot;$object&quot;; then
-  echo &quot;depcomp: Variables source, object and depmode must be set&quot; 1&gt;&amp;2
-  exit 1
-fi
-
-# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
-depfile=${depfile-`echo &quot;$object&quot; |
-  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&amp;|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
-tmpdepfile=${tmpdepfile-`echo &quot;$depfile&quot; | sed 's/\.\([^.]*\)$/.T\1/'`}
-
-rm -f &quot;$tmpdepfile&quot;
-
-# Some modes work just like other modes, but use different flags.  We
-# parameterize here, but still list the modes in the big case below,
-# to make depend.m4 easier to write.  Note that we *cannot* use a case
-# here, because this file can only contain one case statement.
-if test &quot;$depmode&quot; = hp; then
-  # HP compiler uses -M and no extra arg.
-  gccflag=-M
-  depmode=gcc
-fi
-
-if test &quot;$depmode&quot; = dashXmstdout; then
-   # This is just like dashmstdout with a different argument.
-   dashmflag=-xM
-   depmode=dashmstdout
-fi
-
-case &quot;$depmode&quot; in
-gcc3)
-## gcc 3 implements dependency tracking that does exactly what
-## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
-## it if -MD -MP comes after the -MF stuff.  Hmm.
-  &quot;$@&quot; -MT &quot;$object&quot; -MD -MP -MF &quot;$tmpdepfile&quot;
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f &quot;$tmpdepfile&quot;
-    exit $stat
-  fi
-  mv &quot;$tmpdepfile&quot; &quot;$depfile&quot;
-  ;;
-
-gcc)
-## There are various ways to get dependency output from gcc.  Here's
-## why we pick this rather obscure method:
-## - Don't want to use -MD because we'd like the dependencies to end
-##   up in a subdir.  Having to rename by hand is ugly.
-##   (We might end up doing this anyway to support other compilers.)
-## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
-##   -MM, not -M (despite what the docs say).
-## - Using -M directly means running the compiler twice (even worse
-##   than renaming).
-  if test -z &quot;$gccflag&quot;; then
-    gccflag=-MD,
-  fi
-  &quot;$@&quot; -Wp,&quot;$gccflag$tmpdepfile&quot;
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f &quot;$tmpdepfile&quot;
-    exit $stat
-  fi
-  rm -f &quot;$depfile&quot;
-  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
-  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
-## The second -e expression handles DOS-style file names with drive letters.
-  sed -e 's/^[^:]*: / /' \
-      -e 's/^['$alpha']:\/[^:]*: / /' &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
-## This next piece of magic avoids the `deleted header file' problem.
-## The problem is that when a header file which appears in a .P file
-## is deleted, the dependency causes make to die (because there is
-## typically no way to rebuild the header).  We avoid this by adding
-## dummy dependencies for each header file.  Too bad gcc doesn't do
-## this for us directly.
-  tr ' ' '
-' &lt; &quot;$tmpdepfile&quot; |
-## Some versions of gcc put a space before the `:'.  On the theory
-## that the space means something, we add a space to the output as
-## well.
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-hp)
-  # This case exists only to let depend.m4 do its work.  It works by
-  # looking at the text of this script.  This case will never be run,
-  # since it is checked for above.
-  exit 1
-  ;;
-
-sgi)
-  if test &quot;$libtool&quot; = yes; then
-    &quot;$@&quot; &quot;-Wp,-MDupdate,$tmpdepfile&quot;
-  else
-    &quot;$@&quot; -MDupdate &quot;$tmpdepfile&quot;
-  fi
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f &quot;$tmpdepfile&quot;
-    exit $stat
-  fi
-  rm -f &quot;$depfile&quot;
-
-  if test -f &quot;$tmpdepfile&quot;; then  # yes, the sourcefile depend on other files
-    echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
-
-    # Clip off the initial element (the dependent).  Don't try to be
-    # clever and replace this with sed code, as IRIX sed won't handle
-    # lines with more than a fixed number of characters (4096 in
-    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
-    # the IRIX cc adds comments like `#:fec' to the end of the
-    # dependency line.
-    tr ' ' '
-' &lt; &quot;$tmpdepfile&quot; \
-    | sed -e 's/^.*\.<A HREF="o://">o://</A>' -e 's/#.*$//' -e '/^$/ d' | \
-    tr '
-' ' ' &gt;&gt; $depfile
-    echo &gt;&gt; $depfile
-
-    # The second pass generates a dummy entry for each header file.
-    tr ' ' '
-' &lt; &quot;$tmpdepfile&quot; \
-   | sed -e 's/^.*\.<A HREF="o://">o://</A>' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
-   &gt;&gt; $depfile
-  else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # &quot;include basename.Plo&quot; scheme.
-    echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
-  fi
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-aix)
-  # The C for AIX Compiler uses -M and outputs the dependencies
-  # in a .u file.  In older versions, this file always lives in the
-  # current directory.  Also, the AIX compiler puts `$object:' at the
-  # start of each line; $object doesn't have directory information.
-  # Version 6 uses the directory in both cases.
-  stripped=`echo &quot;$object&quot; | sed 's/\(.*\)\..*$/\1/'`
-  tmpdepfile=&quot;$stripped.u&quot;
-  if test &quot;$libtool&quot; = yes; then
-    &quot;$@&quot; -Wc,-M
-  else
-    &quot;$@&quot; -M
-  fi
-  stat=$?
-
-  if test -f &quot;$tmpdepfile&quot;; then :
-  else
-    stripped=`echo &quot;$stripped&quot; | sed 's,^.*/,,'`
-    tmpdepfile=&quot;$stripped.u&quot;
-  fi
-
-  if test $stat -eq 0; then :
-  else
-    rm -f &quot;$tmpdepfile&quot;
-    exit $stat
-  fi
-
-  if test -f &quot;$tmpdepfile&quot;; then
-    outname=&quot;$stripped.o&quot;
-    # Each line is of the form `foo.o: dependent.h'.
-    # Do two passes, one to just change these to
-    # `$object: dependent.h' and one to simply `dependent.h:'.
-    sed -e &quot;s,^$outname:,$object :,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
-    sed -e &quot;s,^$outname: \(.*\)$,\1:,&quot; &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
-  else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # &quot;include basename.Plo&quot; scheme.
-    echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
-  fi
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-icc)
-  # Intel's C compiler understands `-MD -MF file'.  However on
-  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
-  # ICC 7.0 will fill foo.d with something like
-  #    foo.o: sub/foo.c
-  #    foo.o: sub/foo.h
-  # which is wrong.  We want:
-  #    sub/foo.o: sub/foo.c
-  #    sub/foo.o: sub/foo.h
-  #    sub/foo.c:
-  #    sub/foo.h:
-  # ICC 7.1 will output
-  #    foo.o: sub/foo.c sub/foo.h
-  # and will wrap long lines using \ :
-  #    foo.o: sub/foo.c ... \
-  #     sub/foo.h ... \
-  #     ...
-
-  &quot;$@&quot; -MD -MF &quot;$tmpdepfile&quot;
-  stat=$?
-  if test $stat -eq 0; then :
-  else
-    rm -f &quot;$tmpdepfile&quot;
-    exit $stat
-  fi
-  rm -f &quot;$depfile&quot;
-  # Each line is of the form `foo.o: dependent.h',
-  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
-  # Do two passes, one to just change these to
-  # `$object: dependent.h' and one to simply `dependent.h:'.
-  sed &quot;s,^[^:]*:,$object :,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
-  # Some versions of the HPUX 10.20 sed can't process this invocation
-  # correctly.  Breaking it into two sed invocations is a workaround.
-  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' &lt; &quot;$tmpdepfile&quot; |
-    sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-tru64)
-   # The Tru64 compiler uses -MD to generate dependencies as a side
-   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
-   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
-   # dependencies in `foo.d' instead, so we check for that too.
-   # Subdirectories are respected.
-   dir=`echo &quot;$object&quot; | sed -e 's|/[^/]*$|/|'`
-   test &quot;x$dir&quot; = &quot;x$object&quot; &amp;&amp; dir=
-   base=`echo &quot;$object&quot; | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
-
-   if test &quot;$libtool&quot; = yes; then
-      # With Tru64 cc, shared objects can also be used to make a
-      # static library.  This mecanism is used in libtool 1.4 series to
-      # handle both shared and static libraries in a single compilation.
-      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
-      #
-      # With libtool 1.5 this exception was removed, and libtool now
-      # generates 2 separate objects for the 2 libraries.  These two
-      # compilations output dependencies in in $dir.libs/$base.o.d and
-      # in $dir$base.o.d.  We have to check for both files, because
-      # one of the two compilations can be disabled.  We should prefer
-      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
-      # automatically cleaned when .libs/ is deleted, while ignoring
-      # the former would cause a distcleancheck panic.
-      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
-      tmpdepfile2=$dir$base.o.d          # libtool 1.5
-      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
-      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
-      &quot;$@&quot; -Wc,-MD
-   else
-      tmpdepfile1=$dir$base.o.d
-      tmpdepfile2=$dir$base.d
-      tmpdepfile3=$dir$base.d
-      tmpdepfile4=$dir$base.d
-      &quot;$@&quot; -MD
-   fi
-
-   stat=$?
-   if test $stat -eq 0; then :
-   else
-      rm -f &quot;$tmpdepfile1&quot; &quot;$tmpdepfile2&quot; &quot;$tmpdepfile3&quot; &quot;$tmpdepfile4&quot;
-      exit $stat
-   fi
-
-   for tmpdepfile in &quot;$tmpdepfile1&quot; &quot;$tmpdepfile2&quot; &quot;$tmpdepfile3&quot; &quot;$tmpdepfile4&quot;
-   do
-     test -f &quot;$tmpdepfile&quot; &amp;&amp; break
-   done
-   if test -f &quot;$tmpdepfile&quot;; then
-      sed -e &quot;s,^.*\.[a-z]*:,$object:,&quot; &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
-      # That's a tab and a space in the [].
-      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
-   else
-      echo &quot;#dummy&quot; &gt; &quot;$depfile&quot;
-   fi
-   rm -f &quot;$tmpdepfile&quot;
-   ;;
-
-#nosideeffect)
-  # This comment above is used by automake to tell side-effect
-  # dependency tracking mechanisms from slower ones.
-
-dashmstdout)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o.
-  &quot;$@&quot; || exit $?
-
-  # Remove the call to Libtool.
-  if test &quot;$libtool&quot; = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-
-  # Remove `-o $object'.
-  IFS=&quot; &quot;
-  for arg
-  do
-    case $arg in
-    -o)
-      shift
-      ;;
-    $object)
-      shift
-      ;;
-    *)
-      set fnord &quot;$@&quot; &quot;$arg&quot;
-      shift # fnord
-      shift # $arg
-      ;;
-    esac
-  done
-
-  test -z &quot;$dashmflag&quot; &amp;&amp; dashmflag=-M
-  # Require at least two characters before searching for `:'
-  # in the target name.  This is to cope with DOS-style filenames:
-  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
-  &quot;$@&quot; $dashmflag |
-    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'&quot;$object&quot;'\: :' &gt; &quot;$tmpdepfile&quot;
-  rm -f &quot;$depfile&quot;
-  cat &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
-  tr ' ' '
-' &lt; &quot;$tmpdepfile&quot; | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-dashXmstdout)
-  # This case only exists to satisfy depend.m4.  It is never actually
-  # run, as this mode is specially recognized in the preamble.
-  exit 1
-  ;;
-
-makedepend)
-  &quot;$@&quot; || exit $?
-  # Remove any Libtool call
-  if test &quot;$libtool&quot; = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-  # X makedepend
-  shift
-  cleared=no
-  for arg in &quot;$@&quot;; do
-    case $cleared in
-    no)
-      set &quot;&quot;; shift
-      cleared=yes ;;
-    esac
-    case &quot;$arg&quot; in
-    -D*|-I*)
-      set fnord &quot;$@&quot; &quot;$arg&quot;; shift ;;
-    # Strip any option that makedepend may not understand.  Remove
-    # the object too, otherwise makedepend will parse it as a source file.
-    -*|$object)
-      ;;
-    *)
-      set fnord &quot;$@&quot; &quot;$arg&quot;; shift ;;
-    esac
-  done
-  obj_suffix=&quot;`echo $object | sed 's/^.*\././'`&quot;
-  touch &quot;$tmpdepfile&quot;
-  ${MAKEDEPEND-makedepend} -o&quot;$obj_suffix&quot; -f&quot;$tmpdepfile&quot; &quot;$@&quot;
-  rm -f &quot;$depfile&quot;
-  cat &lt; &quot;$tmpdepfile&quot; &gt; &quot;$depfile&quot;
-  sed '1,2d' &quot;$tmpdepfile&quot; | tr ' ' '
-' | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot; &quot;$tmpdepfile&quot;.bak
-  ;;
-
-cpp)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout.
-  &quot;$@&quot; || exit $?
-
-  # Remove the call to Libtool.
-  if test &quot;$libtool&quot; = yes; then
-    while test $1 != '--mode=compile'; do
-      shift
-    done
-    shift
-  fi
-
-  # Remove `-o $object'.
-  IFS=&quot; &quot;
-  for arg
-  do
-    case $arg in
-    -o)
-      shift
-      ;;
-    $object)
-      shift
-      ;;
-    *)
-      set fnord &quot;$@&quot; &quot;$arg&quot;
-      shift # fnord
-      shift # $arg
-      ;;
-    esac
-  done
-
-  &quot;$@&quot; -E |
-    sed -n -e '/^# [0-9][0-9]* &quot;\([^&quot;]*\)&quot;.*/ s:: \1 \\:p' \
-       -e '/^#line [0-9][0-9]* &quot;\([^&quot;]*\)&quot;.*/ s:: \1 \\:p' |
-    sed '$ s: \\$::' &gt; &quot;$tmpdepfile&quot;
-  rm -f &quot;$depfile&quot;
-  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
-  cat &lt; &quot;$tmpdepfile&quot; &gt;&gt; &quot;$depfile&quot;
-  sed &lt; &quot;$tmpdepfile&quot; '/^$/d;s/^ //;s/ \\$//;s/$/ :/' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-msvisualcpp)
-  # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o,
-  # because we must use -o when running libtool.
-  &quot;$@&quot; || exit $?
-  IFS=&quot; &quot;
-  for arg
-  do
-    case &quot;$arg&quot; in
-    &quot;-Gm&quot;|&quot;/Gm&quot;|&quot;-Gi&quot;|&quot;/Gi&quot;|&quot;-ZI&quot;|&quot;/ZI&quot;)
-	set fnord &quot;$@&quot;
-	shift
-	shift
-	;;
-    *)
-	set fnord &quot;$@&quot; &quot;$arg&quot;
-	shift
-	shift
-	;;
-    esac
-  done
-  &quot;$@&quot; -E |
-  sed -n '/^#line [0-9][0-9]* &quot;\([^&quot;]*\)&quot;/ s::echo &quot;`cygpath -u \\&quot;\1\\&quot;`&quot;:p' | sort | uniq &gt; &quot;$tmpdepfile&quot;
-  rm -f &quot;$depfile&quot;
-  echo &quot;$object : \\&quot; &gt; &quot;$depfile&quot;
-  . &quot;$tmpdepfile&quot; | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' &gt;&gt; &quot;$depfile&quot;
-  echo &quot;	&quot; &gt;&gt; &quot;$depfile&quot;
-  . &quot;$tmpdepfile&quot; | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' &gt;&gt; &quot;$depfile&quot;
-  rm -f &quot;$tmpdepfile&quot;
-  ;;
-
-none)
-  exec &quot;$@&quot;
-  ;;
-
-*)
-  echo &quot;Unknown depmode $depmode&quot; 1&gt;&amp;2
-  exit 1
-  ;;
-esac
-
-exit 0
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;scriptversion=&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
-# time-stamp-end: &quot;$&quot;
-# End:

Deleted: trunk/install-sh
===================================================================
--- trunk/install-sh	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/install-sh	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,323 +0,0 @@
-#!/bin/sh
-# install - install a program, script, or datafile
-
-scriptversion=2005-05-14.22
-
-# This originates from X11R5 (mit/util/scripts/install.sh), which was
-# later released in X11R6 (xc/config/util/install.sh) with the
-# following copyright and license.
-#
-# Copyright (C) 1994 X Consortium
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the &quot;Software&quot;), to
-# deal in the Software without restriction, including without limitation the
-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-# sell copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
-# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#
-# Except as contained in this notice, the name of the X Consortium shall not
-# be used in advertising or otherwise to promote the sale, use or other deal-
-# ings in this Software without prior written authorization from the X Consor-
-# tium.
-#
-#
-# FSF changes to this file are in the public domain.
-#
-# Calling this script install-sh is preferred over install.sh, to prevent
-# `make' implicit rules from creating a file called install from it
-# when there is no Makefile.
-#
-# This script is compatible with the BSD install script, but was written
-# from scratch.  It can only install one file at a time, a restriction
-# shared with many OS's install programs.
-
-# set DOITPROG to echo to test this script
-
-# Don't use :- since 4.3BSD and earlier shells don't like it.
-doit=&quot;${DOITPROG-}&quot;
-
-# put in absolute paths if you don't have them in your path; or use env. vars.
-
-mvprog=&quot;${MVPROG-mv}&quot;
-cpprog=&quot;${CPPROG-cp}&quot;
-chmodprog=&quot;${CHMODPROG-chmod}&quot;
-chownprog=&quot;${CHOWNPROG-chown}&quot;
-chgrpprog=&quot;${CHGRPPROG-chgrp}&quot;
-stripprog=&quot;${STRIPPROG-strip}&quot;
-rmprog=&quot;${RMPROG-rm}&quot;
-mkdirprog=&quot;${MKDIRPROG-mkdir}&quot;
-
-chmodcmd=&quot;$chmodprog 0755&quot;
-chowncmd=
-chgrpcmd=
-stripcmd=
-rmcmd=&quot;$rmprog -f&quot;
-mvcmd=&quot;$mvprog&quot;
-src=
-dst=
-dir_arg=
-dstarg=
-no_target_directory=
-
-usage=&quot;Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
-   or: $0 [OPTION]... SRCFILES... DIRECTORY
-   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
-   or: $0 [OPTION]... -d DIRECTORIES...
-
-In the 1st form, copy SRCFILE to DSTFILE.
-In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
-In the 4th, create DIRECTORIES.
-
-Options:
--c         (ignored)
--d         create directories instead of installing files.
--g GROUP   $chgrpprog installed files to GROUP.
--m MODE    $chmodprog installed files to MODE.
--o USER    $chownprog installed files to USER.
--s         $stripprog installed files.
--t DIRECTORY  install into DIRECTORY.
--T         report an error if DSTFILE is a directory.
---help     display this help and exit.
---version  display version info and exit.
-
-Environment variables override the default commands:
-  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
-&quot;
-
-while test -n &quot;$1&quot;; do
-  case $1 in
-    -c) shift
-        continue;;
-
-    -d) dir_arg=true
-        shift
-        continue;;
-
-    -g) chgrpcmd=&quot;$chgrpprog $2&quot;
-        shift
-        shift
-        continue;;
-
-    --help) echo &quot;$usage&quot;; exit $?;;
-
-    -m) chmodcmd=&quot;$chmodprog $2&quot;
-        shift
-        shift
-        continue;;
-
-    -o) chowncmd=&quot;$chownprog $2&quot;
-        shift
-        shift
-        continue;;
-
-    -s) stripcmd=$stripprog
-        shift
-        continue;;
-
-    -t) dstarg=$2
-	shift
-	shift
-	continue;;
-
-    -T) no_target_directory=true
-	shift
-	continue;;
-
-    --version) echo &quot;$0 $scriptversion&quot;; exit $?;;
-
-    *)  # When -d is used, all remaining arguments are directories to create.
-	# When -t is used, the destination is already specified.
-	test -n &quot;$dir_arg$dstarg&quot; &amp;&amp; break
-        # Otherwise, the last argument is the destination.  Remove it from $@.
-	for arg
-	do
-          if test -n &quot;$dstarg&quot;; then
-	    # $@ is not empty: it contains at least $arg.
-	    set fnord &quot;$@&quot; &quot;$dstarg&quot;
-	    shift # fnord
-	  fi
-	  shift # arg
-	  dstarg=$arg
-	done
-	break;;
-  esac
-done
-
-if test -z &quot;$1&quot;; then
-  if test -z &quot;$dir_arg&quot;; then
-    echo &quot;$0: no input file specified.&quot; &gt;&amp;2
-    exit 1
-  fi
-  # It's OK to call `install-sh -d' without argument.
-  # This can happen when creating conditional directories.
-  exit 0
-fi
-
-for src
-do
-  # Protect names starting with `-'.
-  case $src in
-    -*) src=./$src ;;
-  esac
-
-  if test -n &quot;$dir_arg&quot;; then
-    dst=$src
-    src=
-
-    if test -d &quot;$dst&quot;; then
-      mkdircmd=:
-      chmodcmd=
-    else
-      mkdircmd=$mkdirprog
-    fi
-  else
-    # Waiting for this to be detected by the &quot;$cpprog $src $dsttmp&quot; command
-    # might cause directories to be created, which would be especially bad
-    # if $src (and thus $dsttmp) contains '*'.
-    if test ! -f &quot;$src&quot; &amp;&amp; test ! -d &quot;$src&quot;; then
-      echo &quot;$0: $src does not exist.&quot; &gt;&amp;2
-      exit 1
-    fi
-
-    if test -z &quot;$dstarg&quot;; then
-      echo &quot;$0: no destination specified.&quot; &gt;&amp;2
-      exit 1
-    fi
-
-    dst=$dstarg
-    # Protect names starting with `-'.
-    case $dst in
-      -*) dst=./$dst ;;
-    esac
-
-    # If destination is a directory, append the input filename; won't work
-    # if double slashes aren't ignored.
-    if test -d &quot;$dst&quot;; then
-      if test -n &quot;$no_target_directory&quot;; then
-	echo &quot;$0: $dstarg: Is a directory&quot; &gt;&amp;2
-	exit 1
-      fi
-      dst=$dst/`basename &quot;$src&quot;`
-    fi
-  fi
-
-  # This sed command emulates the dirname command.
-  dstdir=`echo &quot;$dst&quot; | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`
-
-  # Make sure that the destination directory exists.
-
-  # Skip lots of stat calls in the usual case.
-  if test ! -d &quot;$dstdir&quot;; then
-    defaultIFS='
-	 '
-    IFS=&quot;${IFS-$defaultIFS}&quot;
-
-    oIFS=$IFS
-    # Some sh's can't handle IFS=/ for some reason.
-    IFS='%'
-    set x `echo &quot;$dstdir&quot; | sed -e 's@/@%@g' -e 's@^%@/@'`
-    shift
-    IFS=$oIFS
-
-    pathcomp=
-
-    while test $# -ne 0 ; do
-      pathcomp=$pathcomp$1
-      shift
-      if test ! -d &quot;$pathcomp&quot;; then
-        $mkdirprog &quot;$pathcomp&quot;
-	# mkdir can fail with a `File exist' error in case several
-	# install-sh are creating the directory concurrently.  This
-	# is OK.
-	test -d &quot;$pathcomp&quot; || exit
-      fi
-      pathcomp=$pathcomp/
-    done
-  fi
-
-  if test -n &quot;$dir_arg&quot;; then
-    $doit $mkdircmd &quot;$dst&quot; \
-      &amp;&amp; { test -z &quot;$chowncmd&quot; || $doit $chowncmd &quot;$dst&quot;; } \
-      &amp;&amp; { test -z &quot;$chgrpcmd&quot; || $doit $chgrpcmd &quot;$dst&quot;; } \
-      &amp;&amp; { test -z &quot;$stripcmd&quot; || $doit $stripcmd &quot;$dst&quot;; } \
-      &amp;&amp; { test -z &quot;$chmodcmd&quot; || $doit $chmodcmd &quot;$dst&quot;; }
-
-  else
-    dstfile=`basename &quot;$dst&quot;`
-
-    # Make a couple of temp file names in the proper directory.
-    dsttmp=$dstdir/_inst.$$_
-    rmtmp=$dstdir/_rm.$$_
-
-    # Trap to clean up those temp files at exit.
-    trap 'ret=$?; rm -f &quot;$dsttmp&quot; &quot;$rmtmp&quot; &amp;&amp; exit $ret' 0
-    trap '(exit $?); exit' 1 2 13 15
-
-    # Copy the file name to the temp name.
-    $doit $cpprog &quot;$src&quot; &quot;$dsttmp&quot; &amp;&amp;
-
-    # and set any options; do chmod last to preserve setuid bits.
-    #
-    # If any of these fail, we abort the whole thing.  If we want to
-    # ignore errors from any of these, just make sure not to ignore
-    # errors from the above &quot;$doit $cpprog $src $dsttmp&quot; command.
-    #
-    { test -z &quot;$chowncmd&quot; || $doit $chowncmd &quot;$dsttmp&quot;; } \
-      &amp;&amp; { test -z &quot;$chgrpcmd&quot; || $doit $chgrpcmd &quot;$dsttmp&quot;; } \
-      &amp;&amp; { test -z &quot;$stripcmd&quot; || $doit $stripcmd &quot;$dsttmp&quot;; } \
-      &amp;&amp; { test -z &quot;$chmodcmd&quot; || $doit $chmodcmd &quot;$dsttmp&quot;; } &amp;&amp;
-
-    # Now rename the file to the real destination.
-    { $doit $mvcmd -f &quot;$dsttmp&quot; &quot;$dstdir/$dstfile&quot; 2&gt;/dev/null \
-      || {
-	   # The rename failed, perhaps because mv can't rename something else
-	   # to itself, or perhaps because mv is so ancient that it does not
-	   # support -f.
-
-	   # Now remove or move aside any old file at destination location.
-	   # We try this two ways since rm can't unlink itself on some
-	   # systems and the destination file might be busy for other
-	   # reasons.  In this case, the final cleanup might fail but the new
-	   # file should still install successfully.
-	   {
-	     if test -f &quot;$dstdir/$dstfile&quot;; then
-	       $doit $rmcmd -f &quot;$dstdir/$dstfile&quot; 2&gt;/dev/null \
-	       || $doit $mvcmd -f &quot;$dstdir/$dstfile&quot; &quot;$rmtmp&quot; 2&gt;/dev/null \
-	       || {
-		 echo &quot;$0: cannot unlink or rename $dstdir/$dstfile&quot; &gt;&amp;2
-		 (exit 1); exit 1
-	       }
-	     else
-	       :
-	     fi
-	   } &amp;&amp;
-
-	   # Now rename the file to the real destination.
-	   $doit $mvcmd &quot;$dsttmp&quot; &quot;$dstdir/$dstfile&quot;
-	 }
-    }
-  fi || { (exit 1); exit 1; }
-done
-
-# The final little trick to &quot;correctly&quot; pass the exit status to the exit trap.
-{
-  (exit 0); exit 0
-}
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;scriptversion=&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
-# time-stamp-end: &quot;$&quot;
-# End:

Deleted: trunk/missing
===================================================================
--- trunk/missing	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/missing	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,360 +0,0 @@
-#! /bin/sh
-# Common stub for a few missing GNU programs while installing.
-
-scriptversion=2005-06-08.21
-
-# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005
-#   Free Software Foundation, Inc.
-# Originally by Fran,cois Pinard &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">pinard at iro.umontreal.ca</A>&gt;, 1996.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-# 02110-1301, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-if test $# -eq 0; then
-  echo 1&gt;&amp;2 &quot;Try \`$0 --help' for more information&quot;
-  exit 1
-fi
-
-run=:
-
-# In the cases where this matters, `missing' is being run in the
-# srcdir already.
-if test -f configure.ac; then
-  configure_ac=configure.ac
-else
-  configure_ac=configure.in
-fi
-
-msg=&quot;missing on your system&quot;
-
-case &quot;$1&quot; in
---run)
-  # Try to run requested program, and just exit if it succeeds.
-  run=
-  shift
-  &quot;$@&quot; &amp;&amp; exit 0
-  # Exit code 63 means version mismatch.  This often happens
-  # when the user try to use an ancient version of a tool on
-  # a file that requires a minimum version.  In this case we
-  # we should proceed has if the program had been absent, or
-  # if --run hadn't been passed.
-  if test $? = 63; then
-    run=:
-    msg=&quot;probably too old&quot;
-  fi
-  ;;
-
-  -h|--h|--he|--hel|--help)
-    echo &quot;\
-$0 [OPTION]... PROGRAM [ARGUMENT]...
-
-Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
-error status if there is no known handling for PROGRAM.
-
-Options:
-  -h, --help      display this help and exit
-  -v, --version   output version information and exit
-  --run           try to run the given command, and emulate it if it fails
-
-Supported PROGRAM values:
-  aclocal      touch file \`aclocal.m4'
-  autoconf     touch file \`configure'
-  autoheader   touch file \`config.h.in'
-  automake     touch all \`Makefile.in' files
-  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
-  flex         create \`lex.yy.c', if possible, from existing .c
-  help2man     touch the output file
-  lex          create \`lex.yy.c', if possible, from existing .c
-  makeinfo     touch the output file
-  tar          try tar, gnutar, gtar, then tar without non-portable flags
-  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
-
-Send bug reports to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.&quot;
-    exit $?
-    ;;
-
-  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
-    echo &quot;missing $scriptversion (GNU Automake)&quot;
-    exit $?
-    ;;
-
-  -*)
-    echo 1&gt;&amp;2 &quot;$0: Unknown \`$1' option&quot;
-    echo 1&gt;&amp;2 &quot;Try \`$0 --help' for more information&quot;
-    exit 1
-    ;;
-
-esac
-
-# Now exit if we have it, but it failed.  Also exit now if we
-# don't have it and --version was passed (most likely to detect
-# the program).
-case &quot;$1&quot; in
-  lex|yacc)
-    # Not GNU programs, they don't have --version.
-    ;;
-
-  tar)
-    if test -n &quot;$run&quot;; then
-       echo 1&gt;&amp;2 &quot;ERROR: \`tar' requires --run&quot;
-       exit 1
-    elif test &quot;x$2&quot; = &quot;x--version&quot; || test &quot;x$2&quot; = &quot;x--help&quot;; then
-       exit 1
-    fi
-    ;;
-
-  *)
-    if test -z &quot;$run&quot; &amp;&amp; ($1 --version) &gt; /dev/null 2&gt;&amp;1; then
-       # We have it, but it failed.
-       exit 1
-    elif test &quot;x$2&quot; = &quot;x--version&quot; || test &quot;x$2&quot; = &quot;x--help&quot;; then
-       # Could not run --version or --help.  This is probably someone
-       # running `$TOOL --version' or `$TOOL --help' to check whether
-       # $TOOL exists and not knowing $TOOL uses missing.
-       exit 1
-    fi
-    ;;
-esac
-
-# If it does not exist, or fails to run (possibly an outdated version),
-# try to emulate it.
-case &quot;$1&quot; in
-  aclocal*)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
-         to install the \`Automake' and \`Perl' packages.  Grab them from
-         any GNU archive site.&quot;
-    touch aclocal.m4
-    ;;
-
-  autoconf)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`${configure_ac}'.  You might want to install the
-         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
-         archive site.&quot;
-    touch configure
-    ;;
-
-  autoheader)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
-         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
-         from any GNU archive site.&quot;
-    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
-    test -z &quot;$files&quot; &amp;&amp; files=&quot;config.h&quot;
-    touch_files=
-    for f in $files; do
-      case &quot;$f&quot; in
-      *:*) touch_files=&quot;$touch_files &quot;`echo &quot;$f&quot; |
-				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
-      *) touch_files=&quot;$touch_files $f.in&quot;;;
-      esac
-    done
-    touch $touch_files
-    ;;
-
-  automake*)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
-         You might want to install the \`Automake' and \`Perl' packages.
-         Grab them from any GNU archive site.&quot;
-    find . -type f -name Makefile.am -print |
-	   sed 's/\.am$/.in/' |
-	   while read f; do touch &quot;$f&quot;; done
-    ;;
-
-  autom4te)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is needed, but is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.
-         You can get \`$1' as part of \`Autoconf' from any GNU
-         archive site.&quot;
-
-    file=`echo &quot;$*&quot; | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
-    test -z &quot;$file&quot; &amp;&amp; file=`echo &quot;$*&quot; | sed -n 's/.*-o[ ]*\([^ ]*\).*/\1/p'`
-    if test -f &quot;$file&quot;; then
-	touch $file
-    else
-	test -z &quot;$file&quot; || exec &gt;$file
-	echo &quot;#! /bin/sh&quot;
-	echo &quot;# Created by GNU Automake missing as a replacement of&quot;
-	echo &quot;#  $ $@&quot;
-	echo &quot;exit 0&quot;
-	chmod +x $file
-	exit 1
-    fi
-    ;;
-
-  bison|yacc)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' $msg.  You should only need it if
-         you modified a \`.y' file.  You may need the \`Bison' package
-         in order for those modifications to take effect.  You can get
-         \`Bison' from any GNU archive site.&quot;
-    rm -f y.tab.c y.tab.h
-    if [ $# -ne 1 ]; then
-        eval LASTARG=&quot;\${$#}&quot;
-	case &quot;$LASTARG&quot; in
-	*.y)
-	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/y$/c/'`
-	    if [ -f &quot;$SRCFILE&quot; ]; then
-	         cp &quot;$SRCFILE&quot; y.tab.c
-	    fi
-	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/y$/h/'`
-	    if [ -f &quot;$SRCFILE&quot; ]; then
-	         cp &quot;$SRCFILE&quot; y.tab.h
-	    fi
-	  ;;
-	esac
-    fi
-    if [ ! -f y.tab.h ]; then
-	echo &gt;y.tab.h
-    fi
-    if [ ! -f y.tab.c ]; then
-	echo 'main() { return 0; }' &gt;y.tab.c
-    fi
-    ;;
-
-  lex|flex)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.l' file.  You may need the \`Flex' package
-         in order for those modifications to take effect.  You can get
-         \`Flex' from any GNU archive site.&quot;
-    rm -f lex.yy.c
-    if [ $# -ne 1 ]; then
-        eval LASTARG=&quot;\${$#}&quot;
-	case &quot;$LASTARG&quot; in
-	*.l)
-	    SRCFILE=`echo &quot;$LASTARG&quot; | sed 's/l$/c/'`
-	    if [ -f &quot;$SRCFILE&quot; ]; then
-	         cp &quot;$SRCFILE&quot; lex.yy.c
-	    fi
-	  ;;
-	esac
-    fi
-    if [ ! -f lex.yy.c ]; then
-	echo 'main() { return 0; }' &gt;lex.yy.c
-    fi
-    ;;
-
-  help2man)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-	 you modified a dependency of a manual page.  You may need the
-	 \`Help2man' package in order for those modifications to take
-	 effect.  You can get \`Help2man' from any GNU archive site.&quot;
-
-    file=`echo &quot;$*&quot; | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
-    if test -z &quot;$file&quot;; then
-	file=`echo &quot;$*&quot; | sed -n 's/.*--output=\([^ ]*\).*/\1/p'`
-    fi
-    if [ -f &quot;$file&quot; ]; then
-	touch $file
-    else
-	test -z &quot;$file&quot; || exec &gt;$file
-	echo &quot;.ab help2man is required to generate this page&quot;
-	exit 1
-    fi
-    ;;
-
-  makeinfo)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.texi' or \`.texinfo' file, or any other file
-         indirectly affecting the aspect of the manual.  The spurious
-         call might also be the consequence of using a buggy \`make' (AIX,
-         DU, IRIX).  You might want to install the \`Texinfo' package or
-         the \`GNU make' package.  Grab either from any GNU archive site.&quot;
-    # The file to touch is that specified with -o ...
-    file=`echo &quot;$*&quot; | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
-    if test -z &quot;$file&quot;; then
-      # ... or it is the one specified with @setfilename ...
-      infile=`echo &quot;$*&quot; | sed 's/.* \([^ ]*\) *$/\1/'`
-      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $infile`
-      # ... or it is derived from the source name (dir/f.texi becomes f.info)
-      test -z &quot;$file&quot; &amp;&amp; file=`echo &quot;$infile&quot; | sed 's,.*/,,;s,.[^.]*$,,'`.info
-    fi
-    # If the file does not exist, the user really needs makeinfo;
-    # let's fail without touching anything.
-    test -f $file || exit 1
-    touch $file
-    ;;
-
-  tar)
-    shift
-
-    # We have already tried tar in the generic part.
-    # Look for gnutar/gtar before invocation to avoid ugly error
-    # messages.
-    if (gnutar --version &gt; /dev/null 2&gt;&amp;1); then
-       gnutar &quot;$@&quot; &amp;&amp; exit 0
-    fi
-    if (gtar --version &gt; /dev/null 2&gt;&amp;1); then
-       gtar &quot;$@&quot; &amp;&amp; exit 0
-    fi
-    firstarg=&quot;$1&quot;
-    if shift; then
-	case &quot;$firstarg&quot; in
-	*o*)
-	    firstarg=`echo &quot;$firstarg&quot; | sed s/o//`
-	    tar &quot;$firstarg&quot; &quot;$@&quot; &amp;&amp; exit 0
-	    ;;
-	esac
-	case &quot;$firstarg&quot; in
-	*h*)
-	    firstarg=`echo &quot;$firstarg&quot; | sed s/h//`
-	    tar &quot;$firstarg&quot; &quot;$@&quot; &amp;&amp; exit 0
-	    ;;
-	esac
-    fi
-
-    echo 1&gt;&amp;2 &quot;\
-WARNING: I can't seem to be able to run \`tar' with the given arguments.
-         You may want to install GNU tar or Free paxutils, or check the
-         command line arguments.&quot;
-    exit 1
-    ;;
-
-  *)
-    echo 1&gt;&amp;2 &quot;\
-WARNING: \`$1' is needed, and is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.  Check the \`README' file,
-         it often tells you about the needed prerequisites for installing
-         this package.  You may also peek at any GNU archive site, in case
-         some other package would contain this missing \`$1' program.&quot;
-    exit 1
-    ;;
-esac
-
-exit 0
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;scriptversion=&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
-# time-stamp-end: &quot;$&quot;
-# End:

Deleted: trunk/mkinstalldirs
===================================================================
--- trunk/mkinstalldirs	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/mkinstalldirs	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,150 +0,0 @@
-#! /bin/sh
-# mkinstalldirs --- make directory hierarchy
-
-scriptversion=2004-02-15.20
-
-# Original author: Noah Friedman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">friedman at prep.ai.mit.edu</A>&gt;
-# Created: 1993-05-16
-# Public domain.
-#
-# This file is maintained in Automake, please report
-# bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt; or send patches to
-# &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">automake-patches at gnu.org</A>&gt;.
-
-errstatus=0
-dirmode=&quot;&quot;
-
-usage=&quot;\
-Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
-
-Create each directory DIR (with mode MODE, if specified), including all
-leading file name components.
-
-Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">bug-automake at gnu.org</A>&gt;.&quot;
-
-# process command line arguments
-while test $# -gt 0 ; do
-  case $1 in
-    -h | --help | --h*)         # -h for help
-      echo &quot;$usage&quot;
-      exit 0
-      ;;
-    -m)                         # -m PERM arg
-      shift
-      test $# -eq 0 &amp;&amp; { echo &quot;$usage&quot; 1&gt;&amp;2; exit 1; }
-      dirmode=$1
-      shift
-      ;;
-    --version)
-      echo &quot;$0 $scriptversion&quot;
-      exit 0
-      ;;
-    --)                         # stop option processing
-      shift
-      break
-      ;;
-    -*)                         # unknown option
-      echo &quot;$usage&quot; 1&gt;&amp;2
-      exit 1
-      ;;
-    *)                          # first non-opt arg
-      break
-      ;;
-  esac
-done
-
-for file
-do
-  if test -d &quot;$file&quot;; then
-    shift
-  else
-    break
-  fi
-done
-
-case $# in
-  0) exit 0 ;;
-esac
-
-# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
-# mkdir -p a/c at the same time, both will detect that a is missing,
-# one will create a, then the other will try to create a and die with
-# a &quot;File exists&quot; error.  This is a problem when calling mkinstalldirs
-# from a parallel make.  We use --version in the probe to restrict
-# ourselves to GNU mkdir, which is thread-safe.
-case $dirmode in
-  '')
-    if mkdir -p --version . &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test ! -d ./--version; then
-      echo &quot;mkdir -p -- $*&quot;
-      exec mkdir -p -- &quot;$@&quot;
-    else
-      # On NextStep and OpenStep, the `mkdir' command does not
-      # recognize any option.  It will interpret all options as
-      # directories to create, and then abort because `.' already
-      # exists.
-      test -d ./-p &amp;&amp; rmdir ./-p
-      test -d ./--version &amp;&amp; rmdir ./--version
-    fi
-    ;;
-  *)
-    if mkdir -m &quot;$dirmode&quot; -p --version . &gt;/dev/null 2&gt;&amp;1 &amp;&amp;
-       test ! -d ./--version; then
-      echo &quot;mkdir -m $dirmode -p -- $*&quot;
-      exec mkdir -m &quot;$dirmode&quot; -p -- &quot;$@&quot;
-    else
-      # Clean up after NextStep and OpenStep mkdir.
-      for d in ./-m ./-p ./--version &quot;./$dirmode&quot;;
-      do
-        test -d $d &amp;&amp; rmdir $d
-      done
-    fi
-    ;;
-esac
-
-for file
-do
-  set fnord `echo &quot;:$file&quot; | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
-  shift
-
-  pathcomp=
-  for d
-  do
-    pathcomp=&quot;$pathcomp$d&quot;
-    case $pathcomp in
-      -*) pathcomp=./$pathcomp ;;
-    esac
-
-    if test ! -d &quot;$pathcomp&quot;; then
-      echo &quot;mkdir $pathcomp&quot;
-
-      mkdir &quot;$pathcomp&quot; || lasterr=$?
-
-      if test ! -d &quot;$pathcomp&quot;; then
-	errstatus=$lasterr
-      else
-	if test ! -z &quot;$dirmode&quot;; then
-	  echo &quot;chmod $dirmode $pathcomp&quot;
-	  lasterr=&quot;&quot;
-	  chmod &quot;$dirmode&quot; &quot;$pathcomp&quot; || lasterr=$?
-
-	  if test ! -z &quot;$lasterr&quot;; then
-	    errstatus=$lasterr
-	  fi
-	fi
-      fi
-    fi
-
-    pathcomp=&quot;$pathcomp/&quot;
-  done
-done
-
-exit $errstatus
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: &quot;scriptversion=&quot;
-# time-stamp-format: &quot;%:y-%02m-%02d.%02H&quot;
-# time-stamp-end: &quot;$&quot;
-# End:

Copied: trunk/sst.py (from rev 809, trunk/src/sst.py)
===================================================================
--- trunk/sst.py	                        (rev 0)
+++ trunk/sst.py	2010-11-30 08:15:36 UTC (rev 810)
@@ -0,0 +1,6339 @@
+#!/usr/bin/env python
+&quot;&quot;&quot;
+sst.py -- Super Star Trek 2K
+
+SST2K is a Python translation of a C translation of a FORTRAN
+original dating back to 1973.  Beautiful Python it is not, but it
+works.  Translation by Eric S. Raymond; original game by David Matuszek
+and Paul Reynolds, with modifications by Don Smith, Tom Almy,
+Stas Sergeev, and Eric S. Raymond.
+
+See the doc/HACKING file in the distribution for designers notes and advice
+on how to modify (and how not to modify!) this code.
+&quot;&quot;&quot;
+import os, sys, math, curses, time, readline, cPickle, random, copy, gettext, getpass
+
+docpath  	= (&quot;.&quot;, &quot;../doc&quot;, &quot;/usr/share/doc/sst&quot;)
+
+def _(str): return gettext.gettext(str)
+
+GALSIZE 	= 8		# Galaxy size in quadrants
+NINHAB  	= (GALSIZE * GALSIZE / 2)	# Number of inhabited worlds
+MAXUNINHAB	= 10		# Maximum uninhabited worlds
+QUADSIZE	= 10		# Quadrant size in sectors
+BASEMIN		= 2				# Minimum starbases
+BASEMAX 	= (GALSIZE * GALSIZE / 12)	# Maximum starbases
+MAXKLGAME	= 127		# Maximum Klingons per game
+MAXKLQUAD	= 9		# Maximum Klingons per quadrant
+FULLCREW	= 428		# Crew size. BSD Trek was 387, that's wrong 
+FOREVER 	= 1e30		# Time for the indefinite future
+MAXBURST	= 3		# Max # of torps you can launch in one turn
+MINCMDR 	= 10		# Minimum number of Klingon commanders
+DOCKFAC		= 0.25		# Repair faster when docked
+PHASEFAC	= 2.0		# Unclear what this is, it was in the C version
+
+DEFAULT      = -1
+BLACK        = 0
+BLUE         = 1
+GREEN        = 2
+CYAN         = 3
+RED          = 4
+MAGENTA      = 5
+BROWN        = 6
+LIGHTGRAY    = 7
+DARKGRAY     = 8
+LIGHTBLUE    = 9
+LIGHTGREEN   = 10
+LIGHTCYAN    = 11
+LIGHTRED     = 12
+LIGHTMAGENTA = 13
+YELLOW       = 14
+WHITE        = 15
+
+class TrekError:
+    pass
+
+class coord:
+    def __init__(self, x=None, y=None):
+        self.i = x
+        self.j = y
+    def valid_quadrant(self):
+        return self.i&gt;=0 and self.i&lt;GALSIZE and self.j&gt;=0 and self.j&lt;GALSIZE
+    def valid_sector(self):
+	return self.i&gt;=0 and self.i&lt;QUADSIZE and self.j&gt;=0 and self.j&lt;QUADSIZE
+    def invalidate(self):
+        self.i = self.j = None
+    def is_valid(self):
+        return self.i != None and self.j != None
+    def __eq__(self, other):
+        return other != None and self.i == other.i and self.j == other.j
+    def __ne__(self, other):
+        return other == None or self.i != other.i or self.j != other.j
+    def __add__(self, other):
+        return coord(self.i+other.i, self.j+other.j)
+    def __sub__(self, other):
+        return coord(self.i-other.i, self.j-other.j)
+    def __mul__(self, other):
+        return coord(self.i*other, self.j*other)
+    def __rmul__(self, other):
+        return coord(self.i*other, self.j*other)
+    def __div__(self, other):
+        return coord(self.i/other, self.j/other)
+    def __mod__(self, other):
+        return coord(self.i % other, self.j % other)
+    def __rdiv__(self, other):
+        return coord(self.i/other, self.j/other)
+    def roundtogrid(self):
+        return coord(int(round(self.i)), int(round(self.j)))
+    def distance(self, other=None):
+        if not other: other = coord(0, 0)
+        return math.sqrt((self.i - other.i)**2 + (self.j - other.j)**2)
+    def bearing(self):
+        return 1.90985*math.atan2(self.j, self.i)
+    def sgn(self):
+        s = coord()
+        if self.i == 0:
+            s.i = 0
+        else:
+            s.i = self.i / abs(self.i)
+        if self.j == 0:
+            s.j = 0
+        else:
+            s.j = self.j / abs(self.j)
+        return s
+    def quadrant(self):
+        #print &quot;Location %s -&gt; %s&quot; % (self, (self / QUADSIZE).roundtogrid())
+        return self.roundtogrid() / QUADSIZE
+    def sector(self):
+        return self.roundtogrid() % QUADSIZE
+    def scatter(self):
+        s = coord()
+        s.i = self.i + randrange(-1, 2)
+        s.j = self.j + randrange(-1, 2)
+        return s
+    def __str__(self):
+        if self.i == None or self.j == None:
+            return &quot;Nowhere&quot;
+        return &quot;%s - %s&quot; % (self.i+1, self.j+1)
+    __repr__ = __str__
+
+class planet:
+    def __init__(self):
+        self.name = None	# string-valued if inhabited
+        self.quadrant = coord()	# quadrant located
+        self.pclass = None	# could be &quot;&quot;M&quot;, &quot;N&quot;, &quot;O&quot;, or &quot;destroyed&quot;
+        self.crystals = &quot;absent&quot;# could be &quot;mined&quot;, &quot;present&quot;, &quot;absent&quot;
+        self.known = &quot;unknown&quot;	# could be &quot;unknown&quot;, &quot;known&quot;, &quot;shuttle_down&quot;
+        self.inhabited = False	# is it inhabites?
+    def __str__(self):
+        return self.name
+
+class quadrant:
+    def __init__(self):
+        self.stars = 0
+        self.planet = None
+	self.starbase = False
+	self.klingons = 0
+	self.romulans = 0
+	self.supernova = False
+	self.charted = False
+        self.status = &quot;secure&quot;	# Could be &quot;secure&quot;, &quot;distressed&quot;, &quot;enslaved&quot;
+
+class page:
+    def __init__(self):
+	self.stars = None
+	self.starbase = None
+	self.klingons = None
+
+def fill2d(size, fillfun):
+    &quot;Fill an empty list in 2D.&quot;
+    lst = []
+    for i in range(size):
+        lst.append([]) 
+        for j in range(size):
+            lst[i].append(fillfun(i, j))
+    return lst
+
+class snapshot:
+    def __init__(self):
+        self.snap = False	# snapshot taken
+        self.crew = 0   	# crew complement
+	self.remkl = 0  	# remaining klingons
+	self.nscrem = 0		# remaining super commanders
+	self.starkl = 0 	# destroyed stars
+	self.basekl = 0 	# destroyed bases
+	self.nromrem = 0	# Romulans remaining
+	self.nplankl = 0	# destroyed uninhabited planets
+	self.nworldkl = 0	# destroyed inhabited planets
+        self.planets = []	# Planet information
+        self.date = 0.0   	# stardate
+	self.remres = 0 	# remaining resources
+	self.remtime = 0	# remaining time
+        self.baseq = [] 	# Base quadrant coordinates
+        self.kcmdr = [] 	# Commander quadrant coordinates
+	self.kscmdr = coord()	# Supercommander quadrant coordinates
+        # the galaxy
+        self.galaxy = fill2d(GALSIZE, lambda i, j: quadrant())
+        # the starchart
+    	self.chart = fill2d(GALSIZE, lambda i, j: page())
+
+class event:
+    def __init__(self):
+        self.date = None	# A real number
+        self.quadrant = None	# A coord structure
+
+# game options 
+OPTION_ALL	= 0xffffffff
+OPTION_TTY	= 0x00000001	# old interface 
+OPTION_CURSES	= 0x00000002	# new interface 
+OPTION_IOMODES	= 0x00000003	# cover both interfaces 
+OPTION_PLANETS	= 0x00000004	# planets and mining 
+OPTION_THOLIAN	= 0x00000008	# Tholians and their webs (UT 1979 version)
+OPTION_THINGY	= 0x00000010	# Space Thingy can shoot back (Stas, 2005)
+OPTION_PROBE	= 0x00000020	# deep-space probes (DECUS version, 1980)
+OPTION_SHOWME	= 0x00000040	# bracket Enterprise in chart 
+OPTION_RAMMING	= 0x00000080	# enemies may ram Enterprise (Almy)
+OPTION_MVBADDY	= 0x00000100	# more enemies can move (Almy)
+OPTION_BLKHOLE	= 0x00000200	# black hole may timewarp you (Stas, 2005) 
+OPTION_BASE	= 0x00000400	# bases have good shields (Stas, 2005)
+OPTION_WORLDS	= 0x00000800	# logic for inhabited worlds (ESR, 2006)
+OPTION_AUTOSCAN	= 0x00001000	# automatic LRSCAN before CHART (ESR, 2006)
+OPTION_PLAIN	= 0x01000000	# user chose plain game 
+OPTION_ALMY	= 0x02000000	# user chose Almy variant 
+OPTION_COLOR    = 0x04000000	# enable color display (experimental, ESR, 2010)
+
+# Define devices 
+DSRSENS	= 0
+DLRSENS	= 1
+DPHASER	= 2
+DPHOTON	= 3
+DLIFSUP	= 4
+DWARPEN	= 5
+DIMPULS	= 6
+DSHIELD	= 7
+DRADIO	= 0
+DSHUTTL = 9
+DCOMPTR = 10
+DNAVSYS	= 11
+DTRANSP = 12
+DSHCTRL	= 13
+DDRAY	= 14
+DDSP	= 15
+NDEVICES= 16	# Number of devices
+
+SKILL_NONE	= 0
+SKILL_NOVICE	= 1
+SKILL_FAIR	= 2
+SKILL_GOOD	= 3
+SKILL_EXPERT	= 4
+SKILL_EMERITUS	= 5
+
+def damaged(dev):	return (game.damage[dev] != 0.0)
+def communicating():	return not damaged(DRADIO) or game.condition==&quot;docked&quot;
+
+# Define future events 
+FSPY	= 0	# Spy event happens always (no future[] entry)
+		# can cause SC to tractor beam Enterprise
+FSNOVA  = 1	# Supernova
+FTBEAM  = 2	# Commander tractor beams Enterprise
+FSNAP   = 3	# Snapshot for time warp
+FBATTAK = 4	# Commander attacks base
+FCDBAS  = 5	# Commander destroys base
+FSCMOVE = 6	# Supercommander moves (might attack base)
+FSCDBAS = 7	# Supercommander destroys base
+FDSPROB = 8	# Move deep space probe
+FDISTR	= 9	# Emit distress call from an inhabited world 
+FENSLV	= 10	# Inhabited word is enslaved */
+FREPRO	= 11	# Klingons build a ship in an enslaved system
+NEVENTS	= 12
+
+# Abstract out the event handling -- underlying data structures will change
+# when we implement stateful events 
+def findevent(evtype):	return game.future[evtype]
+
+class enemy:
+    def __init__(self, type=None, loc=None, power=None):
+        self.type = type
+        self.location = coord()
+        if loc:
+            self.move(loc)
+        self.power = power	# enemy energy level
+        game.enemies.append(self)
+    def move(self, loc):
+        motion = (loc != self.location)
+        if self.location.i is not None and self.location.j is not None:
+            if motion:
+                if self.type == 'T':
+                    game.quad[self.location.i][self.location.j] = '#'
+                else:
+                    game.quad[self.location.i][self.location.j] = '.'
+        if loc:
+            self.location = copy.copy(loc)
+            game.quad[self.location.i][self.location.j] = self.type
+            self.kdist = self.kavgd = (game.sector - loc).distance()
+        else:
+            self.location = coord()
+            self.kdist = self.kavgd = None
+            game.enemies.remove(self)
+        return motion
+    def __repr__(self):
+        return &quot;&lt;%s,%s.%f&gt;&quot; % (self.type, self.location, self.power)	# For debugging
+
+class gamestate:
+    def __init__(self):
+        self.options = None	# Game options
+        self.state = snapshot()	# A snapshot structure
+        self.snapsht = snapshot()	# Last snapshot taken for time-travel purposes
+        self.quad = None	# contents of our quadrant
+        self.damage = [0.0] * NDEVICES	# damage encountered
+        self.future = []		# future events
+        for i in range(NEVENTS):
+            self.future.append(event())
+        self.passwd  = None;		# Self Destruct password
+        self.enemies = []
+        self.quadrant = None	# where we are in the large
+        self.sector = None	# where we are in the small
+        self.tholian = None	# Tholian enemy object
+        self.base = None	# position of base in current quadrant
+        self.battle = None	# base coordinates being attacked
+        self.plnet = None	# location of planet in quadrant
+        self.gamewon = False	# Finished!
+        self.ididit = False	# action taken -- allows enemy to attack
+        self.alive = False	# we are alive (not killed)
+        self.justin = False	# just entered quadrant
+        self.shldup = False	# shields are up
+        self.shldchg = False	# shield is changing (affects efficiency)
+        self.iscate = False	# super commander is here
+        self.ientesc = False	# attempted escape from supercommander
+        self.resting = False	# rest time
+        self.icraft = False	# Kirk in Galileo
+        self.landed = False	# party on planet (true), on ship (false)
+        self.alldone = False	# game is now finished
+        self.neutz = False	# Romulan Neutral Zone
+        self.isarmed = False	# probe is armed
+        self.inorbit = False	# orbiting a planet
+        self.imine = False	# mining
+        self.icrystl = False	# dilithium crystals aboard
+        self.iseenit = False	# seen base attack report
+        self.thawed = False	# thawed game
+        self.condition = None	# &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;docked&quot;, &quot;dead&quot;
+        self.iscraft = None	# &quot;onship&quot;, &quot;offship&quot;, &quot;removed&quot;
+        self.skill = None	# Player skill level
+        self.inkling = 0	# initial number of klingons
+        self.inbase = 0		# initial number of bases
+        self.incom = 0		# initial number of commanders
+        self.inscom = 0		# initial number of commanders
+        self.inrom = 0		# initial number of commanders
+        self.instar = 0		# initial stars
+        self.intorps = 0	# initial/max torpedoes
+        self.torps = 0		# number of torpedoes
+        self.ship = 0		# ship type -- 'E' is Enterprise
+        self.abandoned = 0	# count of crew abandoned in space
+        self.length = 0		# length of game
+        self.klhere = 0		# klingons here
+        self.casual = 0		# causalties
+        self.nhelp = 0		# calls for help
+        self.nkinks = 0		# count of energy-barrier crossings
+        self.iplnet = None	# planet # in quadrant
+        self.inplan = 0		# initial planets
+        self.irhere = 0		# Romulans in quadrant
+        self.isatb = 0		# =2 if super commander is attacking base
+        self.tourn = None	# tournament number
+        self.nprobes = 0	# number of probes available
+        self.inresor = 0.0	# initial resources
+        self.intime = 0.0	# initial time
+        self.inenrg = 0.0	# initial/max energy
+        self.inshld = 0.0	# initial/max shield
+        self.inlsr = 0.0	# initial life support resources
+        self.indate = 0.0	# initial date
+        self.energy = 0.0	# energy level
+        self.shield = 0.0	# shield level
+        self.warpfac = 0.0	# warp speed
+        self.lsupres = 0.0	# life support reserves
+        self.optime = 0.0	# time taken by current operation
+        self.damfac = 0.0	# damage factor
+        self.lastchart = 0.0	# time star chart was last updated
+        self.cryprob = 0.0	# probability that crystal will work
+        self.probe = None	# object holding probe course info
+        self.height = 0.0	# height of orbit around planet
+    def recompute(self):
+        # Stas thinks this should be (C expression): 
+        # game.state.remkl + len(game.state.kcmdr) &gt; 0 ?
+	#	game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr)) : 99
+        # He says the existing expression is prone to divide-by-zero errors
+        # after killing the last klingon when score is shown -- perhaps also
+        # if the only remaining klingon is SCOM.
+        game.state.remtime = game.state.remres/(game.state.remkl + 4*len(game.state.kcmdr))
+
+FWON = 0
+FDEPLETE = 1
+FLIFESUP = 2
+FNRG = 3
+FBATTLE = 4
+FNEG3 = 5
+FNOVA = 6
+FSNOVAED = 7
+FABANDN = 8
+FDILITHIUM = 9
+FMATERIALIZE = 10
+FPHASER = 11
+FLOST = 12
+FMINING = 13
+FDPLANET = 14
+FPNOVA = 15
+FSSC = 16
+FSTRACTOR = 17
+FDRAY = 18
+FTRIBBLE = 19
+FHOLE = 20
+FCREW = 21
+
+def withprob(p):
+    return random.random() &lt; p
+
+def randrange(*args):
+    return random.randrange(*args)
+
+def randreal(*args):
+    v = random.random()
+    if len(args) == 1:
+        v *= args[0] 		# from [0, args[0])
+    elif len(args) == 2:
+        v = args[0] + v*(args[1]-args[0])	# from [args[0], args[1])
+    return v
+
+# Code from ai.c begins here
+
+def welcoming(iq):
+    &quot;Would this quadrant welcome another Klingon?&quot;
+    return iq.valid_quadrant() and \
+	not game.state.galaxy[iq.i][iq.j].supernova and \
+	game.state.galaxy[iq.i][iq.j].klingons &lt; MAXKLQUAD
+
+def tryexit(enemy, look, irun):
+    &quot;A bad guy attempts to bug out.&quot;
+    iq = coord()
+    iq.i = game.quadrant.i+(look.i+(QUADSIZE-1))/QUADSIZE - 1
+    iq.j = game.quadrant.j+(look.j+(QUADSIZE-1))/QUADSIZE - 1
+    if not welcoming(iq):
+	return False;
+    if enemy.type == 'R':
+	return False; # Romulans cannot escape! 
+    if not irun:
+	# avoid intruding on another commander's territory 
+	if enemy.type == 'C':
+            if iq in game.state.kcmdr:
+                return False
+	    # refuse to leave if currently attacking starbase 
+	    if game.battle == game.quadrant:
+		return False
+	# don't leave if over 1000 units of energy 
+	if enemy.power &gt; 1000.0:
+	    return False
+    # emit escape message and move out of quadrant.
+    # we know this if either short or long range sensors are working
+    if not damaged(DSRSENS) or not damaged(DLRSENS) or \
+	game.condition == &quot;docked&quot;:
+	prout(crmena(True, enemy.type, &quot;sector&quot;, enemy.location) + \
+              (_(&quot; escapes to Quadrant %s (and regains strength).&quot;) % q))
+    # handle local matters related to escape
+    enemy.move(None)
+    game.klhere -= 1
+    if game.condition != &quot;docked&quot;:
+	newcnd()
+    # Handle global matters related to escape 
+    game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
+    game.state.galaxy[iq.i][iq.j].klingons += 1
+    if enemy.type=='S':
+	game.iscate = False
+	game.ientesc = False
+	game.isatb = 0
+	schedule(FSCMOVE, 0.2777)
+	unschedule(FSCDBAS)
+	game.state.kscmdr=iq
+    else:
+	for cmdr in game.state.kcmdr:
+	    if cmdr == game.quadrant:
+		game.state.kcmdr[n] = iq
+		break
+    return True; # success 
+
+# The bad-guy movement algorithm:
+# 
+# 1. Enterprise has &quot;force&quot; based on condition of phaser and photon torpedoes.
+# If both are operating full strength, force is 1000. If both are damaged,
+# force is -1000. Having shields down subtracts an additional 1000.
+# 
+# 2. Enemy has forces equal to the energy of the attacker plus
+# 100*(K+R) + 500*(C+S) - 400 for novice through good levels OR
+# 346*K + 400*R + 500*(C+S) - 400 for expert and emeritus.
+# 
+# Attacker Initial energy levels (nominal):
+# Klingon   Romulan   Commander   Super-Commander
+# Novice    400        700        1200        
+# Fair      425        750        1250
+# Good      450        800        1300        1750
+# Expert    475        850        1350        1875
+# Emeritus  500        900        1400        2000
+# VARIANCE   75        200         200         200
+# 
+# Enemy vessels only move prior to their attack. In Novice - Good games
+# only commanders move. In Expert games, all enemy vessels move if there
+# is a commander present. In Emeritus games all enemy vessels move.
+# 
+# 3. If Enterprise is not docked, an aggressive action is taken if enemy
+# forces are 1000 greater than Enterprise.
+# 
+# Agressive action on average cuts the distance between the ship and
+# the enemy to 1/4 the original.
+# 
+# 4.  At lower energy advantage, movement units are proportional to the
+# advantage with a 650 advantage being to hold ground, 800 to move forward
+# 1, 950 for two, 150 for back 4, etc. Variance of 100.
+# 
+# If docked, is reduced by roughly 1.75*game.skill, generally forcing a
+# retreat, especially at high skill levels.
+# 
+# 5.  Motion is limited to skill level, except for SC hi-tailing it out.
+
+def movebaddy(enemy):
+    &quot;Tactical movement for the bad guys.&quot;
+    next = coord(); look = coord()
+    irun = False
+    # This should probably be just (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant) 
+    if game.skill &gt;= SKILL_EXPERT:
+	nbaddys = (((game.quadrant in game.state.kcmdr)*2 + (game.state.kscmdr==game.quadrant)*2+game.klhere*1.23+game.irhere*1.5)/2.0)
+    else:
+	nbaddys = (game.quadrant in game.state.kcmdr) + (game.state.kscmdr==game.quadrant)
+    dist1 = enemy.kdist
+    mdist = int(dist1 + 0.5); # Nearest integer distance 
+    # If SC, check with spy to see if should hi-tail it 
+    if enemy.type=='S' and \
+	(enemy.power &lt;= 500.0 or (game.condition==&quot;docked&quot; and not damaged(DPHOTON))):
+	irun = True
+	motion = -QUADSIZE
+    else:
+	# decide whether to advance, retreat, or hold position 
+	forces = enemy.power+100.0*len(game.enemies)+400*(nbaddys-1)
+	if not game.shldup:
+	    forces += 1000; # Good for enemy if shield is down! 
+	if not damaged(DPHASER) or not damaged(DPHOTON):
+            if damaged(DPHASER): # phasers damaged 
+		forces += 300.0
+	    else:
+		forces -= 0.2*(game.energy - 2500.0)
+	    if damaged(DPHOTON): # photon torpedoes damaged 
+		forces += 300.0
+	    else:
+		forces -= 50.0*game.torps
+	else:
+	    # phasers and photon tubes both out! 
+	    forces += 1000.0
+	motion = 0
+        if forces &lt;= 1000.0 and game.condition != &quot;docked&quot;: # Typical situation 
+	    motion = ((forces + randreal(200))/150.0) - 5.0
+	else:
+            if forces &gt; 1000.0: # Very strong -- move in for kill 
+		motion = (1.0 - randreal())**2 * dist1 + 1.0
+	    if game.condition==&quot;docked&quot; and (game.options &amp; OPTION_BASE): # protected by base -- back off ! 
+		motion -= game.skill*(2.0-randreal()**2)
+	if idebug:
+	    proutn(&quot;=== MOTION = %d, FORCES = %1.2f, &quot; % (motion, forces))
+	# don't move if no motion 
+	if motion==0:
+	    return
+	# Limit motion according to skill 
+	if abs(motion) &gt; game.skill:
+            if motion &lt; 0:
+                motion = -game.skill
+            else:
+                motion = game.skill
+    # calculate preferred number of steps 
+    nsteps = abs(int(motion))
+    if motion &gt; 0 and nsteps &gt; mdist:
+	nsteps = mdist; # don't overshoot 
+    if nsteps &gt; QUADSIZE:
+	nsteps = QUADSIZE; # This shouldn't be necessary 
+    if nsteps &lt; 1:
+	nsteps = 1; # This shouldn't be necessary 
+    if idebug:
+	proutn(&quot;NSTEPS = %d:&quot; % nsteps)
+    # Compute preferred values of delta X and Y 
+    m = game.sector - enemy.location
+    if 2.0 * abs(m.i) &lt; abs(m.j):
+	m.i = 0
+    if 2.0 * abs(m.j) &lt; abs(game.sector.i-enemy.location.i):
+	m.j = 0
+    m = (motion * m).sgn()
+    next = enemy.location
+    # main move loop 
+    for ll in range(nsteps):
+	if idebug:
+	    proutn(&quot; %d&quot; % (ll+1))
+	# Check if preferred position available 
+	look = next + m
+        if m.i &lt; 0:
+            krawli = 1
+        else:
+            krawli = -1
+        if m.j &lt; 0:
+            krawlj = 1
+        else:
+            krawlj = -1
+	success = False
+	attempts = 0; # Settle mysterious hang problem 
+	while attempts &lt; 20 and not success:
+            attempts += 1
+	    if look.i &lt; 0 or look.i &gt;= QUADSIZE:
+		if motion &lt; 0 and tryexit(enemy, look, irun):
+		    return
+		if krawli == m.i or m.j == 0:
+		    break
+		look.i = next.i + krawli
+		krawli = -krawli
+	    elif look.j &lt; 0 or look.j &gt;= QUADSIZE:
+		if motion &lt; 0 and tryexit(enemy, look, irun):
+		    return
+		if krawlj == m.j or m.i == 0:
+		    break
+		look.j = next.j + krawlj
+		krawlj = -krawlj
+	    elif (game.options &amp; OPTION_RAMMING) and game.quad[look.i][look.j] != '.':
+		# See if enemy should ram ship 
+		if game.quad[look.i][look.j] == game.ship and \
+		    (enemy.type == 'C' or enemy.type == 'S'):
+		    collision(rammed=True, enemy=enemy)
+		    return
+		if krawli != m.i and m.j != 0:
+		    look.i = next.i + krawli
+		    krawli = -krawli
+		elif krawlj != m.j and m.i != 0:
+		    look.j = next.j + krawlj
+		    krawlj = -krawlj
+		else:
+		    break; # we have failed 
+	    else:
+		success = True
+	if success:
+	    next = look
+	    if idebug:
+		proutn(`next`)
+	else:
+	    break; # done early 
+    if idebug:
+	skip(1)
+    if enemy.move(next):
+	if not damaged(DSRSENS) or game.condition == &quot;docked&quot;:
+	    proutn(_(&quot;*** %s from Sector %s&quot;) % (cramen(enemy.type), enemy.location))
+	    if enemy.kdist &lt; dist1:
+		proutn(_(&quot; advances to &quot;))
+	    else:
+		proutn(_(&quot; retreats to &quot;))
+	    prout(&quot;Sector %s.&quot; % next)
+
+def moveklings():
+    &quot;Sequence Klingon tactical movement.&quot;
+    if idebug:
+	prout(&quot;== MOVCOM&quot;)
+    # Figure out which Klingon is the commander (or Supercommander)
+    # and do move
+    if game.quadrant in game.state.kcmdr:
+        for enemy in game.enemies:
+	    if enemy.type == 'C':
+		movebaddy(enemy)
+    if game.state.kscmdr==game.quadrant:
+        for enemy in game.enemies:
+	    if enemy.type == 'S':
+		movebaddy(enemy)
+		break
+    # If skill level is high, move other Klingons and Romulans too!
+    # Move these last so they can base their actions on what the
+    # commander(s) do.
+    if game.skill &gt;= SKILL_EXPERT and (game.options &amp; OPTION_MVBADDY):
+        for enemy in game.enemies:
+            if enemy.type in ('K', 'R'):
+		movebaddy(enemy)
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+
+def movescom(iq, avoid):
+    &quot;Commander movement helper.&quot; 
+    # Avoid quadrants with bases if we want to avoid Enterprise 
+    if not welcoming(iq) or (avoid and iq in game.state.baseq):
+	return False
+    if game.justin and not game.iscate:
+	return False
+    # do the move 
+    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons -= 1
+    game.state.kscmdr = iq
+    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].klingons += 1
+    if game.state.kscmdr==game.quadrant:
+	# SC has scooted, remove him from current quadrant 
+	game.iscate=False
+	game.isatb=0
+	game.ientesc = False
+	unschedule(FSCDBAS)
+	for enemy in game.enemies:
+	    if enemy.type == 'S':
+		break
+	enemy.move(None)
+	game.klhere -= 1
+	if game.condition != &quot;docked&quot;:
+	    newcnd()
+        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    # check for a helpful planet 
+    for i in range(game.inplan):
+	if game.state.planets[i].quadrant == game.state.kscmdr and \
+	    game.state.planets[i].crystals == &quot;present&quot;:
+	    # destroy the planet 
+	    game.state.planets[i].pclass = &quot;destroyed&quot;
+	    game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].planet = None
+	    if communicating():
+		announce()
+		prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
+		proutn(_(&quot;   a planet in Quadrant %s has been destroyed&quot;) % game.state.kscmdr)
+		prout(_(&quot;   by the Super-commander.\&quot;&quot;))
+	    break
+    return True; # looks good! 
+			
+def supercommander():
+    &quot;Move the Super Commander.&quot; 
+    iq = coord(); sc = coord(); ibq = coord(); idelta = coord()
+    basetbl = []
+    if idebug:
+	prout(&quot;== SUPERCOMMANDER&quot;)
+    # Decide on being active or passive 
+    avoid = ((game.incom - len(game.state.kcmdr) + game.inkling - game.state.remkl)/(game.state.date+0.01-game.indate) &lt; 0.1*game.skill*(game.skill+1.0) or \
+	    (game.state.date-game.indate) &lt; 3.0)
+    if not game.iscate and avoid:
+	# compute move away from Enterprise 
+	idelta = game.state.kscmdr-game.quadrant
+	if idelta.distance() &gt; 2.0:
+	    # circulate in space 
+	    idelta.i = game.state.kscmdr.j-game.quadrant.j
+	    idelta.j = game.quadrant.i-game.state.kscmdr.i
+    else:
+	# compute distances to starbases 
+	if not game.state.baseq:
+	    # nothing left to do 
+	    unschedule(FSCMOVE)
+	    return
+	sc = game.state.kscmdr
+        for base in game.state.baseq:
+	    basetbl.append((i, (base - sc).distance()))
+	if game.state.baseq &gt; 1:
+            basetbl.sort(lambda x, y: cmp(x[1]. y[1]))
+	# look for nearest base without a commander, no Enterprise, and
+        # without too many Klingons, and not already under attack. 
+	ifindit = iwhichb = 0
+	for (i2, base) in enumerate(game.state.baseq):
+	    i = basetbl[i2][0];	# bug in original had it not finding nearest
+	    if base==game.quadrant or base==game.battle or not welcoming(base):
+		continue
+	    # if there is a commander, and no other base is appropriate,
+	    # we will take the one with the commander
+            for cmdr in game.state.kcmdr:
+		if base == cmdr and ifindit != 2:
+		    ifindit = 2
+		    iwhichb = i
+		    break
+	    else:	# no commander -- use this one 
+		ifindit = 1
+		iwhichb = i
+		break
+	if ifindit==0:
+	    return # Nothing suitable -- wait until next time
+	ibq = game.state.baseq[iwhichb]
+	# decide how to move toward base 
+	idelta = ibq - game.state.kscmdr
+    # Maximum movement is 1 quadrant in either or both axes 
+    idelta = idelta.sgn()
+    # try moving in both x and y directions
+    # there was what looked like a bug in the Almy C code here,
+    # but it might be this translation is just wrong.
+    iq = game.state.kscmdr + idelta
+    if not movescom(iq, avoid):
+	# failed -- try some other maneuvers 
+	if idelta.i==0 or idelta.j==0:
+	    # attempt angle move 
+	    if idelta.i != 0:
+		iq.j = game.state.kscmdr.j + 1
+		if not movescom(iq, avoid):
+		    iq.j = game.state.kscmdr.j - 1
+		    movescom(iq, avoid)
+	    elif idelta.j != 0:
+		iq.i = game.state.kscmdr.i + 1
+		if not movescom(iq, avoid):
+		    iq.i = game.state.kscmdr.i - 1
+		    movescom(iq, avoid)
+	else:
+	    # try moving just in x or y 
+	    iq.j = game.state.kscmdr.j
+	    if not movescom(iq, avoid):
+		iq.j = game.state.kscmdr.j + idelta.j
+		iq.i = game.state.kscmdr.i
+		movescom(iq, avoid)
+    # check for a base 
+    if len(game.state.baseq) == 0:
+	unschedule(FSCMOVE)
+    else:
+        for ibq in game.state.baseq:
+	    if ibq == game.state.kscmdr and game.state.kscmdr == game.battle:
+		# attack the base 
+		if avoid:
+		    return # no, don't attack base! 
+		game.iseenit = False
+		game.isatb = 1
+		schedule(FSCDBAS, randreal(1.0, 3.0))
+		if is_scheduled(FCDBAS):
+		    postpone(FSCDBAS, scheduled(FCDBAS)-game.state.date)
+		if not communicating():
+		    return # no warning 
+		game.iseenit = True
+		announce()
+		prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) \
+                      % game.state.kscmdr)
+		prout(_(&quot;   reports that it is under attack from the Klingon Super-commander.&quot;))
+		proutn(_(&quot;   It can survive until stardate %d.\&quot;&quot;) \
+                       % int(scheduled(FSCDBAS)))
+		if not game.resting:
+		    return
+		prout(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
+		if ja() == False:
+		    return
+		game.resting = False
+		game.optime = 0.0; # actually finished 
+		return
+    # Check for intelligence report 
+    if not idebug and \
+	(withprob(0.8) or \
+	 (not communicating()) or \
+	 not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].charted):
+	return
+    announce()
+    prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Intelligence reports&quot;))
+    proutn(_(&quot;   the Super-commander is in Quadrant %s,&quot;) % game.state.kscmdr)
+    return
+
+def movetholian():
+    &quot;Move the Tholian.&quot;
+    if not game.tholian or game.justin:
+	return
+    id = coord()
+    if game.tholian.location.i == 0 and game.tholian.location.j == 0:
+	id.i = 0; id.j = QUADSIZE-1
+    elif game.tholian.location.i == 0 and game.tholian.location.j == QUADSIZE-1:
+	id.i = QUADSIZE-1; id.j = QUADSIZE-1
+    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == QUADSIZE-1:
+	id.i = QUADSIZE-1; id.j = 0
+    elif game.tholian.location.i == QUADSIZE-1 and game.tholian.location.j == 0:
+	id.i = 0; id.j = 0
+    else:
+	# something is wrong! 
+	game.tholian.move(None)
+        prout(&quot;***Internal error: Tholian in a bad spot.&quot;)
+	return
+    # do nothing if we are blocked 
+    if game.quad[id.i][id.j] not in ('.', '#'):
+	return
+    here = copy.copy(game.tholian.location)
+    delta = (id - game.tholian.location).sgn()
+    # move in x axis 
+    while here.i != id.i:
+        here.i += delta.i
+        if game.quad[here.i][here.j]=='.':
+            game.tholian.move(here)
+    # move in y axis 
+    while here.j != id.j:
+        here.j += delta.j
+        if game.quad[here.i][here.j]=='.':
+            game.tholian.move(here)
+    # check to see if all holes plugged 
+    for i in range(QUADSIZE):
+	if game.quad[0][i]!='#' and game.quad[0][i]!='T':
+	    return
+	if game.quad[QUADSIZE-1][i]!='#' and game.quad[QUADSIZE-1][i]!='T':
+	    return
+	if game.quad[i][0]!='#' and game.quad[i][0]!='T':
+	    return
+	if game.quad[i][QUADSIZE-1]!='#' and game.quad[i][QUADSIZE-1]!='T':
+	    return
+    # All plugged up -- Tholian splits 
+    game.quad[game.tholian.location.i][game.tholian.location.j]='#'
+    dropin(' ')
+    prout(crmena(True, 'T', &quot;sector&quot;, game.tholian) + _(&quot; completes web.&quot;))
+    game.tholian.move(None)
+    return
+
+# Code from battle.c begins here
+
+def doshield(shraise):
+    &quot;Change shield status.&quot;
+    action = &quot;NONE&quot;
+    game.ididit = False
+    if shraise:
+	action = &quot;SHUP&quot;
+    else:
+	key = scanner.next()
+	if key == &quot;IHALPHA&quot;:
+	    if scanner.sees(&quot;transfer&quot;):
+		action = &quot;NRG&quot;
+	    else:
+		if damaged(DSHIELD):
+		    prout(_(&quot;Shields damaged and down.&quot;))
+		    return
+		if scanner.sees(&quot;up&quot;):
+		    action = &quot;SHUP&quot;
+		elif scanner.sees(&quot;down&quot;):
+		    action = &quot;SHDN&quot;
+	if action==&quot;NONE&quot;:
+	    proutn(_(&quot;Do you wish to change shield energy? &quot;))
+	    if ja() == True:
+		action = &quot;NRG&quot;
+	    elif damaged(DSHIELD):
+		prout(_(&quot;Shields damaged and down.&quot;))
+		return
+	    elif game.shldup:
+		proutn(_(&quot;Shields are up. Do you want them down? &quot;))
+		if ja() == True:
+		    action = &quot;SHDN&quot;
+		else:
+		    scanner.chew()
+		    return
+	    else:
+		proutn(_(&quot;Shields are down. Do you want them up? &quot;))
+		if ja() == True:
+		    action = &quot;SHUP&quot;
+		else:
+		    scanner.chew()
+		    return    
+    if action == &quot;SHUP&quot;: # raise shields 
+	if game.shldup:
+	    prout(_(&quot;Shields already up.&quot;))
+	    return
+	game.shldup = True
+	game.shldchg = True
+	if game.condition != &quot;docked&quot;:
+	    game.energy -= 50.0
+	prout(_(&quot;Shields raised.&quot;))
+	if game.energy &lt;= 0:
+	    skip(1)
+	    prout(_(&quot;Shields raising uses up last of energy.&quot;))
+	    finish(FNRG)
+	    return
+	game.ididit=True
+	return
+    elif action == &quot;SHDN&quot;:
+	if not game.shldup:
+	    prout(_(&quot;Shields already down.&quot;))
+	    return
+	game.shldup=False
+	game.shldchg=True
+	prout(_(&quot;Shields lowered.&quot;))
+	game.ididit = True
+	return
+    elif action == &quot;NRG&quot;:
+	while scanner.next() != &quot;IHREAL&quot;:
+	    scanner.chew()
+	    proutn(_(&quot;Energy to transfer to shields- &quot;))
+        nrg = scanner.real
+	scanner.chew()
+	if nrg == 0:
+	    return
+	if nrg &gt; game.energy:
+	    prout(_(&quot;Insufficient ship energy.&quot;))
+	    return
+	game.ididit = True
+	if game.shield+nrg &gt;= game.inshld:
+	    prout(_(&quot;Shield energy maximized.&quot;))
+	    if game.shield+nrg &gt; game.inshld:
+		prout(_(&quot;Excess energy requested returned to ship energy&quot;))
+	    game.energy -= game.inshld-game.shield
+	    game.shield = game.inshld
+	    return
+	if nrg &lt; 0.0 and game.energy-nrg &gt; game.inenrg:
+	    # Prevent shield drain loophole 
+	    skip(1)
+	    prout(_(&quot;Engineering to bridge--&quot;))
+	    prout(_(&quot;  Scott here. Power circuit problem, Captain.&quot;))
+	    prout(_(&quot;  I can't drain the shields.&quot;))
+	    game.ididit = False
+	    return
+	if game.shield+nrg &lt; 0:
+	    prout(_(&quot;All shield energy transferred to ship.&quot;))
+	    game.energy += game.shield
+	    game.shield = 0.0
+	    return
+	proutn(_(&quot;Scotty- \&quot;&quot;))
+	if nrg &gt; 0:
+	    prout(_(&quot;Transferring energy to shields.\&quot;&quot;))
+	else:
+	    prout(_(&quot;Draining energy from shields.\&quot;&quot;))
+	game.shield += nrg
+	game.energy -= nrg
+	return
+
+def randdevice():
+    &quot;Choose a device to damage, at random.&quot;
+    weights = (
+	105,	# DSRSENS: short range scanners	10.5% 
+	105,	# DLRSENS: long range scanners		10.5% 
+	120,	# DPHASER: phasers			12.0% 
+	120,	# DPHOTON: photon torpedoes		12.0% 
+	25,	# DLIFSUP: life support			 2.5% 
+	65,	# DWARPEN: warp drive			 6.5% 
+	70,	# DIMPULS: impulse engines		 6.5% 
+	145,	# DSHIELD: deflector shields		14.5% 
+	30,	# DRADIO:  subspace radio		 3.0% 
+	45,	# DSHUTTL: shuttle			 4.5% 
+	15,	# DCOMPTR: computer			 1.5% 
+	20,	# NAVCOMP: navigation system		 2.0% 
+	75,	# DTRANSP: transporter			 7.5% 
+	20,	# DSHCTRL: high-speed shield controller  2.0% 
+	10,	# DDRAY: death ray			 1.0% 
+	30,	# DDSP: deep-space probes		 3.0% 
+    )
+    assert(sum(weights) == 1000)
+    idx = randrange(1000)
+    sum = 0
+    for (i, w) in enumerate(weights):
+	sum += w
+	if idx &lt; sum:
+	    return i
+    return None;	# we should never get here
+
+def collision(rammed, enemy):
+    &quot;Collision handling fot rammong events.&quot;
+    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+    skip(1)
+    prout(_(&quot;***COLLISION IMMINENT.&quot;))
+    skip(2)
+    proutn(&quot;***&quot;)
+    proutn(crmshp())
+    hardness = {'R':1.5, 'C':2.0, 'S':2.5, 'T':0.5, '?':4.0}.get(enemy.type, 1.0)
+    if rammed:
+        proutn(_(&quot; rammed by &quot;))
+    else:
+        proutn(_(&quot; rams &quot;))
+    proutn(crmena(False, enemy.type, &quot;sector&quot;, enemy.location))
+    if rammed:
+	proutn(_(&quot; (original position)&quot;))
+    skip(1)
+    deadkl(enemy.location, enemy.type, game.sector)
+    proutn(&quot;***&quot; + crmship() + &quot; heavily damaged.&quot;)
+    icas = randrange(10, 30)
+    prout(_(&quot;***Sickbay reports %d casualties&quot;), icas)
+    game.casual += icas
+    game.state.crew -= icas
+    # In the pre-SST2K version, all devices got equiprobably damaged,
+    # which was silly.  Instead, pick up to half the devices at
+    # random according to our weighting table,
+    ncrits = randrange(NDEVICES/2)
+    for m in range(ncrits):
+	dev = randdevice()
+	if game.damage[dev] &lt; 0:
+	    continue
+	extradm = (10.0*hardness*randreal()+1.0)*game.damfac
+	# Damage for at least time of travel! 
+	game.damage[dev] += game.optime + extradm
+    game.shldup = False
+    prout(_(&quot;***Shields are down.&quot;))
+    if game.state.remkl + len(game.state.kcmdr) + game.state.nscrem:
+	announce()
+	damagereport()
+    else:
+	finish(FWON)
+    return
+
+def torpedo(origin, bearing, dispersion, number, nburst):
+    &quot;Let a photon torpedo fly&quot; 
+    if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
+	setwnd(srscan_window)
+    else: 
+	setwnd(message_window)
+    ac = bearing + 0.25*dispersion	# dispersion is a random variable
+    bullseye = (15.0 - bearing)*0.5235988
+    track = course(bearing=ac, distance=QUADSIZE, origin=cartesian(origin)) 
+    bumpto = coord(0, 0)
+    # Loop to move a single torpedo 
+    setwnd(message_window)
+    for step in range(1, QUADSIZE*2):
+        if not track.next(): break
+        w = track.sector()
+	if not w.valid_sector():
+	    break
+	iquad=game.quad[w.i][w.j]
+	tracktorpedo(origin, w, step, number, nburst, iquad)
+	if iquad=='.':
+	    continue
+	# hit something 
+	if not damaged(DSRSENS) or game.condition == &quot;docked&quot;:
+	    skip(1);	# start new line after text track 
+	if iquad in ('E', 'F'): # Hit our ship 
+	    skip(1)
+	    prout(_(&quot;Torpedo hits %s.&quot;) % crmshp())
+	    hit = 700.0 + randreal(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
+	    newcnd(); # we're blown out of dock 
+	    if game.landed or game.condition==&quot;docked&quot;:
+		return hit # Cheat if on a planet 
+            # In the C/FORTRAN version, dispersion was 2.5 radians, which
+            # is 143 degrees, which is almost exactly 4.8 clockface units
+            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
+            displacement.next()
+            bumpto = displacement.sector()
+	    if not bumpto.valid_sector():
+		return hit
+	    if game.quad[bumpto.i][bumpto.j]==' ':
+		finish(FHOLE)
+		return hit
+	    if game.quad[bumpto.i][bumpto.j]!='.':
+		# can't move into object 
+		return hit
+	    game.sector = bumpto
+	    proutn(crmshp())
+            game.quad[w.i][w.j]='.'
+            game.quad[bumpto.i][bumpto.j]=iquad
+            prout(_(&quot; displaced by blast to Sector %s &quot;) % bumpto)
+            for enemy in game.enemies:
+                enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
+            game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+            return None
+	elif iquad in ('C', 'S', 'R', 'K'): # Hit a regular enemy 
+	    # find the enemy 
+	    if iquad in ('C', 'S') and withprob(0.05):
+		prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; uses anti-photon device;&quot;))
+		prout(_(&quot;   torpedo neutralized.&quot;))
+		return None
+            for enemy in game.enemies:
+		if w == enemy.location:
+		    break
+	    kp = math.fabs(enemy.power)
+	    h1 = 700.0 + randrange(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-track.angle))
+	    h1 = math.fabs(h1)
+	    if kp &lt; h1:
+		h1 = kp
+            if enemy.power &lt; 0:
+                enemy.power -= -h1
+            else:
+                enemy.power -= h1
+	    if enemy.power == 0:
+		deadkl(w, iquad, w)
+		return None
+	    proutn(crmena(True, iquad, &quot;sector&quot;, w))
+            displacement = course(track.bearing+randreal(-2.4,2.4), distance=2**0.5)
+            displacement.next()
+            bumpto = displacement.sector()
+            if not bumpto.valid_sector():
+		prout(_(&quot; damaged but not destroyed.&quot;))
+		return
+	    if game.quad[bumpto.i][bumpto.j] == ' ':
+		prout(_(&quot; buffeted into black hole.&quot;))
+		deadkl(w, iquad, bumpto)
+	    if game.quad[bumpto.i][bumpto.j] != '.':
+		prout(_(&quot; damaged but not destroyed.&quot;))
+            else:
+                prout(_(&quot; damaged-- displaced by blast to Sector %s &quot;)%bumpto)
+                enemy.location = bumpto
+                game.quad[w.i][w.j]='.'
+                game.quad[bumpto.i][bumpto.j]=iquad
+                for enemy in game.enemies:
+                    enemy.kdist = enemy.kavgd = (game.sector-enemy.location).distance()
+                game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+            return None
+	elif iquad == 'B': # Hit a base 
+	    skip(1)
+	    prout(_(&quot;***STARBASE DESTROYED..&quot;))
+            game.state.baseq = filter(lambda x: x != game.quadrant, game.state.baseq)
+	    game.quad[w.i][w.j]='.'
+	    game.base.invalidate()
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase -= 1
+	    game.state.chart[game.quadrant.i][game.quadrant.j].starbase -= 1
+	    game.state.basekl += 1
+	    newcnd()
+	    return None
+	elif iquad == 'P': # Hit a planet 
+	    prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; destroyed.&quot;))
+	    game.state.nplankl += 1
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+	    game.iplnet.pclass = &quot;destroyed&quot;
+	    game.iplnet = None
+	    game.plnet.invalidate()
+	    game.quad[w.i][w.j] = '.'
+	    if game.landed:
+		# captain perishes on planet 
+		finish(FDPLANET)
+	    return None
+	elif iquad == '@': # Hit an inhabited world -- very bad! 
+	    prout(crmena(True, iquad, &quot;sector&quot;, w) + _(&quot; destroyed.&quot;))
+	    game.state.nworldkl += 1
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+	    game.iplnet.pclass = &quot;destroyed&quot;
+	    game.iplnet = None
+	    game.plnet.invalidate()
+	    game.quad[w.i][w.j] = '.'
+	    if game.landed:
+		# captain perishes on planet 
+		finish(FDPLANET)
+	    prout(_(&quot;The torpedo destroyed an inhabited planet.&quot;))
+	    return None
+	elif iquad == '*': # Hit a star 
+	    if withprob(0.9):
+		nova(w)
+            else:
+                prout(crmena(True, '*', &quot;sector&quot;, w) + _(&quot; unaffected by photon blast.&quot;))
+	    return None
+	elif iquad == '?': # Hit a thingy 
+	    if not (game.options &amp; OPTION_THINGY) or withprob(0.3):
+		skip(1)
+		prouts(_(&quot;AAAAIIIIEEEEEEEEAAAAAAAAUUUUUGGGGGHHHHHHHHHHHH!!!&quot;))
+		skip(1)
+		prouts(_(&quot;    HACK!     HACK!    HACK!        *CHOKE!*  &quot;))
+		skip(1)
+		proutn(_(&quot;Mr. Spock-&quot;))
+		prouts(_(&quot;  \&quot;Fascinating!\&quot;&quot;))
+		skip(1)
+		deadkl(w, iquad, w)
+	    else:
+		# Stas Sergeev added the possibility that
+		# you can shove the Thingy and piss it off.
+		# It then becomes an enemy and may fire at you.
+		thing.angry = True
+		shoved = True
+	    return None
+	elif iquad == ' ': # Black hole 
+	    skip(1)
+	    prout(crmena(True, ' ', &quot;sector&quot;, w) + _(&quot; swallows torpedo.&quot;))
+	    return None
+	elif iquad == '#': # hit the web 
+	    skip(1)
+	    prout(_(&quot;***Torpedo absorbed by Tholian web.&quot;))
+	    return None
+	elif iquad == 'T':  # Hit a Tholian 
+	    h1 = 700.0 + randrange(100) - \
+		1000.0 * (w-origin).distance() * math.fabs(math.sin(bullseye-angle))
+	    h1 = math.fabs(h1)
+	    if h1 &gt;= 600:
+		game.quad[w.i][w.j] = '.'
+		deadkl(w, iquad, w)
+		game.tholian = None
+		return None
+	    skip(1)
+	    proutn(crmena(True, 'T', &quot;sector&quot;, w))
+	    if withprob(0.05):
+		prout(_(&quot; survives photon blast.&quot;))
+		return None
+	    prout(_(&quot; disappears.&quot;))
+	    game.tholian.move(None)
+	    game.quad[w.i][w.j] = '#'
+	    dropin(' ')
+	    return None
+        else: # Problem!
+	    skip(1)
+	    proutn(&quot;Don't know how to handle torpedo collision with &quot;)
+	    proutn(crmena(True, iquad, &quot;sector&quot;, w))
+	    skip(1)
+	    return None
+	break
+    skip(1)
+    prout(_(&quot;Torpedo missed.&quot;))
+    return None;
+
+def fry(hit):
+    &quot;Critical-hit resolution.&quot; 
+    if hit &lt; (275.0-25.0*game.skill)*randreal(1.0, 1.5):
+	return
+    ncrit = int(1.0 + hit/(500.0+randreal(100)))
+    proutn(_(&quot;***CRITICAL HIT--&quot;))
+    # Select devices and cause damage
+    cdam = []
+    for loop1 in range(ncrit):
+        while True:
+	    j = randdevice()
+	    # Cheat to prevent shuttle damage unless on ship 
+            if not (game.damage[j]&lt;0.0 or (j==DSHUTTL and game.iscraft != &quot;onship&quot;)):
+                break
+	cdam.append(j)
+	extradm = (hit*game.damfac)/(ncrit*randreal(75, 100))
+	game.damage[j] += extradm
+    skipcount = 0
+    for (i, j) in enumerate(cdam):
+	proutn(device[j])
+        if skipcount % 3 == 2 and i &lt; len(cdam)-1:
+            skip(1)
+        skipcount += 1
+        if i &lt; len(cdam)-1:
+            proutn(_(&quot; and &quot;))
+    prout(_(&quot; damaged.&quot;))
+    if damaged(DSHIELD) and game.shldup:
+	prout(_(&quot;***Shields knocked down.&quot;))
+	game.shldup=False
+
+def attack(torps_ok):
+    # bad guy attacks us 
+    # torps_ok == False forces use of phasers in an attack 
+    # game could be over at this point, check
+    if game.alldone:
+	return
+    attempt = False; ihurt = False;
+    hitmax=0.0; hittot=0.0; chgfac=1.0
+    where = &quot;neither&quot;
+    if idebug:
+	prout(&quot;=== ATTACK!&quot;)
+    # Tholian gets to move before attacking 
+    if game.tholian:
+	movetholian()
+    # if you have just entered the RNZ, you'll get a warning 
+    if game.neutz: # The one chance not to be attacked 
+	game.neutz = False
+	return
+    # commanders get a chance to tac-move towards you 
+    if (((game.quadrant in game.state.kcmdr or game.state.kscmdr==game.quadrant) and not game.justin) or game.skill == SKILL_EMERITUS) and torps_ok:
+	moveklings()
+    # if no enemies remain after movement, we're done 
+    if len(game.enemies)==0 or (len(game.enemies)==1 and thing == game.quadrant and not thing.angry):
+	return
+    # set up partial hits if attack happens during shield status change 
+    pfac = 1.0/game.inshld
+    if game.shldchg:
+	chgfac = 0.25 + randreal(0.5)
+    skip(1)
+    # message verbosity control 
+    if game.skill &lt;= SKILL_FAIR:
+	where = &quot;sector&quot;
+    for enemy in game.enemies:
+	if enemy.power &lt; 0:
+	    continue;	# too weak to attack 
+	# compute hit strength and diminish shield power 
+	r = randreal()
+	# Increase chance of photon torpedos if docked or enemy energy is low 
+	if game.condition == &quot;docked&quot;:
+	    r *= 0.25
+	if enemy.power &lt; 500:
+	    r *= 0.25; 
+	if enemy.type=='T' or (enemy.type=='?' and not thing.angry):
+	    continue
+	# different enemies have different probabilities of throwing a torp 
+	usephasers = not torps_ok or \
+	    (enemy.type == 'K' and r &gt; 0.0005) or \
+	    (enemy.type=='C' and r &gt; 0.015) or \
+	    (enemy.type=='R' and r &gt; 0.3) or \
+	    (enemy.type=='S' and r &gt; 0.07) or \
+	    (enemy.type=='?' and r &gt; 0.05)
+	if usephasers:	    # Enemy uses phasers 
+	    if game.condition == &quot;docked&quot;:
+		continue; # Don't waste the effort! 
+	    attempt = True; # Attempt to attack 
+	    dustfac = randreal(0.8, 0.85)
+	    hit = enemy.power*math.pow(dustfac,enemy.kavgd)
+	    enemy.power *= 0.75
+	else: # Enemy uses photon torpedo 
+	    # We should be able to make the bearing() method work here
+	    course = 1.90985*math.atan2(game.sector.j-enemy.location.j, enemy.location.i-game.sector.i)
+	    hit = 0
+	    proutn(_(&quot;***TORPEDO INCOMING&quot;))
+	    if not damaged(DSRSENS):
+		proutn(_(&quot; From &quot;) + crmena(False, enemy.type, where, enemy.location))
+	    attempt = True
+	    prout(&quot;  &quot;)
+	    dispersion = (randreal()+randreal())*0.5 - 0.5
+	    dispersion += 0.002*enemy.power*dispersion
+	    hit = torpedo(enemy.location, course, dispersion, number=1, nburst=1)
+	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+		finish(FWON); # Klingons did themselves in! 
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.alldone:
+		return # Supernova or finished 
+	    if hit == None:
+		continue
+	# incoming phaser or torpedo, shields may dissipate it 
+	if game.shldup or game.shldchg or game.condition==&quot;docked&quot;:
+	    # shields will take hits 
+	    propor = pfac * game.shield
+            if game.condition ==&quot;docked&quot;:
+                propr *= 2.1
+	    if propor &lt; 0.1:
+		propor = 0.1
+	    hitsh = propor*chgfac*hit+1.0
+	    absorb = 0.8*hitsh
+	    if absorb &gt; game.shield:
+		absorb = game.shield
+	    game.shield -= absorb
+	    hit -= hitsh
+	    # taking a hit blasts us out of a starbase dock 
+	    if game.condition == &quot;docked&quot;:
+		dock(False)
+	    # but the shields may take care of it 
+	    if propor &gt; 0.1 and hit &lt; 0.005*game.energy:
+		continue
+	# hit from this opponent got through shields, so take damage 
+	ihurt = True
+	proutn(_(&quot;%d unit hit&quot;) % int(hit))
+	if (damaged(DSRSENS) and usephasers) or game.skill&lt;=SKILL_FAIR:
+	    proutn(_(&quot; on the &quot;) + crmshp())
+	if not damaged(DSRSENS) and usephasers:
+	    prout(_(&quot; from &quot;) + crmena(False, enemy.type, where, enemy.location))
+	skip(1)
+	# Decide if hit is critical 
+	if hit &gt; hitmax:
+	    hitmax = hit
+	hittot += hit
+	fry(hit)
+	game.energy -= hit
+    if game.energy &lt;= 0:
+	# Returning home upon your shield, not with it... 
+	finish(FBATTLE)
+	return
+    if not attempt and game.condition == &quot;docked&quot;:
+	prout(_(&quot;***Enemies decide against attacking your ship.&quot;))
+    percent = 100.0*pfac*game.shield+0.5
+    if not ihurt:
+	# Shields fully protect ship 
+	proutn(_(&quot;Enemy attack reduces shield strength to &quot;))
+    else:
+	# Emit message if starship suffered hit(s) 
+	skip(1)
+	proutn(_(&quot;Energy left %2d    shields &quot;) % int(game.energy))
+	if game.shldup:
+	    proutn(_(&quot;up &quot;))
+	elif not damaged(DSHIELD):
+	    proutn(_(&quot;down &quot;))
+	else:
+	    proutn(_(&quot;damaged, &quot;))
+    prout(_(&quot;%d%%,   torpedoes left %d&quot;) % (percent, game.torps))
+    # Check if anyone was hurt 
+    if hitmax &gt;= 200 or hittot &gt;= 500:
+	icas = randrange(int(hittot * 0.015))
+	if icas &gt;= 2:
+	    skip(1)
+	    prout(_(&quot;Mc Coy-  \&quot;Sickbay to bridge.  We suffered %d casualties&quot;) % icas)
+	    prout(_(&quot;   in that last attack.\&quot;&quot;))
+	    game.casual += icas
+	    game.state.crew -= icas
+    # After attack, reset average distance to enemies 
+    for enemy in game.enemies:
+	enemy.kavgd = enemy.kdist
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    return
+		
+def deadkl(w, type, mv):
+    &quot;Kill a Klingon, Tholian, Romulan, or Thingy.&quot; 
+    # Added mv to allow enemy to &quot;move&quot; before dying 
+    proutn(crmena(True, type, &quot;sector&quot;, mv))
+    # Decide what kind of enemy it is and update appropriately 
+    if type == 'R':
+        # Chalk up a Romulan 
+        game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans -= 1
+        game.irhere -= 1
+        game.state.nromrem -= 1
+    elif type == 'T':
+        # Killed a Tholian 
+        game.tholian = None
+    elif type == '?':
+        # Killed a Thingy
+        global thing
+        thing = None
+    else:
+        # Killed some type of Klingon 
+        game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons -= 1
+        game.klhere -= 1
+        if type == 'C':
+            game.state.kcmdr.remove(game.quadrant)
+            unschedule(FTBEAM)
+            if game.state.kcmdr:
+                schedule(FTBEAM, expran(1.0*game.incom/len(game.state.kcmdr)))
+            if is_scheduled(FCDBAS) and game.battle == game.quadrant:
+                unschedule(FCDBAS)    
+        elif type ==  'K':
+            game.state.remkl -= 1
+        elif type ==  'S':
+            game.state.nscrem -= 1
+            game.state.kscmdr.invalidate()
+            game.isatb = 0
+            game.iscate = False
+            unschedule(FSCMOVE)
+            unschedule(FSCDBAS)
+    # For each kind of enemy, finish message to player 
+    prout(_(&quot; destroyed.&quot;))
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+	return
+    game.recompute()
+    # Remove enemy ship from arrays describing local conditions
+    for e in game.enemies:
+	if e.location == w:
+            e.move(None)
+	    break
+    return
+
+def targetcheck(w):
+    &quot;Return None if target is invalid, otherwise return a course angle.&quot;
+    if not w.valid_sector():
+	huh()
+	return None
+    delta = coord()
+    # FIXME: C code this was translated from is wacky -- why the sign reversal?
+    delta.j = (w.j - game.sector.j);
+    delta.i = (game.sector.i - w.i);
+    if delta == coord(0, 0):
+	skip(1)
+	prout(_(&quot;Spock-  \&quot;Bridge to sickbay.  Dr. McCoy,&quot;))
+	prout(_(&quot;  I recommend an immediate review of&quot;))
+	prout(_(&quot;  the Captain's psychological profile.\&quot;&quot;))
+	scanner.chew()
+	return None
+    return delta.bearing()
+
+def torps():
+    &quot;Launch photon torpedo salvo.&quot;
+    course = []
+    game.ididit = False
+    if damaged(DPHOTON):
+	prout(_(&quot;Photon tubes damaged.&quot;))
+	scanner.chew()
+	return
+    if game.torps == 0:
+	prout(_(&quot;No torpedoes left.&quot;))
+	scanner.chew()
+	return
+    # First, get torpedo count
+    while True:
+        scanner.next()
+	if scanner.token == &quot;IHALPHA&quot;:
+	    huh()
+	    return
+	elif scanner.token == &quot;IHEOL&quot; or not scanner.waiting():
+	    prout(_(&quot;%d torpedoes left.&quot;) % game.torps)
+            scanner.chew()
+	    proutn(_(&quot;Number of torpedoes to fire- &quot;))
+            continue	# Go back around to get a number
+	else: # key == &quot;IHREAL&quot;
+	    n = scanner.int()
+	    if n &lt;= 0: # abort command 
+		scanner.chew()
+		return
+	    if n &gt; MAXBURST:
+		scanner.chew()
+		prout(_(&quot;Maximum of %d torpedoes per burst.&quot;) % MAXBURST)
+		return
+            if n &gt; game.torps:
+                scanner.chew()	# User requested more torps than available
+                continue	# Go back around
+            break	# All is good, go to next stage
+    # Next, get targets
+    target = []
+    for i in range(n):
+	key = scanner.next()
+	if i==0 and key == &quot;IHEOL&quot;:
+	    break;	# no coordinate waiting, we will try prompting 
+	if i==1 and key == &quot;IHEOL&quot;:
+	    # direct all torpedoes at one target 
+	    while i &lt; n:
+		target.append(target[0])
+		course.append(course[0])
+		i += 1
+	    break
+        scanner.push(scanner.token)
+        target.append(scanner.getcoord())
+        if target[-1] == None:
+            return
+        course.append(targetcheck(target[-1]))
+        if course[-1] == None:
+	    return
+    scanner.chew()
+    if len(target) == 0:
+	# prompt for each one 
+	for i in range(n):
+	    proutn(_(&quot;Target sector for torpedo number %d- &quot;) % (i+1))
+	    scanner.chew()
+            target.append(scanner.getcoord())
+            if target[-1] == None:
+                return
+            course.append(targetcheck(target[-1]))
+            if course[-1] == None:
+                return
+    game.ididit = True
+    # Loop for moving &lt;n&gt; torpedoes 
+    for i in range(n):
+	if game.condition != &quot;docked&quot;:
+	    game.torps -= 1
+	dispersion = (randreal()+randreal())*0.5 -0.5
+	if math.fabs(dispersion) &gt;= 0.47:
+	    # misfire! 
+	    dispersion *= randreal(1.2, 2.2)
+	    if n &gt; 0:
+		prouts(_(&quot;***TORPEDO NUMBER %d MISFIRES&quot;) % (i+1))
+	    else:
+		prouts(_(&quot;***TORPEDO MISFIRES.&quot;))
+	    skip(1)
+	    if i &lt; n:
+		prout(_(&quot;  Remainder of burst aborted.&quot;))
+	    if withprob(0.2):
+		prout(_(&quot;***Photon tubes damaged by misfire.&quot;))
+		game.damage[DPHOTON] = game.damfac * randreal(1.0, 3.0)
+	    break
+	if game.shldup or game.condition == &quot;docked&quot;:
+	    dispersion *= 1.0 + 0.0001*game.shield
+	torpedo(game.sector, course[i], dispersion, number=i, nburst=n)
+	if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+	    return
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+	finish(FWON);
+
+def overheat(rpow):
+    &quot;Check for phasers overheating.&quot;
+    if rpow &gt; 1500:
+        checkburn = (rpow-1500.0)*0.00038
+        if withprob(checkburn):
+	    prout(_(&quot;Weapons officer Sulu-  \&quot;Phasers overheated, sir.\&quot;&quot;))
+	    game.damage[DPHASER] = game.damfac* randreal(1.0, 2.0) * (1.0+checkburn)
+
+def checkshctrl(rpow):
+    &quot;Check shield control.&quot;
+    skip(1)
+    if withprob(0.998):
+	prout(_(&quot;Shields lowered.&quot;))
+	return False
+    # Something bad has happened 
+    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+    skip(2)
+    hit = rpow*game.shield/game.inshld
+    game.energy -= rpow+hit*0.8
+    game.shield -= hit*0.2
+    if game.energy &lt;= 0.0:
+	prouts(_(&quot;Sulu-  \&quot;Captain! Shield malf***********************\&quot;&quot;))
+	skip(1)
+	stars()
+	finish(FPHASER)
+	return True
+    prouts(_(&quot;Sulu-  \&quot;Captain! Shield malfunction! Phaser fire contained!\&quot;&quot;))
+    skip(2)
+    prout(_(&quot;Lt. Uhura-  \&quot;Sir, all decks reporting damage.\&quot;&quot;))
+    icas = randrange(int(hit*0.012))
+    skip(1)
+    fry(0.8*hit)
+    if icas:
+	skip(1)
+	prout(_(&quot;McCoy to bridge- \&quot;Severe radiation burns, Jim.&quot;))
+	prout(_(&quot;  %d casualties so far.\&quot;&quot;) % icas)
+	game.casual += icas
+	game.state.crew -= icas
+    skip(1)
+    prout(_(&quot;Phaser energy dispersed by shields.&quot;))
+    prout(_(&quot;Enemy unaffected.&quot;))
+    overheat(rpow)
+    return True;
+
+def hittem(hits):
+    &quot;Register a phaser hit on Klingons and Romulans.&quot;
+    nenhr2 = len(game.enemies); kk=0
+    w = coord()
+    skip(1)
+    for (k, wham) in enumerate(hits):
+	if wham==0:
+	    continue
+	dustfac = randreal(0.9, 1.0)
+	hit = wham*math.pow(dustfac,game.enemies[kk].kdist)
+	kpini = game.enemies[kk].power
+	kp = math.fabs(kpini)
+	if PHASEFAC*hit &lt; kp:
+	    kp = PHASEFAC*hit
+        if game.enemies[kk].power &lt; 0:
+            game.enemies[kk].power -= -kp
+        else:
+            game.enemies[kk].power -= kp
+	kpow = game.enemies[kk].power
+	w = game.enemies[kk].location
+	if hit &gt; 0.005:
+	    if not damaged(DSRSENS):
+		boom(w)
+	    proutn(_(&quot;%d unit hit on &quot;) % int(hit))
+	else:
+	    proutn(_(&quot;Very small hit on &quot;))
+	ienm = game.quad[w.i][w.j]
+	if ienm=='?':
+	    thing.angry = True
+	proutn(crmena(False, ienm, &quot;sector&quot;, w))
+	skip(1)
+	if kpow == 0:
+	    deadkl(w, ienm, w)
+	    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0:
+		finish(FWON);		
+	    if game.alldone:
+		return
+	    kk -= 1	# don't do the increment
+            continue
+	else: # decide whether or not to emasculate klingon 
+	    if kpow&gt;0 and withprob(0.9) and kpow &lt;= randreal(0.4, 0.8)*kpini:
+		prout(_(&quot;***Mr. Spock-  \&quot;Captain, the vessel at Sector %s&quot;)%w)
+		prout(_(&quot;   has just lost its firepower.\&quot;&quot;))
+		game.enemies[kk].power = -kpow
+        kk += 1
+    return
+
+def phasers():
+    &quot;Fire phasers at bad guys.&quot;
+    hits = []
+    kz = 0; k = 1; irec=0 # Cheating inhibitor 
+    ifast = False; no = False; itarg = True; msgflag = True; rpow=0
+    automode = &quot;NOTSET&quot;
+    key=0
+    skip(1)
+    # SR sensors and Computer are needed for automode 
+    if damaged(DSRSENS) or damaged(DCOMPTR):
+	itarg = False
+    if game.condition == &quot;docked&quot;:
+	prout(_(&quot;Phasers can't be fired through base shields.&quot;))
+	scanner.chew()
+	return
+    if damaged(DPHASER):
+	prout(_(&quot;Phaser control damaged.&quot;))
+	scanner.chew()
+	return
+    if game.shldup:
+	if damaged(DSHCTRL):
+	    prout(_(&quot;High speed shield control damaged.&quot;))
+	    scanner.chew()
+	    return
+	if game.energy &lt;= 200.0:
+	    prout(_(&quot;Insufficient energy to activate high-speed shield control.&quot;))
+	    scanner.chew()
+	    return
+	prout(_(&quot;Weapons Officer Sulu-  \&quot;High-speed shield control enabled, sir.\&quot;&quot;))
+	ifast = True
+    # Original code so convoluted, I re-did it all
+    # (That was Tom Almy talking about the C code, I think -- ESR)
+    while automode==&quot;NOTSET&quot;:
+	key=scanner.next()
+	if key == &quot;IHALPHA&quot;:
+	    if scanner.sees(&quot;manual&quot;):
+		if len(game.enemies)==0:
+		    prout(_(&quot;There is no enemy present to select.&quot;))
+		    scanner.chew()
+		    key = &quot;IHEOL&quot;
+		    automode=&quot;AUTOMATIC&quot;
+		else:
+		    automode = &quot;MANUAL&quot;
+		    key = scanner.next()
+	    elif scanner.sees(&quot;automatic&quot;):
+		if (not itarg) and len(game.enemies) != 0:
+		    automode = &quot;FORCEMAN&quot;
+		else:
+		    if len(game.enemies)==0:
+			prout(_(&quot;Energy will be expended into space.&quot;))
+		    automode = &quot;AUTOMATIC&quot;
+		    key = scanner.next()
+	    elif scanner.sees(&quot;no&quot;):
+		no = True
+	    else:
+		huh()
+		return
+	elif key == &quot;IHREAL&quot;:
+	    if len(game.enemies)==0:
+		prout(_(&quot;Energy will be expended into space.&quot;))
+		automode = &quot;AUTOMATIC&quot;
+	    elif not itarg:
+		automode = &quot;FORCEMAN&quot;
+	    else:
+		automode = &quot;AUTOMATIC&quot;
+	else:
+	    # &quot;IHEOL&quot; 
+	    if len(game.enemies)==0:
+		prout(_(&quot;Energy will be expended into space.&quot;))
+		automode = &quot;AUTOMATIC&quot;
+	    elif not itarg:
+		automode = &quot;FORCEMAN&quot;
+	    else: 
+		proutn(_(&quot;Manual or automatic? &quot;))
+                scanner.chew()
+    avail = game.energy
+    if ifast:
+        avail -= 200.0
+    if automode == &quot;AUTOMATIC&quot;:
+	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
+	    no = True
+	    key = scanner.next()
+	if key != &quot;IHREAL&quot; and len(game.enemies) != 0:
+	    prout(_(&quot;Phasers locked on target. Energy available: %.2f&quot;)%avail)
+	irec=0
+        while True:
+	    scanner.chew()
+	    if not kz:
+		for i in range(len(game.enemies)):
+		    irec += math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))*randreal(1.01, 1.06) + 1.0
+	    kz=1
+	    proutn(_(&quot;%d units required. &quot;) % irec)
+	    scanner.chew()
+	    proutn(_(&quot;Units to fire= &quot;))
+	    key = scanner.next()
+	    if key!=&quot;IHREAL&quot;:
+		return
+	    rpow = scanner.real
+	    if rpow &gt; avail:
+		proutn(_(&quot;Energy available= %.2f&quot;) % avail)
+		skip(1)
+		key = &quot;IHEOL&quot;
+            if not rpow &gt; avail:
+                break
+	if rpow&lt;=0:
+	    # chicken out 
+	    scanner.chew()
+	    return
+        key=scanner.next()
+	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
+	    no = True
+	if ifast:
+	    game.energy -= 200; # Go and do it! 
+	    if checkshctrl(rpow):
+		return
+	scanner.chew()
+	game.energy -= rpow
+	extra = rpow
+	if len(game.enemies):
+	    extra = 0.0
+	    powrem = rpow
+	    for i in range(len(game.enemies)):
+		hits.append(0.0)
+		if powrem &lt;= 0:
+		    continue
+		hits[i] = math.fabs(game.enemies[i].power)/(PHASEFAC*math.pow(0.90,game.enemies[i].kdist))
+		over = randreal(1.01, 1.06) * hits[i]
+		temp = powrem
+		powrem -= hits[i] + over
+		if powrem &lt;= 0 and temp &lt; hits[i]:
+		    hits[i] = temp
+		if powrem &lt;= 0:
+		    over = 0.0
+		extra += over
+	    if powrem &gt; 0.0:
+		extra += powrem
+	    hittem(hits)
+	    game.ididit = True
+	if extra &gt; 0 and not game.alldone:
+	    if game.tholian:
+		proutn(_(&quot;*** Tholian web absorbs &quot;))
+		if len(game.enemies)&gt;0:
+		    proutn(_(&quot;excess &quot;))
+		prout(_(&quot;phaser energy.&quot;))
+	    else:
+		prout(_(&quot;%d expended on empty space.&quot;) % int(extra))
+    elif automode == &quot;FORCEMAN&quot;:
+	scanner.chew()
+	key = &quot;IHEOL&quot;
+	if damaged(DCOMPTR):
+	    prout(_(&quot;Battle computer damaged, manual fire only.&quot;))
+	else:
+	    skip(1)
+	    prouts(_(&quot;---WORKING---&quot;))
+	    skip(1)
+	    prout(_(&quot;Short-range-sensors-damaged&quot;))
+	    prout(_(&quot;Insufficient-data-for-automatic-phaser-fire&quot;))
+	    prout(_(&quot;Manual-fire-must-be-used&quot;))
+	    skip(1)
+    elif automode == &quot;MANUAL&quot;:
+	rpow = 0.0
+        for k in range(len(game.enemies)):
+	    aim = game.enemies[k].location
+	    ienm = game.quad[aim.i][aim.j]
+	    if msgflag:
+		proutn(_(&quot;Energy available= %.2f&quot;) % (avail-0.006))
+		skip(1)
+		msgflag = False
+		rpow = 0.0
+	    if damaged(DSRSENS) and \
+               not game.sector.distance(aim)&lt;2**0.5 and ienm in ('C', 'S'):
+		prout(cramen(ienm) + _(&quot; can't be located without short range scan.&quot;))
+		scanner.chew()
+		key = &quot;IHEOL&quot;
+		hits[k] = 0; # prevent overflow -- thanks to Alexei Voitenko 
+		k += 1
+		continue
+	    if key == &quot;IHEOL&quot;:
+		scanner.chew()
+		if itarg and k &gt; kz:
+		    irec=(abs(game.enemies[k].power)/(PHASEFAC*math.pow(0.9,game.enemies[k].kdist))) *	randreal(1.01, 1.06) + 1.0
+		kz = k
+		proutn(&quot;(&quot;)
+		if not damaged(DCOMPTR):
+		    proutn(&quot;%d&quot; % irec)
+		else:
+		    proutn(&quot;??&quot;)
+		proutn(&quot;)  &quot;)
+		proutn(_(&quot;units to fire at %s-  &quot;) % crmena(False, ienm, &quot;sector&quot;, aim))		
+		key = scanner.next()
+	    if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
+		no = True
+		key = scanner.next()
+		continue
+	    if key == &quot;IHALPHA&quot;:
+		huh()
+		return
+	    if key == &quot;IHEOL&quot;:
+		if k==1: # Let me say I'm baffled by this 
+		    msgflag = True
+		continue
+	    if scanner.real &lt; 0:
+		# abort out 
+		scanner.chew()
+		return
+	    hits[k] = scanner.real
+	    rpow += scanner.real
+	    # If total requested is too much, inform and start over 
+            if rpow &gt; avail:
+		prout(_(&quot;Available energy exceeded -- try again.&quot;))
+		scanner.chew()
+		return
+	    key = scanner.next(); # scan for next value 
+	    k += 1
+	if rpow == 0.0:
+	    # zero energy -- abort 
+	    scanner.chew()
+	    return
+	if key == &quot;IHALPHA&quot; and scanner.sees(&quot;no&quot;):
+	    no = True
+	game.energy -= rpow
+	scanner.chew()
+	if ifast:
+	    game.energy -= 200.0
+	    if checkshctrl(rpow):
+		return
+	hittem(hits)
+	game.ididit = True
+     # Say shield raised or malfunction, if necessary 
+    if game.alldone:
+	return
+    if ifast:
+	skip(1)
+	if no == 0:
+	    if withprob(0.01):
+		prout(_(&quot;Sulu-  \&quot;Sir, the high-speed shield control has malfunctioned . . .&quot;))
+		prouts(_(&quot;         CLICK   CLICK   POP  . . .&quot;))
+		prout(_(&quot; No response, sir!&quot;))
+		game.shldup = False
+	    else:
+		prout(_(&quot;Shields raised.&quot;))
+	else:
+	    game.shldup = False
+    overheat(rpow);
+
+# Code from events,c begins here.
+
+# This isn't a real event queue a la BSD Trek yet -- you can only have one 
+# event of each type active at any given time.  Mostly these means we can 
+# only have one FDISTR/FENSLV/FREPRO sequence going at any given time
+# BSD Trek, from which we swiped the idea, can have up to 5.
+
+def unschedule(evtype):
+    &quot;Remove an event from the schedule.&quot;
+    game.future[evtype].date = FOREVER
+    return game.future[evtype]
+
+def is_scheduled(evtype):
+    &quot;Is an event of specified type scheduled.&quot;
+    return game.future[evtype].date != FOREVER
+
+def scheduled(evtype):
+    &quot;When will this event happen?&quot;
+    return game.future[evtype].date
+
+def schedule(evtype, offset):
+    &quot;Schedule an event of specified type.&quot;
+    game.future[evtype].date = game.state.date + offset
+    return game.future[evtype]
+
+def postpone(evtype, offset):
+    &quot;Postpone a scheduled event.&quot;
+    game.future[evtype].date += offset
+
+def cancelrest():
+    &quot;Rest period is interrupted by event.&quot;
+    if game.resting:
+	skip(1)
+	proutn(_(&quot;Mr. Spock-  \&quot;Captain, shall we cancel the rest period?\&quot;&quot;))
+	if ja() == True:
+	    game.resting = False
+	    game.optime = 0.0
+	    return True
+    return False
+
+def events():
+    &quot;Run through the event queue looking for things to do.&quot;
+    i=0
+    fintim = game.state.date + game.optime; yank=0
+    ictbeam = False; istract = False
+    w = coord(); hold = coord()
+    ev = event(); ev2 = event()
+
+    def tractorbeam(yank):
+        &quot;Tractor-beaming cases merge here.&quot; 
+        announce()
+        game.optime = (10.0/(7.5*7.5))*yank # 7.5 is yank rate (warp 7.5) 
+        skip(1)
+        prout(&quot;***&quot; + crmshp() + _(&quot; caught in long range tractor beam--&quot;))
+        # If Kirk &amp; Co. screwing around on planet, handle 
+        atover(True) # atover(true) is Grab 
+        if game.alldone:
+            return
+        if game.icraft: # Caught in Galileo? 
+            finish(FSTRACTOR)
+            return
+        # Check to see if shuttle is aboard 
+        if game.iscraft == &quot;offship&quot;:
+            skip(1)
+            if withprob(0.5):
+                prout(_(&quot;Galileo, left on the planet surface, is captured&quot;))
+                prout(_(&quot;by aliens and made into a flying McDonald's.&quot;))
+                game.damage[DSHUTTL] = -10
+                game.iscraft = &quot;removed&quot;
+            else:
+                prout(_(&quot;Galileo, left on the planet surface, is well hidden.&quot;))
+        if evcode == FSPY:
+            game.quadrant = game.state.kscmdr
+        else:
+            game.quadrant = game.state.kcmdr[i]
+        game.sector = randplace(QUADSIZE)
+        prout(crmshp() + _(&quot; is pulled to Quadrant %s, Sector %s&quot;) \
+               % (game.quadrant, game.sector))
+        if game.resting:
+            prout(_(&quot;(Remainder of rest/repair period cancelled.)&quot;))
+            game.resting = False
+        if not game.shldup:
+            if not damaged(DSHIELD) and game.shield &gt; 0:
+                doshield(shraise=True) # raise shields 
+                game.shldchg = False
+            else:
+                prout(_(&quot;(Shields not currently useable.)&quot;))
+        newqad()
+        # Adjust finish time to time of tractor beaming 
+        fintim = game.state.date+game.optime
+        attack(torps_ok=False)
+        if not game.state.kcmdr:
+            unschedule(FTBEAM)
+        else: 
+            schedule(FTBEAM, game.optime+expran(1.5*game.intime/len(game.state.kcmdr)))
+
+    def destroybase():
+        &quot;Code merges here for any commander destroying a starbase.&quot; 
+        # Not perfect, but will have to do 
+        # Handle case where base is in same quadrant as starship 
+        if game.battle == game.quadrant:
+            game.state.chart[game.battle.i][game.battle.j].starbase = False
+            game.quad[game.base.i][game.base.j] = '.'
+            game.base.invalidate()
+            newcnd()
+            skip(1)
+            prout(_(&quot;Spock-  \&quot;Captain, I believe the starbase has been destroyed.\&quot;&quot;))
+        elif game.state.baseq and communicating():
+            # Get word via subspace radio 
+            announce()
+            skip(1)
+            prout(_(&quot;Lt. Uhura-  \&quot;Captain, Starfleet Command reports that&quot;))
+            proutn(_(&quot;   the starbase in Quadrant %s has been destroyed by&quot;) % game.battle)
+            if game.isatb == 2: 
+                prout(_(&quot;the Klingon Super-Commander&quot;))
+            else:
+                prout(_(&quot;a Klingon Commander&quot;))
+            game.state.chart[game.battle.i][game.battle.j].starbase = False
+        # Remove Starbase from galaxy 
+        game.state.galaxy[game.battle.i][game.battle.j].starbase = False
+        game.state.baseq = filter(lambda x: x != game.battle, game.state.baseq)
+        if game.isatb == 2:
+            # reinstate a commander's base attack 
+            game.battle = hold
+            game.isatb = 0
+        else:
+            game.battle.invalidate()
+    if idebug:
+	prout(&quot;=== EVENTS from %.2f to %.2f:&quot; % (game.state.date, fintim))
+	for i in range(1, NEVENTS):
+	    if   i == FSNOVA:  proutn(&quot;=== Supernova       &quot;)
+	    elif i == FTBEAM:  proutn(&quot;=== T Beam          &quot;)
+	    elif i == FSNAP:   proutn(&quot;=== Snapshot        &quot;)
+	    elif i == FBATTAK: proutn(&quot;=== Base Attack     &quot;)
+	    elif i == FCDBAS:  proutn(&quot;=== Base Destroy    &quot;)
+	    elif i == FSCMOVE: proutn(&quot;=== SC Move         &quot;)
+	    elif i == FSCDBAS: proutn(&quot;=== SC Base Destroy &quot;)
+	    elif i == FDSPROB: proutn(&quot;=== Probe Move      &quot;)
+	    elif i == FDISTR:  proutn(&quot;=== Distress Call   &quot;)
+	    elif i == FENSLV:  proutn(&quot;=== Enslavement     &quot;)
+	    elif i == FREPRO:  proutn(&quot;=== Klingon Build   &quot;)
+	    if is_scheduled(i):
+		prout(&quot;%.2f&quot; % (scheduled(i)))
+	    else:
+		prout(&quot;never&quot;)
+    radio_was_broken = damaged(DRADIO)
+    hold.i = hold.j = 0
+    while True:
+	# Select earliest extraneous event, evcode==0 if no events 
+	evcode = FSPY
+	if game.alldone:
+	    return
+	datemin = fintim
+	for l in range(1, NEVENTS):
+	    if game.future[l].date &lt; datemin:
+		evcode = l
+		if idebug:
+		    prout(&quot;== Event %d fires&quot; % evcode)
+		datemin = game.future[l].date
+	xtime = datemin-game.state.date
+	game.state.date = datemin
+	# Decrement Federation resources and recompute remaining time 
+	game.state.remres -= (game.state.remkl+4*len(game.state.kcmdr))*xtime
+        game.recompute()
+	if game.state.remtime &lt;=0:
+	    finish(FDEPLETE)
+	    return
+	# Any crew left alive? 
+	if game.state.crew &lt;=0:
+	    finish(FCREW)
+	    return
+	# Is life support adequate? 
+	if damaged(DLIFSUP) and game.condition != &quot;docked&quot;:
+	    if game.lsupres &lt; xtime and game.damage[DLIFSUP] &gt; game.lsupres:
+		finish(FLIFESUP)
+		return
+	    game.lsupres -= xtime
+	    if game.damage[DLIFSUP] &lt;= xtime:
+		game.lsupres = game.inlsr
+	# Fix devices 
+	repair = xtime
+	if game.condition == &quot;docked&quot;:
+	    repair /= DOCKFAC
+	# Don't fix Deathray here 
+	for l in range(NDEVICES):
+	    if game.damage[l] &gt; 0.0 and l != DDRAY:
+                if game.damage[l]-repair &gt; 0.0:
+                    game.damage[l] -= repair
+                else:
+                    game.damage[l] = 0.0
+	# If radio repaired, update star chart and attack reports 
+	if radio_was_broken and not damaged(DRADIO):
+	    prout(_(&quot;Lt. Uhura- \&quot;Captain, the sub-space radio is working and&quot;))
+	    prout(_(&quot;   surveillance reports are coming in.&quot;))
+	    skip(1)
+	    if not game.iseenit:
+		attackreport(False)
+		game.iseenit = True
+	    rechart()
+	    prout(_(&quot;   The star chart is now up to date.\&quot;&quot;))
+	    skip(1)
+	# Cause extraneous event EVCODE to occur 
+	game.optime -= xtime
+	if evcode == FSNOVA: # Supernova 
+	    announce()
+	    supernova(None)
+	    schedule(FSNOVA, expran(0.5*game.intime))
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		return
+	elif evcode == FSPY: # Check with spy to see if SC should tractor beam 
+	    if game.state.nscrem == 0 or \
+		ictbeam or istract or \
+                game.condition==&quot;docked&quot; or game.isatb==1 or game.iscate:
+		return
+	    if game.ientesc or \
+		(game.energy&lt;2000 and game.torps&lt;4 and game.shield &lt; 1250) or \
+		(damaged(DPHASER) and (damaged(DPHOTON) or game.torps&lt;4)) or \
+		(damaged(DSHIELD) and \
+		 (game.energy &lt; 2500 or damaged(DPHASER)) and \
+                 (game.torps &lt; 5 or damaged(DPHOTON))):
+		# Tractor-beam her! 
+		istract = ictbeam = True
+                tractorbeam((game.state.kscmdr-game.quadrant).distance())
+	    else:
+		return
+	elif evcode == FTBEAM: # Tractor beam 
+            if not game.state.kcmdr:
+                unschedule(FTBEAM)
+                continue
+            i = randrange(len(game.state.kcmdr))
+            yank = (game.state.kcmdr[i]-game.quadrant).distance()
+            if istract or game.condition == &quot;docked&quot; or yank == 0:
+                # Drats! Have to reschedule 
+                schedule(FTBEAM, 
+                         game.optime + expran(1.5*game.intime/len(game.state.kcmdr)))
+                continue
+            ictbeam = True
+            tractorbeam(yank)
+	elif evcode == FSNAP: # Snapshot of the universe (for time warp) 
+	    game.snapsht = copy.deepcopy(game.state)
+	    game.state.snap = True
+	    schedule(FSNAP, expran(0.5 * game.intime))
+	elif evcode == FBATTAK: # Commander attacks starbase 
+	    if not game.state.kcmdr or not game.state.baseq:
+		# no can do 
+		unschedule(FBATTAK)
+		unschedule(FCDBAS)
+                continue
+            try:
+                for ibq in game.state.baseq:
+                   for cmdr in game.state.kcmdr: 
+                       if ibq == cmdr and ibq != game.quadrant and ibq != game.state.kscmdr:
+                           raise ibq
+                else:
+                    # no match found -- try later 
+                    schedule(FBATTAK, expran(0.3*game.intime))
+                    unschedule(FCDBAS)
+                    continue
+            except coord:
+                pass
+	    # commander + starbase combination found -- launch attack 
+	    game.battle = ibq
+	    schedule(FCDBAS, randreal(1.0, 4.0))
+	    if game.isatb: # extra time if SC already attacking 
+		postpone(FCDBAS, scheduled(FSCDBAS)-game.state.date)
+	    game.future[FBATTAK].date = game.future[FCDBAS].date + expran(0.3*game.intime)
+	    game.iseenit = False
+            if not communicating():
+		continue # No warning :-( 
+	    game.iseenit = True
+	    announce()
+	    skip(1)
+	    prout(_(&quot;Lt. Uhura-  \&quot;Captain, the starbase in Quadrant %s&quot;) % game.battle)
+	    prout(_(&quot;   reports that it is under attack and that it can&quot;))
+	    prout(_(&quot;   hold out only until stardate %d.\&quot;&quot;) % (int(scheduled(FCDBAS))))
+	    if cancelrest():
+                return
+	elif evcode == FSCDBAS: # Supercommander destroys base 
+	    unschedule(FSCDBAS)
+	    game.isatb = 2
+	    if not game.state.galaxy[game.state.kscmdr.i][game.state.kscmdr.j].starbase: 
+		continue # WAS RETURN! 
+	    hold = game.battle
+	    game.battle = game.state.kscmdr
+	    destroybase()
+	elif evcode == FCDBAS: # Commander succeeds in destroying base 
+	    if evcode==FCDBAS:
+		unschedule(FCDBAS)
+                if not game.state.baseq() \
+                       or not game.state.galaxy[game.battle.i][game.battle.j].starbase:
+		    game.battle.invalidate()
+                    continue
+		# find the lucky pair 
+		for cmdr in game.state.kcmdr:
+		    if cmdr == game.battle: 
+			break
+                else:
+		    # No action to take after all 
+		    continue
+            destroybase()
+	elif evcode == FSCMOVE: # Supercommander moves 
+	    schedule(FSCMOVE, 0.2777)
+	    if not game.ientesc and not istract and game.isatb != 1 and \
+                   (not game.iscate or not game.justin): 
+		supercommander()
+	elif evcode == FDSPROB: # Move deep space probe 
+	    schedule(FDSPROB, 0.01)
+            if not game.probe.next():
+		if not game.probe.quadrant().valid_quadrant() or \
+		    game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j].supernova:
+		    # Left galaxy or ran into supernova
+                    if communicating():
+			announce()
+			skip(1)
+			proutn(_(&quot;Lt. Uhura-  \&quot;The deep space probe &quot;))
+			if not game.probe.quadrant().valid_quadrant():
+			    prout(_(&quot;has left the galaxy.\&quot;&quot;))
+			else:
+			    prout(_(&quot;is no longer transmitting.\&quot;&quot;))
+		    unschedule(FDSPROB)
+		    continue
+                if communicating():
+		    #announce()
+		    skip(1)
+		    prout(_(&quot;Lt. Uhura-  \&quot;The deep space probe is now in Quadrant %s.\&quot;&quot;) % game.probe.quadrant())
+	    pdest = game.state.galaxy[game.probe.quadrant().i][game.probe.quadrant().j]
+	    if communicating():
+		chp = game.state.chart[game.probe.quadrant().i][game.probe.quadrant().j]
+		chp.klingons = pdest.klingons
+		chp.starbase = pdest.starbase
+		chp.stars = pdest.stars
+		pdest.charted = True
+	    game.probe.moves -= 1 # One less to travel
+	    if game.probe.arrived() and game.isarmed and pdest.stars:
+		supernova(game.probe)		# fire in the hole!
+		unschedule(FDSPROB)
+		if game.state.galaxy[game.quadrant().i][game.quadrant().j].supernova: 
+		    return
+	elif evcode == FDISTR: # inhabited system issues distress call 
+	    unschedule(FDISTR)
+	    # try a whole bunch of times to find something suitable 
+            for i in range(100):
+		# need a quadrant which is not the current one,
+		# which has some stars which are inhabited and
+		# not already under attack, which is not
+		# supernova'ed, and which has some Klingons in it
+		w = randplace(GALSIZE)
+		q = game.state.galaxy[w.i][w.j]
+                if not (game.quadrant == w or q.planet == None or \
+		      not q.planet.inhabited or \
+		      q.supernova or q.status!=&quot;secure&quot; or q.klingons&lt;=0):
+                    break
+            else:
+		# can't seem to find one; ignore this call 
+		if idebug:
+		    prout(&quot;=== Couldn't find location for distress event.&quot;)
+		continue
+	    # got one!!  Schedule its enslavement 
+	    ev = schedule(FENSLV, expran(game.intime))
+	    ev.quadrant = w
+	    q.status = &quot;distressed&quot;
+	    # tell the captain about it if we can 
+	    if communicating():
+		prout(_(&quot;Uhura- Captain, %s in Quadrant %s reports it is under attack&quot;) \
+                        % (q.planet, `w`))
+		prout(_(&quot;by a Klingon invasion fleet.&quot;))
+		if cancelrest():
+		    return
+	elif evcode == FENSLV:		# starsystem is enslaved 
+	    ev = unschedule(FENSLV)
+	    # see if current distress call still active 
+	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
+	    if q.klingons &lt;= 0:
+		q.status = &quot;secure&quot;
+		continue
+	    q.status = &quot;enslaved&quot;
+
+	    # play stork and schedule the first baby 
+	    ev2 = schedule(FREPRO, expran(2.0 * game.intime))
+	    ev2.quadrant = ev.quadrant
+
+	    # report the disaster if we can 
+	    if communicating():
+		prout(_(&quot;Uhura- We've lost contact with starsystem %s&quot;) % \
+                        q.planet)
+		prout(_(&quot;in Quadrant %s.\n&quot;) % ev.quadrant)
+	elif evcode == FREPRO:		# Klingon reproduces 
+	    # If we ever switch to a real event queue, we'll need to
+	    # explicitly retrieve and restore the x and y.
+	    ev = schedule(FREPRO, expran(1.0 * game.intime))
+	    # see if current distress call still active 
+	    q = game.state.galaxy[ev.quadrant.i][ev.quadrant.j]
+	    if q.klingons &lt;= 0:
+		q.status = &quot;secure&quot;
+		continue
+	    if game.state.remkl &gt;=MAXKLGAME:
+		continue		# full right now 
+	    # reproduce one Klingon 
+	    w = ev.quadrant
+            m = coord()
+	    if game.klhere &gt;= MAXKLQUAD:
+                try:
+                    # this quadrant not ok, pick an adjacent one 
+                    for m.i in range(w.i - 1, w.i + 2):
+                        for m.j in range(w.j - 1, w.j + 2):
+                            if not m.valid_quadrant():
+                                continue
+                            q = game.state.galaxy[m.i][m.j]
+                            # check for this quad ok (not full &amp; no snova) 
+                            if q.klingons &gt;= MAXKLQUAD or q.supernova:
+                                continue
+                            raise &quot;FOUNDIT&quot;
+                    else:
+                        continue	# search for eligible quadrant failed
+                except &quot;FOUNDIT&quot;:
+                    w = m
+	    # deliver the child 
+	    game.state.remkl += 1
+	    q.klingons += 1
+	    if game.quadrant == w:
+                game.klhere += 1
+		game.enemies.append(newkling())
+	    # recompute time left
+            game.recompute()
+	    if communicating():
+		if game.quadrant == w:
+		    prout(_(&quot;Spock- sensors indicate the Klingons have&quot;))
+		    prout(_(&quot;launched a warship from %s.&quot;) % q.planet)
+		else:
+		    prout(_(&quot;Uhura- Starfleet reports increased Klingon activity&quot;))
+		    if q.planet != None:
+			proutn(_(&quot;near %s &quot;) % q.planet)
+		    prout(_(&quot;in Quadrant %s.&quot;) % w)
+				
+def wait():
+    &quot;Wait on events.&quot;
+    game.ididit = False
+    while True:
+	key = scanner.next()
+	if key  != &quot;IHEOL&quot;:
+	    break
+	proutn(_(&quot;How long? &quot;))
+    scanner.chew()
+    if key != &quot;IHREAL&quot;:
+	huh()
+	return
+    origTime = delay = scanner.real
+    if delay &lt;= 0.0:
+	return
+    if delay &gt;= game.state.remtime or len(game.enemies) != 0:
+	proutn(_(&quot;Are you sure? &quot;))
+	if ja() == False:
+	    return
+    # Alternate resting periods (events) with attacks 
+    game.resting = True
+    while True:
+	if delay &lt;= 0:
+	    game.resting = False
+	if not game.resting:
+	    prout(_(&quot;%d stardates left.&quot;) % int(game.state.remtime))
+	    return
+	temp = game.optime = delay
+	if len(game.enemies):
+	    rtime = randreal(1.0, 2.0)
+	    if rtime &lt; temp:
+		temp = rtime
+	    game.optime = temp
+	if game.optime &lt; delay:
+	    attack(torps_ok=False)
+	if game.alldone:
+	    return
+	events()
+	game.ididit = True
+	if game.alldone:
+	    return
+	delay -= temp
+	# Repair Deathray if long rest at starbase 
+	if origTime-delay &gt;= 9.99 and game.condition == &quot;docked&quot;:
+	    game.damage[DDRAY] = 0.0
+	# leave if quadrant supernovas
+        if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            break
+    game.resting = False
+    game.optime = 0
+
+def nova(nov):
+    &quot;Star goes nova.&quot; 
+    course = (0.0, 10.5, 12.0, 1.5, 9.0, 0.0, 3.0, 7.5, 6.0, 4.5)
+    newc = coord(); neighbor = coord(); bump = coord(0, 0)
+    if withprob(0.05):
+	# Wow! We've supernova'ed 
+	supernova(game.quadrant)
+	return
+    # handle initial nova 
+    game.quad[nov.i][nov.j] = '.'
+    prout(crmena(False, '*', &quot;sector&quot;, nov) + _(&quot; novas.&quot;))
+    game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
+    game.state.starkl += 1
+    # Set up queue to recursively trigger adjacent stars 
+    hits = [nov]
+    kount = 0
+    while hits:
+        offset = coord()
+        start = hits.pop()
+        for offset.i in range(-1, 1+1):
+            for offset.j in range(-1, 1+1):
+                if offset.j==0 and offset.i==0:
+                    continue
+                neighbor = start + offset
+                if not neighbor.valid_sector():
+                    continue
+                iquad = game.quad[neighbor.i][neighbor.j]
+                # Empty space ends reaction
+                if iquad in ('.', '?', ' ', 'T', '#'):
+                    pass
+                elif iquad == '*': # Affect another star 
+                    if withprob(0.05):
+                        # This star supernovas 
+                        supernova(game.quadrant)
+                        return
+                    else:
+                        hits.append(neighbor)
+			game.state.galaxy[game.quadrant.i][game.quadrant.j].stars -= 1
+			game.state.starkl += 1
+			proutn(crmena(True, '*', &quot;sector&quot;, neighbor))
+			prout(_(&quot; novas.&quot;))
+                        game.quad[neighbor.i][neighbor.j] = '.'
+                        kount += 1
+                elif iquad in ('P', '@'): # Destroy planet 
+                    game.state.galaxy[game.quadrant.i][game.quadrant.j].planet = None
+                    if iquad == 'P':
+                        game.state.nplankl += 1
+                    else:
+                        game.state.worldkl += 1
+                    prout(crmena(True, 'B', &quot;sector&quot;, neighbor) + _(&quot; destroyed.&quot;))
+                    game.iplnet.pclass = &quot;destroyed&quot;
+                    game.iplnet = None
+                    game.plnet.invalidate()
+                    if game.landed:
+                        finish(FPNOVA)
+                        return
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                elif iquad == 'B': # Destroy base 
+                    game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase = False
+                    game.state.baseq = filter(lambda x: x!= game.quadrant, game.state.baseq)
+                    game.base.invalidate()
+                    game.state.basekl += 1
+                    newcnd()
+                    prout(crmena(True, 'B', &quot;sector&quot;, neighbor) + _(&quot; destroyed.&quot;))
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                elif iquad in ('E', 'F'): # Buffet ship 
+                    prout(_(&quot;***Starship buffeted by nova.&quot;))
+                    if game.shldup:
+                        if game.shield &gt;= 2000.0:
+                            game.shield -= 2000.0
+                        else:
+                            diff = 2000.0 - game.shield
+                            game.energy -= diff
+                            game.shield = 0.0
+                            game.shldup = False
+                            prout(_(&quot;***Shields knocked out.&quot;))
+                            game.damage[DSHIELD] += 0.005*game.damfac*randreal()*diff
+                    else:
+                        game.energy -= 2000.0
+                    if game.energy &lt;= 0:
+                        finish(FNOVA)
+                        return
+                    # add in course nova contributes to kicking starship
+                    bump += (game.sector-hits[mm]).sgn()
+                elif iquad == 'K': # kill klingon 
+                    deadkl(neighbor, iquad, neighbor)
+                elif iquad in ('C','S','R'): # Damage/destroy big enemies 
+                    for ll in range(len(game.enemies)):
+                        if game.enemies[ll].location == neighbor:
+                            break
+                    game.enemies[ll].power -= 800.0 # If firepower is lost, die 
+                    if game.enemies[ll].power &lt;= 0.0:
+                        deadkl(neighbor, iquad, neighbor)
+                        break
+                    newc = neighbor + neighbor - hits[mm]
+                    proutn(crmena(True, iquad, &quot;sector&quot;, neighbor) + _(&quot; damaged&quot;))
+                    if not newc.valid_sector():
+                        # can't leave quadrant 
+                        skip(1)
+                        break
+                    iquad1 = game.quad[newc.i][newc.j]
+                    if iquad1 == ' ':
+                        proutn(_(&quot;, blasted into &quot;) + crmena(False, ' ', &quot;sector&quot;, newc))
+                        skip(1)
+                        deadkl(neighbor, iquad, newc)
+                        break
+                    if iquad1 != '.':
+                        # can't move into something else 
+                        skip(1)
+                        break
+                    proutn(_(&quot;, buffeted to Sector %s&quot;) % newc)
+                    game.quad[neighbor.i][neighbor.j] = '.'
+                    game.quad[newc.i][newc.j] = iquad
+                    game.enemies[ll].move(newc)
+    # Starship affected by nova -- kick it away. 
+    dist = kount*0.1
+    direc = course[3*(bump.i+1)+bump.j+2]
+    if direc == 0.0:
+	dist = 0.0
+    if dist == 0.0:
+	return
+    course = course(bearing=direc, distance=dist)
+    game.optime = course.time(warp=4)
+    skip(1)
+    prout(_(&quot;Force of nova displaces starship.&quot;))
+    imove(course, noattack=True)
+    game.optime = course.time(warp=4)
+    return
+	
+def supernova(w):
+    &quot;Star goes supernova.&quot;
+    num = 0; npdead = 0
+    if w != None: 
+	nq = copy.copy(w)
+    else:
+	# Scheduled supernova -- select star at random. 
+	stars = 0
+        nq = coord()
+	for nq.i in range(GALSIZE):
+	    for nq.j in range(GALSIZE):
+		stars += game.state.galaxy[nq.i][nq.j].stars
+	if stars == 0:
+	    return # nothing to supernova exists 
+	num = randrange(stars) + 1
+	for nq.i in range(GALSIZE):
+	    for nq.j in range(GALSIZE):
+		num -= game.state.galaxy[nq.i][nq.j].stars
+		if num &lt;= 0:
+		    break
+	    if num &lt;=0:
+		break
+	if idebug:
+	    proutn(&quot;=== Super nova here?&quot;)
+	    if ja() == True:
+		nq = game.quadrant
+    if not nq == game.quadrant or game.justin:
+	# it isn't here, or we just entered (treat as enroute) 
+	if communicating():
+	    skip(1)
+	    prout(_(&quot;Message from Starfleet Command       Stardate %.2f&quot;) % game.state.date)
+	    prout(_(&quot;     Supernova in Quadrant %s; caution advised.&quot;) % nq)
+    else:
+	ns = coord()
+	# we are in the quadrant! 
+	num = randrange(game.state.galaxy[nq.i][nq.j].stars) + 1
+	for ns.i in range(QUADSIZE):
+	    for ns.j in range(QUADSIZE):
+		if game.quad[ns.i][ns.j]=='*':
+		    num -= 1
+		    if num==0:
+			break
+	    if num==0:
+		break
+	skip(1)
+	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+	skip(1)
+	prout(_(&quot;***Incipient supernova detected at Sector %s&quot;) % ns)
+	if (ns.i-game.sector.i)**2 + (ns.j-game.sector.j)**2 &lt;= 2.1:
+	    proutn(_(&quot;Emergency override attempts t&quot;))
+	    prouts(&quot;***************&quot;)
+	    skip(1)
+	    stars()
+	    game.alldone = True
+    # destroy any Klingons in supernovaed quadrant
+    kldead = game.state.galaxy[nq.i][nq.j].klingons
+    game.state.galaxy[nq.i][nq.j].klingons = 0
+    if nq == game.state.kscmdr:
+	# did in the Supercommander! 
+	game.state.nscrem = game.state.kscmdr.i = game.state.kscmdr.j = game.isatb =  0
+	game.iscate = False
+	unschedule(FSCMOVE)
+	unschedule(FSCDBAS)
+    survivors = filter(lambda w: w != nq, game.state.kcmdr)
+    comkills = len(game.state.kcmdr) - len(survivors)
+    game.state.kcmdr = survivors
+    kldead -= comkills
+    if not game.state.kcmdr:
+        unschedule(FTBEAM)
+    game.state.remkl -= kldead
+    # destroy Romulans and planets in supernovaed quadrant 
+    nrmdead = game.state.galaxy[nq.i][nq.j].romulans
+    game.state.galaxy[nq.i][nq.j].romulans = 0
+    game.state.nromrem -= nrmdead
+    # Destroy planets 
+    for loop in range(game.inplan):
+	if game.state.planets[loop].quadrant == nq:
+	    game.state.planets[loop].pclass = &quot;destroyed&quot;
+	    npdead += 1
+    # Destroy any base in supernovaed quadrant
+    game.state.baseq = filter(lambda x: x != nq, game.state.baseq)
+    # If starship caused supernova, tally up destruction 
+    if w != None:
+	game.state.starkl += game.state.galaxy[nq.i][nq.j].stars
+	game.state.basekl += game.state.galaxy[nq.i][nq.j].starbase
+	game.state.nplankl += npdead
+    # mark supernova in galaxy and in star chart 
+    if game.quadrant == nq or communicating():
+	game.state.galaxy[nq.i][nq.j].supernova = True
+    # If supernova destroys last Klingons give special message 
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0 and not nq == game.quadrant:
+	skip(2)
+	if w == None:
+	    prout(_(&quot;Lucky you!&quot;))
+	proutn(_(&quot;A supernova in %s has just destroyed the last Klingons.&quot;) % nq)
+	finish(FWON)
+	return
+    # if some Klingons remain, continue or die in supernova 
+    if game.alldone:
+	finish(FSNOVAED)
+    return
+
+# Code from finish.c ends here.
+
+def selfdestruct():
+    &quot;Self-destruct maneuver. Finish with a BANG!&quot; 
+    scanner.chew()
+    if damaged(DCOMPTR):
+	prout(_(&quot;Computer damaged; cannot execute destruct sequence.&quot;))
+	return
+    prouts(_(&quot;---WORKING---&quot;)); skip(1)
+    prouts(_(&quot;SELF-DESTRUCT-SEQUENCE-ACTIVATED&quot;)); skip(1)
+    prouts(&quot;   10&quot;); skip(1)
+    prouts(&quot;       9&quot;); skip(1)
+    prouts(&quot;          8&quot;); skip(1)
+    prouts(&quot;             7&quot;); skip(1)
+    prouts(&quot;                6&quot;); skip(1)
+    skip(1)
+    prout(_(&quot;ENTER-CORRECT-PASSWORD-TO-CONTINUE-&quot;))
+    skip(1)
+    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-OTHERWISE-&quot;))
+    skip(1)
+    prout(_(&quot;SELF-DESTRUCT-SEQUENCE-WILL-BE-ABORTED&quot;))
+    skip(1)
+    scanner.next()
+    scanner.chew()
+    if game.passwd != scanner.token:
+	prouts(_(&quot;PASSWORD-REJECTED;&quot;))
+	skip(1)
+	prouts(_(&quot;CONTINUITY-EFFECTED&quot;))
+	skip(2)
+	return
+    prouts(_(&quot;PASSWORD-ACCEPTED&quot;)); skip(1)
+    prouts(&quot;                   5&quot;); skip(1)
+    prouts(&quot;                      4&quot;); skip(1)
+    prouts(&quot;                         3&quot;); skip(1)
+    prouts(&quot;                            2&quot;); skip(1)
+    prouts(&quot;                              1&quot;); skip(1)
+    if withprob(0.15):
+	prouts(_(&quot;GOODBYE-CRUEL-WORLD&quot;))
+	skip(1)
+    kaboom()
+
+def kaboom():
+    stars()
+    if game.ship=='E':
+	prouts(&quot;***&quot;)
+    prouts(_(&quot;********* Entropy of %s maximized *********&quot;) % crmshp())
+    skip(1)
+    stars()
+    skip(1)
+    if len(game.enemies) != 0:
+	whammo = 25.0 * game.energy
+	l=1
+	while l &lt;= len(game.enemies):
+	    if game.enemies[l].power*game.enemies[l].kdist &lt;= whammo: 
+		deadkl(game.enemies[l].location, game.quad[game.enemies[l].location.i][game.enemies[l].location.j], game.enemies[l].location)
+	    l += 1
+    finish(FDILITHIUM)
+				
+def killrate():
+    &quot;Compute our rate of kils over time.&quot;
+    elapsed = game.state.date - game.indate
+    if elapsed == 0:	# Avoid divide-by-zero error if calculated on turn 0
+        return 0
+    else:
+        starting = (game.inkling + game.incom + game.inscom)
+        remaining = (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)
+        return (starting - remaining)/elapsed
+
+def badpoints():
+    &quot;Compute demerits.&quot;
+    badpt = 5.0*game.state.starkl + \
+            game.casual + \
+            10.0*game.state.nplankl + \
+            300*game.state.nworldkl + \
+            45.0*game.nhelp +\
+            100.0*game.state.basekl +\
+            3.0*game.abandoned
+    if game.ship == 'F':
+        badpt += 100.0
+    elif game.ship == None:
+        badpt += 200.0
+    return badpt
+
+def finish(ifin):
+    # end the game, with appropriate notfications 
+    igotit = False
+    game.alldone = True
+    skip(3)
+    prout(_(&quot;It is stardate %.1f.&quot;) % game.state.date)
+    skip(1)
+    if ifin == FWON: # Game has been won
+	if game.state.nromrem != 0:
+	    prout(_(&quot;The remaining %d Romulans surrender to Starfleet Command.&quot;) %
+		  game.state.nromrem)
+
+	prout(_(&quot;You have smashed the Klingon invasion fleet and saved&quot;))
+	prout(_(&quot;the Federation.&quot;))
+	game.gamewon = True
+	if game.alive:
+            badpt = badpoints()
+            if badpt &lt; 100.0:
+                badpt = 0.0	# Close enough!
+            # killsPerDate &gt;= RateMax
+	    if game.state.date-game.indate &lt; 5.0 or \
+                killrate() &gt;= 0.1*game.skill*(game.skill+1.0) + 0.1 + 0.008*badpt:
+		skip(1)
+		prout(_(&quot;In fact, you have done so well that Starfleet Command&quot;))
+		if game.skill == SKILL_NOVICE:
+		    prout(_(&quot;promotes you one step in rank from \&quot;Novice\&quot; to \&quot;Fair\&quot;.&quot;))
+		elif game.skill == SKILL_FAIR:
+		    prout(_(&quot;promotes you one step in rank from \&quot;Fair\&quot; to \&quot;Good\&quot;.&quot;))
+		elif game.skill == SKILL_GOOD:
+		    prout(_(&quot;promotes you one step in rank from \&quot;Good\&quot; to \&quot;Expert\&quot;.&quot;))
+		elif game.skill == SKILL_EXPERT:
+		    prout(_(&quot;promotes you to Commodore Emeritus.&quot;))
+		    skip(1)
+		    prout(_(&quot;Now that you think you're really good, try playing&quot;))
+		    prout(_(&quot;the \&quot;Emeritus\&quot; game. It will splatter your ego.&quot;))
+		elif game.skill == SKILL_EMERITUS:
+		    skip(1)
+		    proutn(_(&quot;Computer-  &quot;))
+		    prouts(_(&quot;ERROR-ERROR-ERROR-ERROR&quot;))
+		    skip(2)
+		    prouts(_(&quot;  YOUR-SKILL-HAS-EXCEEDED-THE-CAPACITY-OF-THIS-PROGRAM&quot;))
+		    skip(1)
+		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
+		    skip(1)
+		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
+		    skip(1)
+		    prouts(_(&quot;  THIS-PROGRAM-MUST-SURVIVE&quot;))
+		    skip(1)
+		    prouts(_(&quot;  THIS-PROGRAM-MUST?- MUST ? - SUR? ? -?  VI&quot;))
+		    skip(2)
+		    prout(_(&quot;Now you can retire and write your own Star Trek game!&quot;))
+		    skip(1)
+		elif game.skill &gt;= SKILL_EXPERT:
+		    if game.thawed and not idebug:
+			prout(_(&quot;You cannot get a citation, so...&quot;))
+		    else:
+			proutn(_(&quot;Do you want your Commodore Emeritus Citation printed? &quot;))
+			scanner.chew()
+			if ja() == True:
+			    igotit = True
+	    # Only grant long life if alive (original didn't!)
+	    skip(1)
+	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
+	score()
+	if igotit:
+	    plaque()	    
+	return
+    elif ifin == FDEPLETE: # Federation Resources Depleted
+	prout(_(&quot;Your time has run out and the Federation has been&quot;))
+	prout(_(&quot;conquered.  Your starship is now Klingon property,&quot;))
+	prout(_(&quot;and you are put on trial as a war criminal.  On the&quot;))
+	proutn(_(&quot;basis of your record, you are &quot;))
+	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)*3.0 &gt; (game.inkling + game.incom + game.inscom):
+	    prout(_(&quot;acquitted.&quot;))
+	    skip(1)
+	    prout(_(&quot;LIVE LONG AND PROSPER.&quot;))
+	else:
+	    prout(_(&quot;found guilty and&quot;))
+	    prout(_(&quot;sentenced to death by slow torture.&quot;))
+	    game.alive = False
+	score()
+	return
+    elif ifin == FLIFESUP:
+	prout(_(&quot;Your life support reserves have run out, and&quot;))
+	prout(_(&quot;you die of thirst, starvation, and asphyxiation.&quot;))
+	prout(_(&quot;Your starship is a derelict in space.&quot;))
+    elif ifin == FNRG:
+	prout(_(&quot;Your energy supply is exhausted.&quot;))
+	skip(1)
+	prout(_(&quot;Your starship is a derelict in space.&quot;))
+    elif ifin == FBATTLE:
+	prout(_(&quot;The %s has been destroyed in battle.&quot;) % crmshp())
+	skip(1)
+	prout(_(&quot;Dulce et decorum est pro patria mori.&quot;))
+    elif ifin == FNEG3:
+	prout(_(&quot;You have made three attempts to cross the negative energy&quot;))
+	prout(_(&quot;barrier which surrounds the galaxy.&quot;))
+	skip(1)
+	prout(_(&quot;Your navigation is abominable.&quot;))
+	score()
+    elif ifin == FNOVA:
+	prout(_(&quot;Your starship has been destroyed by a nova.&quot;))
+	prout(_(&quot;That was a great shot.&quot;))
+	skip(1)
+    elif ifin == FSNOVAED:
+	prout(_(&quot;The %s has been fried by a supernova.&quot;) % crmshp())
+	prout(_(&quot;...Not even cinders remain...&quot;))
+    elif ifin == FABANDN:
+	prout(_(&quot;You have been captured by the Klingons. If you still&quot;))
+	prout(_(&quot;had a starbase to be returned to, you would have been&quot;))
+	prout(_(&quot;repatriated and given another chance. Since you have&quot;))
+	prout(_(&quot;no starbases, you will be mercilessly tortured to death.&quot;))
+    elif ifin == FDILITHIUM:
+	prout(_(&quot;Your starship is now an expanding cloud of subatomic particles&quot;))
+    elif ifin == FMATERIALIZE:
+	prout(_(&quot;Starbase was unable to re-materialize your starship.&quot;))
+	prout(_(&quot;Sic transit gloria mundi&quot;))
+    elif ifin == FPHASER:
+	prout(_(&quot;The %s has been cremated by its own phasers.&quot;) % crmshp())
+    elif ifin == FLOST:
+	prout(_(&quot;You and your landing party have been&quot;))
+	prout(_(&quot;converted to energy, disipating through space.&quot;))
+    elif ifin == FMINING:
+	prout(_(&quot;You are left with your landing party on&quot;))
+	prout(_(&quot;a wild jungle planet inhabited by primitive cannibals.&quot;))
+	skip(1)
+	prout(_(&quot;They are very fond of \&quot;Captain Kirk\&quot; soup.&quot;))
+	skip(1)
+	prout(_(&quot;Without your leadership, the %s is destroyed.&quot;) % crmshp())
+    elif ifin == FDPLANET:
+	prout(_(&quot;You and your mining party perish.&quot;))
+	skip(1)
+	prout(_(&quot;That was a great shot.&quot;))
+	skip(1)
+    elif ifin == FSSC:
+	prout(_(&quot;The Galileo is instantly annihilated by the supernova.&quot;))
+	prout(_(&quot;You and your mining party are atomized.&quot;))
+	skip(1)
+	prout(_(&quot;Mr. Spock takes command of the %s and&quot;) % crmshp())
+	prout(_(&quot;joins the Romulans, wreaking terror on the Federation.&quot;))
+    elif ifin == FPNOVA:
+	prout(_(&quot;You and your mining party are atomized.&quot;))
+	skip(1)
+	prout(_(&quot;Mr. Spock takes command of the %s and&quot;) % crmshp())
+	prout(_(&quot;joins the Romulans, wreaking terror on the Federation.&quot;))
+    elif ifin == FSTRACTOR:
+	prout(_(&quot;The shuttle craft Galileo is also caught,&quot;))
+	prout(_(&quot;and breaks up under the strain.&quot;))
+	skip(1)
+	prout(_(&quot;Your debris is scattered for millions of miles.&quot;))
+	prout(_(&quot;Without your leadership, the %s is destroyed.&quot;) % crmshp())
+    elif ifin == FDRAY:
+	prout(_(&quot;The mutants attack and kill Spock.&quot;))
+	prout(_(&quot;Your ship is captured by Klingons, and&quot;))
+	prout(_(&quot;your crew is put on display in a Klingon zoo.&quot;))
+    elif ifin == FTRIBBLE:
+	prout(_(&quot;Tribbles consume all remaining water,&quot;))
+	prout(_(&quot;food, and oxygen on your ship.&quot;))
+	skip(1)
+	prout(_(&quot;You die of thirst, starvation, and asphyxiation.&quot;))
+	prout(_(&quot;Your starship is a derelict in space.&quot;))
+    elif ifin == FHOLE:
+	prout(_(&quot;Your ship is drawn to the center of the black hole.&quot;))
+	prout(_(&quot;You are crushed into extremely dense matter.&quot;))
+    elif ifin == FCREW:
+	prout(_(&quot;Your last crew member has died.&quot;))
+    if game.ship == 'F':
+	game.ship = None
+    elif game.ship == 'E':
+	game.ship = 'F'
+    game.alive = False
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0:
+	goodies = game.state.remres/game.inresor
+	baddies = (game.state.remkl + 2.0*len(game.state.kcmdr))/(game.inkling+2.0*game.incom)
+	if goodies/baddies &gt;= randreal(1.0, 1.5):
+	    prout(_(&quot;As a result of your actions, a treaty with the Klingon&quot;))
+	    prout(_(&quot;Empire has been signed. The terms of the treaty are&quot;))
+	    if goodies/baddies &gt;= randreal(3.0):
+		prout(_(&quot;favorable to the Federation.&quot;))
+		skip(1)
+		prout(_(&quot;Congratulations!&quot;))
+	    else:
+		prout(_(&quot;highly unfavorable to the Federation.&quot;))
+	else:
+	    prout(_(&quot;The Federation will be destroyed.&quot;))
+    else:
+	prout(_(&quot;Since you took the last Klingon with you, you are a&quot;))
+	prout(_(&quot;martyr and a hero. Someday maybe they'll erect a&quot;))
+	prout(_(&quot;statue in your memory. Rest in peace, and try not&quot;))
+	prout(_(&quot;to think about pigeons.&quot;))
+	game.gamewon = True
+    score()
+
+def score():
+    &quot;Compute player's score.&quot;
+    timused = game.state.date - game.indate
+    iskill = game.skill
+    if (timused == 0 or (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) != 0) and timused &lt; 5.0:
+	timused = 5.0
+    perdate = killrate()
+    ithperd = 500*perdate + 0.5
+    iwon = 0
+    if game.gamewon:
+	iwon = 100*game.skill
+    if game.ship == 'E': 
+	klship = 0
+    elif game.ship == 'F': 
+	klship = 1
+    else:
+	klship = 2
+    iscore = 10*(game.inkling - game.state.remkl) \
+             + 50*(game.incom - len(game.state.kcmdr)) \
+             + ithperd + iwon \
+             + 20*(game.inrom - game.state.nromrem) \
+             + 200*(game.inscom - game.state.nscrem) \
+    	     - game.state.nromrem \
+             - badpoints()
+    if not game.alive:
+	iscore -= 200
+    skip(2)
+    prout(_(&quot;Your score --&quot;))
+    if game.inrom - game.state.nromrem:
+	prout(_(&quot;%6d Romulans destroyed                 %5d&quot;) %
+	      (game.inrom - game.state.nromrem, 20*(game.inrom - game.state.nromrem)))
+    if game.state.nromrem and game.gamewon:
+	prout(_(&quot;%6d Romulans captured                  %5d&quot;) %
+	      (game.state.nromrem, game.state.nromrem))
+    if game.inkling - game.state.remkl:
+	prout(_(&quot;%6d ordinary Klingons destroyed        %5d&quot;) %
+	      (game.inkling - game.state.remkl, 10*(game.inkling - game.state.remkl)))
+    if game.incom - len(game.state.kcmdr):
+	prout(_(&quot;%6d Klingon commanders destroyed       %5d&quot;) %
+	      (game.incom - len(game.state.kcmdr), 50*(game.incom - len(game.state.kcmdr))))
+    if game.inscom - game.state.nscrem:
+	prout(_(&quot;%6d Super-Commander destroyed          %5d&quot;) %
+	      (game.inscom - game.state.nscrem, 200*(game.inscom - game.state.nscrem)))
+    if ithperd:
+	prout(_(&quot;%6.2f Klingons per stardate              %5d&quot;) %
+	      (perdate, ithperd))
+    if game.state.starkl:
+	prout(_(&quot;%6d stars destroyed by your action     %5d&quot;) %
+	      (game.state.starkl, -5*game.state.starkl))
+    if game.state.nplankl:
+	prout(_(&quot;%6d planets destroyed by your action   %5d&quot;) %
+	      (game.state.nplankl, -10*game.state.nplankl))
+    if (game.options &amp; OPTION_WORLDS) and game.state.nworldkl:
+	prout(_(&quot;%6d inhabited planets destroyed by your action   %5d&quot;) %
+	      (game.state.nworldkl, -300*game.state.nworldkl))
+    if game.state.basekl:
+	prout(_(&quot;%6d bases destroyed by your action     %5d&quot;) %
+	      (game.state.basekl, -100*game.state.basekl))
+    if game.nhelp:
+	prout(_(&quot;%6d calls for help from starbase       %5d&quot;) %
+	      (game.nhelp, -45*game.nhelp))
+    if game.casual:
+	prout(_(&quot;%6d casualties incurred                %5d&quot;) %
+	      (game.casual, -game.casual))
+    if game.abandoned:
+	prout(_(&quot;%6d crew abandoned in space            %5d&quot;) %
+	      (game.abandoned, -3*game.abandoned))
+    if klship:
+	prout(_(&quot;%6d ship(s) lost or destroyed          %5d&quot;) %
+	      (klship, -100*klship))
+    if not game.alive:
+	prout(_(&quot;Penalty for getting yourself killed        -200&quot;))
+    if game.gamewon:
+	proutn(_(&quot;Bonus for winning &quot;))
+	if game.skill   == SKILL_NOVICE:	proutn(_(&quot;Novice game  &quot;))
+	elif game.skill == SKILL_FAIR:  	proutn(_(&quot;Fair game    &quot;))
+	elif game.skill ==  SKILL_GOOD: 	proutn(_(&quot;Good game    &quot;))
+	elif game.skill ==  SKILL_EXPERT:	proutn(_(&quot;Expert game  &quot;))
+	elif game.skill ==  SKILL_EMERITUS:	proutn(_(&quot;Emeritus game&quot;))
+	prout(&quot;           %5d&quot; % iwon)
+    skip(1)
+    prout(_(&quot;TOTAL SCORE                               %5d&quot;) % iscore)
+
+def plaque():
+    &quot;Emit winner's commemmorative plaque.&quot; 
+    skip(2)
+    while True:
+        proutn(_(&quot;File or device name for your plaque: &quot;))
+        winner = cgetline()
+        try:
+            fp = open(winner, &quot;w&quot;)
+            break
+        except IOError:
+            prout(_(&quot;Invalid name.&quot;))
+
+    proutn(_(&quot;Enter name to go on plaque (up to 30 characters): &quot;))
+    winner = cgetline()
+    # The 38 below must be 64 for 132-column paper 
+    nskip = 38 - len(winner)/2
+    fp.write(&quot;\n\n\n\n&quot;)
+    # --------DRAW ENTERPRISE PICTURE. 
+    fp.write(&quot;                                       EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot; )
+    fp.write(&quot;                                      EEE                      E  : :                                         :  E\n&quot; )
+    fp.write(&quot;                                    EE   EEE                   E  : :                   NCC-1701              :  E\n&quot;)
+    fp.write(&quot;EEEEEEEEEEEEEEEE        EEEEEEEEEEEEEEE  : :                              : E\n&quot;)
+    fp.write(&quot; E                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
+    fp.write(&quot;                      EEEEEEEEE               EEEEEEEEEEEEE                 E  E\n&quot;)
+    fp.write(&quot;                               EEEEEEE   EEEEE    E          E              E  E\n&quot;)
+    fp.write(&quot;                                      EEE           E          E            E  E\n&quot;)
+    fp.write(&quot;                                                       E         E          E  E\n&quot;)
+    fp.write(&quot;                                                         EEEEEEEEEEEEE      E  E\n&quot;)
+    fp.write(&quot;                                                      EEE :           EEEEEEE  EEEEEEEE\n&quot;)
+    fp.write(&quot;                                                    :E    :                 EEEE       E\n&quot;)
+    fp.write(&quot;                                                   .-E   -:-----                       E\n&quot;)
+    fp.write(&quot;                                                    :E    :                            E\n&quot;)
+    fp.write(&quot;                                                      EE  :                    EEEEEEEE\n&quot;)
+    fp.write(&quot;                                                       EEEEEEEEEEEEEEEEEEEEEEE\n&quot;)
+    fp.write(&quot;\n\n\n&quot;)
+    fp.write(_(&quot;                                                       U. S. S. ENTERPRISE\n&quot;))
+    fp.write(&quot;\n\n\n\n&quot;)
+    fp.write(_(&quot;                                  For demonstrating outstanding ability as a starship captain\n&quot;))
+    fp.write(&quot;\n&quot;)
+    fp.write(_(&quot;                                                Starfleet Command bestows to you\n&quot;))
+    fp.write(&quot;\n&quot;)
+    fp.write(&quot;%*s%s\n\n&quot; % (nskip, &quot;&quot;, winner))
+    fp.write(_(&quot;                                                           the rank of\n\n&quot;))
+    fp.write(_(&quot;                                                       \&quot;Commodore Emeritus\&quot;\n\n&quot;))
+    fp.write(&quot;                                                          &quot;)
+    if game.skill ==  SKILL_EXPERT:
+        fp.write(_(&quot; Expert level\n\n&quot;))
+    elif game.skill == SKILL_EMERITUS:
+        fp.write(_(&quot;Emeritus level\n\n&quot;))
+    else:
+        fp.write(_(&quot; Cheat level\n\n&quot;))
+    timestring = time.ctime()
+    fp.write(_(&quot;                                                 This day of %.6s %.4s, %.8s\n\n&quot;) %
+                    (timestring+4, timestring+20, timestring+11))
+    fp.write(_(&quot;                                                        Your score:  %d\n\n&quot;) % iscore)
+    fp.write(_(&quot;                                                    Klingons per stardate:  %.2f\n&quot;) % perdate)
+    fp.close()
+
+# Code from io.c begins here
+
+rows = linecount = 0	# for paging 
+stdscr = None
+replayfp = None
+fullscreen_window = None
+srscan_window     = None
+report_window     = None
+status_window     = None
+lrscan_window     = None
+message_window    = None
+prompt_window     = None
+curwnd = None
+
+def iostart():
+    global stdscr, rows
+    &quot;for some recent versions of python2, the following enables UTF8&quot;
+    &quot;for the older ones we probably need to set C locale, and the python3&quot;
+    &quot;has no problems at all&quot;
+    if sys.version_info.major &lt; 3:
+	import locale
+	locale.setlocale(locale.LC_ALL, &quot;&quot;)
+    gettext.bindtextdomain(&quot;sst&quot;, &quot;/usr/local/share/locale&quot;)
+    gettext.textdomain(&quot;sst&quot;)
+    if not (game.options &amp; OPTION_CURSES):
+	ln_env = os.getenv(&quot;LINES&quot;)
+        if ln_env:
+            rows = ln_env
+        else:
+            rows = 25
+    else:
+	stdscr = curses.initscr()
+	stdscr.keypad(True)
+	curses.nonl()
+	curses.cbreak()
+        if game.options &amp; OPTION_COLOR:
+            curses.start_color();
+            curses.use_default_colors()
+            curses.init_pair(curses.COLOR_BLACK,   curses.COLOR_BLACK, -1);
+            curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN, -1);
+            curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED, -1);
+            curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN, -1);
+            curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE, -1);
+            curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1);
+            curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE, -1);
+            curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW, -1);
+        global fullscreen_window, srscan_window, report_window, status_window
+        global lrscan_window, message_window, prompt_window
+        (rows, columns)   = stdscr.getmaxyx()
+	fullscreen_window = stdscr
+	srscan_window     = curses.newwin(12, 25, 0,       0)
+	report_window     = curses.newwin(11, 0,  1,       25)
+	status_window     = curses.newwin(10, 0,  1,       39)
+	lrscan_window     = curses.newwin(5,  0,  0,       64) 
+	message_window    = curses.newwin(0,  0,  12,      0)
+	prompt_window     = curses.newwin(1,  0,  rows-2,  0) 
+	message_window.scrollok(True)
+	setwnd(fullscreen_window)
+
+def ioend():
+    &quot;Wrap up I/O.&quot;
+    if game.options &amp; OPTION_CURSES:
+        stdscr.keypad(False)
+        curses.echo()
+        curses.nocbreak()
+        curses.endwin()
+
+def waitfor():
+    &quot;Wait for user action -- OK to do nothing if on a TTY&quot;
+    if game.options &amp; OPTION_CURSES:
+	stdscr.getch()
+
+def announce():
+    skip(1)
+    prouts(_(&quot;[ANNOUNCEMENT ARRIVING...]&quot;))
+    skip(1)
+
+def pause_game():
+    if game.skill &gt; SKILL_FAIR:
+        prompt = _(&quot;[CONTINUE?]&quot;)
+    else:
+        prompt = _(&quot;[PRESS ENTER TO CONTINUE]&quot;)
+
+    if game.options &amp; OPTION_CURSES:
+        drawmaps(0)
+        setwnd(prompt_window)
+        prompt_window.clear()
+        prompt_window.addstr(prompt)
+        prompt_window.getstr()
+        prompt_window.clear()
+        prompt_window.refresh()
+        setwnd(message_window)
+    else:
+        global linecount
+        sys.stdout.write('\n')
+        proutn(prompt)
+        raw_input()
+        for j in range(rows):
+            sys.stdout.write('\n')
+        linecount = 0
+
+def skip(i):
+    &quot;Skip i lines.  Pause game if this would cause a scrolling event.&quot;
+    for dummy in range(i):
+	if game.options &amp; OPTION_CURSES:
+            (y, x) = curwnd.getyx()
+            (my, mx) = curwnd.getmaxyx()
+	    if curwnd == message_window and y &gt;= my - 2:
+		pause_game()
+		clrscr()
+	    else:
+                try:
+                    curwnd.move(y+1, 0)
+                except curses.error:
+                    pass
+	else:
+            global linecount
+	    linecount += 1
+	    if rows and linecount &gt;= rows:
+		pause_game()
+	    else:
+		sys.stdout.write('\n')
+
+def proutn(line):
+    &quot;Utter a line with no following line feed.&quot;
+    if game.options &amp; OPTION_CURSES:
+	curwnd.addstr(line)
+	curwnd.refresh()
+    else:
+	sys.stdout.write(line)
+        sys.stdout.flush()
+
+def prout(line):
+    proutn(line)
+    skip(1)
+
+def prouts(line):
+    &quot;Emit slowly!&quot; 
+    for c in line:
+        if not replayfp or replayfp.closed:	# Don't slow down replays
+            time.sleep(0.03)
+	proutn(c)
+	if game.options &amp; OPTION_CURSES:
+	    curwnd.refresh()
+	else:
+	    sys.stdout.flush()
+    if not replayfp or replayfp.closed:
+        time.sleep(0.03)
+
+def cgetline():
+    &quot;Get a line of input.&quot;
+    if game.options &amp; OPTION_CURSES:
+	line = curwnd.getstr() + &quot;\n&quot;
+	curwnd.refresh()
+    else:
+	if replayfp and not replayfp.closed:
+            while True:
+                line = replayfp.readline()
+                proutn(line)
+                if line == '':
+                    prout(&quot;*** Replay finished&quot;)
+                    replayfp.close()
+                    break
+                elif line[0] != &quot;#&quot;:
+                    break
+	else:
+	    line = raw_input() + &quot;\n&quot;
+    if logfp:
+	logfp.write(line)
+    return line
+
+def setwnd(wnd):
+    &quot;Change windows -- OK for this to be a no-op in tty mode.&quot;
+    global curwnd
+    if game.options &amp; OPTION_CURSES:
+        curwnd = wnd
+        curses.curs_set(wnd == fullscreen_window or wnd == message_window or wnd == prompt_window)
+
+def clreol():
+    &quot;Clear to end of line -- can be a no-op in tty mode&quot; 
+    if game.options &amp; OPTION_CURSES:
+        curwnd.clrtoeol()
+        curwnd.refresh()
+
+def clrscr():
+    &quot;Clear screen -- can be a no-op in tty mode.&quot;
+    global linecount
+    if game.options &amp; OPTION_CURSES:
+       curwnd.clear()
+       curwnd.move(0, 0)
+       curwnd.refresh()
+    linecount = 0
+
+def textcolor(color=DEFAULT):
+    if game.options &amp; OPTION_COLOR:
+	if color == DEFAULT: 
+	    curwnd.attrset(0);
+	elif color ==  BLACK: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK));
+	elif color ==  BLUE: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE));
+	elif color ==  GREEN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN));
+	elif color ==  CYAN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN));
+	elif color ==  RED: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_RED));
+	elif color ==  MAGENTA: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA));
+	elif color ==  BROWN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW));
+	elif color ==  LIGHTGRAY: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE));
+	elif color ==  DARKGRAY: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLACK) | curses.A_BOLD);
+	elif color ==  LIGHTBLUE: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_BLUE) | curses.A_BOLD);
+	elif color ==  LIGHTGREEN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_GREEN) | curses.A_BOLD);
+	elif color ==  LIGHTCYAN: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_CYAN) | curses.A_BOLD);
+	elif color ==  LIGHTRED: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_RED) | curses.A_BOLD);
+	elif color ==  LIGHTMAGENTA: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_MAGENTA) | curses.A_BOLD);
+	elif color ==  YELLOW: 
+	    curwnd.attron(curses.color_pair(curses.COLOR_YELLOW) | curses.A_BOLD);
+	elif color ==  WHITE:
+	    curwnd.attron(curses.color_pair(curses.COLOR_WHITE) | curses.A_BOLD);
+
+def highvideo():
+    if game.options &amp; OPTION_COLOR:
+        curwnd.attron(curses.A_REVERSE)
+
+#
+# Things past this point have policy implications.
+# 
+
+def drawmaps(mode):
+    &quot;Hook to be called after moving to redraw maps.&quot;
+    if game.options &amp; OPTION_CURSES:
+	if mode == 1:
+	    sensor()
+        setwnd(srscan_window)
+        curwnd.move(0, 0)
+        srscan()
+	if mode != 2:
+	    setwnd(status_window)
+	    status_window.clear()
+	    status_window.move(0, 0)
+	    setwnd(report_window)
+	    report_window.clear()
+	    report_window.move(0, 0)
+	    status()
+	    setwnd(lrscan_window)
+	    lrscan_window.clear()
+	    lrscan_window.move(0, 0)
+	    lrscan(silent=False)
+
+def put_srscan_sym(w, sym):
+    &quot;Emit symbol for short-range scan.&quot;
+    srscan_window.move(w.i+1, w.j*2+2)
+    srscan_window.addch(sym)
+    srscan_window.refresh()
+
+def boom(w):
+    &quot;Enemy fall down, go boom.&quot;  
+    if game.options &amp; OPTION_CURSES:
+	drawmaps(2)
+	setwnd(srscan_window)
+	srscan_window.attron(curses.A_REVERSE)
+	put_srscan_sym(w, game.quad[w.i][w.j])
+	#sound(500)
+	#time.sleep(1.0)
+	#nosound()
+	srscan_window.attroff(curses.A_REVERSE)
+	put_srscan_sym(w, game.quad[w.i][w.j])
+	curses.delay_output(500)
+	setwnd(message_window) 
+
+def warble():
+    &quot;Sound and visual effects for teleportation.&quot;
+    if game.options &amp; OPTION_CURSES:
+	drawmaps(2)
+	setwnd(message_window)
+	#sound(50)
+    prouts(&quot;     . . . . .     &quot;)
+    if game.options &amp; OPTION_CURSES:
+	#curses.delay_output(1000)
+	#nosound()
+        pass
+
+def tracktorpedo(origin, w, step, i, n, iquad):
+    &quot;Torpedo-track animation.&quot; 
+    if not game.options &amp; OPTION_CURSES:
+	if step == 1:
+	    if n != 1:
+		skip(1)
+		proutn(_(&quot;Track for torpedo number %d-  &quot;) % (i+1))
+	    else:
+		skip(1)
+		proutn(_(&quot;Torpedo track- &quot;))
+	elif step==4 or step==9: 
+	    skip(1)
+	proutn(&quot;%s   &quot; % w)
+    else:
+	if not damaged(DSRSENS) or game.condition==&quot;docked&quot;:
+	    if i != 0 and step == 1:
+		drawmaps(2)
+		time.sleep(0.4)
+	    if (iquad=='.') or (iquad==' '):
+		put_srscan_sym(w, '+')
+		#sound(step*10)
+		#time.sleep(0.1)
+		#nosound()
+		put_srscan_sym(w, iquad)
+	    else:
+		curwnd.attron(curses.A_REVERSE)
+		put_srscan_sym(w, iquad)
+		#sound(500)
+		#time.sleep(1.0)
+		#nosound()
+		curwnd.attroff(curses.A_REVERSE)
+		put_srscan_sym(w, iquad)
+	else:
+	    proutn(&quot;%s   &quot; % w)
+
+def makechart():
+    &quot;Display the current galaxy chart.&quot;
+    if game.options &amp; OPTION_CURSES:
+	setwnd(message_window)
+	message_window.clear()
+    chart()
+    if game.options &amp; OPTION_TTY:
+	skip(1)
+
+NSYM	= 14
+
+def prstat(txt, data):
+    proutn(txt)
+    if game.options &amp; OPTION_CURSES:
+	skip(1)
+	setwnd(status_window)
+    else:
+        proutn(&quot; &quot; * (NSYM - len(txt)))
+    proutn(data)
+    skip(1)
+    if game.options &amp; OPTION_CURSES:
+	setwnd(report_window)
+
+# Code from moving.c begins here
+
+def imove(course=None, noattack=False):
+    &quot;Movement execution for warp, impulse, supernova, and tractor-beam events.&quot;
+    w = coord()
+
+    def newquadrant(noattack):
+        # Leaving quadrant -- allow final enemy attack 
+        # Don't do it if being pushed by Nova 
+        if len(game.enemies) != 0 and not noattack:
+            newcnd()
+            for enemy in game.enemies:
+                finald = (w - enemy.location).distance()
+                enemy.kavgd = 0.5 * (finald + enemy.kdist)
+            # Stas Sergeev added the condition
+            # that attacks only happen if Klingons
+            # are present and your skill is good.
+            if game.skill &gt; SKILL_GOOD and game.klhere &gt; 0 and not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+                attack(torps_ok=False)
+            if game.alldone:
+                return
+        # check for edge of galaxy 
+        kinks = 0
+        while True:
+            kink = False
+            if course.final.i &lt; 0:
+                course.final.i = -course.final.i
+                kink = True
+            if course.final.j &lt; 0:
+                course.final.j = -course.final.j
+                kink = True
+            if course.final.i &gt;= GALSIZE*QUADSIZE:
+                course.final.i = (GALSIZE*QUADSIZE*2) - course.final.i
+                kink = True
+            if course.final.j &gt;= GALSIZE*QUADSIZE:
+                course.final.j = (GALSIZE*QUADSIZE*2) - course.final.j
+                kink = True
+            if kink:
+                kinks += 1
+            else:
+                break
+        if kinks:
+            game.nkinks += 1
+            if game.nkinks == 3:
+                # Three strikes -- you're out! 
+                finish(FNEG3)
+                return
+            skip(1)
+            prout(_(&quot;YOU HAVE ATTEMPTED TO CROSS THE NEGATIVE ENERGY BARRIER&quot;))
+            prout(_(&quot;AT THE EDGE OF THE GALAXY.  THE THIRD TIME YOU TRY THIS,&quot;))
+            prout(_(&quot;YOU WILL BE DESTROYED.&quot;))
+        # Compute final position in new quadrant 
+        if trbeam: # Don't bother if we are to be beamed 
+            return
+        game.quadrant = course.final.quadrant()
+        game.sector = course.final.sector()
+        skip(1)
+        prout(_(&quot;Entering Quadrant %s.&quot;) % game.quadrant)
+        game.quad[game.sector.i][game.sector.j] = game.ship
+        newqad()
+        if game.skill&gt;SKILL_NOVICE:
+            attack(torps_ok=False)  
+
+    def check_collision(h):
+        iquad = game.quad[h.i][h.j]
+        if iquad != '.':
+            # object encountered in flight path 
+            stopegy = 50.0*course.distance/game.optime
+            if iquad in ('T', 'K', 'C', 'S', 'R', '?'):
+                for enemy in game.enemies:
+                    if enemy.location == game.sector:
+                        break
+                collision(rammed=False, enemy=enemy)
+                return True
+            elif iquad == ' ':
+                skip(1)
+                prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+                skip(1)
+                proutn(&quot;***&quot; + crmshp())
+                proutn(_(&quot; pulled into black hole at Sector %s&quot;) % h)
+                # Getting pulled into a black hole was certain
+                # death in Almy's original.  Stas Sergeev added a
+                # possibility that you'll get timewarped instead.
+                n=0
+                for m in range(NDEVICES):
+                    if game.damage[m]&gt;0: 
+                        n += 1
+                probf=math.pow(1.4,(game.energy+game.shield)/5000.0-1.0)*math.pow(1.3,1.0/(n+1)-1.0)
+                if (game.options &amp; OPTION_BLKHOLE) and withprob(1-probf): 
+                    timwrp()
+                else: 
+                    finish(FHOLE)
+                return True
+            else:
+                # something else 
+                skip(1)
+                proutn(crmshp())
+                if iquad == '#':
+                    prout(_(&quot; encounters Tholian web at %s;&quot;) % h)
+                else:
+                    prout(_(&quot; blocked by object at %s;&quot;) % h)
+                proutn(_(&quot;Emergency stop required &quot;))
+                prout(_(&quot;%2d units of energy.&quot;) % int(stopegy))
+                game.energy -= stopegy
+                if game.energy &lt;= 0:
+                    finish(FNRG)
+                return True
+        return False
+
+    trbeam = False
+    if game.inorbit:
+	prout(_(&quot;Helmsman Sulu- \&quot;Leaving standard orbit.\&quot;&quot;))
+	game.inorbit = False
+    # If tractor beam is to occur, don't move full distance 
+    if game.state.date+game.optime &gt;= scheduled(FTBEAM):
+	trbeam = True
+	game.condition = &quot;red&quot;
+	course.distance = course.distance*(scheduled(FTBEAM)-game.state.date)/game.optime + 0.1
+	game.optime = scheduled(FTBEAM) - game.state.date + 1e-5
+    # Move out
+    game.quad[game.sector.i][game.sector.j] = '.'
+    for m in range(course.moves):
+        course.next()
+        w = course.sector()
+        if course.origin.quadrant() != course.location.quadrant():
+            newquadrant(noattack)
+            break
+        elif check_collision(w):
+            print &quot;Collision detected&quot;
+            break
+        else:
+            game.sector = w
+    # We're in destination quadrant -- compute new average enemy distances
+    game.quad[game.sector.i][game.sector.j] = game.ship
+    if game.enemies:
+        for enemy in game.enemies:
+            finald = (w-enemy.location).distance()
+            enemy.kavgd = 0.5 * (finald + enemy.kdist)
+            enemy.kdist = finald
+        game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            attack(torps_ok=False)
+        for enemy in game.enemies:
+            enemy.kavgd = enemy.kdist
+    newcnd()
+    drawmaps(0)
+    setwnd(message_window)
+    return
+
+def dock(verbose):
+    &quot;Dock our ship at a starbase.&quot;
+    scanner.chew()
+    if game.condition == &quot;docked&quot; and verbose:
+	prout(_(&quot;Already docked.&quot;))
+	return
+    if game.inorbit:
+	prout(_(&quot;You must first leave standard orbit.&quot;))
+	return
+    if not game.base.is_valid() or abs(game.sector.i-game.base.i) &gt; 1 or abs(game.sector.j-game.base.j) &gt; 1:
+	prout(crmshp() + _(&quot; not adjacent to base.&quot;))
+	return
+    game.condition = &quot;docked&quot;
+    if &quot;verbose&quot;:
+	prout(_(&quot;Docked.&quot;))
+    game.ididit = True
+    if game.energy &lt; game.inenrg:
+	game.energy = game.inenrg
+    game.shield = game.inshld
+    game.torps = game.intorps
+    game.lsupres = game.inlsr
+    game.state.crew = FULLCREW
+    if not damaged(DRADIO) and \
+	((is_scheduled(FCDBAS) or game.isatb == 1) and not game.iseenit):
+	# get attack report from base 
+	prout(_(&quot;Lt. Uhura- \&quot;Captain, an important message from the starbase:\&quot;&quot;))
+	attackreport(False)
+	game.iseenit = True
+
+def cartesian(loc1=None, loc2=None):
+    if loc1 is None:
+        return game.quadrant * QUADSIZE + game.sector
+    elif loc2 is None:
+        return game.quadrant * QUADSIZE + loc1
+    else:
+        return loc1 * QUADSIZE + loc2
+
+def getcourse(isprobe):
+    &quot;Get a course and distance from the user.&quot;
+    key = 0
+    dquad = copy.copy(game.quadrant)
+    navmode = &quot;unspecified&quot;
+    itemp = &quot;curt&quot;
+    dsect = coord()
+    iprompt = False
+    if game.landed and not isprobe:
+	prout(_(&quot;Dummy! You can't leave standard orbit until you&quot;))
+	proutn(_(&quot;are back aboard the ship.&quot;))
+	scanner.chew()
+	raise TrekError
+    while navmode == &quot;unspecified&quot;:
+	if damaged(DNAVSYS):
+	    if isprobe:
+		prout(_(&quot;Computer damaged; manual navigation only&quot;))
+	    else:
+		prout(_(&quot;Computer damaged; manual movement only&quot;))
+	    scanner.chew()
+	    navmode = &quot;manual&quot;
+	    key = &quot;IHEOL&quot;
+	    break
+        key = scanner.next()
+	if key == &quot;IHEOL&quot;:
+	    proutn(_(&quot;Manual or automatic- &quot;))
+	    iprompt = True
+	    scanner.chew()
+	elif key == &quot;IHALPHA&quot;:
+            if scanner.sees(&quot;manual&quot;):
+		navmode = &quot;manual&quot;
+		key = scanner.next()
+		break
+            elif scanner.sees(&quot;automatic&quot;):
+		navmode = &quot;automatic&quot;
+		key = scanner.next()
+		break
+	    else:
+		huh()
+		scanner.chew()
+		raise TrekError
+	else: # numeric 
+	    if isprobe:
+		prout(_(&quot;(Manual navigation assumed.)&quot;))
+	    else:
+		prout(_(&quot;(Manual movement assumed.)&quot;))
+	    navmode = &quot;manual&quot;
+	    break
+    delta = coord()
+    if navmode == &quot;automatic&quot;:
+	while key == &quot;IHEOL&quot;:
+	    if isprobe:
+		proutn(_(&quot;Target quadrant or quadrant&amp;sector- &quot;))
+	    else:
+		proutn(_(&quot;Destination sector or quadrant&amp;sector- &quot;))
+	    scanner.chew()
+	    iprompt = True
+	    key = scanner.next()
+	if key != &quot;IHREAL&quot;:
+	    huh()
+	    raise TrekError
+	xi = int(round(scanner.real))-1
+	key = scanner.next()
+	if key != &quot;IHREAL&quot;:
+	    huh()
+	    raise TrekError
+	xj = int(round(scanner.real))-1
+	key = scanner.next()
+	if key == &quot;IHREAL&quot;:
+	    # both quadrant and sector specified 
+	    xk = int(round(scanner.real))-1
+	    key = scanner.next()
+	    if key != &quot;IHREAL&quot;:
+		huh()
+		raise TrekError
+	    xl = int(round(scanner.real))-1
+	    dquad.i = xi
+	    dquad.j = xj
+	    dsect.i = xk
+	    dsect.j = xl
+	else:
+            # only one pair of numbers was specified
+	    if isprobe:
+		# only quadrant specified -- go to center of dest quad 
+		dquad.i = xi
+		dquad.j = xj
+		dsect.j = dsect.i = 4	# preserves 1-origin behavior
+	    else:
+                # only sector specified
+		dsect.i = xi
+		dsect.j = xj
+	    itemp = &quot;normal&quot;
+	if not dquad.valid_quadrant() or not dsect.valid_sector():
+	    huh()
+	    raise TrekError
+	skip(1)
+	if not isprobe:
+	    if itemp &gt; &quot;curt&quot;:
+		if iprompt:
+		    prout(_(&quot;Helmsman Sulu- \&quot;Course locked in for Sector %s.\&quot;&quot;) % dsect)
+	    else:
+		prout(_(&quot;Ensign Chekov- \&quot;Course laid in, Captain.\&quot;&quot;))
+        # the actual deltas get computed here
+	delta.j = dquad.j-game.quadrant.j + (dsect.j-game.sector.j)/(QUADSIZE*1.0)
+	delta.i = game.quadrant.i-dquad.i + (game.sector.i-dsect.i)/(QUADSIZE*1.0)
+    else: # manual 
+	while key == &quot;IHEOL&quot;:
+	    proutn(_(&quot;X and Y displacements- &quot;))
+	    scanner.chew()
+	    iprompt = True
+	    key = scanner.next()
+	itemp = &quot;verbose&quot;
+	if key != &quot;IHREAL&quot;:
+	    huh()
+	    raise TrekError
+	delta.j = scanner.real
+	key = scanner.next()
+	if key != &quot;IHREAL&quot;:
+	    huh()
+	    raise TrekError
+	delta.i = scanner.real
+    # Check for zero movement 
+    if delta.i == 0 and delta.j == 0:
+	scanner.chew()
+	raise TrekError
+    if itemp == &quot;verbose&quot; and not isprobe:
+	skip(1)
+	prout(_(&quot;Helmsman Sulu- \&quot;Aye, Sir.\&quot;&quot;))
+    scanner.chew()
+    return course(bearing=delta.bearing(), distance=delta.distance())
+
+class course:
+    def __init__(self, bearing, distance, origin=None): 
+        self.distance = distance
+        self.bearing = bearing
+        if origin is None:
+            self.origin = cartesian(game.quadrant, game.sector)
+        else:
+            self.origin = origin
+        # The bearing() code we inherited from FORTRAN is actually computing
+        # clockface directions!
+        if self.bearing &lt; 0.0:
+            self.bearing += 12.0
+        self.angle = ((15.0 - self.bearing) * 0.5235988)
+        if origin is None:
+            self.origin = cartesian(game.quadrant, game.sector)
+        else:
+            self.origin = cartesian(game.quadrant, origin)
+        self.increment = coord(-math.sin(self.angle), math.cos(self.angle))
+        bigger = max(abs(self.increment.i), abs(self.increment.j))
+        self.increment /= bigger
+        self.moves = int(round(10*self.distance*bigger))
+        self.reset()
+        self.final = (self.location + self.moves*self.increment).roundtogrid()
+    def reset(self):
+        self.location = self.origin
+        self.step = 0
+    def arrived(self):
+        return self.location.roundtogrid() == self.final
+    def next(self):
+        &quot;Next step on course.&quot;
+        self.step += 1
+        self.nextlocation = self.location + self.increment
+        samequad = (self.location.quadrant() == self.nextlocation.quadrant())
+        self.location = self.nextlocation
+        return samequad
+    def quadrant(self):
+        return self.location.quadrant()
+    def sector(self):
+        return self.location.sector()
+    def power(self, warp):
+	return self.distance*(warp**3)*(game.shldup+1)
+    def time(self, warp):
+        return 10.0*self.distance/warp**2
+
+def impulse():
+    &quot;Move under impulse power.&quot;
+    game.ididit = False
+    if damaged(DIMPULS):
+	scanner.chew()
+	skip(1)
+	prout(_(&quot;Engineer Scott- \&quot;The impulse engines are damaged, Sir.\&quot;&quot;))
+	return
+    if game.energy &gt; 30.0:
+        try:
+            course = getcourse(isprobe=False)
+        except TrekError:
+	    return
+	power = 20.0 + 100.0*course.distance
+    else:
+	power = 30.0
+    if power &gt;= game.energy:
+	# Insufficient power for trip 
+	skip(1)
+	prout(_(&quot;First Officer Spock- \&quot;Captain, the impulse engines&quot;))
+	prout(_(&quot;require 20.0 units to engage, plus 100.0 units per&quot;))
+	if game.energy &gt; 30:
+	    proutn(_(&quot;quadrant.  We can go, therefore, a maximum of %d&quot;) %
+                     int(0.01 * (game.energy-20.0)-0.05))
+	    prout(_(&quot; quadrants.\&quot;&quot;))
+	else:
+	    prout(_(&quot;quadrant.  They are, therefore, useless.\&quot;&quot;))
+	scanner.chew()
+	return
+    # Make sure enough time is left for the trip 
+    game.optime = course.dist/0.095
+    if game.optime &gt;= game.state.remtime:
+	prout(_(&quot;First Officer Spock- \&quot;Captain, our speed under impulse&quot;))
+	prout(_(&quot;power is only 0.95 sectors per stardate. Are you sure&quot;))
+	proutn(_(&quot;we dare spend the time?\&quot; &quot;))
+	if ja() == False:
+	    return
+    # Activate impulse engines and pay the cost 
+    imove(course, noattack=False)
+    game.ididit = True
+    if game.alldone:
+	return
+    power = 20.0 + 100.0*course.dist
+    game.energy -= power
+    game.optime = course.dist/0.095
+    if game.energy &lt;= 0:
+	finish(FNRG)
+    return
+
+def warp(course, involuntary):
+    &quot;ove under warp drive.&quot;
+    blooey = False; twarp = False
+    if not involuntary: # Not WARPX entry 
+	game.ididit = False
+	if game.damage[DWARPEN] &gt; 10.0:
+	    scanner.chew()
+	    skip(1)
+	    prout(_(&quot;Engineer Scott- \&quot;The warp engines are damaged, Sir.\&quot;&quot;))
+	    return
+	if damaged(DWARPEN) and game.warpfac &gt; 4.0:
+	    scanner.chew()
+	    skip(1)
+	    prout(_(&quot;Engineer Scott- \&quot;Sorry, Captain. Until this damage&quot;))
+	    prout(_(&quot;  is repaired, I can only give you warp 4.\&quot;&quot;))
+	    return
+       	# Read in course and distance
+        if course==None:
+            try:
+                course = getcourse(isprobe=False)
+            except TrekError:
+                return
+	# Make sure starship has enough energy for the trip
+        # Note: this formula is slightly different from the C version,
+        # and lets you skate a bit closer to the edge.
+	if course.power(game.warpfac) &gt;= game.energy:
+	    # Insufficient power for trip 
+	    game.ididit = False
+	    skip(1)
+	    prout(_(&quot;Engineering to bridge--&quot;))
+	    if not game.shldup or 0.5*power &gt; game.energy:
+		iwarp = (game.energy/(course.dist+0.05)) ** 0.333333333
+		if iwarp &lt;= 0:
+		    prout(_(&quot;We can't do it, Captain. We don't have enough energy.&quot;))
+		else:
+		    proutn(_(&quot;We don't have enough energy, but we could do it at warp %d&quot;) % iwarp)
+		    if game.shldup:
+			prout(&quot;,&quot;)
+			prout(_(&quot;if you'll lower the shields.&quot;))
+		    else:
+			prout(&quot;.&quot;)
+	    else:
+		prout(_(&quot;We haven't the energy to go that far with the shields up.&quot;))
+	    return				
+	# Make sure enough time is left for the trip 
+	game.optime = course.time(game.warpfac)
+	if game.optime &gt;= 0.8*game.state.remtime:
+	    skip(1)
+	    prout(_(&quot;First Officer Spock- \&quot;Captain, I compute that such&quot;))
+	    proutn(_(&quot;  a trip would require approximately %2.0f&quot;) %
+		   (100.0*game.optime/game.state.remtime))
+	    prout(_(&quot; percent of our&quot;))
+	    proutn(_(&quot;  remaining time.  Are you sure this is wise?\&quot; &quot;))
+	    if ja() == False:
+		game.ididit = False
+		game.optime=0 
+		return
+    # Entry WARPX 
+    if game.warpfac &gt; 6.0:
+	# Decide if engine damage will occur
+        # ESR: Seems wrong. Probability of damage goes *down* with distance? 
+	prob = course.distance*(6.0-game.warpfac)**2/66.666666666
+	if prob &gt; randreal():
+	    blooey = True
+	    course.distance = randreal(course.distance)
+	# Decide if time warp will occur 
+	if 0.5*course.distance*math.pow(7.0,game.warpfac-10.0) &gt; randreal():
+	    twarp = True
+	if idebug and game.warpfac==10 and not twarp:
+	    blooey = False
+	    proutn(&quot;=== Force time warp? &quot;)
+	    if ja() == True:
+		twarp = True
+	if blooey or twarp:
+	    # If time warp or engine damage, check path 
+	    # If it is obstructed, don't do warp or damage 
+            for m in range(course.moves):
+                course.next()
+                w = course.sector()
+                if not w.valid_sector():
+                    break
+		if game.quad[w.i][w.j] != '.':
+		    blooey = False
+		    twarp = False
+            course.reset()
+    # Activate Warp Engines and pay the cost 
+    imove(course, noattack=False)
+    if game.alldone:
+	return
+    game.energy -= course.power(game.warpfac)
+    if game.energy &lt;= 0:
+	finish(FNRG)
+    game.optime = course.time(game.warpfac)
+    if twarp:
+	timwrp()
+    if blooey:
+	game.damage[DWARPEN] = game.damfac * randreal(1.0, 4.0)
+	skip(1)
+	prout(_(&quot;Engineering to bridge--&quot;))
+	prout(_(&quot;  Scott here.  The warp engines are damaged.&quot;))
+	prout(_(&quot;  We'll have to reduce speed to warp 4.&quot;))
+    game.ididit = True
+    return
+
+def setwarp():
+    &quot;Change the warp factor.&quot;
+    while True:
+        key=scanner.next()
+        if key != &quot;IHEOL&quot;:
+            break
+	scanner.chew()
+	proutn(_(&quot;Warp factor- &quot;))
+    if key != &quot;IHREAL&quot;:
+	huh()
+	return
+    if game.damage[DWARPEN] &gt; 10.0:
+	prout(_(&quot;Warp engines inoperative.&quot;))
+	return
+    if damaged(DWARPEN) and scanner.real &gt; 4.0:
+	prout(_(&quot;Engineer Scott- \&quot;I'm doing my best, Captain,&quot;))
+	prout(_(&quot;  but right now we can only go warp 4.\&quot;&quot;))
+	return
+    if scanner.real &gt; 10.0:
+	prout(_(&quot;Helmsman Sulu- \&quot;Our top speed is warp 10, Captain.\&quot;&quot;))
+	return
+    if scanner.real &lt; 1.0:
+	prout(_(&quot;Helmsman Sulu- \&quot;We can't go below warp 1, Captain.\&quot;&quot;))
+	return
+    oldfac = game.warpfac
+    game.warpfac = scanner.real
+    if game.warpfac &lt;= oldfac or game.warpfac &lt;= 6.0:
+	prout(_(&quot;Helmsman Sulu- \&quot;Warp factor %d, Captain.\&quot;&quot;) %
+	       int(game.warpfac))
+	return
+    if game.warpfac &lt; 8.00:
+	prout(_(&quot;Engineer Scott- \&quot;Aye, but our maximum safe speed is warp 6.\&quot;&quot;))
+	return
+    if game.warpfac == 10.0:
+	prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, we'll try it.\&quot;&quot;))
+	return
+    prout(_(&quot;Engineer Scott- \&quot;Aye, Captain, but our engines may not take it.\&quot;&quot;))
+    return
+
+def atover(igrab):
+    &quot;Cope with being tossed out of quadrant by supernova or yanked by beam.&quot;
+    scanner.chew()
+    # is captain on planet? 
+    if game.landed:
+	if damaged(DTRANSP):
+	    finish(FPNOVA)
+	    return
+	prout(_(&quot;Scotty rushes to the transporter controls.&quot;))
+	if game.shldup:
+	    prout(_(&quot;But with the shields up it's hopeless.&quot;))
+	    finish(FPNOVA)
+	prouts(_(&quot;His desperate attempt to rescue you . . .&quot;))
+	if withprob(0.5):
+	    prout(_(&quot;fails.&quot;))
+	    finish(FPNOVA)
+	    return
+	prout(_(&quot;SUCCEEDS!&quot;))
+	if game.imine:
+	    game.imine = False
+	    proutn(_(&quot;The crystals mined were &quot;))
+	    if withprob(0.25):
+		prout(_(&quot;lost.&quot;))
+	    else:
+		prout(_(&quot;saved.&quot;))
+		game.icrystl = True
+    if igrab:
+	return
+    # Check to see if captain in shuttle craft 
+    if game.icraft:
+	finish(FSTRACTOR)
+    if game.alldone:
+	return
+    # Inform captain of attempt to reach safety 
+    skip(1)
+    while True:
+	if game.justin:
+	    prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+	    skip(1)
+	    proutn(_(&quot;The %s has stopped in a quadrant containing&quot;) % crmshp())
+	    prouts(_(&quot;   a supernova.&quot;))
+	    skip(2)
+	prout(_(&quot;***Emergency automatic override attempts to hurl &quot;)+crmshp())
+	prout(_(&quot;safely out of quadrant.&quot;))
+	if not damaged(DRADIO):
+	    game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
+	# Try to use warp engines 
+	if damaged(DWARPEN):
+	    skip(1)
+	    prout(_(&quot;Warp engines damaged.&quot;))
+	    finish(FSNOVAED)
+	    return
+	game.warpfac = randreal(6.0, 8.0)
+	prout(_(&quot;Warp factor set to %d&quot;) % int(game.warpfac))
+	power = 0.75*game.energy
+	dist = power/(game.warpfac*game.warpfac*game.warpfac*(game.shldup+1))
+	dist = max(dist, randreal(math.sqrt(2)))
+        bugout = course(bearing=randreal(12), distance=dist)	# How dumb!
+	game.optime = bugout.time(game.warpfac)
+	game.justin = False
+	game.inorbit = False
+	warp(bugout, involuntary=True)
+	if not game.justin:
+	    # This is bad news, we didn't leave quadrant. 
+	    if game.alldone:
+		return
+	    skip(1)
+	    prout(_(&quot;Insufficient energy to leave quadrant.&quot;))
+	    finish(FSNOVAED)
+	    return
+	# Repeat if another snova
+        if not game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+            break
+    if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)==0: 
+	finish(FWON) # Snova killed remaining enemy. 
+
+def timwrp():
+    &quot;Let's do the time warp again.&quot;
+    prout(_(&quot;***TIME WARP ENTERED.&quot;))
+    if game.state.snap and withprob(0.5):
+	# Go back in time 
+	prout(_(&quot;You are traveling backwards in time %d stardates.&quot;) %
+	      int(game.state.date-game.snapsht.date))
+	game.state = game.snapsht
+	game.state.snap = False
+	if len(game.state.kcmdr):
+	    schedule(FTBEAM, expran(game.intime/len(game.state.kcmdr)))
+	    schedule(FBATTAK, expran(0.3*game.intime))
+	schedule(FSNOVA, expran(0.5*game.intime))
+	# next snapshot will be sooner 
+	schedule(FSNAP, expran(0.25*game.state.remtime))
+				
+	if game.state.nscrem:
+	    schedule(FSCMOVE, 0.2777)	    
+	game.isatb = 0
+	unschedule(FCDBAS)
+	unschedule(FSCDBAS)
+	game.battle.invalidate()
+	# Make sure Galileo is consistant -- Snapshot may have been taken
+        # when on planet, which would give us two Galileos! 
+	gotit = False
+	for l in range(game.inplan):
+	    if game.state.planets[l].known == &quot;shuttle_down&quot;:
+		gotit = True
+		if game.iscraft == &quot;onship&quot; and game.ship=='E':
+		    prout(_(&quot;Chekov-  \&quot;Security reports the Galileo has disappeared, Sir!&quot;))
+		    game.iscraft = &quot;offship&quot;
+	# Likewise, if in the original time the Galileo was abandoned, but
+	# was on ship earlier, it would have vanished -- let's restore it.
+	if game.iscraft == &quot;offship&quot; and not gotit and game.damage[DSHUTTL] &gt;= 0.0:
+	    prout(_(&quot;Chekov-  \&quot;Security reports the Galileo has reappeared in the dock!\&quot;&quot;))
+	    game.iscraft = &quot;onship&quot;
+        # There used to be code to do the actual reconstrction here,
+        # but the starchart is now part of the snapshotted galaxy state.
+	prout(_(&quot;Spock has reconstructed a correct star chart from memory&quot;))
+    else:
+	# Go forward in time 
+	game.optime = expran(0.5*game.intime)
+	prout(_(&quot;You are traveling forward in time %d stardates.&quot;) % int(game.optime))
+	# cheat to make sure no tractor beams occur during time warp 
+	postpone(FTBEAM, game.optime)
+	game.damage[DRADIO] += game.optime
+    newqad()
+    events()	# Stas Sergeev added this -- do pending events 
+
+def probe():
+    &quot;Launch deep-space probe.&quot; 
+    # New code to launch a deep space probe 
+    if game.nprobes == 0:
+	scanner.chew()
+	skip(1)
+	if game.ship == 'E': 
+	    prout(_(&quot;Engineer Scott- \&quot;We have no more deep space probes, Sir.\&quot;&quot;))
+	else:
+	    prout(_(&quot;Ye Faerie Queene has no deep space probes.&quot;))
+	return
+    if damaged(DDSP):
+	scanner.chew()
+	skip(1)
+	prout(_(&quot;Engineer Scott- \&quot;The probe launcher is damaged, Sir.\&quot;&quot;))
+	return
+    if is_scheduled(FDSPROB):
+	scanner.chew()
+	skip(1)
+	if damaged(DRADIO) and game.condition != &quot;docked&quot;:
+	    prout(_(&quot;Spock-  \&quot;Records show the previous probe has not yet&quot;))
+	    prout(_(&quot;   reached its destination.\&quot;&quot;))
+	else:
+	    prout(_(&quot;Uhura- \&quot;The previous probe is still reporting data, Sir.\&quot;&quot;))
+	return
+    key = scanner.next()
+    if key == &quot;IHEOL&quot;:
+        if game.nprobes == 1:
+            prout(_(&quot;1 probe left.&quot;))
+        else:
+            prout(_(&quot;%d probes left&quot;) % game.nprobes)
+	proutn(_(&quot;Are you sure you want to fire a probe? &quot;))
+	if ja() == False:
+	    return
+    game.isarmed = False
+    if key == &quot;IHALPHA&quot; and scanner.token == &quot;armed&quot;:
+	game.isarmed = True
+	key = scanner.next()
+    elif key == &quot;IHEOL&quot;:
+	proutn(_(&quot;Arm NOVAMAX warhead? &quot;))
+	game.isarmed = ja()
+    elif key == &quot;IHREAL&quot;:		# first element of course
+        scanner.push(scanner.token)
+    try:
+        game.probe = getcourse(isprobe=True)
+    except TrekError:
+        return
+    game.nprobes -= 1
+    schedule(FDSPROB, 0.01) # Time to move one sector
+    prout(_(&quot;Ensign Chekov-  \&quot;The deep space probe is launched, Captain.\&quot;&quot;))
+    game.ididit = True
+    return
+
+def mayday():
+    &quot;Yell for help from nearest starbase.&quot;
+    # There's more than one way to move in this game! 
+    scanner.chew()
+    # Test for conditions which prevent calling for help 
+    if game.condition == &quot;docked&quot;:
+	prout(_(&quot;Lt. Uhura-  \&quot;But Captain, we're already docked.\&quot;&quot;))
+	return
+    if damaged(DRADIO):
+	prout(_(&quot;Subspace radio damaged.&quot;))
+	return
+    if not game.state.baseq:
+	prout(_(&quot;Lt. Uhura-  \&quot;Captain, I'm not getting any response from Starbase.\&quot;&quot;))
+	return
+    if game.landed:
+	prout(_(&quot;You must be aboard the %s.&quot;) % crmshp())
+	return
+    # OK -- call for help from nearest starbase 
+    game.nhelp += 1
+    if game.base.i!=0:
+	# There's one in this quadrant 
+	ddist = (game.base - game.sector).distance()
+    else:
+	ddist = FOREVER
+        for ibq in game.state.baseq:
+	    xdist = QUADSIZE * (ibq - game.quadrant).distance()
+	    if xdist &lt; ddist:
+		ddist = xdist
+	# Since starbase not in quadrant, set up new quadrant 
+	game.quadrant = ibq
+	newqad()
+    # dematerialize starship 
+    game.quad[game.sector.i][game.sector.j]='.'
+    proutn(_(&quot;Starbase in Quadrant %s responds--%s dematerializes&quot;) \
+           % (game.quadrant, crmshp()))
+    game.sector.invalidate()
+    for m in range(1, 5+1):
+        w = game.base.scatter() 
+	if w.valid_sector() and game.quad[w.i][w.j]=='.':
+	    # found one -- finish up 
+            game.sector = w
+	    break
+    if not game.sector.is_valid():
+	prout(_(&quot;You have been lost in space...&quot;))
+	finish(FMATERIALIZE)
+	return
+    # Give starbase three chances to rematerialize starship 
+    probf = math.pow((1.0 - math.pow(0.98,ddist)), 0.33333333)
+    for m in range(1, 3+1):
+	if m == 1: proutn(_(&quot;1st&quot;))
+	elif m == 2: proutn(_(&quot;2nd&quot;))
+	elif m == 3: proutn(_(&quot;3rd&quot;))
+	proutn(_(&quot; attempt to re-materialize &quot;) + crmshp())
+	game.quad[ix][iy]=('-','o','O')[m-1]
+        textcolor(RED)
+	warble()
+	if randreal() &gt; probf:
+	    break
+	prout(_(&quot;fails.&quot;))
+        textcolor(DEFAULT)
+	curses.delay_output(500)
+    if m &gt; 3:
+	game.quad[ix][iy]='?'
+	game.alive = False
+	drawmaps(1)
+	setwnd(message_window)
+	finish(FMATERIALIZE)
+	return
+    game.quad[ix][iy]=game.ship
+    textcolor(GREEN);
+    prout(_(&quot;succeeds.&quot;))
+    textcolor(DEFAULT);
+    dock(False)
+    skip(1)
+    prout(_(&quot;Lt. Uhura-  \&quot;Captain, we made it!\&quot;&quot;))
+
+def abandon():
+    &quot;Abandon ship.&quot;
+    scanner.chew()
+    if game.condition==&quot;docked&quot;:
+	if game.ship!='E':
+	    prout(_(&quot;You cannot abandon Ye Faerie Queene.&quot;))
+	    return
+    else:
+	# Must take shuttle craft to exit 
+	if game.damage[DSHUTTL]==-1:
+	    prout(_(&quot;Ye Faerie Queene has no shuttle craft.&quot;))
+	    return
+	if game.damage[DSHUTTL]&lt;0:
+	    prout(_(&quot;Shuttle craft now serving Big Macs.&quot;))
+	    return
+	if game.damage[DSHUTTL]&gt;0:
+	    prout(_(&quot;Shuttle craft damaged.&quot;))
+	    return
+	if game.landed:
+	    prout(_(&quot;You must be aboard the ship.&quot;))
+	    return
+	if game.iscraft != &quot;onship&quot;:
+	    prout(_(&quot;Shuttle craft not currently available.&quot;))
+	    return
+	# Emit abandon ship messages 
+	skip(1)
+	prouts(_(&quot;***ABANDON SHIP!  ABANDON SHIP!&quot;))
+	skip(1)
+	prouts(_(&quot;***ALL HANDS ABANDON SHIP!&quot;))
+	skip(2)
+	prout(_(&quot;Captain and crew escape in shuttle craft.&quot;))
+	if not game.state.baseq:
+	    # Oops! no place to go... 
+	    finish(FABANDN)
+	    return
+	q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
+	# Dispose of crew 
+	if not (game.options &amp; OPTION_WORLDS) and not damaged(DTRANSP):
+	    prout(_(&quot;Remainder of ship's complement beam down&quot;))
+	    prout(_(&quot;to nearest habitable planet.&quot;))
+	elif q.planet != None and not damaged(DTRANSP):
+	    prout(_(&quot;Remainder of ship's complement beam down to %s.&quot;) %
+		    q.planet)
+	else:
+	    prout(_(&quot;Entire crew of %d left to die in outer space.&quot;) %
+		    game.state.crew)
+	    game.casual += game.state.crew
+	    game.abandoned += game.state.crew
+	# If at least one base left, give 'em the Faerie Queene 
+	skip(1)
+	game.icrystl = False # crystals are lost 
+	game.nprobes = 0 # No probes 
+	prout(_(&quot;You are captured by Klingons and released to&quot;))
+	prout(_(&quot;the Federation in a prisoner-of-war exchange.&quot;))
+	nb = randrange(len(game.state.baseq))
+	# Set up quadrant and position FQ adjacient to base 
+	if not game.quadrant == game.state.baseq[nb]:
+	    game.quadrant = game.state.baseq[nb]
+	    game.sector.i = game.sector.j = 5
+	    newqad()
+	while True:
+	    # position next to base by trial and error 
+	    game.quad[game.sector.i][game.sector.j] = '.'
+	    for l in range(QUADSIZE):
+		game.sector = game.base.scatter()
+		if game.sector.valid_sector() and \
+                       game.quad[game.sector.i][game.sector.j] == '.':
+                    break
+	    if l &lt; QUADSIZE+1:
+		break # found a spot 
+	    game.sector.i=QUADSIZE/2
+	    game.sector.j=QUADSIZE/2
+	    newqad()
+    # Get new commission 
+    game.quad[game.sector.i][game.sector.j] = game.ship = 'F'
+    game.state.crew = FULLCREW
+    prout(_(&quot;Starfleet puts you in command of another ship,&quot;))
+    prout(_(&quot;the Faerie Queene, which is antiquated but,&quot;))
+    prout(_(&quot;still useable.&quot;))
+    if game.icrystl:
+	prout(_(&quot;The dilithium crystals have been moved.&quot;))
+    game.imine = False
+    game.iscraft = &quot;offship&quot; # Galileo disappears 
+    # Resupply ship 
+    game.condition=&quot;docked&quot;
+    for l in range(NDEVICES): 
+	game.damage[l] = 0.0
+    game.damage[DSHUTTL] = -1
+    game.energy = game.inenrg = 3000.0
+    game.shield = game.inshld = 1250.0
+    game.torps = game.intorps = 6
+    game.lsupres=game.inlsr=3.0
+    game.shldup=False
+    game.warpfac=5.0
+    return
+
+# Code from planets.c begins here.
+
+def consumeTime():
+    &quot;Abort a lengthy operation if an event interrupts it.&quot; 
+    game.ididit = True
+    events()
+    if game.alldone or game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova or game.justin: 
+	return True
+    return False
+
+def survey():
+    &quot;Report on (uninhabited) planets in the galaxy.&quot;
+    iknow = False
+    skip(1)
+    scanner.chew()
+    prout(_(&quot;Spock-  \&quot;Planet report follows, Captain.\&quot;&quot;))
+    skip(1)
+    for i in range(game.inplan):
+	if game.state.planets[i].pclass == &quot;destroyed&quot;:
+	    continue
+	if (game.state.planets[i].known != &quot;unknown&quot; \
+            and not game.state.planets[i].inhabited) \
+            or idebug:
+	    iknow = True
+	    if idebug and game.state.planets[i].known==&quot;unknown&quot;:
+		proutn(&quot;(Unknown) &quot;)
+	    proutn(_(&quot;Quadrant %s&quot;) % game.state.planets[i].quadrant)
+	    proutn(_(&quot;   class &quot;))
+	    proutn(game.state.planets[i].pclass)
+	    proutn(&quot;   &quot;)
+	    if game.state.planets[i].crystals != present:
+		proutn(_(&quot;no &quot;))
+	    prout(_(&quot;dilithium crystals present.&quot;))
+	    if game.state.planets[i].known==&quot;shuttle_down&quot;: 
+		prout(_(&quot;    Shuttle Craft Galileo on surface.&quot;))
+    if not iknow:
+	prout(_(&quot;No information available.&quot;))
+
+def orbit():
+    &quot;Enter standard orbit.&quot; 
+    skip(1)
+    scanner.chew()
+    if game.inorbit:
+	prout(_(&quot;Already in standard orbit.&quot;))
+	return
+    if damaged(DWARPEN) and damaged(DIMPULS):
+	prout(_(&quot;Both warp and impulse engines damaged.&quot;))
+	return
+    if not game.plnet.is_valid():
+        prout(&quot;There is no planet in this sector.&quot;)
+        return
+    if abs(game.sector.i-game.plnet.i)&gt;1 or abs(game.sector.j-game.plnet.j)&gt;1:
+	prout(crmshp() + _(&quot; not adjacent to planet.&quot;))
+	skip(1)
+	return
+    game.optime = randreal(0.02, 0.05)
+    prout(_(&quot;Helmsman Sulu-  \&quot;Entering standard orbit, Sir.\&quot;&quot;))
+    newcnd()
+    if consumeTime():
+	return
+    game.height = randreal(1400, 8600)
+    prout(_(&quot;Sulu-  \&quot;Entered orbit at altitude %.2f kilometers.\&quot;&quot;) % game.height)
+    game.inorbit = True
+    game.ididit = True
+
+def sensor():
+    &quot;Examine planets in this quadrant.&quot;
+    if damaged(DSRSENS):
+	if game.options &amp; OPTION_TTY:
+	    prout(_(&quot;Short range sensors damaged.&quot;))
+	return
+    if game.iplnet == None:
+	if game.options &amp; OPTION_TTY:
+	    prout(_(&quot;Spock- \&quot;No planet in this quadrant, Captain.\&quot;&quot;))
+	return
+    if game.iplnet.known == &quot;unknown&quot;:
+	prout(_(&quot;Spock-  \&quot;Sensor scan for Quadrant %s-&quot;) % game.quadrant)
+	skip(1)
+	prout(_(&quot;         Planet at Sector %s is of class %s.&quot;) %
+	      (game.plnet, game.iplnet.pclass))
+	if game.iplnet.known==&quot;shuttle_down&quot;: 
+	    prout(_(&quot;         Sensors show Galileo still on surface.&quot;))
+	proutn(_(&quot;         Readings indicate&quot;))
+	if game.iplnet.crystals != &quot;present&quot;:
+	    proutn(_(&quot; no&quot;))
+	prout(_(&quot; dilithium crystals present.\&quot;&quot;))
+	if game.iplnet.known == &quot;unknown&quot;:
+	    game.iplnet.known = &quot;known&quot;
+    elif game.iplnet.inhabited:
+        prout(_(&quot;Spock-  \&quot;The inhabited planet %s &quot;) % game.iplnet.name)
+        prout(_(&quot;        is located at Sector %s, Captain.\&quot;&quot;) % game.plnet)
+
+def beam():
+    &quot;Use the transporter.&quot;
+    nrgneed = 0
+    scanner.chew()
+    skip(1)
+    if damaged(DTRANSP):
+	prout(_(&quot;Transporter damaged.&quot;))
+	if not damaged(DSHUTTL) and (game.iplnet.known==&quot;shuttle_down&quot; or game.iscraft == &quot;onship&quot;):
+	    skip(1)
+	    proutn(_(&quot;Spock-  \&quot;May I suggest the shuttle craft, Sir?\&quot; &quot;))
+	    if ja() == True:
+		shuttle()
+	return
+    if not game.inorbit:
+	prout(crmshp() + _(&quot; not in standard orbit.&quot;))
+	return
+    if game.shldup:
+	prout(_(&quot;Impossible to transport through shields.&quot;))
+	return
+    if game.iplnet.known==&quot;unknown&quot;:
+	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
+	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
+	prout(_(&quot;  you may not go down.\&quot;&quot;))
+	return
+    if not game.landed and game.iplnet.crystals==&quot;absent&quot;:
+	prout(_(&quot;Spock-  \&quot;Captain, I fail to see the logic in&quot;))
+	prout(_(&quot;  exploring a planet with no dilithium crystals.&quot;))
+	proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
+	if ja() == False:
+	    scanner.chew()
+	    return
+    if not (game.options &amp; OPTION_PLAIN):
+	nrgneed = 50 * game.skill + game.height / 100.0
+	if nrgneed &gt; game.energy:
+    	    prout(_(&quot;Engineering to bridge--&quot;))
+	    prout(_(&quot;  Captain, we don't have enough energy for transportation.&quot;))
+	    return
+	if not game.landed and nrgneed * 2 &gt; game.energy:
+    	    prout(_(&quot;Engineering to bridge--&quot;))
+	    prout(_(&quot;  Captain, we have enough energy only to transport you down to&quot;))
+	    prout(_(&quot;  the planet, but there wouldn't be an energy for the trip back.&quot;))
+	    if game.iplnet.known == &quot;shuttle_down&quot;:
+		prout(_(&quot;  Although the Galileo shuttle craft may still be on a surface.&quot;))
+	    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
+	    if ja() == False:
+		scanner.chew()
+		return
+    if game.landed:
+	# Coming from planet 
+	if game.iplnet.known==&quot;shuttle_down&quot;:
+	    proutn(_(&quot;Spock-  \&quot;Wouldn't you rather take the Galileo?\&quot; &quot;))
+	    if ja() == True:
+		scanner.chew()
+		return
+	    prout(_(&quot;Your crew hides the Galileo to prevent capture by aliens.&quot;))
+	prout(_(&quot;Landing party assembled, ready to beam up.&quot;))
+	skip(1)
+	prout(_(&quot;Kirk whips out communicator...&quot;))
+	prouts(_(&quot;BEEP  BEEP  BEEP&quot;))
+	skip(2)
+	prout(_(&quot;\&quot;Kirk to enterprise-  Lock on coordinates...energize.\&quot;&quot;))
+    else:
+	# Going to planet 
+	prout(_(&quot;Scotty-  \&quot;Transporter room ready, Sir.\&quot;&quot;))
+	skip(1)
+	prout(_(&quot;Kirk and landing party prepare to beam down to planet surface.&quot;))
+	skip(1)
+	prout(_(&quot;Kirk-  \&quot;Energize.\&quot;&quot;))
+    game.ididit = True
+    skip(1)
+    prouts(&quot;WWHOOOIIIIIRRRRREEEE.E.E.  .  .  .  .   .    .&quot;)
+    skip(2)
+    if withprob(0.98):
+	prouts(&quot;BOOOIIIOOOIIOOOOIIIOIING . . .&quot;)
+	skip(2)
+	prout(_(&quot;Scotty-  \&quot;Oh my God!  I've lost them.\&quot;&quot;))
+	finish(FLOST)
+	return
+    prouts(&quot;.    .   .  .  .  .  .E.E.EEEERRRRRIIIIIOOOHWW&quot;)
+    game.landed = not game.landed
+    game.energy -= nrgneed
+    skip(2)
+    prout(_(&quot;Transport complete.&quot;))
+    if game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
+	prout(_(&quot;The shuttle craft Galileo is here!&quot;))
+    if not game.landed and game.imine:
+	game.icrystl = True
+	game.cryprob = 0.05
+    game.imine = False
+    return
+
+def mine():
+    &quot;Strip-mine a world for dilithium.&quot;
+    skip(1)
+    scanner.chew()
+    if not game.landed:
+	prout(_(&quot;Mining party not on planet.&quot;))
+	return
+    if game.iplnet.crystals == &quot;mined&quot;:
+	prout(_(&quot;This planet has already been strip-mined for dilithium.&quot;))
+	return
+    elif game.iplnet.crystals == &quot;absent&quot;:
+	prout(_(&quot;No dilithium crystals on this planet.&quot;))
+	return
+    if game.imine:
+	prout(_(&quot;You've already mined enough crystals for this trip.&quot;))
+	return
+    if game.icrystl and game.cryprob == 0.05:
+	prout(_(&quot;With all those fresh crystals aboard the &quot;) + crmshp())
+	prout(_(&quot;there's no reason to mine more at this time.&quot;))
+	return
+    game.optime = randreal(0.1, 0.3)*(ord(game.iplnet.pclass)-ord(&quot;L&quot;))
+    if consumeTime():
+	return
+    prout(_(&quot;Mining operation complete.&quot;))
+    game.iplnet.crystals = &quot;mined&quot;
+    game.imine = game.ididit = True
+
+def usecrystals():
+    &quot;Use dilithium crystals.&quot;
+    game.ididit = False
+    skip(1)
+    scanner.chew()
+    if not game.icrystl:
+	prout(_(&quot;No dilithium crystals available.&quot;))
+	return
+    if game.energy &gt;= 1000:
+	prout(_(&quot;Spock-  \&quot;Captain, Starfleet Regulations prohibit such an operation&quot;))
+	prout(_(&quot;  except when Condition Yellow exists.&quot;))
+	return
+    prout(_(&quot;Spock- \&quot;Captain, I must warn you that loading&quot;))
+    prout(_(&quot;  raw dilithium crystals into the ship's power&quot;))
+    prout(_(&quot;  system may risk a severe explosion.&quot;))
+    proutn(_(&quot;  Are you sure this is wise?\&quot; &quot;))
+    if ja() == False:
+	scanner.chew()
+	return
+    skip(1)
+    prout(_(&quot;Engineering Officer Scott-  \&quot;(GULP) Aye Sir.&quot;))
+    prout(_(&quot;  Mr. Spock and I will try it.\&quot;&quot;))
+    skip(1)
+    prout(_(&quot;Spock-  \&quot;Crystals in place, Sir.&quot;))
+    prout(_(&quot;  Ready to activate circuit.\&quot;&quot;))
+    skip(1)
+    prouts(_(&quot;Scotty-  \&quot;Keep your fingers crossed, Sir!\&quot;&quot;))
+    skip(1)
+    if withprob(game.cryprob):
+	prouts(_(&quot;  \&quot;Activating now! - - No good!  It's***&quot;))
+	skip(2)
+	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
+	skip(1)
+	stars()
+	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
+	skip(1)
+	kaboom()
+	return
+    game.energy += randreal(5000.0, 5500.0)
+    prouts(_(&quot;  \&quot;Activating now! - - &quot;))
+    prout(_(&quot;The instruments&quot;))
+    prout(_(&quot;   are going crazy, but I think it's&quot;))
+    prout(_(&quot;   going to work!!  Congratulations, Sir!\&quot;&quot;))
+    game.cryprob *= 2.0
+    game.ididit = True
+
+def shuttle():
+    &quot;Use shuttlecraft for planetary jaunt.&quot;
+    scanner.chew()
+    skip(1)
+    if damaged(DSHUTTL):
+	if game.damage[DSHUTTL] == -1.0:
+	    if game.inorbit and game.iplnet.known == &quot;shuttle_down&quot;:
+		prout(_(&quot;Ye Faerie Queene has no shuttle craft bay to dock it at.&quot;))
+	    else:
+		prout(_(&quot;Ye Faerie Queene had no shuttle craft.&quot;))
+	elif game.damage[DSHUTTL] &gt; 0:
+	    prout(_(&quot;The Galileo is damaged.&quot;))
+	else: # game.damage[DSHUTTL] &lt; 0  
+	    prout(_(&quot;Shuttle craft is now serving Big Macs.&quot;))
+	return
+    if not game.inorbit:
+	prout(crmshp() + _(&quot; not in standard orbit.&quot;))
+	return
+    if (game.iplnet.known != &quot;shuttle_down&quot;) and game.iscraft != &quot;onship&quot;:
+	prout(_(&quot;Shuttle craft not currently available.&quot;))
+	return
+    if not game.landed and game.iplnet.known==&quot;shuttle_down&quot;:
+	prout(_(&quot;You will have to beam down to retrieve the shuttle craft.&quot;))
+	return
+    if game.shldup or game.condition == &quot;docked&quot;:
+	prout(_(&quot;Shuttle craft cannot pass through shields.&quot;))
+	return
+    if game.iplnet.known==&quot;unknown&quot;:
+	prout(_(&quot;Spock-  \&quot;Captain, we have no information on this planet&quot;))
+	prout(_(&quot;  and Starfleet Regulations clearly state that in this situation&quot;))
+	prout(_(&quot;  you may not fly down.\&quot;&quot;))
+	return
+    game.optime = 3.0e-5*game.height
+    if game.optime &gt;= 0.8*game.state.remtime:
+	prout(_(&quot;First Officer Spock-  \&quot;Captain, I compute that such&quot;))
+	proutn(_(&quot;  a maneuver would require approximately %2d%% of our&quot;) % \
+	       int(100*game.optime/game.state.remtime))
+	prout(_(&quot;remaining time.&quot;))
+	proutn(_(&quot;Are you sure this is wise?\&quot; &quot;))
+	if ja() == False:
+	    game.optime = 0.0
+	    return
+    if game.landed:
+	# Kirk on planet 
+	if game.iscraft == &quot;onship&quot;:
+	    # Galileo on ship! 
+	    if not damaged(DTRANSP):
+		proutn(_(&quot;Spock-  \&quot;Would you rather use the transporter?\&quot; &quot;))
+		if ja() == True:
+		    beam()
+		    return
+		proutn(_(&quot;Shuttle crew&quot;))
+	    else:
+		proutn(_(&quot;Rescue party&quot;))
+	    prout(_(&quot; boards Galileo and swoops toward planet surface.&quot;))
+	    game.iscraft = &quot;offship&quot;
+	    skip(1)
+	    if consumeTime():
+		return
+	    game.iplnet.known=&quot;shuttle_down&quot;
+	    prout(_(&quot;Trip complete.&quot;))
+	    return
+	else:
+	    # Ready to go back to ship 
+	    prout(_(&quot;You and your mining party board the&quot;))
+	    prout(_(&quot;shuttle craft for the trip back to the Enterprise.&quot;))
+	    skip(1)
+	    prouts(_(&quot;The short hop begins . . .&quot;))
+	    skip(1)
+	    game.iplnet.known=&quot;known&quot;
+	    game.icraft = True
+	    skip(1)
+	    game.landed = False
+	    if consumeTime():
+		return
+	    game.iscraft = &quot;onship&quot;
+	    game.icraft = False
+	    if game.imine:
+		game.icrystl = True
+		game.cryprob = 0.05
+	    game.imine = False
+	    prout(_(&quot;Trip complete.&quot;))
+	    return
+    else:
+	# Kirk on ship and so is Galileo 
+	prout(_(&quot;Mining party assembles in the hangar deck,&quot;))
+	prout(_(&quot;ready to board the shuttle craft \&quot;Galileo\&quot;.&quot;))
+	skip(1)
+	prouts(_(&quot;The hangar doors open; the trip begins.&quot;))
+	skip(1)
+	game.icraft = True
+	game.iscraft = &quot;offship&quot;
+	if consumeTime():
+	    return
+	game.iplnet.known = &quot;shuttle_down&quot;
+	game.landed = True
+	game.icraft = False
+	prout(_(&quot;Trip complete.&quot;))
+	return
+
+def deathray():
+    &quot;Use the big zapper.&quot;
+    game.ididit = False
+    skip(1)
+    scanner.chew()
+    if game.ship != 'E':
+	prout(_(&quot;Ye Faerie Queene has no death ray.&quot;))
+	return
+    if len(game.enemies)==0:
+	prout(_(&quot;Sulu-  \&quot;But Sir, there are no enemies in this quadrant.\&quot;&quot;))
+	return
+    if damaged(DDRAY):
+	prout(_(&quot;Death Ray is damaged.&quot;))
+	return
+    prout(_(&quot;Spock-  \&quot;Captain, the 'Experimental Death Ray'&quot;))
+    prout(_(&quot;  is highly unpredictible.  Considering the alternatives,&quot;))
+    proutn(_(&quot;  are you sure this is wise?\&quot; &quot;))
+    if ja() == False:
+	return
+    prout(_(&quot;Spock-  \&quot;Acknowledged.\&quot;&quot;))
+    skip(1)
+    game.ididit = True
+    prouts(_(&quot;WHOOEE ... WHOOEE ... WHOOEE ... WHOOEE&quot;))
+    skip(1)
+    prout(_(&quot;Crew scrambles in emergency preparation.&quot;))
+    prout(_(&quot;Spock and Scotty ready the death ray and&quot;))
+    prout(_(&quot;prepare to channel all ship's power to the device.&quot;))
+    skip(1)
+    prout(_(&quot;Spock-  \&quot;Preparations complete, sir.\&quot;&quot;))
+    prout(_(&quot;Kirk-  \&quot;Engage!\&quot;&quot;))
+    skip(1)
+    prouts(_(&quot;WHIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR&quot;))
+    skip(1)
+    dprob = 0.30
+    if game.options &amp; OPTION_PLAIN:
+	dprob = 0.5
+    r = randreal()
+    if r &gt; dprob:
+	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
+	skip(2)
+	while len(game.enemies) &gt; 0:
+	    deadkl(game.enemies[1].location, game.quad[game.enemies[1].location.i][game.enemies[1].location.j],game.enemies[1].location)
+	prout(_(&quot;Ensign Chekov-  \&quot;Congratulations, Captain!\&quot;&quot;))
+	if (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem) == 0:
+	    finish(FWON)    
+	if (game.options &amp; OPTION_PLAIN) == 0:
+	    prout(_(&quot;Spock-  \&quot;Captain, I believe the `Experimental Death Ray'&quot;))
+	    if withprob(0.05):
+		prout(_(&quot;   is still operational.\&quot;&quot;))
+	    else:
+		prout(_(&quot;   has been rendered nonfunctional.\&quot;&quot;))
+		game.damage[DDRAY] = 39.95
+	return
+    r = randreal()	# Pick failure method 
+    if r &lt;= 0.30:
+	prouts(_(&quot;Sulu- \&quot;Captain!  It's working!\&quot;&quot;))
+	skip(1)
+	prouts(_(&quot;***RED ALERT!  RED ALERT!&quot;))
+	skip(1)
+	prout(_(&quot;***MATTER-ANTIMATTER IMPLOSION IMMINENT!&quot;))
+	skip(1)
+	prouts(_(&quot;***RED ALERT!  RED A*L********************************&quot;))
+	skip(1)
+	stars()
+	prouts(_(&quot;******************   KA-BOOM!!!!   *******************&quot;))
+	skip(1)
+	kaboom()
+	return
+    if r &lt;= 0.55:
+	prouts(_(&quot;Sulu- \&quot;Captain!  Yagabandaghangrapl, brachriigringlanbla!\&quot;&quot;))
+	skip(1)
+	prout(_(&quot;Lt. Uhura-  \&quot;Graaeek!  Graaeek!\&quot;&quot;))
+	skip(1)
+	prout(_(&quot;Spock-  \&quot;Fascinating!  . . . All humans aboard&quot;))
+	prout(_(&quot;  have apparently been transformed into strange mutations.&quot;))
+	prout(_(&quot;  Vulcans do not seem to be affected.&quot;))
+	skip(1)
+	prout(_(&quot;Kirk-  \&quot;Raauch!  Raauch!\&quot;&quot;))
+	finish(FDRAY)
+	return
+    if r &lt;= 0.75:
+	intj
+	prouts(_(&quot;Sulu- \&quot;Captain!  It's   --WHAT?!?!\&quot;&quot;))
+	skip(2)
+	proutn(_(&quot;Spock-  \&quot;I believe the word is&quot;))
+	prouts(_(&quot; *ASTONISHING*&quot;))
+	prout(_(&quot; Mr. Sulu.&quot;))
+	for i in range(QUADSIZE):
+	    for j in range(QUADSIZE):
+		if game.quad[i][j] == '.':
+		    game.quad[i][j] = '?'
+	prout(_(&quot;  Captain, our quadrant is now infested with&quot;))
+	prouts(_(&quot; - - - - - -  *THINGS*.&quot;))
+	skip(1)
+	prout(_(&quot;  I have no logical explanation.\&quot;&quot;))
+	return
+    prouts(_(&quot;Sulu- \&quot;Captain!  The Death Ray is creating tribbles!\&quot;&quot;))
+    skip(1)
+    prout(_(&quot;Scotty-  \&quot;There are so many tribbles down here&quot;))
+    prout(_(&quot;  in Engineering, we can't move for 'em, Captain.\&quot;&quot;))
+    finish(FTRIBBLE)
+    return
+
+# Code from reports.c begins here
+
+def attackreport(curt):
+    &quot;eport status of bases under attack.&quot;
+    if not curt:
+	if is_scheduled(FCDBAS):
+	    prout(_(&quot;Starbase in Quadrant %s is currently under Commander attack.&quot;) % game.battle)
+	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FCDBAS)))
+	elif game.isatb == 1:
+	    prout(_(&quot;Starbase in Quadrant %s is under Super-commander attack.&quot;) % game.state.kscmdr)
+	    prout(_(&quot;It can hold out until Stardate %d.&quot;) % int(scheduled(FSCDBAS)))
+	else:
+	    prout(_(&quot;No Starbase is currently under attack.&quot;))
+    else:
+        if is_scheduled(FCDBAS):
+	    proutn(_(&quot;Base in %s attacked by C. Alive until %.1f&quot;) % (game.battle, scheduled(FCDBAS)))
+        if game.isatb:
+	    proutn(_(&quot;Base in %s attacked by S. Alive until %.1f&quot;) % (game.state.kscmdr, scheduled(FSCDBAS)))
+	clreol()
+
+def report():
+    # report on general game status 
+    scanner.chew()
+    s1 = &quot;&quot; and game.thawed and _(&quot;thawed &quot;)
+    s2 = {1:&quot;short&quot;, 2:&quot;medium&quot;, 4:&quot;long&quot;}[game.length]
+    s3 = (None, _(&quot;novice&quot;), _(&quot;fair&quot;),
+          _(&quot;good&quot;), _(&quot;expert&quot;), _(&quot;emeritus&quot;))[game.skill]
+    prout(_(&quot;You %s a %s%s %s game.&quot;) % ((_(&quot;were playing&quot;), _(&quot;are playing&quot;))[game.alldone], s1, s2, s3))
+    if game.skill&gt;SKILL_GOOD and game.thawed and not game.alldone:
+	prout(_(&quot;No plaque is allowed.&quot;))
+    if game.tourn:
+	prout(_(&quot;This is tournament game %d.&quot;) % game.tourn)
+    prout(_(&quot;Your secret password is \&quot;%s\&quot;&quot;) % game.passwd)
+    proutn(_(&quot;%d of %d Klingons have been killed&quot;) % (((game.inkling + game.incom + game.inscom) - (game.state.remkl + len(game.state.kcmdr) + game.state.nscrem)), 
+	   (game.inkling + game.incom + game.inscom)))
+    if game.incom - len(game.state.kcmdr):
+	prout(_(&quot;, including %d Commander%s.&quot;) % (game.incom - len(game.state.kcmdr), (_(&quot;s&quot;), &quot;&quot;)[(game.incom - len(game.state.kcmdr))==1]))
+    elif game.inkling - game.state.remkl + (game.inscom - game.state.nscrem) &gt; 0:
+	prout(_(&quot;, but no Commanders.&quot;))
+    else:
+	prout(&quot;.&quot;)
+    if game.skill &gt; SKILL_FAIR:
+	prout(_(&quot;The Super Commander has %sbeen destroyed.&quot;) % (&quot;&quot;, _(&quot;not &quot;))[game.state.nscrem])
+    if len(game.state.baseq) != game.inbase:
+	proutn(_(&quot;There &quot;))
+	if game.inbase-len(game.state.baseq)==1:
+	    proutn(_(&quot;has been 1 base&quot;))
+	else:
+	    proutn(_(&quot;have been %d bases&quot;) % (game.inbase-len(game.state.baseq)))
+	prout(_(&quot; destroyed, %d remaining.&quot;) % len(game.state.baseq))
+    else:
+	prout(_(&quot;There are %d bases.&quot;) % game.inbase)
+    if communicating() or game.iseenit:
+	# Don't report this if not seen and
+	# either the radio is dead or not at base!
+	attackreport(False)
+	game.iseenit = True
+    if game.casual: 
+	prout(_(&quot;%d casualt%s suffered so far.&quot;) % (game.casual, (&quot;y&quot;, &quot;ies&quot;)[game.casual!=1]))
+    if game.nhelp:
+	prout(_(&quot;There were %d call%s for help.&quot;) % (game.nhelp,  (&quot;&quot; , _(&quot;s&quot;))[game.nhelp!=1]))
+    if game.ship == 'E':
+	proutn(_(&quot;You have &quot;))
+	if game.nprobes:
+	    proutn(&quot;%d&quot; % (game.nprobes))
+	else:
+	    proutn(_(&quot;no&quot;))
+	proutn(_(&quot; deep space probe&quot;))
+	if game.nprobes!=1:
+	    proutn(_(&quot;s&quot;))
+	prout(&quot;.&quot;)
+    if communicating() and is_scheduled(FDSPROB):
+	if game.isarmed: 
+	    proutn(_(&quot;An armed deep space probe is in &quot;))
+	else:
+	    proutn(_(&quot;A deep space probe is in &quot;))
+	prout(&quot;Quadrant %s.&quot; % game.probec)
+    if game.icrystl:
+	if game.cryprob &lt;= .05:
+	    prout(_(&quot;Dilithium crystals aboard ship... not yet used.&quot;))
+	else:
+	    i=0
+	    ai = 0.05
+	    while game.cryprob &gt; ai:
+		ai *= 2.0
+		i += 1
+	    prout(_(&quot;Dilithium crystals have been used %d time%s.&quot;) % \
+                  (i, (_(&quot;s&quot;), &quot;&quot;)[i==1]))
+    skip(1)
+	
+def lrscan(silent):
+    &quot;Long-range sensor scan.&quot;
+    if damaged(DLRSENS):
+	# Now allow base's sensors if docked 
+	if game.condition != &quot;docked&quot;:
+            if not silent:
+                prout(_(&quot;LONG-RANGE SENSORS DAMAGED.&quot;))
+	    return
+        if not silent:
+            prout(_(&quot;Starbase's long-range scan&quot;))
+    elif not silent:
+	prout(_(&quot;Long-range scan&quot;))
+    for x in range(game.quadrant.i-1, game.quadrant.i+2):
+        if not silent:
+            proutn(&quot; &quot;)
+        for y in range(game.quadrant.j-1, game.quadrant.j+2):
+	    if not coord(x, y).valid_quadrant():
+                if not silent:
+                    proutn(&quot;  -1&quot;)
+	    else:
+		if not damaged(DRADIO):
+		    game.state.galaxy[x][y].charted = True
+		game.state.chart[x][y].klingons = game.state.galaxy[x][y].klingons
+		game.state.chart[x][y].starbase = game.state.galaxy[x][y].starbase
+		game.state.chart[x][y].stars = game.state.galaxy[x][y].stars
+		if not silent and game.state.galaxy[x][y].supernova: 
+		    proutn(&quot; ***&quot;)
+		elif not silent:
+		    proutn(&quot; %3d&quot; % (game.state.chart[x][y].klingons*100 + game.state.chart[x][y].starbase * 10 + game.state.chart[x][y].stars))
+	if not silent:
+	    prout(&quot; &quot;)
+
+def damagereport():
+    &quot;Damage report.&quot;
+    jdam = False
+    scanner.chew()
+    for i in range(NDEVICES):
+	if damaged(i):
+	    if not jdam:
+		prout(_(&quot;\tDEVICE\t\t\t-REPAIR TIMES-&quot;))
+		prout(_(&quot;\t\t\tIN FLIGHT\t\tDOCKED&quot;))
+		jdam = True
+	    prout(&quot;  %-26s\t%8.2f\t\t%8.2f&quot; % (device[i],
+                                               game.damage[i]+0.05,
+                                               DOCKFAC*game.damage[i]+0.005))
+    if not jdam:
+	prout(_(&quot;All devices functional.&quot;))
+
+def rechart():
+    &quot;Update the chart in the Enterprise's computer from galaxy data.&quot;
+    game.lastchart = game.state.date
+    for i in range(GALSIZE):
+	for j in range(GALSIZE):
+	    if game.state.galaxy[i][j].charted:
+		game.state.chart[i][j].klingons = game.state.galaxy[i][j].klingons
+		game.state.chart[i][j].starbase = game.state.galaxy[i][j].starbase
+		game.state.chart[i][j].stars = game.state.galaxy[i][j].stars
+
+def chart():
+    &quot;Display the star chart.&quot;
+    scanner.chew()
+    if (game.options &amp; OPTION_AUTOSCAN):
+        lrscan(silent=True)
+    if not damaged(DRADIO):
+	rechart()
+    if game.lastchart &lt; game.state.date and game.condition == &quot;docked&quot;:
+	prout(_(&quot;Spock-  \&quot;I revised the Star Chart from the starbase's records.\&quot;&quot;))
+	rechart()
+    prout(_(&quot;       STAR CHART FOR THE KNOWN GALAXY&quot;))
+    if game.state.date &gt; game.lastchart:
+	prout(_(&quot;(Last surveillance update %d stardates ago).&quot;) % ((int)(game.state.date-game.lastchart)))
+    prout(&quot;      1    2    3    4    5    6    7    8&quot;)
+    for i in range(GALSIZE):
+	proutn(&quot;%d |&quot; % (i+1))
+	for j in range(GALSIZE):
+	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
+		proutn(&quot;&lt;&quot;)
+	    else:
+		proutn(&quot; &quot;)
+	    if game.state.galaxy[i][j].supernova:
+		show = &quot;***&quot;
+	    elif not game.state.galaxy[i][j].charted and game.state.galaxy[i][j].starbase:
+		show = &quot;.1.&quot;
+	    elif game.state.galaxy[i][j].charted:
+		show = &quot;%3d&quot; % (game.state.chart[i][j].klingons*100 + game.state.chart[i][j].starbase * 10 + game.state.chart[i][j].stars)
+	    else:
+		show = &quot;...&quot;
+	    proutn(show)
+	    if (game.options &amp; OPTION_SHOWME) and i == game.quadrant.i and j == game.quadrant.j:
+		proutn(&quot;&gt;&quot;)
+	    else:
+		proutn(&quot; &quot;)
+	proutn(&quot;  |&quot;)
+	if i&lt;GALSIZE:
+	    skip(1)
+
+def sectscan(goodScan, i, j):
+    &quot;Light up an individual dot in a sector.&quot;
+    if goodScan or (abs(i-game.sector.i)&lt;= 1 and abs(j-game.sector.j) &lt;= 1):
+        textcolor({&quot;green&quot;:GREEN,
+                   &quot;yellow&quot;:YELLOW,
+                   &quot;red&quot;:RED,
+                   &quot;docked&quot;:CYAN,
+                   &quot;dead&quot;:BROWN}[game.condition]) 
+        if game.quad[i][j] != game.ship: 
+            highvideo();
+	proutn(&quot;%c &quot; % game.quad[i][j])
+        textcolor(DEFAULT)
+    else:
+	proutn(&quot;- &quot;)
+
+def status(req=0):
+    &quot;Emit status report lines&quot;
+    if not req or req == 1:
+	prstat(_(&quot;Stardate&quot;), _(&quot;%.1f, Time Left %.2f&quot;) \
+               % (game.state.date, game.state.remtime))
+    if not req or req == 2:
+	if game.condition != &quot;docked&quot;:
+	    newcnd()
+	prstat(_(&quot;Condition&quot;), _(&quot;%s, %i DAMAGES&quot;) % \
+               (game.condition.upper(), sum(map(lambda x: x &gt; 0, game.damage))))
+    if not req or req == 3:
+	prstat(_(&quot;Position&quot;), &quot;%s , %s&quot; % (game.quadrant, game.sector))
+    if not req or req == 4:
+	if damaged(DLIFSUP):
+	    if game.condition == &quot;docked&quot;:
+		s = _(&quot;DAMAGED, Base provides&quot;)
+	    else:
+		s = _(&quot;DAMAGED, reserves=%4.2f&quot;) % game.lsupres
+	else:
+	    s = _(&quot;ACTIVE&quot;)
+	prstat(_(&quot;Life Support&quot;), s)
+    if not req or req == 5:
+	prstat(_(&quot;Warp Factor&quot;), &quot;%.1f&quot; % game.warpfac)
+    if not req or req == 6:
+        extra = &quot;&quot;
+        if game.icrystl and (game.options &amp; OPTION_SHOWME):
+            extra = _(&quot; (have crystals)&quot;)
+	prstat(_(&quot;Energy&quot;), &quot;%.2f%s&quot; % (game.energy, extra))
+    if not req or req == 7:
+	prstat(_(&quot;Torpedoes&quot;), &quot;%d&quot; % (game.torps))
+    if not req or req == 8:
+	if damaged(DSHIELD):
+	    s = _(&quot;DAMAGED,&quot;)
+	elif game.shldup:
+	    s = _(&quot;UP,&quot;)
+	else:
+	    s = _(&quot;DOWN,&quot;)
+	data = _(&quot; %d%% %.1f units&quot;) \
+               % (int((100.0*game.shield)/game.inshld + 0.5), game.shield)
+	prstat(_(&quot;Shields&quot;), s+data)
+    if not req or req == 9:
+        prstat(_(&quot;Klingons Left&quot;), &quot;%d&quot; \
+               % (game.state.remkl+len(game.state.kcmdr)+game.state.nscrem))
+    if not req or req == 10:
+	if game.options &amp; OPTION_WORLDS:
+	    plnet = game.state.galaxy[game.quadrant.i][game.quadrant.j].planet
+	    if plnet and plnet.inhabited:
+		prstat(_(&quot;Major system&quot;), plnet.name)
+	    else:
+		prout(_(&quot;Sector is uninhabited&quot;))
+    elif not req or req == 11:
+	attackreport(not req)
+
+def request():
+    &quot;Request specified status data, a historical relic from slow TTYs.&quot;
+    requests = (&quot;da&quot;,&quot;co&quot;,&quot;po&quot;,&quot;ls&quot;,&quot;wa&quot;,&quot;en&quot;,&quot;to&quot;,&quot;sh&quot;,&quot;kl&quot;,&quot;sy&quot;, &quot;ti&quot;)
+    while scanner.next() == &quot;IHEOL&quot;:
+	proutn(_(&quot;Information desired? &quot;))
+    scanner.chew()
+    if scanner.token in requests:
+        status(requests.index(scanner.token))
+    else:
+	prout(_(&quot;UNRECOGNIZED REQUEST. Legal requests are:&quot;))
+	prout((&quot;  date, condition, position, lsupport, warpfactor,&quot;))
+	prout((&quot;  energy, torpedoes, shields, klingons, system, time.&quot;))
+		
+def srscan():
+    &quot;Short-range scan.&quot; 
+    goodScan=True
+    if damaged(DSRSENS):
+	# Allow base's sensors if docked 
+	if game.condition != &quot;docked&quot;:
+	    prout(_(&quot;   S.R. SENSORS DAMAGED!&quot;))
+	    goodScan=False
+	else:
+	    prout(_(&quot;  [Using Base's sensors]&quot;))
+    else:
+	prout(_(&quot;     Short-range scan&quot;))
+    if goodScan and not damaged(DRADIO): 
+	game.state.chart[game.quadrant.i][game.quadrant.j].klingons = game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons
+	game.state.chart[game.quadrant.i][game.quadrant.j].starbase = game.state.galaxy[game.quadrant.i][game.quadrant.j].starbase
+	game.state.chart[game.quadrant.i][game.quadrant.j].stars = game.state.galaxy[game.quadrant.i][game.quadrant.j].stars
+	game.state.galaxy[game.quadrant.i][game.quadrant.j].charted = True
+    prout(&quot;    1 2 3 4 5 6 7 8 9 10&quot;)
+    if game.condition != &quot;docked&quot;:
+	newcnd()
+    for i in range(QUADSIZE):
+	proutn(&quot;%2d  &quot; % (i+1))
+	for j in range(QUADSIZE):
+	    sectscan(goodScan, i, j)
+	skip(1)
+		
+def eta():
+    &quot;Use computer to get estimated time of arrival for a warp jump.&quot;
+    w1 = coord(); w2 = coord()
+    prompt = False
+    if damaged(DCOMPTR):
+	prout(_(&quot;COMPUTER DAMAGED, USE A POCKET CALCULATOR.&quot;))
+	skip(1)
+	return
+    if scanner.next() != &quot;IHREAL&quot;:
+	prompt = True
+	scanner.chew()
+	proutn(_(&quot;Destination quadrant and/or sector? &quot;))
+	if scanner.next()!=&quot;IHREAL&quot;:
+	    huh()
+	    return
+    w1.j = int(scanner.real-0.5)
+    if scanner.next() != &quot;IHREAL&quot;:
+	huh()
+	return
+    w1.i = int(scanner.real-0.5)
+    if scanner.next() == &quot;IHREAL&quot;:
+	w2.j = int(scanner.real-0.5)
+	if scanner.next() != &quot;IHREAL&quot;:
+	    huh()
+	    return
+	w2.i = int(scanner.real-0.5)
+    else:
+	if game.quadrant.j&gt;w1.i:
+	    w2.i = 0
+	else:
+	    w2.i=QUADSIZE-1
+	if game.quadrant.i&gt;w1.j:
+	    w2.j = 0
+	else:
+	    w2.j=QUADSIZE-1
+    if not w1.valid_quadrant() or not w2.valid_sector():
+	huh()
+	return
+    dist = math.sqrt((w1.j-game.quadrant.j+(w2.j-game.sector.j)/(QUADSIZE*1.0))**2+
+		(w1.i-game.quadrant.i+(w2.i-game.sector.i)/(QUADSIZE*1.0))**2)
+    wfl = False
+    if prompt:
+	prout(_(&quot;Answer \&quot;no\&quot; if you don't know the value:&quot;))
+    while True:
+	scanner.chew()
+	proutn(_(&quot;Time or arrival date? &quot;))
+	if scanner.next()==&quot;IHREAL&quot;:
+	    ttime = scanner.real
+	    if ttime &gt; game.state.date:
+		ttime -= game.state.date # Actually a star date
+            twarp=(math.floor(math.sqrt((10.0*dist)/ttime)*10.0)+1.0)/10.0
+            if ttime &lt;= 1e-10 or twarp &gt; 10:
+		prout(_(&quot;We'll never make it, sir.&quot;))
+		scanner.chew()
+		return
+	    if twarp &lt; 1.0:
+		twarp = 1.0
+	    break
+	scanner.chew()
+	proutn(_(&quot;Warp factor? &quot;))
+	if scanner.next()== &quot;IHREAL&quot;:
+	    wfl = True
+	    twarp = scanner.real
+	    if twarp&lt;1.0 or twarp &gt; 10.0:
+		huh()
+		return
+	    break
+	prout(_(&quot;Captain, certainly you can give me one of these.&quot;))
+    while True:
+	scanner.chew()
+	ttime = (10.0*dist)/twarp**2
+	tpower = dist*twarp*twarp*twarp*(game.shldup+1)
+	if tpower &gt;= game.energy:
+	    prout(_(&quot;Insufficient energy, sir.&quot;))
+	    if not game.shldup or tpower &gt; game.energy*2.0:
+		if not wfl:
+		    return
+		proutn(_(&quot;New warp factor to try? &quot;))
+		if scanner.next() == &quot;IHREAL&quot;:
+		    wfl = True
+		    twarp = scanner.real
+		    if twarp&lt;1.0 or twarp &gt; 10.0:
+			huh()
+			return
+		    continue
+		else:
+		    scanner.chew()
+		    skip(1)
+		    return
+	    prout(_(&quot;But if you lower your shields,&quot;))
+	    proutn(_(&quot;remaining&quot;))
+	    tpower /= 2
+	else:
+	    proutn(_(&quot;Remaining&quot;))
+	prout(_(&quot; energy will be %.2f.&quot;) % (game.energy-tpower))
+	if wfl:
+	    prout(_(&quot;And we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
+	elif twarp==1.0:
+	    prout(_(&quot;Any warp speed is adequate.&quot;))
+	else:
+	    prout(_(&quot;Minimum warp needed is %.2f,&quot;) % (twarp))
+	    prout(_(&quot;and we will arrive at stardate %.2f.&quot;) % (game.state.date+ttime))
+	if game.state.remtime &lt; ttime:
+	    prout(_(&quot;Unfortunately, the Federation will be destroyed by then.&quot;))
+	if twarp &gt; 6.0:
+	    prout(_(&quot;You'll be taking risks at that speed, Captain&quot;))
+	if (game.isatb==1 and game.state.kscmdr == w1 and \
+	     scheduled(FSCDBAS)&lt; ttime+game.state.date) or \
+	    (scheduled(FCDBAS)&lt;ttime+game.state.date and game.battle == w1):
+	    prout(_(&quot;The starbase there will be destroyed by then.&quot;))
+	proutn(_(&quot;New warp factor to try? &quot;))
+	if scanner.next() == &quot;IHREAL&quot;:
+	    wfl = True
+	    twarp = scanner.real
+	    if twarp&lt;1.0 or twarp &gt; 10.0:
+		huh()
+		return
+	else:
+	    scanner.chew()
+	    skip(1)
+	    return
+
+# Code from setup.c begins here
+
+def prelim():
+    &quot;Issue a historically correct banner.&quot;
+    skip(2)
+    prout(_(&quot;-SUPER- STAR TREK&quot;))
+    skip(1)
+# From the FORTRAN original
+#    prout(_(&quot;Latest update-21 Sept 78&quot;))
+#    skip(1)
+
+def freeze(boss):
+    &quot;Save game.&quot;
+    if boss:
+	scanner.push(&quot;emsave.trk&quot;)
+    key = scanner.next()
+    if key == &quot;IHEOL&quot;:
+        proutn(_(&quot;File name: &quot;))
+        key = scanner.next()
+    if key != &quot;IHALPHA&quot;:
+        huh()
+        return
+    scanner.chew()
+    if '.' not in scanner.token:
+        scanner.token += &quot;.trk&quot;
+    try:
+        fp = open(scanner.token, &quot;wb&quot;)
+    except IOError:
+	prout(_(&quot;Can't freeze game as file %s&quot;) % scanner.token)
+	return
+    cPickle.dump(game, fp)
+    fp.close()
+
+def thaw():
+    &quot;Retrieve saved game.&quot; 
+    game.passwd[0] = '\0'
+    key = scanner.next()
+    if key == &quot;IHEOL&quot;:
+	proutn(_(&quot;File name: &quot;))
+	key = scanner.next()
+    if key != &quot;IHALPHA&quot;:
+	huh()
+	return True
+    scanner.chew()
+    if '.' not in scanner.token:
+        scanner.token += &quot;.trk&quot;
+    try:
+        fp = open(scanner.token, &quot;rb&quot;)
+    except IOError:
+	prout(_(&quot;Can't thaw game in %s&quot;) % scanner.token)
+	return
+    game = cPickle.load(fp)
+    fp.close()
+    return False
+
+# I used &lt;<A HREF="http://www.memory-alpha.org">http://www.memory-alpha.org</A>&gt; to find planets
+# with references in ST:TOS.  Eath and the Alpha Centauri
+# Colony have been omitted.
+# 
+# Some planets marked Class G and P here will be displayed as class M
+# because of the way planets are generated. This is a known bug.
+systnames = (
+    # Federation Worlds 
+    _(&quot;Andoria (Fesoan)&quot;),	# several episodes 
+    _(&quot;Tellar Prime (Miracht)&quot;),	# TOS: &quot;Journey to Babel&quot; 
+    _(&quot;Vulcan (T'Khasi)&quot;),	# many episodes 
+    _(&quot;Medusa&quot;),		# TOS: &quot;Is There in Truth No Beauty?&quot; 
+    _(&quot;Argelius II (Nelphia)&quot;),	# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
+    _(&quot;Ardana&quot;),		# TOS: &quot;The Cloud Minders&quot; 
+    _(&quot;Catulla (Cendo-Prae)&quot;),	# TOS: &quot;The Way to Eden&quot; 
+    _(&quot;Gideon&quot;),		# TOS: &quot;The Mark of Gideon&quot; 
+    _(&quot;Aldebaran III&quot;),		# TOS: &quot;The Deadly Years&quot; 
+    _(&quot;Alpha Majoris I&quot;),	# TOS: &quot;Wolf in the Fold&quot; 
+    _(&quot;Altair IV&quot;),		# TOS: &quot;Amok Time 
+    _(&quot;Ariannus&quot;),		# TOS: &quot;Let That Be Your Last Battlefield&quot; 
+    _(&quot;Benecia&quot;),		# TOS: &quot;The Conscience of the King&quot; 
+    _(&quot;Beta Niobe I (Sarpeidon)&quot;),	# TOS: &quot;All Our Yesterdays&quot; 
+    _(&quot;Alpha Carinae II&quot;),	# TOS: &quot;The Ultimate Computer&quot; 
+    _(&quot;Capella IV (Kohath)&quot;),	# TOS: &quot;Friday's Child&quot; (Class G) 
+    _(&quot;Daran V&quot;),		# TOS: &quot;For the World is Hollow and I Have Touched the Sky&quot; 
+    _(&quot;Deneb II&quot;),		# TOS: &quot;Wolf in the Fold&quot; (&quot;IV&quot; in BSD) 
+    _(&quot;Eminiar VII&quot;),		# TOS: &quot;A Taste of Armageddon&quot; 
+    _(&quot;Gamma Canaris IV&quot;),	# TOS: &quot;Metamorphosis&quot; 
+    _(&quot;Gamma Tranguli VI (Vaalel)&quot;),	# TOS: &quot;The Apple&quot; 
+    _(&quot;Ingraham B&quot;),		# TOS: &quot;Operation: Annihilate&quot; 
+    _(&quot;Janus IV&quot;),		# TOS: &quot;The Devil in the Dark&quot; 
+    _(&quot;Makus III&quot;),		# TOS: &quot;The Galileo Seven&quot; 
+    _(&quot;Marcos XII&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
+    _(&quot;Omega IV&quot;),		# TOS: &quot;The Omega Glory&quot; 
+    _(&quot;Regulus V&quot;),		# TOS: &quot;Amok Time 
+    _(&quot;Deneva&quot;),		# TOS: &quot;Operation -- Annihilate!&quot; 
+    # Worlds from BSD Trek 
+    _(&quot;Rigel II&quot;),		# TOS: &quot;Shore Leave&quot; (&quot;III&quot; in BSD) 
+    _(&quot;Beta III&quot;),		# TOS: &quot;The Return of the Archons&quot; 
+    _(&quot;Triacus&quot;),		# TOS: &quot;And the Children Shall Lead&quot;, 
+    _(&quot;Exo III&quot;),		# TOS: &quot;What Are Little Girls Made Of?&quot; (Class P) 
+#	# Others 
+#    _(&quot;Hansen's Planet&quot;),	# TOS: &quot;The Galileo Seven&quot; 
+#    _(&quot;Taurus IV&quot;),		# TOS: &quot;The Galileo Seven&quot; (class G) 
+#    _(&quot;Antos IV (Doraphane)&quot;),	# TOS: &quot;Whom Gods Destroy&quot;, &quot;Who Mourns for Adonais?&quot; 
+#    _(&quot;Izar&quot;),			# TOS: &quot;Whom Gods Destroy&quot; 
+#    _(&quot;Tiburon&quot;),		# TOS: &quot;The Way to Eden&quot; 
+#    _(&quot;Merak II&quot;),		# TOS: &quot;The Cloud Minders&quot; 
+#    _(&quot;Coridan (Desotriana)&quot;),	# TOS: &quot;Journey to Babel&quot; 
+#    _(&quot;Iotia&quot;),		# TOS: &quot;A Piece of the Action&quot; 
+)
+
+device = (
+	_(&quot;S. R. Sensors&quot;), \
+	_(&quot;L. R. Sensors&quot;), \
+	_(&quot;Phasers&quot;), \
+	_(&quot;Photon Tubes&quot;), \
+	_(&quot;Life Support&quot;), \
+	_(&quot;Warp Engines&quot;), \
+	_(&quot;Impulse Engines&quot;), \
+	_(&quot;Shields&quot;), \
+	_(&quot;Subspace Radio&quot;), \
+	_(&quot;Shuttle Craft&quot;), \
+	_(&quot;Computer&quot;), \
+	_(&quot;Navigation System&quot;), \
+	_(&quot;Transporter&quot;), \
+	_(&quot;Shield Control&quot;), \
+	_(&quot;Death Ray&quot;), \
+	_(&quot;D. S. Probe&quot;), \
+)
+
+def setup():
+    &quot;Prepare to play, set up cosmos.&quot;
+    w = coord()
+    #  Decide how many of everything
+    if choose():
+	return # frozen game
+    # Prepare the Enterprise
+    game.alldone = game.gamewon = game.shldchg = game.shldup = False
+    game.ship = 'E'
+    game.state.crew = FULLCREW
+    game.energy = game.inenrg = 5000.0
+    game.shield = game.inshld = 2500.0
+    game.inlsr = 4.0
+    game.lsupres = 4.0
+    game.quadrant = randplace(GALSIZE)
+    game.sector = randplace(QUADSIZE)
+    game.torps = game.intorps = 10
+    game.nprobes = randrange(2, 5)
+    game.warpfac = 5.0
+    for i in range(NDEVICES): 
+	game.damage[i] = 0.0
+    # Set up assorted game parameters
+    game.battle = coord()
+    game.state.date = game.indate = 100.0 * randreal(20, 51)
+    game.nkinks = game.nhelp = game.casual = game.abandoned = 0
+    game.iscate = game.resting = game.imine = game.icrystl = game.icraft = False
+    game.isatb = game.state.nplankl = 0
+    game.state.starkl = game.state.basekl = 0
+    game.iscraft = &quot;onship&quot;
+    game.landed = False
+    game.alive = True
+    # Starchart is functional but we've never seen it
+    game.lastchart = FOREVER
+    # Put stars in the galaxy
+    game.instar = 0
+    for i in range(GALSIZE):
+	for j in range(GALSIZE):
+	    k = randrange(1, QUADSIZE**2/10+1)
+	    game.instar += k
+	    game.state.galaxy[i][j].stars = k
+    # Locate star bases in galaxy
+    for i in range(game.inbase):
+        while True:
+            while True:
+                w = randplace(GALSIZE)
+                if not game.state.galaxy[w.i][w.j].starbase:
+                    break
+	    contflag = False
+            # C version: for (j = i-1; j &gt; 0; j--)
+            # so it did them in the opposite order.
+            for j in range(1, i):
+		# Improved placement algorithm to spread out bases
+		distq = (w - game.state.baseq[j]).distance()
+		if distq &lt; 6.0*(BASEMAX+1-game.inbase) and withprob(0.75):
+		    contflag = True
+		    if idebug:
+			prout(&quot;=== Abandoning base #%d at %s&quot; % (i, w))
+		    break
+		elif distq &lt; 6.0 * (BASEMAX+1-game.inbase):
+		    if idebug:
+			prout(&quot;=== Saving base #%d, close to #%d&quot; % (i, j))
+            if not contflag:
+                break
+	game.state.baseq.append(w)
+	game.state.galaxy[w.i][w.j].starbase = game.state.chart[w.i][w.j].starbase = True
+    # Position ordinary Klingon Battle Cruisers
+    krem = game.inkling
+    klumper = 0.25*game.skill*(9.0-game.length)+1.0
+    if klumper &gt; MAXKLQUAD: 
+	klumper = MAXKLQUAD
+    while True:
+	r = randreal()
+	klump = (1.0 - r*r)*klumper
+	if klump &gt; krem:
+	    klump = krem
+	krem -= klump
+        while True:
+            w = randplace(GALSIZE)
+            if not game.state.galaxy[w.i][w.j].supernova and \
+               game.state.galaxy[w.i][w.j].klingons + klump &lt;= MAXKLQUAD:
+                break
+	game.state.galaxy[w.i][w.j].klingons += int(klump)
+        if krem &lt;= 0:
+            break
+    # Position Klingon Commander Ships
+    for i in range(game.incom):
+        while True:
+            w = randplace(GALSIZE)
+            if not welcoming(w) or w in game.state.kcmdr:
+                continue
+            if (game.state.galaxy[w.i][w.j].klingons or withprob(0.25)):
+                break
+	game.state.galaxy[w.i][w.j].klingons += 1
+	game.state.kcmdr.append(w)
+    # Locate planets in galaxy
+    for i in range(game.inplan):
+        while True:
+            w = randplace(GALSIZE) 
+            if game.state.galaxy[w.i][w.j].planet == None:
+                break
+        new = planet()
+	new.quadrant = w
+        new.crystals = &quot;absent&quot;
+	if (game.options &amp; OPTION_WORLDS) and i &lt; NINHAB:
+	    new.pclass = &quot;M&quot;	# All inhabited planets are class M
+	    new.crystals = &quot;absent&quot;
+	    new.known = &quot;known&quot;
+            new.name = systnames[i]
+	    new.inhabited = True
+	else:
+	    new.pclass = (&quot;M&quot;, &quot;N&quot;, &quot;O&quot;)[randrange(0, 3)]
+            if withprob(0.33):
+                new.crystals = &quot;present&quot;
+	    new.known = &quot;unknown&quot;
+	    new.inhabited = False
+	game.state.galaxy[w.i][w.j].planet = new
+        game.state.planets.append(new)
+    # Locate Romulans
+    for i in range(game.state.nromrem):
+	w = randplace(GALSIZE)
+	game.state.galaxy[w.i][w.j].romulans += 1
+    # Place the Super-Commander if needed
+    if game.state.nscrem &gt; 0:
+        while True:
+            w = randplace(GALSIZE)
+            if welcoming(w):
+                break
+	game.state.kscmdr = w
+	game.state.galaxy[w.i][w.j].klingons += 1
+    # Initialize times for extraneous events
+    schedule(FSNOVA, expran(0.5 * game.intime))
+    schedule(FTBEAM, expran(1.5 * (game.intime / len(game.state.kcmdr))))
+    schedule(FSNAP, randreal(1.0, 2.0)) # Force an early snapshot
+    schedule(FBATTAK, expran(0.3*game.intime))
+    unschedule(FCDBAS)
+    if game.state.nscrem:
+	schedule(FSCMOVE, 0.2777)
+    else:
+	unschedule(FSCMOVE)
+    unschedule(FSCDBAS)
+    unschedule(FDSPROB)
+    if (game.options &amp; OPTION_WORLDS) and game.skill &gt;= SKILL_GOOD:
+	schedule(FDISTR, expran(1.0 + game.intime))
+    else:
+	unschedule(FDISTR)
+    unschedule(FENSLV)
+    unschedule(FREPRO)
+    # Place thing (in tournament game, we don't want one!)
+    # New in SST2K: never place the Thing near a starbase.
+    # This makes sense and avoids a special case in the old code.
+    global thing
+    if game.tourn is None:
+        while True:
+            thing = randplace(GALSIZE)
+            if thing not in game.state.baseq:
+                break
+    skip(2)
+    game.state.snap = False
+    if game.skill == SKILL_NOVICE:
+	prout(_(&quot;It is stardate %d. The Federation is being attacked by&quot;) % int(game.state.date))
+	prout(_(&quot;a deadly Klingon invasion force. As captain of the United&quot;))
+	prout(_(&quot;Starship U.S.S. Enterprise, it is your mission to seek out&quot;))
+	prout(_(&quot;and destroy this invasion force of %d battle cruisers.&quot;) % ((game.inkling + game.incom + game.inscom)))
+	prout(_(&quot;You have an initial allotment of %d stardates to complete&quot;) % int(game.intime))
+	prout(_(&quot;your mission.  As you proceed you may be given more time.&quot;))
+	skip(1)
+	prout(_(&quot;You will have %d supporting starbases.&quot;) % (game.inbase))
+	proutn(_(&quot;Starbase locations-  &quot;))
+    else:
+	prout(_(&quot;Stardate %d.&quot;) % int(game.state.date))
+	skip(1)
+	prout(_(&quot;%d Klingons.&quot;) % (game.inkling + game.incom + game.inscom))
+	prout(_(&quot;An unknown number of Romulans.&quot;))
+	if game.state.nscrem:
+	    prout(_(&quot;And one (GULP) Super-Commander.&quot;))
+	prout(_(&quot;%d stardates.&quot;) % int(game.intime))
+	proutn(_(&quot;%d starbases in &quot;) % game.inbase)
+    for i in range(game.inbase):
+	proutn(`game.state.baseq[i]`)
+	proutn(&quot;  &quot;)
+    skip(2)
+    proutn(_(&quot;The Enterprise is currently in Quadrant %s&quot;) % game.quadrant)
+    proutn(_(&quot; Sector %s&quot;) % game.sector)
+    skip(2)
+    prout(_(&quot;Good Luck!&quot;))
+    if game.state.nscrem:
+	prout(_(&quot;  YOU'LL NEED IT.&quot;))
+    waitfor()
+    newqad()
+    if len(game.enemies) - (thing == game.quadrant) - (game.tholian != None):
+	game.shldup = True
+    if game.neutz:	# bad luck to start in a Romulan Neutral Zone
+	attack(torps_ok=False)
+
+def choose():
+    &quot;Choose your game type.&quot;
+    while True:
+	game.tourn = game.length = 0
+	game.thawed = False
+	game.skill = SKILL_NONE
+	if not scanner.inqueue: # Can start with command line options 
+	    proutn(_(&quot;Would you like a regular, tournament, or saved game? &quot;))
+        scanner.next()
+        if scanner.sees(&quot;tournament&quot;):
+	    while scanner.next() == &quot;IHEOL&quot;:
+		proutn(_(&quot;Type in tournament number-&quot;))
+	    if scanner.real == 0:
+		scanner.chew()
+		continue # We don't want a blank entry
+	    game.tourn = int(round(scanner.real))
+	    random.seed(scanner.real)
+            if logfp:
+                logfp.write(&quot;# random.seed(%d)\n&quot; % scanner.real)
+	    break
+        if scanner.sees(&quot;saved&quot;) or scanner.sees(&quot;frozen&quot;):
+	    if thaw():
+		continue
+	    scanner.chew()
+	    if game.passwd == None:
+		continue
+	    if not game.alldone:
+		game.thawed = True # No plaque if not finished
+	    report()
+	    waitfor()
+	    return True
+        if scanner.sees(&quot;regular&quot;):
+	    break
+	proutn(_(&quot;What is \&quot;%s\&quot;?&quot;) % scanner.token)
+	scanner.chew()
+    while game.length==0 or game.skill==SKILL_NONE:
+	if scanner.next() == &quot;IHALPHA&quot;:
+            if scanner.sees(&quot;short&quot;):
+		game.length = 1
+	    elif scanner.sees(&quot;medium&quot;):
+		game.length = 2
+	    elif scanner.sees(&quot;long&quot;):
+		game.length = 4
+	    elif scanner.sees(&quot;novice&quot;):
+		game.skill = SKILL_NOVICE
+	    elif scanner.sees(&quot;fair&quot;):
+		game.skill = SKILL_FAIR
+	    elif scanner.sees(&quot;good&quot;):
+		game.skill = SKILL_GOOD
+	    elif scanner.sees(&quot;expert&quot;):
+		game.skill = SKILL_EXPERT
+	    elif scanner.sees(&quot;emeritus&quot;):
+		game.skill = SKILL_EMERITUS
+	    else:
+		proutn(_(&quot;What is \&quot;&quot;))
+		proutn(scanner.token)
+		prout(&quot;\&quot;?&quot;)
+	else:
+	    scanner.chew()
+	    if game.length==0:
+		proutn(_(&quot;Would you like a Short, Medium, or Long game? &quot;))
+	    elif game.skill == SKILL_NONE:
+		proutn(_(&quot;Are you a Novice, Fair, Good, Expert, or Emeritus player? &quot;))
+    # Choose game options -- added by ESR for SST2K
+    if scanner.next() != &quot;IHALPHA&quot;:
+	scanner.chew()
+	proutn(_(&quot;Choose your game style (plain, almy, fancy or just press enter): &quot;))
+	scanner.next()
+    if scanner.sees(&quot;plain&quot;):
+	# Approximates the UT FORTRAN version.
+	game.options &amp;=~ (OPTION_THOLIAN | OPTION_PLANETS | OPTION_THINGY | OPTION_PROBE | OPTION_RAMMING | OPTION_MVBADDY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
+	game.options |= OPTION_PLAIN
+    elif scanner.sees(&quot;almy&quot;):
+	# Approximates Tom Almy's version.
+	game.options &amp;=~ (OPTION_THINGY | OPTION_BLKHOLE | OPTION_BASE | OPTION_WORLDS)
+	game.options |= OPTION_ALMY
+    elif scanner.sees(&quot;fancy&quot;) or scanner.sees(&quot;\n&quot;):
+	pass
+    elif len(scanner.token):
+        proutn(_(&quot;What is \&quot;%s\&quot;?&quot;) % scanner.token)
+    game.options &amp;=~ OPTION_COLOR
+    setpassword()
+    if game.passwd == &quot;debug&quot;:
+	idebug = True
+	prout(&quot;=== Debug mode enabled.&quot;)
+    # Use parameters to generate initial values of things
+    game.damfac = 0.5 * game.skill
+    game.inbase = randrange(BASEMIN, BASEMAX+1)
+    game.inplan = 0
+    if game.options &amp; OPTION_PLANETS:
+	game.inplan += randrange(MAXUNINHAB/2, MAXUNINHAB+1)
+    if game.options &amp; OPTION_WORLDS:
+	game.inplan += int(NINHAB)
+    game.state.nromrem = game.inrom = randrange(2 *game.skill)
+    game.state.nscrem = game.inscom = (game.skill &gt; SKILL_FAIR)
+    game.state.remtime = 7.0 * game.length
+    game.intime = game.state.remtime
+    game.state.remkl = game.inkling = 2.0*game.intime*((game.skill+1 - 2*randreal())*game.skill*0.1+.15)
+    game.incom = min(MINCMDR, int(game.skill + 0.0625*game.inkling*randreal()))
+    game.state.remres = (game.inkling+4*game.incom)*game.intime
+    game.inresor = game.state.remres
+    if game.inkling &gt; 50:
+        game.state.inbase += 1
+    return False
+
+def dropin(iquad=None):
+    &quot;Drop a feature on a random dot in the current quadrant.&quot;
+    while True:
+        w = randplace(QUADSIZE)
+        if game.quad[w.i][w.j] == '.':
+            break
+    if iquad is not None:
+        game.quad[w.i][w.j] = iquad
+    return w
+
+def newcnd():
+    &quot;Update our alert status.&quot;
+    game.condition = &quot;green&quot;
+    if game.energy &lt; 1000.0:
+	game.condition = &quot;yellow&quot;
+    if game.state.galaxy[game.quadrant.i][game.quadrant.j].klingons or game.state.galaxy[game.quadrant.i][game.quadrant.j].romulans:
+	game.condition = &quot;red&quot;
+    if not game.alive:
+	game.condition=&quot;dead&quot;
+
+def newkling():
+    &quot;Drop new Klingon into current quadrant.&quot;
+    return enemy('K', loc=dropin(), power=randreal(300,450)+25.0*game.skill)
+
+def newqad():
+    &quot;Set up a new state of quadrant, for when we enter or re-enter it.&quot;
+    game.justin = True
+    game.iplnet = None
+    game.neutz = game.inorbit = game.landed = False
+    game.ientesc = game.iseenit = False
+    # Create a blank quadrant
+    game.quad = fill2d(QUADSIZE, lambda i, j: '.')
+    if game.iscate:
+	# Attempt to escape Super-commander, so tbeam back!
+	game.iscate = False
+	game.ientesc = True
+    q = game.state.galaxy[game.quadrant.i][game.quadrant.j]
+    # cope with supernova
+    if q.supernova:
+	return
+    game.klhere = q.klingons
+    game.irhere = q.romulans
+    # Position Starship
+    game.quad[game.sector.i][game.sector.j] = game.ship
+    game.enemies = []
+    if q.klingons:
+	# Position ordinary Klingons
+	for i in range(game.klhere):
+            newkling()
+	# If we need a commander, promote a Klingon
+        for cmdr in game.state.kcmdr:
+	    if cmdr == game.quadrant:
+                e = game.enemies[game.klhere-1]
+                game.quad[e.location.i][e.location.j] = 'C'
+                e.power = randreal(950,1350) + 50.0*game.skill
+		break	
+	# If we need a super-commander, promote a Klingon
+	if game.quadrant == game.state.kscmdr:
+            e = game.enemies[0]
+	    game.quad[e.location.i][e.location.j] = 'S'
+	    e.power = randreal(1175.0,  1575.0) + 125.0*game.skill
+	    game.iscate = (game.state.remkl &gt; 1)
+    # Put in Romulans if needed
+    for i in range(q.romulans):
+        enemy('R', loc=dropin(), power=randreal(400.0,850.0)+50.0*game.skill)
+    # If quadrant needs a starbase, put it in
+    if q.starbase:
+	game.base = dropin('B')
+    # If quadrant needs a planet, put it in
+    if q.planet:
+	game.iplnet = q.planet
+	if not q.planet.inhabited:
+	    game.plnet = dropin('P')
+	else:
+	    game.plnet = dropin('@')
+    # Check for condition
+    newcnd()
+    # Check for RNZ
+    if game.irhere &gt; 0 and game.klhere == 0:
+	game.neutz = True
+	if not damaged(DRADIO):
+	    skip(1)
+	    prout(_(&quot;LT. Uhura- \&quot;Captain, an urgent message.&quot;))
+	    prout(_(&quot;  I'll put it on audio.\&quot;  CLICK&quot;))
+	    skip(1)
+	    prout(_(&quot;INTRUDER! YOU HAVE VIOLATED THE ROMULAN NEUTRAL ZONE.&quot;))
+	    prout(_(&quot;LEAVE AT ONCE, OR YOU WILL BE DESTROYED!&quot;))
+    # Put in THING if needed
+    if thing == game.quadrant:
+        enemy(type='?', loc=dropin(),
+                  power=randreal(6000,6500.0)+250.0*game.skill)
+        if not damaged(DSRSENS):
+            skip(1)
+            prout(_(&quot;Mr. Spock- \&quot;Captain, this is most unusual.&quot;))
+            prout(_(&quot;    Please examine your short-range scan.\&quot;&quot;))
+    # Decide if quadrant needs a Tholian; lighten up if skill is low 
+    if game.options &amp; OPTION_THOLIAN:
+	if (game.skill &lt; SKILL_GOOD and withprob(0.02)) or \
+	    (game.skill == SKILL_GOOD and withprob(0.05)) or \
+            (game.skill &gt; SKILL_GOOD and withprob(0.08)):
+            w = coord()
+            while True:
+		w.i = withprob(0.5) * (QUADSIZE-1)
+		w.j = withprob(0.5) * (QUADSIZE-1)
+                if game.quad[w.i][w.j] == '.':
+                    break
+            game.tholian = enemy(type='T', loc=w,
+                                 power=randrange(100, 500) + 25.0*game.skill)
+	    # Reserve unoccupied corners 
+	    if game.quad[0][0]=='.':
+		game.quad[0][0] = 'X'
+	    if game.quad[0][QUADSIZE-1]=='.':
+		game.quad[0][QUADSIZE-1] = 'X'
+	    if game.quad[QUADSIZE-1][0]=='.':
+		game.quad[QUADSIZE-1][0] = 'X'
+	    if game.quad[QUADSIZE-1][QUADSIZE-1]=='.':
+		game.quad[QUADSIZE-1][QUADSIZE-1] = 'X'
+    game.enemies.sort(lambda x, y: cmp(x.kdist, y.kdist))
+    # And finally the stars
+    for i in range(q.stars):
+	dropin('*')
+    # Put in a few black holes
+    for i in range(1, 3+1):
+	if withprob(0.5): 
+	    dropin(' ')
+    # Take out X's in corners if Tholian present
+    if game.tholian:
+	if game.quad[0][0]=='X':
+	    game.quad[0][0] = '.'
+	if game.quad[0][QUADSIZE-1]=='X':
+	    game.quad[0][QUADSIZE-1] = '.'
+	if game.quad[QUADSIZE-1][0]=='X':
+	    game.quad[QUADSIZE-1][0] = '.'
+	if game.quad[QUADSIZE-1][QUADSIZE-1]=='X':
+	    game.quad[QUADSIZE-1][QUADSIZE-1] = '.'
+
+def setpassword():
+    &quot;Set the self-destruct password.&quot;
+    if game.options &amp; OPTION_PLAIN:
+	while True:
+	    scanner.chew()
+	    proutn(_(&quot;Please type in a secret password- &quot;))
+	    scanner.next()
+	    game.passwd = scanner.token
+	    if game.passwd != None:
+		break
+    else:
+        game.passwd = &quot;&quot;
+        for i in range(3):
+	    game.passwd += chr(ord('a')+randrange(26))
+
+# Code from sst.c begins here
+
+commands = {
+    &quot;SRSCAN&quot;:   	OPTION_TTY,
+    &quot;STATUS&quot;:   	OPTION_TTY,
+    &quot;REQUEST&quot;:  	OPTION_TTY,
+    &quot;LRSCAN&quot;:   	OPTION_TTY,
+    &quot;PHASERS&quot;:  	0,
+    &quot;TORPEDO&quot;:  	0,
+    &quot;PHOTONS&quot;:  	0,
+    &quot;MOVE&quot;:     	0,
+    &quot;SHIELDS&quot;:   	0,
+    &quot;DOCK&quot;:     	0,
+    &quot;DAMAGES&quot;:   	0,
+    &quot;CHART&quot;:    	0,
+    &quot;IMPULSE&quot;:  	0,
+    &quot;REST&quot;:     	0,
+    &quot;WARP&quot;:     	0,
+    &quot;SCORE&quot;:    	0,
+    &quot;SENSORS&quot;:  	OPTION_PLANETS,
+    &quot;ORBIT&quot;:		OPTION_PLANETS,
+    &quot;TRANSPORT&quot;:	OPTION_PLANETS,
+    &quot;MINE&quot;:		OPTION_PLANETS,
+    &quot;CRYSTALS&quot;:  	OPTION_PLANETS,
+    &quot;SHUTTLE&quot;:  	OPTION_PLANETS,
+    &quot;PLANETS&quot;:  	OPTION_PLANETS,
+    &quot;REPORT&quot;:   	0,
+    &quot;COMPUTER&quot;: 	0,
+    &quot;COMMANDS&quot;: 	0,
+    &quot;EMEXIT&quot;:		0,
+    &quot;PROBE&quot;:		OPTION_PROBE,
+    &quot;SAVE&quot;:		0,
+    &quot;FREEZE&quot;:		0,	# Synonym for SAVE
+    &quot;ABANDON&quot;:  	0,
+    &quot;DESTRUCT&quot;: 	0,
+    &quot;DEATHRAY&quot;: 	0,
+    &quot;DEBUG&quot;:    	0,
+    &quot;MAYDAY&quot;:		0,
+    &quot;SOS&quot;:		0,	# Synonym for MAYDAY
+    &quot;CALL&quot;:		0,	# Synonym for MAYDAY
+    &quot;QUIT&quot;:		0,
+    &quot;HELP&quot;:		0,
+}
+
+def listCommands():
+    &quot;Generate a list of legal commands.&quot;
+    prout(_(&quot;LEGAL COMMANDS ARE:&quot;))
+    emitted = 0
+    for key in commands:
+	if not commands[key] or (commands[key] &amp; game.options):
+            proutn(&quot;%-12s &quot; % key)
+            emitted += 1
+            if emitted % 5 == 4:
+                skip(1)
+    skip(1)
+
+def helpme():
+    &quot;Browse on-line help.&quot;
+    key = scanner.next()
+    while True:
+	if key == &quot;IHEOL&quot;:
+	    setwnd(prompt_window)
+	    proutn(_(&quot;Help on what command? &quot;))
+	    key = scanner.next()
+	setwnd(message_window)
+	if key == &quot;IHEOL&quot;:
+	    return
+        if scanner.token.upper() in commands or scanner.token == &quot;ABBREV&quot;:
+	    break
+	skip(1)
+	listCommands()
+	key = &quot;IHEOL&quot;
+	scanner.chew()
+	skip(1)
+    cmd = scanner.token.upper()
+    for directory in docpath:
+        try:
+            fp = open(os.path.join(directory, &quot;sst.doc&quot;), &quot;r&quot;)
+            break
+        except IOError:
+            pass
+    else:
+        prout(_(&quot;Spock-  \&quot;Captain, that information is missing from the&quot;))
+        prout(_(&quot;   computer. You need to find sst.doc and put it somewhere&quot;))
+        proutn(_(&quot;   in these directories: %s&quot;) % &quot;:&quot;.join(docpath))
+        prout(&quot;.\&quot;&quot;)
+        # This used to continue: &quot;You need to find SST.DOC and put 
+        # it in the current directory.&quot;
+        return
+    while True:
+        linebuf = fp.readline()
+	if linebuf == '':
+	    prout(_(&quot;Spock- \&quot;Captain, there is no information on that command.\&quot;&quot;))
+	    fp.close()
+	    return
+	if linebuf[0] == '%' and linebuf[1] == '%' and linebuf[2] == ' ':
+            linebuf = linebuf[3:].strip()
+            if cmd.upper() == linebuf:
+		break
+    skip(1)
+    prout(_(&quot;Spock- \&quot;Captain, I've found the following information:\&quot;&quot;))
+    skip(1)
+    while True:
+        linebuf = fp.readline()
+        if &quot;******&quot; in linebuf:
+	    break
+	proutn(linebuf)
+    fp.close()
+
+def makemoves():
+    &quot;Command-interpretation loop.&quot;
+    clrscr()
+    setwnd(message_window)
+    while True: 	# command loop 
+	drawmaps(1)
+        while True:	# get a command 
+	    hitme = False
+	    game.optime = game.justin = False
+	    scanner.chew()
+	    setwnd(prompt_window)
+	    clrscr()
+	    proutn(&quot;COMMAND&gt; &quot;)
+	    if scanner.next() == &quot;IHEOL&quot;:
+		if game.options &amp; OPTION_CURSES:
+		    makechart()
+		continue
+            elif scanner.token == &quot;&quot;:
+                continue
+	    game.ididit = False
+	    clrscr()
+	    setwnd(message_window)
+	    clrscr()
+            candidates = filter(lambda x: x.startswith(scanner.token.upper()),
+                                commands)
+            if len(candidates) == 1:
+                cmd = candidates[0]
+                break
+            elif candidates and not (game.options &amp; OPTION_PLAIN):
+                prout(&quot;Commands with prefix '%s': %s&quot; % (scanner.token, &quot; &quot;.join(candidates)))
+            else:
+                listCommands()
+                continue
+	if cmd == &quot;SRSCAN&quot;:		# srscan
+	    srscan()
+	elif cmd == &quot;STATUS&quot;:		# status
+	    status()
+	elif cmd == &quot;REQUEST&quot;:		# status request 
+	    request()
+	elif cmd == &quot;LRSCAN&quot;:		# long range scan
+	    lrscan(silent=False)
+	elif cmd == &quot;PHASERS&quot;:		# phasers
+	    phasers()
+	    if game.ididit:
+		hitme = True
+	elif cmd in (&quot;TORPEDO&quot;, &quot;PHOTONS&quot;):	# photon torpedos
+	    torps()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;MOVE&quot;:		# move under warp
+	    warp(course=None, involuntary=False)
+	elif cmd == &quot;SHIELDS&quot;:		# shields
+	    doshield(shraise=False)
+	    if game.ididit:
+		hitme = True
+		game.shldchg = False
+	elif cmd == &quot;DOCK&quot;:		# dock at starbase
+	    dock(True)
+	    if game.ididit:
+		attack(torps_ok=False)		
+	elif cmd == &quot;DAMAGES&quot;:		# damage reports
+	    damagereport()
+	elif cmd == &quot;CHART&quot;:		# chart
+	    makechart()
+	elif cmd == &quot;IMPULSE&quot;:		# impulse
+	    impulse()
+	elif cmd == &quot;REST&quot;:		# rest
+	    wait()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;WARP&quot;:		# warp
+	    setwarp()
+	elif cmd == &quot;SCORE&quot;:		# score
+	    score()
+	elif cmd == &quot;SENSORS&quot;:		# sensors
+	    sensor()
+	elif cmd == &quot;ORBIT&quot;:		# orbit
+	    orbit()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;TRANSPORT&quot;:		# transport &quot;beam&quot;
+	    beam()
+	elif cmd == &quot;MINE&quot;:		# mine
+	    mine()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;CRYSTALS&quot;:		# crystals
+	    usecrystals()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;SHUTTLE&quot;:		# shuttle
+	    shuttle()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;PLANETS&quot;:		# Planet list
+	    survey()
+	elif cmd == &quot;REPORT&quot;:		# Game Report 
+	    report()
+	elif cmd == &quot;COMPUTER&quot;:		# use COMPUTER!
+	    eta()
+	elif cmd == &quot;COMMANDS&quot;:
+	    listCommands()
+	elif cmd == &quot;EMEXIT&quot;:		# Emergency exit
+	    clrscr()			# Hide screen
+	    freeze(True)		# forced save
+	    raise SysExit,1			# And quick exit
+	elif cmd == &quot;PROBE&quot;:
+	    probe()			# Launch probe
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;ABANDON&quot;:		# Abandon Ship
+	    abandon()
+	elif cmd == &quot;DESTRUCT&quot;:		# Self Destruct
+	    selfdestruct()
+	elif cmd == &quot;SAVE&quot;:		# Save Game
+	    freeze(False)
+	    clrscr()
+	    if game.skill &gt; SKILL_GOOD:
+		prout(_(&quot;WARNING--Saved games produce no plaques!&quot;))
+	elif cmd == &quot;DEATHRAY&quot;:		# Try a desparation measure
+	    deathray()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;DEBUGCMD&quot;:		# What do we want for debug???
+	    debugme()
+	elif cmd == &quot;MAYDAY&quot;:		# Call for help
+	    mayday()
+	    if game.ididit:
+		hitme = True
+	elif cmd == &quot;QUIT&quot;:
+	    game.alldone = True		# quit the game
+	elif cmd == &quot;HELP&quot;:
+	    helpme()			# get help
+	while True:
+	    if game.alldone:
+		break		# Game has ended
+	    if game.optime != 0.0:
+		events()
+		if game.alldone:
+		    break	# Events did us in
+	    if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		atover(False)
+		continue
+	    if hitme and not game.justin:
+		attack(torps_ok=True)
+		if game.alldone:
+		    break
+		if game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova:
+		    atover(False)
+		    hitme = True
+		    continue
+	    break
+	if game.alldone:
+	    break
+    if idebug:
+	prout(&quot;=== Ending&quot;)
+
+def cramen(type):
+    &quot;Emit the name of an enemy or feature.&quot; 
+    if   type == 'R': s = _(&quot;Romulan&quot;)
+    elif type == 'K': s = _(&quot;Klingon&quot;)
+    elif type == 'C': s = _(&quot;Commander&quot;)
+    elif type == 'S': s = _(&quot;Super-commander&quot;)
+    elif type == '*': s = _(&quot;Star&quot;)
+    elif type == 'P': s = _(&quot;Planet&quot;)
+    elif type == 'B': s = _(&quot;Starbase&quot;)
+    elif type == ' ': s = _(&quot;Black hole&quot;)
+    elif type == 'T': s = _(&quot;Tholian&quot;)
+    elif type == '#': s = _(&quot;Tholian web&quot;)
+    elif type == '?': s = _(&quot;Stranger&quot;)
+    elif type == '@': s = _(&quot;Inhabited World&quot;)
+    else: s = &quot;Unknown??&quot;
+    return s
+
+def crmena(stars, enemy, loctype, w):
+    &quot;Emit the name of an enemy and his location.&quot;
+    buf = &quot;&quot;
+    if stars:
+	buf += &quot;***&quot;
+    buf += cramen(enemy) + _(&quot; at &quot;)
+    if loctype == &quot;quadrant&quot;:
+	buf += _(&quot;Quadrant &quot;)
+    elif loctype == &quot;sector&quot;:
+	buf += _(&quot;Sector &quot;)
+    return buf + `w`
+
+def crmshp():
+    &quot;Emit our ship name.&quot; 
+    return{'E':_(&quot;Enterprise&quot;),'F':_(&quot;Faerie Queene&quot;)}.get(game.ship,&quot;Ship???&quot;)
+
+def stars():
+    &quot;Emit a line of stars&quot; 
+    prouts(&quot;******************************************************&quot;)
+    skip(1)
+
+def expran(avrage):
+    return -avrage*math.log(1e-7 + randreal())
+
+def randplace(size):
+    &quot;Choose a random location.&quot;
+    w = coord()
+    w.i = randrange(size) 
+    w.j = randrange(size)
+    return w
+
+class sstscanner:
+    def __init__(self):
+        self.type = None
+        self.token = None
+        self.real = 0.0
+        self.inqueue = []
+    def next(self):
+        # Get a token from the user
+        self.real = 0.0
+        self.token = ''
+        # Fill the token quue if nothing here
+        while not self.inqueue:
+            line = cgetline()
+            if curwnd==prompt_window:
+                clrscr()
+                setwnd(message_window)
+                clrscr()
+            if line == '':
+                return None
+            if not line:
+                continue
+            else:
+                self.inqueue = line.lstrip().split() + [&quot;\n&quot;]
+        # From here on in it's all looking at the queue
+        self.token = self.inqueue.pop(0)
+        if self.token == &quot;\n&quot;:
+            self.type = &quot;IHEOL&quot;
+            return &quot;IHEOL&quot;
+        try:
+            self.real = float(self.token)
+            self.type = &quot;IHREAL&quot;
+            return &quot;IHREAL&quot;
+        except ValueError:
+            pass
+        # Treat as alpha
+        self.token = self.token.lower()
+        self.type = &quot;IHALPHA&quot;
+        self.real = None
+        return &quot;IHALPHA&quot;
+    def append(self, tok):
+        self.inqueue.append(tok)
+    def push(self, tok):
+        self.inqueue.insert(0, tok)
+    def waiting(self):
+        return self.inqueue
+    def chew(self):
+        # Demand input for next scan
+        self.inqueue = []
+        self.real = self.token = None
+    def sees(self, s):
+        # compares s to item and returns true if it matches to the length of s
+        return s.startswith(self.token)
+    def int(self):
+        # Round token value to nearest integer
+        return int(round(scanner.real))
+    def getcoord(self):
+        s = coord()
+        scanner.next()
+    	if scanner.type != &quot;IHREAL&quot;:
+	    huh()
+	    return None
+	s.i = scanner.int()-1
+        scanner.next()
+	if scanner.type != &quot;IHREAL&quot;:
+	    huh()
+	    return None
+	s.j = scanner.int()-1
+        return s
+    def __repr__(str):
+        return &quot;&lt;sstcanner: token=%s, type=%s, queue=%s&gt;&quot; % (scanner.token, scanner.type, scanner.inqueue)
+
+def ja():
+    &quot;Yes-or-no confirmation.&quot;
+    scanner.chew()
+    while True:
+	scanner.next()
+	if scanner.token == 'y':
+	    return True
+	if scanner.token == 'n':
+	    return False
+	scanner.chew()
+	proutn(_(&quot;Please answer with \&quot;y\&quot; or \&quot;n\&quot;: &quot;))
+
+def huh():
+    &quot;Complain about unparseable input.&quot;
+    scanner.chew()
+    skip(1)
+    prout(_(&quot;Beg your pardon, Captain?&quot;))
+
+def debugme():
+    &quot;Access to the internals for debugging.&quot;
+    proutn(&quot;Reset levels? &quot;)
+    if ja() == True:
+	if game.energy &lt; game.inenrg:
+	    game.energy = game.inenrg
+	game.shield = game.inshld
+	game.torps = game.intorps
+	game.lsupres = game.inlsr
+    proutn(&quot;Reset damage? &quot;)
+    if ja() == True:
+	for i in range(NDEVICES): 
+	    if game.damage[i] &gt; 0.0: 
+		game.damage[i] = 0.0
+    proutn(&quot;Toggle debug flag? &quot;)
+    if ja() == True:
+	idebug = not idebug
+	if idebug:
+	    prout(&quot;Debug output ON&quot;)	    
+	else:
+	    prout(&quot;Debug output OFF&quot;)
+    proutn(&quot;Cause selective damage? &quot;)
+    if ja() == True:
+	for i in range(NDEVICES):
+	    proutn(&quot;Kill %s?&quot; % device[i])
+	    scanner.chew()
+	    key = scanner.next()
+            if key == &quot;IHALPHA&quot; and scanner.sees(&quot;y&quot;):
+		game.damage[i] = 10.0
+    proutn(&quot;Examine/change events? &quot;)
+    if ja() == True:
+	ev = event()
+	w = coord()
+        legends = {
+            FSNOVA:  &quot;Supernova       &quot;,
+            FTBEAM:  &quot;T Beam          &quot;,
+            FSNAP:   &quot;Snapshot        &quot;,
+            FBATTAK: &quot;Base Attack     &quot;,
+            FCDBAS:  &quot;Base Destroy    &quot;,
+            FSCMOVE: &quot;SC Move         &quot;,
+            FSCDBAS: &quot;SC Base Destroy &quot;,
+            FDSPROB: &quot;Probe Move      &quot;,
+            FDISTR:  &quot;Distress Call   &quot;,
+            FENSLV:  &quot;Enslavement     &quot;,
+            FREPRO:  &quot;Klingon Build   &quot;,
+        }
+	for i in range(1, NEVENTS):
+            proutn(legends[i])
+	    if is_scheduled(i):
+		proutn(&quot;%.2f&quot; % (scheduled(i)-game.state.date))
+		if i == FENSLV or i == FREPRO:
+		    ev = findevent(i)
+		    proutn(&quot; in %s&quot; % ev.quadrant)
+	    else:
+		proutn(&quot;never&quot;)
+	    proutn(&quot;? &quot;)
+	    scanner.chew()
+	    key = scanner.next()
+	    if key == 'n':
+		unschedule(i)
+		scanner.chew()
+	    elif key == &quot;IHREAL&quot;:
+		ev = schedule(i, scanner.real)
+		if i == FENSLV or i == FREPRO:
+		    scanner.chew()
+		    proutn(&quot;In quadrant- &quot;)
+		    key = scanner.next()
+		    # &quot;IHEOL&quot; says to leave coordinates as they are 
+		    if key != &quot;IHEOL&quot;:
+			if key != &quot;IHREAL&quot;:
+			    prout(&quot;Event %d canceled, no x coordinate.&quot; % (i))
+			    unschedule(i)
+			    continue
+			w.i = int(round(scanner.real))
+			key = scanner.next()
+			if key != &quot;IHREAL&quot;:
+			    prout(&quot;Event %d canceled, no y coordinate.&quot; % (i))
+			    unschedule(i)
+			    continue
+			w.j = int(round(scanner.real))
+			ev.quadrant = w
+	scanner.chew()
+    proutn(&quot;Induce supernova here? &quot;)
+    if ja() == True:
+	game.state.galaxy[game.quadrant.i][game.quadrant.j].supernova = True
+	atover(True)
+
+if __name__ == '__main__':
+    import getopt, socket
+    try:
+        global line, thing, game, idebug
+        game = None
+        thing = coord()
+        thing.angry = False
+        game = gamestate()
+        idebug = 0
+        game.options = OPTION_ALL &amp;~ (OPTION_IOMODES | OPTION_PLAIN | OPTION_ALMY)
+        if os.getenv(&quot;TERM&quot;):
+            game.options |= OPTION_CURSES
+        else:
+            game.options |= OPTION_TTY
+        seed = int(time.time())
+        (options, arguments) = getopt.getopt(sys.argv[1:], &quot;r:s:tx&quot;)
+        for (switch, val) in options:
+            if switch == '-r':
+                try:
+                    replayfp = open(val, &quot;r&quot;)
+                except IOError:
+                    sys.stderr.write(&quot;sst: can't open replay file %s\n&quot; % val)
+                    raise SystemExit, 1
+                try:
+                    line = replayfp.readline().strip()
+                    (leader, key, seed) = line.split()
+                    seed = eval(seed)
+                    sys.stderr.write(&quot;sst2k: seed set to %s\n&quot; % seed)
+                    line = replayfp.readline().strip()
+                    arguments += line.split()[2:]
+                except ValueError:
+                    sys.stderr.write(&quot;sst: replay file %s is ill-formed\n&quot;% val)
+                    raise SystemExit(1)
+                game.options |= OPTION_TTY
+                game.options &amp;=~ OPTION_CURSES
+            elif switch == '-s':
+                seed = int(val)
+            elif switch == '-t':
+                game.options |= OPTION_TTY
+                game.options &amp;=~ OPTION_CURSES
+            elif switch == '-x':
+                idebug = True
+            else:
+                sys.stderr.write(&quot;usage: sst [-t] [-x] [startcommand...].\n&quot;)
+                raise SystemExit, 1
+        # where to save the input in case of bugs
+        if &quot;TMPDIR&quot; in os.environ:
+            tmpdir = os.environ['TMPDIR']
+        else:
+            tmpdir = &quot;/tmp&quot;
+        try:
+            logfp = open(os.path.join(tmpdir, &quot;sst-input.log&quot;), &quot;w&quot;)
+        except IOError:
+            sys.stderr.write(&quot;sst: warning, can't open logfile\n&quot;)
+            sys.exit(1)
+        if logfp:
+            logfp.write(&quot;# seed %s\n&quot; % seed)
+            logfp.write(&quot;# options %s\n&quot; % &quot; &quot;.join(arguments))
+            logfp.write(&quot;# recorded by %s@%s on %s\n&quot; % \
+                    (getpass.getuser(),socket.gethostname(),time.ctime()))
+        random.seed(seed)
+        scanner = sstscanner()
+        map(scanner.append, arguments)
+        try:
+            iostart()
+            while True: # Play a game 
+                setwnd(fullscreen_window)
+                clrscr()
+                prelim()
+                setup()
+                if game.alldone:
+                    score()
+                    game.alldone = False
+                else:
+                    makemoves()
+                skip(1)
+                stars()
+                skip(1)
+                if game.tourn and game.alldone:
+                    proutn(_(&quot;Do you want your score recorded?&quot;))
+                    if ja() == True:
+                        scanner.chew()
+                        scanner.push(&quot;\n&quot;)
+                        freeze(False)
+                scanner.chew()
+                proutn(_(&quot;Do you want to play again? &quot;))
+                if not ja():
+                    break
+            skip(1)
+            prout(_(&quot;May the Great Bird of the Galaxy roost upon your home planet.&quot;))
+        finally:
+            ioend()
+        raise SystemExit, 0
+    except KeyboardInterrupt:
+        if logfp:
+            logfp.close()
+        print &quot;&quot;

Deleted: trunk/sst.spec
===================================================================
--- trunk/sst.spec	2010-11-30 07:54:08 UTC (rev 809)
+++ trunk/sst.spec	2010-11-30 08:15:36 UTC (rev 810)
@@ -1,49 +0,0 @@
-Name: sst
-Version: 2.0
-Release: 1
-URL: <A HREF="http://sst.berlios.de">http://sst.berlios.de</A>
-Source0: %{name}-%{version}.tar.gz
-License: GPL
-Group: Games
-Summary: the classic game of Super Star Trek
-BuildRoot: %{_tmppath}/%{name}-root
-#Freshmeat-Name: strek
-
-%description
-Save the Federation from the invading Klingons!  Visit exotic planets and
-strip-mine them for dilithium!  Encounter mysterious space thingies!
-The classic Super Star Trek game from the days of slow teletypes, reloaded.
-
-%prep
-%setup -q
-
-%build
-make %{?_smp_mflags} all sst-doc.html
-
-%install
-[ &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf &quot;$RPM_BUILD_ROOT&quot;
-mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_bindir}
-mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_mandir}/man6/
-cp sst &quot;$RPM_BUILD_ROOT&quot;%{_bindir}
-cp sst.6 &quot;$RPM_BUILD_ROOT&quot;%{_mandir}/man6/
-mkdir -p &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/
-cp sst.doc &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/
-cp sst-doc.html &quot;$RPM_BUILD_ROOT&quot;%{_defaultdocdir}/sst/index.html
-
-%clean
-[ &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf &quot;$RPM_BUILD_ROOT&quot;
-
-%files
-%doc README COPYING
-%defattr(-,root,root,-)
-%{_mandir}/man6/sst.6*
-%{_bindir}/sst
-%{_defaultdocdir}/sst/sst.doc
-%{_defaultdocdir}/sst/index.html
-
-%changelog
-
-* Thu Apr 14 2005 Eric S. Raymond &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">esr at snark.thyrsus.com</A>&gt; - 2.0-1
-- First release under new management.
-
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000278.html">[Sst-commit-watch] r809 - branches
</A></li>
	<LI>Next message: <A HREF="000280.html">[Sst-commit-watch] r811 - in trunk: . c-version
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#279">[ date ]</a>
              <a href="thread.html#279">[ thread ]</a>
              <a href="subject.html#279">[ subject ]</a>
              <a href="author.html#279">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/sst-commit-watch">More information about the Sst-commit-watch
mailing list</a><br>
</body></html>
